<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CFG.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby.ir.representations</a> &gt; <span class="el_source">CFG.java</span></div><h1>CFG.java</h1><pre class="source lang-java linenums">package org.jruby.ir.representations;

import org.jruby.dirgra.DirectedGraph;
import org.jruby.dirgra.Edge;
import org.jruby.ir.IRClosure;
import org.jruby.ir.IRScope;
import org.jruby.ir.Operation;
import org.jruby.ir.instructions.*;
import org.jruby.ir.operands.Label;
import org.jruby.ir.operands.Operand;
import org.jruby.ir.operands.Variable;
import org.jruby.ir.operands.WrappedIRClosure;
import org.jruby.ir.transformations.inlining.CloneInfo;
import org.jruby.util.log.Logger;
import org.jruby.util.log.LoggerFactory;

import java.util.*;

/**
 * Represents the base build of a CFG.  All information here is accessed via
 * delegation from the CFG itself so this is meant as an internal
 * organizational structure for a build.
 */
<span class="pc bpc" id="L24" title="1 of 2 branches missed.">public class CFG {</span>
<span class="pc" id="L25">    public enum EdgeType {</span>
<span class="fc" id="L26">        REGULAR,       // Any non-special edge.  Not really used.</span>
<span class="fc" id="L27">        EXCEPTION,     // Edge to exception handling basic blocks</span>
<span class="fc" id="L28">        FALL_THROUGH,  // Edge which is the natural fall through choice on a branch</span>
<span class="fc" id="L29">        EXIT           // Edge to dummy exit BB</span>
    }

<span class="fc" id="L32">    private static final Logger LOG = LoggerFactory.getLogger(&quot;CFG&quot;);</span>

    private IRScope scope;
    private Map&lt;Label, BasicBlock&gt; bbMap;

    // Map of bb -&gt; first bb of the rescue block that initiates exception handling for all exceptions thrown within this bb
    private Map&lt;BasicBlock, BasicBlock&gt; rescuerMap;

    /** Entry BB */
    private BasicBlock entryBB;

    /** Exit BB */
    private BasicBlock exitBB;

    /** BB that traps all exception-edges out of the cfg where we could add any cleanup/ensure code (ex: pop frames, etc.) */
    private BasicBlock globalEnsureBB;

    /** The graph itself */
    private DirectedGraph&lt;BasicBlock&gt; graph;

    private int nextBBId;       // Next available basic block id

    LinkedList&lt;BasicBlock&gt; postOrderList; // Post order traversal list of the cfg

<span class="fc" id="L56">    public CFG(IRScope scope) {</span>
<span class="fc" id="L57">        this.scope = scope;</span>
<span class="fc" id="L58">        this.graph = new DirectedGraph&lt;&gt;();</span>
<span class="fc" id="L59">        this.bbMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L60">        this.rescuerMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L61">        this.nextBBId = 0;</span>
<span class="fc" id="L62">        this.entryBB = this.exitBB = null;</span>
<span class="fc" id="L63">        this.globalEnsureBB = null;</span>
<span class="fc" id="L64">        this.postOrderList = null;</span>
<span class="fc" id="L65">    }</span>

    public int getNextBBID() {
<span class="fc" id="L68">        nextBBId++;</span>
<span class="fc" id="L69">        return nextBBId;</span>
    }

    public int getMaxNodeID() {
<span class="fc" id="L73">        return nextBBId;</span>
    }

    public boolean bbIsProtected(BasicBlock b) {
<span class="fc bfc" id="L77" title="All 2 branches covered.">        return getRescuerBBFor(b) != null;</span>
    }

    public BasicBlock getBBForLabel(Label label) {
<span class="fc" id="L81">        return bbMap.get(label);</span>
    }

    public BasicBlock getEntryBB() {
<span class="fc" id="L85">        return entryBB;</span>
    }

    public BasicBlock getExitBB() {
<span class="fc" id="L89">        return exitBB;</span>
    }

    public BasicBlock getGlobalEnsureBB() {
<span class="fc" id="L93">        return globalEnsureBB;</span>
    }

    public LinkedList&lt;BasicBlock&gt; postOrderList() {
        // SSS FIXME: This caching is fragile -- requires invalidation
        // on change of CFG state. We need a better setup than this.
<span class="fc bfc" id="L99" title="All 2 branches covered.">        if (postOrderList == null) postOrderList = buildPostOrderList();</span>
<span class="fc" id="L100">        return postOrderList;</span>
    }

    public Iterator&lt;BasicBlock&gt; getPostOrderTraverser() {
<span class="fc" id="L104">        return postOrderList().iterator();</span>
    }

    public Iterator&lt;BasicBlock&gt; getReversePostOrderTraverser() {
<span class="fc" id="L108">        return postOrderList().descendingIterator();</span>
    }

    public void resetState() {
        // SSS FIXME: anything else?
<span class="nc" id="L113">        postOrderList = null;</span>
<span class="nc" id="L114">    }</span>

    public IRScope getScope() {
<span class="fc" id="L117">        return scope;</span>
    }

    /**
     * How many BasicBlocks are there in this CFG?
     */
    public int size() {
<span class="fc" id="L124">        return graph.size();</span>
    }

    public Collection&lt;BasicBlock&gt; getBasicBlocks() {
<span class="fc" id="L128">        return graph.allData();</span>
    }

    public Collection&lt;BasicBlock&gt; getSortedBasicBlocks() {
<span class="nc" id="L132">        return graph.getInorderData();</span>
    }

    public void addEdge(BasicBlock source, BasicBlock destination, Object type) {
<span class="fc" id="L136">        graph.findOrCreateVertexFor(source).addEdgeTo(destination, type);</span>
<span class="fc" id="L137">    }</span>

    public int inDegree(BasicBlock b) {
<span class="fc" id="L140">        return graph.findVertexFor(b).inDegree();</span>
    }

    public int outDegree(BasicBlock b) {
<span class="fc" id="L144">        return graph.findVertexFor(b).outDegree();</span>
    }

    public Iterable&lt;BasicBlock&gt; getIncomingSources(BasicBlock block) {
<span class="fc" id="L148">        return graph.findVertexFor(block).getIncomingSourcesData();</span>
    }

    public Iterable&lt;Edge&lt;BasicBlock&gt;&gt; getIncomingEdges(BasicBlock block) {
<span class="fc" id="L152">        return graph.findVertexFor(block).getIncomingEdges();</span>
    }

    public BasicBlock getIncomingSource(BasicBlock block) {
<span class="nc" id="L156">        return graph.findVertexFor(block).getIncomingSourceData();</span>
    }

    public BasicBlock getIncomingSourceOfType(BasicBlock block, Object type) {
<span class="fc" id="L160">        return graph.findVertexFor(block).getIncomingSourceDataOfType(type);</span>
    }

    public Edge&lt;BasicBlock&gt; getIncomingEdgeOfType(BasicBlock block, Object type) {
<span class="nc" id="L164">        return graph.findVertexFor(block).getIncomingEdgeOfType(type);</span>
    }

    public Edge&lt;BasicBlock&gt; getOutgoingEdgeOfType(BasicBlock block, Object type) {
<span class="nc" id="L168">        return graph.findVertexFor(block).getOutgoingEdgeOfType(type);</span>
    }

    public BasicBlock getOutgoingDestination(BasicBlock block) {
<span class="nc" id="L172">        return graph.findVertexFor(block).getOutgoingDestinationData();</span>
    }

    public BasicBlock getOutgoingDestinationOfType(BasicBlock block, Object type) {
<span class="fc" id="L176">        return graph.findVertexFor(block).getOutgoingDestinationDataOfType(type);</span>
    }

    public Iterable&lt;BasicBlock&gt; getOutgoingDestinations(BasicBlock block) {
<span class="fc" id="L180">        return graph.findVertexFor(block).getOutgoingDestinationsData();</span>
    }

    public Iterable&lt;BasicBlock&gt; getOutgoingDestinationsOfType(BasicBlock block, Object type) {
<span class="fc" id="L184">        return graph.findVertexFor(block).getOutgoingDestinationsDataOfType(type);</span>
    }

    public Iterable&lt;BasicBlock&gt; getOutgoingDestinationsNotOfType(BasicBlock block, Object type) {
<span class="nc" id="L188">        return graph.findVertexFor(block).getOutgoingDestinationsDataNotOfType(type);</span>
    }

    public Collection&lt;Edge&lt;BasicBlock&gt;&gt; getOutgoingEdges(BasicBlock block) {
<span class="fc" id="L192">        return graph.findVertexFor(block).getOutgoingEdges();</span>
    }

    public Iterable&lt;Edge&lt;BasicBlock&gt;&gt; getOutgoingEdgesNotOfType(BasicBlock block, Object type) {
<span class="nc" id="L196">        return graph.findVertexFor(block).getOutgoingEdgesNotOfType(type);</span>
    }

    public BasicBlock getRescuerBBFor(BasicBlock block) {
<span class="fc" id="L200">        return rescuerMap.get(block);</span>
    }

    /* Add 'b' as a global ensure block that protects all unprotected blocks in this scope */
    public void addGlobalEnsureBB(BasicBlock geb) {
<span class="pc bpc" id="L205" title="3 of 4 branches missed.">        assert globalEnsureBB == null: &quot;CFG for scope &quot; + getScope() + &quot; already has a global ensure block.&quot;;</span>

<span class="fc" id="L207">        addBasicBlock(geb);</span>
<span class="fc" id="L208">        addEdge(geb, getExitBB(), EdgeType.EXIT);</span>

<span class="fc bfc" id="L210" title="All 2 branches covered.">        for (BasicBlock b: getBasicBlocks()) {</span>
<span class="fc bfc" id="L211" title="All 6 branches covered.">            if (b != geb &amp;&amp; !bbIsProtected(b) &amp;&amp; b != getEntryBB()) {</span>
<span class="fc" id="L212">                addEdge(b, geb, EdgeType.EXCEPTION);</span>
<span class="fc" id="L213">                setRescuerBB(b, geb);</span>
            }
<span class="fc" id="L215">        }</span>

<span class="fc" id="L217">        globalEnsureBB = geb;</span>
<span class="fc" id="L218">    }</span>

    public void setRescuerBB(BasicBlock block, BasicBlock rescuerBlock) {
<span class="fc" id="L221">        rescuerMap.put(block, rescuerBlock);</span>
<span class="fc" id="L222">    }</span>

    /**
     *  Build the Control Flow Graph
     */
    public DirectedGraph&lt;BasicBlock&gt; build(List&lt;Instr&gt; instrs) {
        // Map of label &amp; basic blocks which are waiting for a bb with that label
<span class="fc" id="L229">        Map&lt;Label, List&lt;BasicBlock&gt;&gt; forwardRefs = new HashMap&lt;&gt;();</span>

        // List of bbs that have a 'return' instruction
<span class="fc" id="L232">        List&lt;BasicBlock&gt; returnBBs = new ArrayList&lt;&gt;();</span>

        // List of bbs that have a 'throw' instruction
<span class="fc" id="L235">        List&lt;BasicBlock&gt; exceptionBBs = new ArrayList&lt;&gt;();</span>

        // Stack of nested rescue regions
<span class="fc" id="L238">        Stack&lt;ExceptionRegion&gt; nestedExceptionRegions = new Stack&lt;&gt;();</span>

        // List of all rescued regions
<span class="fc" id="L241">        List&lt;ExceptionRegion&gt; allExceptionRegions = new ArrayList&lt;&gt;();</span>

        // Dummy entry basic block (see note at end to see why)
<span class="fc" id="L244">        entryBB = createBB(nestedExceptionRegions);</span>

        // First real bb
<span class="fc" id="L247">        BasicBlock firstBB = createBB(nestedExceptionRegions);</span>

        // Build the rest!
<span class="fc" id="L250">        BasicBlock currBB = firstBB;</span>
        BasicBlock newBB;
<span class="fc" id="L252">        boolean bbEnded = false;</span>
<span class="fc" id="L253">        boolean nextBBIsFallThrough = true;</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">        for (Instr i : instrs) {</span>
            // System.out.println(&quot;Processing: &quot; + i);
<span class="fc" id="L256">            Operation iop = i.getOperation();</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">            if (iop == Operation.LABEL) {</span>
<span class="fc" id="L258">                Label l = ((LabelInstr) i).label;</span>
<span class="fc" id="L259">                newBB = createBB(l, nestedExceptionRegions);</span>
                // Jump instruction bbs dont add an edge to the succeeding bb by default
<span class="fc bfc" id="L261" title="All 2 branches covered.">                if (nextBBIsFallThrough) graph.addEdge(currBB, newBB, EdgeType.FALL_THROUGH);</span>
<span class="fc" id="L262">                currBB = newBB;</span>
<span class="fc" id="L263">                bbEnded = false;</span>
<span class="fc" id="L264">                nextBBIsFallThrough = true;</span>

                // Add forward reference edges
<span class="fc" id="L267">                List&lt;BasicBlock&gt; frefs = forwardRefs.get(l);</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">                if (frefs != null) {</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">                    for (BasicBlock b : frefs) {</span>
<span class="fc" id="L270">                        graph.addEdge(b, newBB, EdgeType.REGULAR);</span>
<span class="fc" id="L271">                    }</span>
                }
<span class="fc bfc" id="L273" title="All 4 branches covered.">            } else if (bbEnded &amp;&amp; iop != Operation.EXC_REGION_END) {</span>
<span class="fc" id="L274">                newBB = createBB(nestedExceptionRegions);</span>
                // Jump instruction bbs dont add an edge to the succeeding bb by default
<span class="fc bfc" id="L276" title="All 2 branches covered.">                if (nextBBIsFallThrough) graph.addEdge(currBB, newBB, EdgeType.FALL_THROUGH); // currBB cannot be null!</span>
<span class="fc" id="L277">                currBB = newBB;</span>
<span class="fc" id="L278">                bbEnded = false;</span>
<span class="fc" id="L279">                nextBBIsFallThrough = true;</span>
            }

<span class="fc bfc" id="L282" title="All 2 branches covered.">            if (i instanceof ExceptionRegionStartMarkerInstr) {</span>
                // We dont need the instruction anymore -- so it is not added to the CFG.
<span class="fc" id="L284">                ExceptionRegionStartMarkerInstr ersmi = (ExceptionRegionStartMarkerInstr) i;</span>
<span class="fc" id="L285">                ExceptionRegion rr = new ExceptionRegion(ersmi.firstRescueBlockLabel, currBB);</span>
<span class="fc" id="L286">                rr.addBB(currBB);</span>
<span class="fc" id="L287">                allExceptionRegions.add(rr);</span>

<span class="fc bfc" id="L289" title="All 2 branches covered.">                if (!nestedExceptionRegions.empty()) {</span>
<span class="fc" id="L290">                    nestedExceptionRegions.peek().addNestedRegion(rr);</span>
                }

<span class="fc" id="L293">                nestedExceptionRegions.push(rr);</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">            } else if (i instanceof ExceptionRegionEndMarkerInstr) {</span>
                // We dont need the instruction anymore -- so it is not added to the CFG.
<span class="fc" id="L296">                nestedExceptionRegions.pop().setEndBB(currBB);</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">            } else if (iop.endsBasicBlock()) {</span>
<span class="fc" id="L298">                bbEnded = true;</span>
<span class="fc" id="L299">                currBB.addInstr(i);</span>
                Label tgt;
<span class="fc" id="L301">                nextBBIsFallThrough = false;</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">                if (i instanceof BranchInstr) {</span>
<span class="fc" id="L303">                    tgt = ((BranchInstr) i).getJumpTarget();</span>
<span class="fc" id="L304">                    nextBBIsFallThrough = true;</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">                } else if (i instanceof JumpInstr) {</span>
<span class="fc" id="L306">                    tgt = ((JumpInstr) i).getJumpTarget();</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">                } else if (iop.isReturn()) { // BREAK, RETURN, CLOSURE_RETURN</span>
<span class="fc" id="L308">                    tgt = null;</span>
<span class="fc" id="L309">                    returnBBs.add(currBB);</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">                } else if (i instanceof ThrowExceptionInstr) {</span>
<span class="fc" id="L311">                    tgt = null;</span>
<span class="fc" id="L312">                    exceptionBBs.add(currBB);</span>
                } else {
<span class="nc" id="L314">                    throw new RuntimeException(&quot;Unhandled case in CFG builder for basic block ending instr: &quot; + i);</span>
                }

<span class="fc bfc" id="L317" title="All 2 branches covered.">                if (tgt != null) addEdge(currBB, tgt, forwardRefs);</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">            } else if (iop != Operation.LABEL) {</span>
<span class="fc" id="L319">                currBB.addInstr(i);</span>
            }

<span class="fc bfc" id="L322" title="All 2 branches covered.">            if (i instanceof CallBase) { // Build CFG for the closure if there exists one</span>
<span class="fc" id="L323">                Operand closureArg = ((CallBase) i).getClosureArg(getScope().getManager().getNil());</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">                if (closureArg instanceof WrappedIRClosure) {</span>
<span class="fc" id="L325">                    ((WrappedIRClosure) closureArg).getClosure().buildCFG();</span>
                }
            }
<span class="fc" id="L328">        }</span>

        // Process all rescued regions
<span class="fc bfc" id="L331" title="All 2 branches covered.">        for (ExceptionRegion rr: allExceptionRegions) {</span>
            // When this exception region represents an unrescued region
            // from a copied ensure block, we have a dummy label
<span class="fc" id="L334">            Label rescueLabel = rr.getFirstRescueBlockLabel();</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">            if (!Label.UNRESCUED_REGION_LABEL.equals(rescueLabel)) {</span>
<span class="fc" id="L336">                BasicBlock firstRescueBB = bbMap.get(rescueLabel);</span>
                // Mark the BB as a rescue entry BB
<span class="fc" id="L338">                firstRescueBB.markRescueEntryBB();</span>

                // Record a mapping from the region's exclusive basic blocks to the first bb that will start exception handling for all their exceptions.
                // Add an exception edge from every exclusive bb of the region to firstRescueBB
<span class="fc bfc" id="L342" title="All 2 branches covered.">                for (BasicBlock b: rr.getExclusiveBBs()) {</span>
<span class="fc" id="L343">                    setRescuerBB(b, firstRescueBB);</span>
<span class="fc" id="L344">                    graph.addEdge(b, firstRescueBB, EdgeType.EXCEPTION);</span>
<span class="fc" id="L345">                }</span>
            }
<span class="fc" id="L347">        }</span>

<span class="fc" id="L349">        buildExitBasicBlock(nestedExceptionRegions, firstBB, returnBBs, exceptionBBs, nextBBIsFallThrough, currBB, entryBB);</span>

        // System.out.println(&quot;-------------- CFG before optimizing --------------&quot;);
        // System.out.println(&quot;\nGraph:\n&quot; + toStringGraph());
        // System.out.println(&quot;\nInstructions:\n&quot; + toStringInstrs());

<span class="fc" id="L355">        optimize(returnBBs); // remove useless cfg edges &amp; orphaned bbs</span>

<span class="fc" id="L357">        return graph;</span>
    }

    private void addEdge(BasicBlock src, Label targetLabel, Map&lt;Label, List&lt;BasicBlock&gt;&gt; forwardRefs) {
<span class="fc" id="L361">        BasicBlock target = bbMap.get(targetLabel);</span>

<span class="fc bfc" id="L363" title="All 2 branches covered.">        if (target != null) {</span>
<span class="fc" id="L364">            graph.addEdge(src, target, EdgeType.REGULAR);</span>
<span class="fc" id="L365">            return;</span>
        }

        // Add a forward reference from target -&gt; source
<span class="fc" id="L369">        List&lt;BasicBlock&gt; forwardReferences = forwardRefs.get(targetLabel);</span>

<span class="fc bfc" id="L371" title="All 2 branches covered.">        if (forwardReferences == null) {</span>
<span class="fc" id="L372">            forwardReferences = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L373">            forwardRefs.put(targetLabel, forwardReferences);</span>
        }

<span class="fc" id="L376">        forwardReferences.add(src);</span>
<span class="fc" id="L377">    }</span>

    /**
     * Create special empty exit BasicBlock that all BasicBlocks will eventually
     * flow into.  All Edges to this 'dummy' BasicBlock will get marked with
     * an edge type of EXIT.
     *
     * Special BasicBlocks worth noting:
     * 1. Exceptions, Returns, Entry(why?) -&gt; ExitBB
     * 2. Returns -&gt; ExitBB
     */
    private BasicBlock buildExitBasicBlock(Stack&lt;ExceptionRegion&gt; nestedExceptionRegions, BasicBlock firstBB,
            List&lt;BasicBlock&gt; returnBBs, List&lt;BasicBlock&gt; exceptionBBs, boolean nextIsFallThrough, BasicBlock currBB, BasicBlock entryBB) {
<span class="fc" id="L390">        exitBB = createBB(nestedExceptionRegions);</span>

<span class="fc" id="L392">        graph.addEdge(entryBB, exitBB, EdgeType.EXIT);</span>
<span class="fc" id="L393">        graph.addEdge(entryBB, firstBB, EdgeType.FALL_THROUGH);</span>

<span class="fc bfc" id="L395" title="All 2 branches covered.">        for (BasicBlock rb : returnBBs) {</span>
<span class="fc" id="L396">            graph.addEdge(rb, exitBB, EdgeType.EXIT);</span>
<span class="fc" id="L397">        }</span>

<span class="fc bfc" id="L399" title="All 2 branches covered.">        for (BasicBlock rb : exceptionBBs) {</span>
<span class="fc" id="L400">            graph.addEdge(rb, exitBB, EdgeType.EXIT);</span>
<span class="fc" id="L401">        }</span>

<span class="fc bfc" id="L403" title="All 2 branches covered.">        if (nextIsFallThrough) graph.addEdge(currBB, exitBB, EdgeType.EXIT);</span>

<span class="fc" id="L405">        return exitBB;</span>
    }

    private BasicBlock createBB(Label label, Stack&lt;ExceptionRegion&gt; nestedExceptionRegions) {
<span class="fc" id="L409">        BasicBlock basicBlock = new BasicBlock(this, label);</span>
<span class="fc" id="L410">        addBasicBlock(basicBlock);</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">        if (label.isGlobalEnsureBlockLabel()) {</span>
<span class="fc" id="L412">            globalEnsureBB = basicBlock;</span>
        }

<span class="fc bfc" id="L415" title="All 2 branches covered.">        if (!nestedExceptionRegions.empty()) nestedExceptionRegions.peek().addBB(basicBlock);</span>

<span class="fc" id="L417">        return basicBlock;</span>
    }

    private BasicBlock createBB(Stack&lt;ExceptionRegion&gt; nestedExceptionRegions) {
<span class="fc" id="L421">        return createBB(scope.getNewLabel(), nestedExceptionRegions);</span>
    }

    public void addBasicBlock(BasicBlock bb) {
<span class="fc" id="L425">        graph.findOrCreateVertexFor(bb); // adds vertex to graph</span>
<span class="fc" id="L426">        bbMap.put(bb.getLabel(), bb);</span>

        // Reset so later dataflow analyses get all basic blocks
<span class="fc" id="L429">        postOrderList = null;</span>
<span class="fc" id="L430">    }</span>

    public void removeEdge(Edge edge) {
<span class="nc" id="L433">        graph.removeEdge(edge);</span>
<span class="nc" id="L434">    }</span>

    public void removeAllOutgoingEdgesForBB(BasicBlock b) {
<span class="nc" id="L437">        graph.findVertexFor(b).removeAllOutgoingEdges();</span>
<span class="nc" id="L438">    }</span>

    private void deleteOrphanedBlocks(DirectedGraph&lt;BasicBlock&gt; graph) {
        // System.out.println(&quot;\nGraph:\n&quot; + toStringGraph());
        // System.out.println(&quot;\nInstructions:\n&quot; + toStringInstrs());

        // FIXME: Quick and dirty implementation
        while (true) {
<span class="fc" id="L446">            BasicBlock bbToRemove = null;</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">            for (BasicBlock b : graph.allData()) {</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">                if (b == entryBB) continue; // Skip entry bb!</span>

                // Every other bb should have at least one incoming edge
<span class="fc bfc" id="L451" title="All 2 branches covered.">                if (graph.findVertexFor(b).getIncomingEdges().isEmpty()) {</span>
<span class="fc" id="L452">                    bbToRemove = b;</span>
<span class="fc" id="L453">                    break;</span>
                }
<span class="fc" id="L455">            }</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">            if (bbToRemove == null) break;</span>

<span class="fc" id="L458">            removeBB(bbToRemove);</span>
<span class="fc" id="L459">            removeNestedScopesFromBB(bbToRemove);</span>
<span class="fc" id="L460">        }</span>
<span class="fc" id="L461">    }</span>

    private boolean mergeBBs(BasicBlock a, BasicBlock b) {
<span class="fc" id="L464">        BasicBlock aR = getRescuerBBFor(a);</span>
<span class="fc" id="L465">        BasicBlock bR = getRescuerBBFor(b);</span>

        // We can merge 'a' and 'b' if one of the following is true:
        // 1. 'a' and 'b' are both not empty
        //    They are protected by the same rescue block.
        //    NOTE: We need not check the ensure block map because all ensure blocks are already
        //    captured in the bb rescue block map.  So, if aR == bR, it is guaranteed that the
        //    ensure blocks for the two are identical.
        // 2. One of 'a' or 'b' is empty.  We dont need to check for rescue block match because
        //    an empty basic block cannot raise an exception, can it?
<span class="pc bpc" id="L475" title="1 of 6 branches missed.">        if (aR == bR || a.isEmpty() || b.isEmpty()) {</span>
            // First, remove straight-line jump, if present
<span class="fc" id="L477">            Instr lastInstr = a.getLastInstr();</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">            if (lastInstr instanceof JumpInstr) a.removeInstr(lastInstr);</span>

            // Swallow b's instrs.
<span class="fc" id="L481">            a.swallowBB(b);</span>

            // Fixup edges
<span class="fc" id="L484">            removeEdge(a, b);</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">            for (Edge&lt;BasicBlock&gt; e : getOutgoingEdges(b)) {</span>
<span class="fc" id="L486">                addEdge(a, e.getDestination().getData(), e.getType());</span>
<span class="fc" id="L487">            }</span>

            // Delete bb
<span class="fc" id="L490">            removeBB(b);</span>

            // Update rescue map
<span class="pc bpc" id="L493" title="1 of 4 branches missed.">            if (aR == null &amp;&amp; bR != null) {</span>
<span class="fc" id="L494">                setRescuerBB(a, bR);</span>
            }

<span class="fc" id="L497">            return true;</span>
        } else {
<span class="fc" id="L499">            return false;</span>
        }
    }

    public void removeBB(BasicBlock b) {
<span class="fc" id="L504">        graph.removeVertexFor(b);</span>
<span class="fc" id="L505">        bbMap.remove(b.getLabel());</span>
<span class="fc" id="L506">        rescuerMap.remove(b);</span>
<span class="fc" id="L507">    }</span>

    /**
     * Wrapped IRClosures in dead BB are lexically rooted to that dead BB so they can
     * be removed from the parent scope if the BB they live in died.
     */
    private void removeNestedScopesFromBB(BasicBlock bb) {
<span class="fc bfc" id="L514" title="All 2 branches covered.">        for (Instr instr: bb.getInstrs()) {</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">            for (Operand oper: instr.getOperands()) {</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">                if (oper instanceof WrappedIRClosure) {</span>
<span class="nc" id="L517">                    scope.removeClosure(((WrappedIRClosure) oper).getClosure());</span>
<span class="nc" id="L518">                    break; // Only one WrappedIRClosure possible per instr</span>
                }
            }
<span class="fc" id="L521">        }</span>
<span class="fc" id="L522">    }</span>

    public void collapseStraightLineBBs() {
        // Collect cfgs in a list first since the cfg/graph API returns an iterator
        // over live data.  But, basic block merging modifies that live data.
        //
        // SSS FIXME: So, we need a cfg/graph API that returns an iterator over
        // frozen data rather than live data.
<span class="fc" id="L530">        List&lt;BasicBlock&gt; cfgBBs = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">        for (BasicBlock b: getBasicBlocks()) cfgBBs.add(b);</span>

<span class="fc" id="L533">        Set&lt;BasicBlock&gt; mergedBBs = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">        for (BasicBlock b: cfgBBs) {</span>
<span class="fc bfc" id="L535" title="All 4 branches covered.">            if (!mergedBBs.contains(b) &amp;&amp; outDegree(b) == 1) {</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">                for (Edge&lt;BasicBlock&gt; e : getOutgoingEdges(b)) {</span>
<span class="fc" id="L537">                    BasicBlock outB = e.getDestination().getData();</span>
<span class="pc bpc" id="L538" title="1 of 6 branches missed.">                    if (e.getType() != EdgeType.EXCEPTION &amp;&amp; inDegree(outB) == 1 &amp;&amp; mergeBBs(b, outB)) {</span>
<span class="fc" id="L539">                        mergedBBs.add(outB);</span>
                    }
<span class="fc" id="L541">                }</span>
            }
<span class="fc" id="L543">        }</span>
<span class="fc" id="L544">    }</span>

    private void optimize(List&lt;BasicBlock&gt; returnBBs) {
        // Propagate returns backwards where possible.
        // If:
        // - there is an edge from BB: x -&gt; r, and
        // - r has a single instr, the return, and
        // - last instr of x is a copy, and
        // - the copy feeds the return
        // then:
        // - replace the copy with a return that returns the copied value
        // - remove the edge from x -&gt; r
        // - add an edge from x -&gt; exit-bb
        //
        // If a jump intervenes in 'x', skip over it and if merge succeeds,
        // delete the jump.
<span class="fc" id="L560">        List&lt;Edge&gt; toRemove = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">        for (BasicBlock retBB: returnBBs) {</span>
<span class="fc" id="L562">            List&lt;Instr&gt; rbInstrs = retBB.getInstrs();</span>
<span class="fc" id="L563">            Instr first = rbInstrs.get(0);</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">            if (first instanceof ReturnInstr) {</span>
<span class="fc" id="L565">                Operand rv = ((ReturnInstr)first).getReturnValue();</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">                if (rv instanceof Variable) {</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">                    for (Edge&lt;BasicBlock&gt; e : getIncomingEdges(retBB)) {</span>
<span class="fc" id="L568">                        BasicBlock srcBB = e.getSource().getData();</span>
<span class="fc" id="L569">                        List&lt;Instr&gt; srcInstrs = srcBB.getInstrs();</span>
<span class="fc" id="L570">                        int n = srcInstrs.size();</span>

                        // Skip over empty bbs
<span class="fc bfc" id="L573" title="All 2 branches covered.">                        if (n == 0) continue;</span>

<span class="fc" id="L575">                        Instr jump = null;</span>
<span class="fc" id="L576">                        Instr last = srcInstrs.get(n-1);</span>
                        // Skip over a jump
<span class="fc bfc" id="L578" title="All 4 branches covered.">                        if (last instanceof JumpInstr &amp;&amp; n &gt; 2) {</span>
<span class="fc" id="L579">                            jump = last;</span>
<span class="fc" id="L580">                            last = srcInstrs.get(n-2);</span>
                        }
                        // Merge
<span class="fc bfc" id="L583" title="All 4 branches covered.">                        if (last instanceof CopyInstr &amp;&amp; ((CopyInstr)last).getResult().equals(rv)) {</span>
<span class="fc" id="L584">                            srcInstrs.set(n-1, new ReturnInstr(((CopyInstr)last).getSource()));</span>
<span class="fc" id="L585">                            toRemove.add(e);</span>
<span class="fc" id="L586">                            addEdge(srcBB, exitBB, EdgeType.EXIT);</span>
                            // System.out.println(&quot;Merged &quot; + last + &quot; with &quot; + ri + &quot; in &quot; + scope);
<span class="fc bfc" id="L588" title="All 2 branches covered.">                            if (jump != null) {</span>
<span class="fc" id="L589">                                srcInstrs.remove(jump);</span>
                                // System.out.println(&quot;Deleting &quot; + jump);
                            }
                        }
<span class="fc" id="L593">                    }</span>
                }
            }
<span class="fc" id="L596">        }</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">        for (Edge edge: toRemove) {</span>
<span class="fc" id="L598">            graph.removeEdge(edge);</span>
<span class="fc" id="L599">        }</span>

        // SSS FIXME: Can't we not add some of these exception edges in the first place??
        // Remove exception edges from blocks that couldn't possibly thrown an exception!
<span class="fc" id="L603">        toRemove = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">        for (BasicBlock b : graph.allData()) {</span>
<span class="fc" id="L605">            boolean noExceptions = true;</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">            for (Instr i : b.getInstrs()) {</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">                if (i.canRaiseException()) {</span>
<span class="fc" id="L608">                    noExceptions = false;</span>
<span class="fc" id="L609">                    break;</span>
                }
<span class="fc" id="L611">            }</span>

<span class="fc bfc" id="L613" title="All 2 branches covered.">            if (noExceptions) {</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">                for (Edge&lt;BasicBlock&gt; e : graph.findVertexFor(b).getOutgoingEdgesOfType(EdgeType.EXCEPTION)) {</span>
<span class="fc" id="L615">                    BasicBlock source = e.getSource().getData();</span>
<span class="fc" id="L616">                    BasicBlock destination = e.getDestination().getData();</span>
<span class="fc" id="L617">                    toRemove.add(e);</span>

<span class="pc bpc" id="L619" title="1 of 2 branches missed.">                    if (rescuerMap.get(source) == destination) rescuerMap.remove(source);</span>
<span class="fc" id="L620">                }</span>
            }
<span class="fc" id="L622">        }</span>

<span class="fc bfc" id="L624" title="All 2 branches covered.">        if (!toRemove.isEmpty()) {</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">            for (Edge edge: toRemove) {</span>
<span class="fc" id="L626">                graph.removeEdge(edge);</span>
<span class="fc" id="L627">            }</span>
        }

<span class="fc" id="L630">        deleteOrphanedBlocks(graph);</span>

<span class="fc" id="L632">        collapseStraightLineBBs();</span>
<span class="fc" id="L633">    }</span>

    public String toStringGraph() {
<span class="nc" id="L636">        return graph.toString();</span>
    }

    public String toStringInstrs() {
<span class="nc" id="L640">        StringBuilder buf = new StringBuilder();</span>

<span class="nc bnc" id="L642" title="All 2 branches missed.">        for (BasicBlock b : getSortedBasicBlocks()) {</span>
<span class="nc" id="L643">            buf.append(b.toStringInstrs());</span>
<span class="nc" id="L644">        }</span>
<span class="nc" id="L645">        buf.append(&quot;\n\n------ Rescue block map ------\n&quot;);</span>
<span class="nc" id="L646">        List&lt;BasicBlock&gt; e = new ArrayList&lt;&gt;(rescuerMap.keySet());</span>
<span class="nc" id="L647">        Collections.sort(e);</span>

<span class="nc bnc" id="L649" title="All 2 branches missed.">        for (BasicBlock bb : e) {</span>
<span class="nc" id="L650">            buf.append(&quot;BB &quot;).append(bb.getID()).append(&quot; --&gt; BB &quot;).append(rescuerMap.get(bb).getID()).append(&quot;\n&quot;);</span>
<span class="nc" id="L651">        }</span>

<span class="nc" id="L653">        List&lt;IRClosure&gt; closures = scope.getClosures();</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">        if (!closures.isEmpty()) {</span>
<span class="nc" id="L655">            buf.append(&quot;\n\n------ Closures encountered in this scope ------\n&quot;);</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">            for (IRClosure c : closures) {</span>
<span class="nc" id="L657">                buf.append(c.toStringBody());</span>
<span class="nc" id="L658">            }</span>
<span class="nc" id="L659">            buf.append(&quot;------------------------------------------------\n&quot;);</span>
        }

<span class="nc" id="L662">        return buf.toString();</span>
    }

    public void removeEdge(BasicBlock a, BasicBlock b) {
<span class="fc" id="L666">       graph.removeEdge(a, b);</span>
<span class="fc" id="L667">    }</span>

    private LinkedList&lt;BasicBlock&gt; buildPostOrderList() {
<span class="fc" id="L670">        BasicBlock             root    = getEntryBB();</span>
<span class="fc" id="L671">        LinkedList&lt;BasicBlock&gt; list    = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L672">        Stack&lt;BasicBlock&gt;      stack   = new Stack&lt;&gt;();</span>
<span class="fc" id="L673">        boolean[]              visited = new boolean[1 + getMaxNodeID()];</span>

<span class="fc" id="L675">        stack.push(root);</span>
<span class="fc" id="L676">        visited[root.getID()] = true;</span>

        // Non-recursive post-order traversal (the added flag is required to handle cycles and common ancestors)
<span class="fc bfc" id="L679" title="All 2 branches covered.">        while (!stack.empty()) {</span>
            // Check if all children of the top of the stack have been added
<span class="fc" id="L681">            BasicBlock b = stack.peek();</span>
<span class="fc" id="L682">            boolean allChildrenVisited = true;</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">            for (BasicBlock dst: getOutgoingDestinations(b)) {</span>
<span class="fc" id="L684">                int dstID = dst.getID();</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">                if (!visited[dstID]) {</span>
<span class="fc" id="L686">                    allChildrenVisited = false;</span>
                    // This ensures that no matter what order we visit children, we process exit nodes before anything.
                    // else.  Alternatively, getOutgoingDestinations(..) would have to return nodes in a specific order
                    // that is dependent on basic block numbering -- which would be fragile.
<span class="fc bfc" id="L690" title="All 2 branches covered.">                    if (graph.findVertexFor(dst).outDegree() == 0) {</span>
<span class="fc" id="L691">                        list.add(dst);</span>
                    } else {
<span class="fc" id="L693">                        stack.push(dst);</span>
                    }
<span class="fc" id="L695">                    visited[dstID] = true;</span>
                }
<span class="fc" id="L697">            }</span>

            // If all children have been added previously, we are ready with 'b' in this round!
<span class="fc bfc" id="L700" title="All 2 branches covered.">            if (allChildrenVisited) {</span>
<span class="fc" id="L701">                stack.pop();</span>
<span class="fc" id="L702">                list.add(b);</span>
            }
<span class="fc" id="L704">        }</span>

        // Sanity check!
<span class="fc bfc" id="L707" title="All 2 branches covered.">        for (BasicBlock b : getBasicBlocks()) {</span>
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">            if (!visited[b.getID()]) {</span>
<span class="nc" id="L709">                printError(&quot;BB &quot; + b.getID() + &quot; missing from po list!&quot;);</span>
<span class="nc" id="L710">                break;</span>
            }
<span class="fc" id="L712">        }</span>

<span class="fc" id="L714">        return list;</span>
    }

    /**
     * Clone this CFG and return a new one.
     *
     * @param info context object to perform the clone
     * @param clonedScope already cloned IRScope which this new CFG will belong to
     * @return a newly cloned CFG
     */
    public CFG clone(CloneInfo info, IRScope clonedScope) {
<span class="nc" id="L725">        CFG newCFG = new CFG(clonedScope);</span>
<span class="nc" id="L726">        Map&lt;BasicBlock, BasicBlock&gt; cloneBBMap = new HashMap&lt;&gt;();</span>

        // Part 1: Clone all BBs and stuff in map so graph building in 2 will have all BBs available.
<span class="nc bnc" id="L729" title="All 2 branches missed.">        for (BasicBlock bb: getBasicBlocks()) {                 // clone bbs</span>
<span class="nc" id="L730">            BasicBlock newBB = bb.clone(info, newCFG);</span>
<span class="nc" id="L731">            newCFG.addBasicBlock(newBB);</span>
<span class="nc" id="L732">            cloneBBMap.put(bb, newBB);</span>
<span class="nc" id="L733">        }</span>

        // Part 2: Clone graph (build new edges from new BBs made in previous phase)
<span class="nc bnc" id="L736" title="All 2 branches missed.">        for (BasicBlock bb: getBasicBlocks()) {</span>
<span class="nc" id="L737">            BasicBlock newSource = cloneBBMap.get(bb);</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">            for (Edge&lt;BasicBlock&gt; edge : getOutgoingEdges(bb)) {</span>
<span class="nc" id="L739">                BasicBlock newDestination = cloneBBMap.get(edge.getDestination().getData());</span>
<span class="nc" id="L740">                newCFG.addEdge(newSource, newDestination, edge.getType());</span>
<span class="nc" id="L741">            }</span>
<span class="nc" id="L742">        }</span>

        // Part 3: clone all non-derivable fields
<span class="nc bnc" id="L745" title="All 2 branches missed.">        for (BasicBlock bb: rescuerMap.keySet()) {              // clone rescuer map</span>
<span class="nc" id="L746">            newCFG.setRescuerBB(cloneBBMap.get(bb), cloneBBMap.get(rescuerMap.get(bb)));</span>
<span class="nc" id="L747">        }</span>

<span class="nc" id="L749">        newCFG.entryBB = cloneBBMap.get(entryBB);               // clone entry BB</span>
<span class="nc" id="L750">        newCFG.exitBB  = cloneBBMap.get(exitBB);                // clone exit BB</span>
<span class="nc" id="L751">        newCFG.globalEnsureBB = cloneBBMap.get(globalEnsureBB); // clone GEB</span>

<span class="nc" id="L753">        return newCFG;</span>
    }

    private void printError(String message) {
<span class="nc" id="L757">        LOG.error(message + &quot;\nGraph:\n&quot; + this + &quot;\nInstructions:\n&quot; + toStringInstrs());</span>
<span class="nc" id="L758">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>