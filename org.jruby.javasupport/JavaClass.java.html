<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JavaClass.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby.javasupport</a> &gt; <span class="el_source">JavaClass.java</span></div><h1>JavaClass.java</h1><pre class="source lang-java linenums">/***** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2002-2004 Anders Bengtsson &lt;ndrsbngtssn@yahoo.se&gt;
 * Copyright (C) 2002-2004 Jan Arne Petersen &lt;jpetersen@uni-bonn.de&gt;
 * Copyright (C) 2004-2005 Thomas E Enebo &lt;enebo@acm.org&gt;
 * Copyright (C) 2004 Stefan Matthias Aust &lt;sma@3plus4.de&gt;
 * Copyright (C) 2004 David Corbin &lt;dcorbin@users.sourceforge.net&gt;
 * Copyright (C) 2005 Charles O Nutter &lt;headius@headius.com&gt;
 * Copyright (C) 2006 Kresten Krab Thorup &lt;krab@gnu.org&gt;
 * Copyright (C) 2007 Miguel Covarrubias &lt;mlcovarrubias@gmail.com&gt;
 * Copyright (C) 2007 William N Dortch &lt;bill.dortch@gmail.com&gt;
 * Copyright (C) 2011 David Pollak &lt;feeder.of.the.bears@gmail.com&gt;
 * 
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby.javasupport;

import org.jruby.java.invokers.StaticFieldGetter;
import org.jruby.java.invokers.StaticMethodInvoker;
import org.jruby.java.invokers.SingletonMethodInvoker;
import org.jruby.java.invokers.InstanceFieldGetter;
import org.jruby.java.invokers.InstanceFieldSetter;
import org.jruby.java.invokers.InstanceMethodInvoker;
import org.jruby.java.invokers.StaticFieldSetter;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ReflectPermission;
import java.security.AccessController;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.concurrent.locks.ReentrantLock;

import org.jruby.Ruby;
import org.jruby.RubyArray;
import org.jruby.RubyBoolean;
import org.jruby.RubyClass;
import org.jruby.RubyInstanceConfig;
import org.jruby.RubyInteger;
import org.jruby.RubyModule;
import org.jruby.RubyString;
import org.jruby.anno.JRubyMethod;
import org.jruby.anno.JRubyClass;
import org.jruby.common.IRubyWarnings.ID;
import org.jruby.exceptions.RaiseException;
import org.jruby.internal.runtime.methods.DynamicMethod;
import org.jruby.internal.runtime.methods.JavaMethod.JavaMethodZero;
import org.jruby.java.proxies.ArrayJavaProxy;
import org.jruby.java.invokers.ConstructorInvoker;
import org.jruby.java.proxies.ConcreteJavaProxy;
import org.jruby.java.util.ArrayUtils;
import org.jruby.runtime.Helpers;
import org.jruby.runtime.Block;
import org.jruby.runtime.ObjectAllocator;
import org.jruby.runtime.ThreadContext;
import org.jruby.runtime.Visibility;
import static org.jruby.runtime.Visibility.*;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.util.ByteList;
import org.jruby.util.IdUtil;
import org.jruby.util.cli.Options;
import org.jruby.util.log.Logger;
import org.jruby.util.log.LoggerFactory;

<span class="pc bpc" id="L96" title="1 of 2 branches missed.">@JRubyClass(name=&quot;Java::JavaClass&quot;, parent=&quot;Java::JavaObject&quot;)</span>
public class JavaClass extends JavaObject {

<span class="fc" id="L99">    private static final Logger LOG = LoggerFactory.getLogger(&quot;JavaClass&quot;);</span>

    public static final String METHOD_MANGLE = &quot;__method&quot;;
    public static final boolean DEBUG_SCALA = false;

    public static final boolean CAN_SET_ACCESSIBLE;

    static {
<span class="fc" id="L107">        boolean canSetAccessible = false;</span>

<span class="pc bpc" id="L109" title="1 of 2 branches missed.">        if (RubyInstanceConfig.CAN_SET_ACCESSIBLE) {</span>
            try {
<span class="nc" id="L111">                AccessController.checkPermission(new ReflectPermission(&quot;suppressAccessChecks&quot;));</span>
<span class="nc" id="L112">                canSetAccessible = true;</span>
<span class="fc" id="L113">            } catch (Throwable t) {</span>
                // added this so if things are weird in the future we can debug without
                // spinning a new binary
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">                if (Options.JI_LOGCANSETACCESSIBLE.load()) {</span>
<span class="nc" id="L117">                    t.printStackTrace();</span>
                }

                // assume any exception means we can't suppress access checks
<span class="fc" id="L121">                canSetAccessible = false;</span>
<span class="nc" id="L122">            }</span>
        }

<span class="fc" id="L125">        CAN_SET_ACCESSIBLE = canSetAccessible;</span>
    }

    private void handleScalaSingletons(Class&lt;?&gt; javaClass, InitializerState state) {
        // check for Scala companion object
        try {
<span class="fc" id="L131">            ClassLoader cl = javaClass.getClassLoader();</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">            if (cl == null) {</span>
                //this is a core class, bail
<span class="fc" id="L134">                return;</span>
            }
            
<span class="nc" id="L137">            Class&lt;?&gt; companionClass = cl.loadClass(javaClass.getName() + &quot;$&quot;);</span>
<span class="nc" id="L138">            Field field = companionClass.getField(&quot;MODULE$&quot;);</span>
<span class="nc" id="L139">            Object singleton = field.get(null);</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">            if (singleton != null) {</span>
<span class="nc" id="L141">                Method[] sMethods = getMethods(companionClass);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">                for (int j = sMethods.length - 1; j &gt;= 0; j--) {</span>
<span class="nc" id="L143">                    Method method = sMethods[j];</span>
<span class="nc" id="L144">                    String name = method.getName();</span>
                    if (DEBUG_SCALA) {
                        LOG.debug(&quot;Companion object method {} for {}&quot;, name, companionClass);
                    }
<span class="nc bnc" id="L148" title="All 2 branches missed.">                    if (name.indexOf(&quot;$&quot;) &gt;= 0) {</span>
<span class="nc" id="L149">                        name = fixScalaNames(name);</span>
                    }
<span class="nc bnc" id="L151" title="All 2 branches missed.">                    if (!Modifier.isStatic(method.getModifiers())) {</span>
<span class="nc" id="L152">                        AssignedName assignedName = state.staticNames.get(name);</span>
                        // For JRUBY-4505, restore __method methods for reserved names
<span class="nc bnc" id="L154" title="All 2 branches missed.">                        if (INSTANCE_RESERVED_NAMES.containsKey(method.getName())) {</span>
                            if (DEBUG_SCALA) {
                                LOG.debug(&quot;in reserved &quot; + name);
                            }
<span class="nc" id="L158">                            installSingletonMethods(state.staticCallbacks, javaClass, singleton, method, name + METHOD_MANGLE);</span>
<span class="nc" id="L159">                            continue;</span>
                        }
<span class="nc bnc" id="L161" title="All 2 branches missed.">                        if (assignedName == null) {</span>
<span class="nc" id="L162">                            state.staticNames.put(name, new AssignedName(name, Priority.METHOD));</span>
                            if (DEBUG_SCALA) {
                                LOG.debug(&quot;Assigned name is null&quot;);
                            }
                        } else {
<span class="nc bnc" id="L167" title="All 2 branches missed.">                            if (Priority.METHOD.lessImportantThan(assignedName)) {</span>
                                if (DEBUG_SCALA) {
                                    LOG.debug(&quot;Less important&quot;);
                                }
<span class="nc" id="L171">                                continue;</span>
                            }
<span class="nc bnc" id="L173" title="All 2 branches missed.">                            if (!Priority.METHOD.asImportantAs(assignedName)) {</span>
<span class="nc" id="L174">                                state.staticCallbacks.remove(name);</span>
<span class="nc" id="L175">                                state.staticCallbacks.remove(name + '=');</span>
<span class="nc" id="L176">                                state.staticNames.put(name, new AssignedName(name, Priority.METHOD));</span>
                            }
                        }
                        if (DEBUG_SCALA) {
                            LOG.debug(&quot;Installing {} {} {}&quot;, name, method, singleton);
                        }
<span class="nc" id="L182">                        installSingletonMethods(state.staticCallbacks, javaClass, singleton, method, name);</span>
                    } else {
                        if (DEBUG_SCALA) {
                            LOG.debug(&quot;Method {} is sadly static&quot;, method);
                        }
                    }
                }
            }
            
<span class="fc" id="L191">        } catch (Exception e) {</span>
            // ignore... there's no companion object
<span class="nc" id="L193">        }</span>
<span class="fc" id="L194">    }</span>
    
    /**
     * Assigned names only override based priority of an assigned type, the type must be less than
     * or equal to the assigned type. For example, field name (FIELD) in a subclass will override
     * an alias (ALIAS) in a superclass, but not a method (METHOD).
     */
<span class="pc" id="L201">    private enum Priority {</span>
<span class="fc" id="L202">        RESERVED(0), METHOD(1), FIELD(2), PROTECTED_METHOD(3),</span>
<span class="fc" id="L203">        WEAKLY_RESERVED(4), ALIAS(5), PROTECTED_FIELD(6);</span>

        private int value;

<span class="fc" id="L207">        Priority(int value) {</span>
<span class="fc" id="L208">            this.value = value;</span>
<span class="fc" id="L209">        }</span>

        public boolean asImportantAs(AssignedName other) {
<span class="pc bpc" id="L212" title="1 of 4 branches missed.">            return other != null &amp;&amp; other.type.value == value;</span>
        }
        
        public boolean lessImportantThan(AssignedName other) {
<span class="pc bpc" id="L216" title="1 of 4 branches missed.">            return other != null &amp;&amp; other.type.value &lt; value;</span>
        }
        
        public boolean moreImportantThan(AssignedName other) {
<span class="pc bpc" id="L220" title="1 of 4 branches missed.">            return other == null || other.type.value &gt; value;</span>
        }
    }

    private static class AssignedName {
        String name;
        Priority type;
        
<span class="nc" id="L228">        AssignedName () {}</span>
<span class="fc" id="L229">        AssignedName(String name, Priority type) {</span>
<span class="fc" id="L230">            this.name = name;</span>
<span class="fc" id="L231">            this.type = type;</span>
<span class="fc" id="L232">        }</span>
    }

    // TODO: other reserved names?
<span class="fc" id="L236">    private static final Map&lt;String, AssignedName&gt; RESERVED_NAMES = new HashMap&lt;String, AssignedName&gt;();</span>
    static {
<span class="fc" id="L238">        RESERVED_NAMES.put(&quot;__id__&quot;, new AssignedName(&quot;__id__&quot;, Priority.RESERVED));</span>
<span class="fc" id="L239">        RESERVED_NAMES.put(&quot;__send__&quot;, new AssignedName(&quot;__send__&quot;, Priority.RESERVED));</span>
        // JRUBY-5132: java.awt.Component.instance_of?() expects 2 args
<span class="fc" id="L241">        RESERVED_NAMES.put(&quot;instance_of?&quot;, new AssignedName(&quot;instance_of?&quot;, Priority.RESERVED));</span>
    }
<span class="fc" id="L243">    private static final Map&lt;String, AssignedName&gt; STATIC_RESERVED_NAMES = new HashMap&lt;String, AssignedName&gt;(RESERVED_NAMES);</span>
    static {
<span class="fc" id="L245">        STATIC_RESERVED_NAMES.put(&quot;new&quot;, new AssignedName(&quot;new&quot;, Priority.RESERVED));</span>
    }
<span class="fc" id="L247">    private static final Map&lt;String, AssignedName&gt; INSTANCE_RESERVED_NAMES = new HashMap&lt;String, AssignedName&gt;(RESERVED_NAMES);</span>
    static {
        // only possible for &quot;getClass&quot; to be an instance method in Java
<span class="fc" id="L250">        INSTANCE_RESERVED_NAMES.put(&quot;class&quot;, new AssignedName(&quot;class&quot;, Priority.RESERVED));</span>
        // &quot;initialize&quot; has meaning only for an instance (as opposed to a class)
<span class="fc" id="L252">        INSTANCE_RESERVED_NAMES.put(&quot;initialize&quot;, new AssignedName(&quot;initialize&quot;, Priority.RESERVED));</span>
    }

    private static abstract class NamedInstaller {
        static final int STATIC_FIELD = 1;
        static final int STATIC_METHOD = 2;
        static final int INSTANCE_FIELD = 3;
        static final int INSTANCE_METHOD = 4;
        static final int CONSTRUCTOR = 5;
        String name;
        int type;
<span class="pc" id="L263">        Visibility visibility = Visibility.PUBLIC;</span>
<span class="nc" id="L264">        NamedInstaller () {}</span>
<span class="fc" id="L265">        NamedInstaller (String name, int type) {</span>
<span class="fc" id="L266">            this.name = name;</span>
<span class="fc" id="L267">            this.type = type;</span>
<span class="fc" id="L268">        }</span>
        abstract void install(RubyModule proxy);
        // small hack to save a cast later on
        boolean hasLocalMethod() {
<span class="nc" id="L272">            return true;</span>
        }
        boolean isPublic() {
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">            return visibility == Visibility.PUBLIC;</span>
        }
        boolean isProtected() {
<span class="nc bnc" id="L278" title="All 2 branches missed.">            return visibility == Visibility.PROTECTED;</span>
        }
    }

    private static abstract class FieldInstaller extends NamedInstaller {
        Field field;
<span class="nc" id="L284">        FieldInstaller(){}</span>
        FieldInstaller(String name, int type, Field field) {
<span class="fc" id="L286">            super(name,type);</span>
<span class="fc" id="L287">            this.field = field;</span>
<span class="fc" id="L288">        }</span>
    }

    private static class StaticFieldGetterInstaller extends FieldInstaller {
<span class="nc" id="L292">        StaticFieldGetterInstaller(){}</span>
        StaticFieldGetterInstaller(String name, Field field) {
<span class="fc" id="L294">            super(name,STATIC_FIELD,field);</span>
<span class="fc" id="L295">        }</span>
        void install(RubyModule proxy) {
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">            if (Modifier.isPublic(field.getModifiers())) {</span>
<span class="fc" id="L298">                proxy.getSingletonClass().addMethod(name, new StaticFieldGetter(name, proxy, field));</span>
            }
<span class="fc" id="L300">        }</span>
    }

    private static class StaticFieldSetterInstaller extends FieldInstaller {
<span class="nc" id="L304">        StaticFieldSetterInstaller(){}</span>
        StaticFieldSetterInstaller(String name, Field field) {
<span class="fc" id="L306">            super(name,STATIC_FIELD,field);</span>
<span class="fc" id="L307">        }</span>
        void install(RubyModule proxy) {
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">            if (Modifier.isPublic(field.getModifiers())) {</span>
<span class="fc" id="L310">                proxy.getSingletonClass().addMethod(name, new StaticFieldSetter(name, proxy, field));</span>
            }
<span class="fc" id="L312">        }</span>
    }

    private static class InstanceFieldGetterInstaller extends FieldInstaller {
<span class="nc" id="L316">        InstanceFieldGetterInstaller(){}</span>
        InstanceFieldGetterInstaller(String name, Field field) {
<span class="fc" id="L318">            super(name,INSTANCE_FIELD,field);</span>
<span class="fc" id="L319">        }</span>
        void install(RubyModule proxy) {
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">            if (Modifier.isPublic(field.getModifiers())) {</span>
<span class="fc" id="L322">                proxy.addMethod(name, new InstanceFieldGetter(name, proxy, field));</span>
            }
<span class="fc" id="L324">        }</span>
    }

    private static class InstanceFieldSetterInstaller extends FieldInstaller {
<span class="nc" id="L328">        InstanceFieldSetterInstaller(){}</span>
        InstanceFieldSetterInstaller(String name, Field field) {
<span class="fc" id="L330">            super(name,INSTANCE_FIELD,field);</span>
<span class="fc" id="L331">        }</span>
        void install(RubyModule proxy) {
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">            if (Modifier.isPublic(field.getModifiers())) {</span>
<span class="fc" id="L334">                proxy.addMethod(name, new InstanceFieldSetter(name, proxy, field));</span>
            }
<span class="fc" id="L336">        }</span>
    }

    private static abstract class MethodInstaller extends NamedInstaller {
        private boolean haveLocalMethod;
        protected List&lt;Method&gt; methods;
        protected List&lt;String&gt; aliases;
<span class="nc" id="L343">        MethodInstaller(){}</span>
        MethodInstaller(String name, int type) {
<span class="fc" id="L345">            super(name,type);</span>
<span class="fc" id="L346">        }</span>

        // called only by initializing thread; no synchronization required
        void addMethod(Method method, Class&lt;?&gt; javaClass) {
<span class="fc bfc" id="L350" title="All 2 branches covered.">            if (methods == null) {</span>
<span class="fc" id="L351">                methods = new ArrayList&lt;Method&gt;(4);</span>
            }
<span class="fc" id="L353">            methods.add(method);</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">            haveLocalMethod |= javaClass == method.getDeclaringClass() ||</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">                    method.getDeclaringClass().isInterface();</span>
<span class="fc" id="L356">        }</span>

        // called only by initializing thread; no synchronization required
        void addAlias(String alias) {
<span class="fc bfc" id="L360" title="All 2 branches covered.">            if (aliases == null) {</span>
<span class="fc" id="L361">                aliases = new ArrayList&lt;String&gt;(4);</span>
            }
<span class="fc bfc" id="L363" title="All 2 branches covered.">            if (!aliases.contains(alias)) {</span>
<span class="fc" id="L364">                aliases.add(alias);</span>
            }
<span class="fc" id="L366">        }</span>

        @Override
        boolean hasLocalMethod () {
<span class="fc" id="L370">            return haveLocalMethod;</span>
        }

        void setLocalMethod(boolean b) {
<span class="fc" id="L374">            haveLocalMethod = b;</span>
<span class="fc" id="L375">        }</span>
    }

    private static class ConstructorInvokerInstaller extends MethodInstaller {
        private boolean haveLocalConstructor;
        protected List&lt;Constructor&gt; constructors;
        
        ConstructorInvokerInstaller(String name) {
<span class="fc" id="L383">            super(name,STATIC_METHOD);</span>
<span class="fc" id="L384">        }</span>

        // called only by initializing thread; no synchronization required
        void addConstructor(Constructor ctor, Class&lt;?&gt; javaClass) {
<span class="fc bfc" id="L388" title="All 2 branches covered.">            if (constructors == null) {</span>
<span class="fc" id="L389">                constructors = new ArrayList&lt;Constructor&gt;(4);</span>
            }
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">            if (!Ruby.isSecurityRestricted()) {</span>
                try {
<span class="fc" id="L393">                    ctor.setAccessible(true);</span>
<span class="pc" id="L394">                } catch(SecurityException e) {}</span>
            }
<span class="fc" id="L396">            constructors.add(ctor);</span>
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">            haveLocalConstructor |= javaClass == ctor.getDeclaringClass();</span>
<span class="fc" id="L398">        }</span>
        
        void install(final RubyModule proxy) {
<span class="fc bfc" id="L401" title="All 2 branches covered.">            if (haveLocalConstructor) {</span>
<span class="fc" id="L402">                DynamicMethod method = new ConstructorInvoker(proxy, constructors);</span>
<span class="fc" id="L403">                proxy.addMethod(name, method);</span>
<span class="fc" id="L404">            } else {</span>
                // if there's no constructor, we must prevent construction
<span class="fc" id="L406">                proxy.addMethod(name, new org.jruby.internal.runtime.methods.JavaMethod(proxy, PUBLIC) {</span>
                    @Override
                    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="nc" id="L409">                        throw context.runtime.newTypeError(&quot;no public constructors for &quot; + clazz);</span>
                    }
                });
            }
<span class="fc" id="L413">        }</span>
    }

    private static class StaticMethodInvokerInstaller extends MethodInstaller {
        StaticMethodInvokerInstaller(String name) {
<span class="fc" id="L418">            super(name,STATIC_METHOD);</span>
<span class="fc" id="L419">        }</span>

        void install(RubyModule proxy) {
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">            if (hasLocalMethod()) {</span>
<span class="fc" id="L423">                RubyClass singleton = proxy.getSingletonClass();</span>
<span class="fc" id="L424">                DynamicMethod method = new StaticMethodInvoker(singleton, methods);</span>
<span class="fc" id="L425">                singleton.addMethod(name, method);</span>
<span class="pc bpc" id="L426" title="1 of 4 branches missed.">                if (aliases != null &amp;&amp; isPublic() ) {</span>
<span class="fc" id="L427">                    singleton.defineAliases(aliases, this.name);</span>
<span class="fc" id="L428">                    aliases = null;</span>
                }
            }
<span class="fc" id="L431">        }</span>
    }

    private static class SingletonMethodInvokerInstaller extends StaticMethodInvokerInstaller {
        private Object singleton;

        SingletonMethodInvokerInstaller(String name, Object singleton) {
<span class="nc" id="L438">            super(name);</span>
<span class="nc" id="L439">            this.singleton = singleton;</span>
<span class="nc" id="L440">        }</span>

        void install(RubyModule proxy) {
            // we don't check haveLocalMethod() here because it's not local and we know
            // that we always want to go ahead and install it
<span class="nc" id="L445">            RubyClass rubySingleton = proxy.getSingletonClass();</span>
<span class="nc" id="L446">            DynamicMethod method = new SingletonMethodInvoker(this.singleton, rubySingleton, methods);</span>
<span class="nc" id="L447">            rubySingleton.addMethod(name, method);</span>
<span class="nc bnc" id="L448" title="All 4 branches missed.">            if (aliases != null &amp;&amp; isPublic()) {</span>
<span class="nc" id="L449">                rubySingleton.defineAliases(aliases, this.name);</span>
<span class="nc" id="L450">                aliases = null;</span>
            }
<span class="nc" id="L452">        }</span>
    }

    private static class InstanceMethodInvokerInstaller extends MethodInstaller {
        InstanceMethodInvokerInstaller(String name) {
<span class="fc" id="L457">            super(name,INSTANCE_METHOD);</span>
<span class="fc" id="L458">        }</span>
        void install(RubyModule proxy) {
<span class="fc bfc" id="L460" title="All 2 branches covered.">            if (hasLocalMethod()) {</span>
<span class="fc" id="L461">                DynamicMethod method = new InstanceMethodInvoker(proxy, methods);</span>
<span class="fc" id="L462">                proxy.addMethod(name, method);</span>
<span class="pc bpc" id="L463" title="1 of 4 branches missed.">                if (aliases != null &amp;&amp; isPublic()) {</span>
<span class="fc" id="L464">                    proxy.defineAliases(aliases, this.name);</span>
<span class="fc" id="L465">                    aliases = null;</span>
                }
            }
<span class="fc" id="L468">        }</span>
    }

    private static class ConstantField {
        static final int CONSTANT = Modifier.FINAL | Modifier.PUBLIC | Modifier.STATIC;
        final Field field;
<span class="fc" id="L474">        ConstantField(Field field) {</span>
<span class="fc" id="L475">            this.field = field;</span>
<span class="fc" id="L476">        }</span>
        void install(final RubyModule proxy) {
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">            if (proxy.getConstantAt(field.getName()) == null) {</span>
                // TODO: catch exception if constant is already set by other
                // thread
                try {
<span class="fc" id="L482">                    proxy.setConstant(field.getName(), JavaUtil.convertJavaToUsableRubyObject(proxy.getRuntime(), field.get(null)));</span>
<span class="nc" id="L483">                } catch (IllegalAccessException iae) {</span>
                    // if we can't read it, we don't set it
<span class="fc" id="L485">                }</span>
            }
<span class="fc" id="L487">        }</span>
        static boolean isConstant(final Field field) {
<span class="fc bfc" id="L489" title="All 2 branches covered.">            return (field.getModifiers() &amp; CONSTANT) == CONSTANT &amp;&amp;</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">                Character.isUpperCase(field.getName().charAt(0));</span>
        }
    }
    
<span class="fc" id="L494">    private final RubyModule JAVA_UTILITIES = getRuntime().getJavaSupport().getJavaUtilitiesModule();</span>
    
    private Map&lt;String, AssignedName&gt; staticAssignedNames;
    private Map&lt;String, AssignedName&gt; instanceAssignedNames;
    private Map&lt;String, NamedInstaller&gt; staticInstallers;
    private Map&lt;String, NamedInstaller&gt; instanceInstallers;
    private ConstructorInvokerInstaller constructorInstaller;
    private List&lt;ConstantField&gt; constantFields;
    // caching constructors, as they're accessed for each new instance
    private volatile RubyArray constructors;
    
    private volatile ArrayList&lt;IRubyObject&gt; proxyExtenders;

    // proxy module for interfaces
    private volatile RubyModule proxyModule;

    // proxy class for concrete classes.  also used for
    // &quot;concrete&quot; interfaces, which is why we have two fields
    private volatile RubyClass proxyClass;

    // readable only by thread building proxy, so don't need to be
    // volatile. used to handle recursive calls to getProxyClass/Module
    // while proxy is being constructed (usually when a constant
    // defined by a class is of the same type as that class).
    private RubyModule unfinishedProxyModule;
    private RubyClass unfinishedProxyClass;
    
<span class="fc" id="L521">    private final ReentrantLock proxyLock = new ReentrantLock();</span>

    private final Initializer initializer;
    
    public RubyModule getProxyModule() {
        // allow proxy to be read without synchronization. if proxy
        // is under construction, only the building thread can see it.
        RubyModule proxy;
<span class="fc bfc" id="L529" title="All 2 branches covered.">        if ((proxy = proxyModule) != null) {</span>
            // proxy is complete, return it
<span class="fc" id="L531">            return proxy;</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">        } else if (proxyLock.isHeldByCurrentThread()) {</span>
            // proxy is under construction, building thread can
            // safely read non-volatile value
<span class="fc" id="L535">            return unfinishedProxyModule; </span>
        }
<span class="fc" id="L537">        return null;</span>
    }
    
    public RubyClass getProxyClass() {
        // allow proxy to be read without synchronization. if proxy
        // is under construction, only the building thread can see it.
        RubyClass proxy;
<span class="fc bfc" id="L544" title="All 2 branches covered.">        if ((proxy = proxyClass) != null) {</span>
            // proxy is complete, return it
<span class="fc" id="L546">            return proxy;</span>
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">        } else if (proxyLock.isHeldByCurrentThread()) {</span>
            // proxy is under construction, building thread can
            // safely read non-volatile value
<span class="fc" id="L550">            return unfinishedProxyClass; </span>
        }
<span class="nc" id="L552">        return null;</span>
    }
    
    public void lockProxy() {
<span class="fc" id="L556">        proxyLock.lock();</span>
<span class="fc" id="L557">    }</span>
    
    public void unlockProxy() {
<span class="fc" id="L560">        proxyLock.unlock();</span>
<span class="fc" id="L561">    }</span>

    private Map&lt;String, AssignedName&gt; getStaticAssignedNames() {
<span class="fc" id="L564">        return staticAssignedNames;</span>
    }
    private Map&lt;String, AssignedName&gt; getInstanceAssignedNames() {
<span class="fc" id="L567">        return instanceAssignedNames;</span>
    }
    
    public JavaClass(Ruby runtime, Class&lt;?&gt; javaClass) {
<span class="fc" id="L571">        super(runtime, (RubyClass) runtime.getJavaSupport().getJavaClassClass(), javaClass);</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">        if (javaClass.isInterface()) {</span>
<span class="fc" id="L573">            initializer = new InterfaceInitializer(javaClass);</span>
<span class="fc bfc" id="L574" title="All 4 branches covered.">        } else if (!(javaClass.isArray() || javaClass.isPrimitive())) {</span>
<span class="fc" id="L575">            initializer = new ClassInitializer(javaClass);</span>
        } else {
<span class="fc" id="L577">            initializer = DUMMY_INITIALIZER;</span>
        }
<span class="fc" id="L579">    }</span>
    
    @Override
    public boolean equals(Object other) {
<span class="nc bnc" id="L583" title="All 2 branches missed.">        return other instanceof JavaClass &amp;&amp;</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">            this.getValue() == ((JavaClass)other).getValue();</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L589">        return javaClass().hashCode();</span>
    }

    private interface Initializer {
        public void initialize();
    }

    private class InterfaceInitializer implements Initializer {
<span class="fc" id="L597">        private volatile boolean hasRun = false;</span>
        private final Class javaClass;

<span class="fc" id="L600">        public InterfaceInitializer(Class&lt;?&gt; javaClass) {</span>
<span class="fc" id="L601">            this.javaClass = javaClass;</span>
<span class="fc" id="L602">        }</span>
        
        public synchronized void initialize() {
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">            if (hasRun) return;</span>
<span class="fc" id="L606">            hasRun = true;</span>

<span class="fc" id="L608">            InitializerState state = new InitializerState(getRuntime(), null);</span>
<span class="fc" id="L609">            Field[] fields = getDeclaredFields(javaClass);</span>

<span class="fc bfc" id="L611" title="All 2 branches covered.">            for (int i = fields.length; --i &gt;= 0; ) {</span>
<span class="fc" id="L612">                Field field = fields[i];</span>
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">                if (javaClass != field.getDeclaringClass()) continue;</span>
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">                if (ConstantField.isConstant(field)) state.constantFields.add(new ConstantField(field));</span>

<span class="fc" id="L616">                int modifiers = field.getModifiers();</span>
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">                if (Modifier.isStatic(modifiers)) addField(state.staticCallbacks, state.staticNames, field, Modifier.isFinal(modifiers), true);</span>
<span class="fc" id="L618">            }</span>

<span class="fc" id="L620">            setupInterfaceMethods(javaClass, state);</span>
            
            // Add in any Scala singleton methods
<span class="fc" id="L623">            handleScalaSingletons(javaClass, state);</span>

            // Now add all aliases for the static methods (fields) as appropriate
<span class="fc bfc" id="L626" title="All 2 branches covered.">            for (Map.Entry&lt;String, NamedInstaller&gt; entry : state.staticCallbacks.entrySet()) {</span>
<span class="pc bpc" id="L627" title="1 of 4 branches missed.">                if (entry.getValue().type == NamedInstaller.STATIC_METHOD &amp;&amp; entry.getValue().hasLocalMethod()) {</span>
<span class="fc" id="L628">                    assignAliases((MethodInstaller)entry.getValue(), state.staticNames);</span>
                }
<span class="fc" id="L630">            }</span>

<span class="fc" id="L632">            JavaClass.this.staticAssignedNames = Collections.unmodifiableMap(state.staticNames);</span>
<span class="fc" id="L633">            JavaClass.this.staticInstallers = Collections.unmodifiableMap(state.staticCallbacks);</span>
<span class="fc" id="L634">            JavaClass.this.constantFields = Collections.unmodifiableList(state.constantFields);</span>
<span class="fc" id="L635">        }</span>
    };

    private class ClassInitializer implements Initializer {
<span class="fc" id="L639">        private volatile boolean hasRun = false;</span>
        private final Class javaClass;

<span class="fc" id="L642">        public ClassInitializer(Class&lt;?&gt; javaClass) {</span>
<span class="fc" id="L643">            this.javaClass = javaClass;</span>
<span class="fc" id="L644">        }</span>

        public synchronized void initialize() {
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">            if (hasRun) return;</span>
<span class="fc" id="L648">            hasRun = true;</span>
            
<span class="fc" id="L650">            Class&lt;?&gt; superclass = javaClass.getSuperclass();</span>

<span class="fc" id="L652">            InitializerState state = new InitializerState(getRuntime(), superclass);</span>

<span class="fc" id="L654">            setupClassFields(javaClass, state);</span>
<span class="fc" id="L655">            setupClassMethods(javaClass, state);</span>
<span class="fc" id="L656">            setupClassConstructors(javaClass);</span>

<span class="fc" id="L658">            JavaClass.this.staticAssignedNames = Collections.unmodifiableMap(state.staticNames);</span>
<span class="fc" id="L659">            JavaClass.this.instanceAssignedNames = Collections.unmodifiableMap(state.instanceNames);</span>
<span class="fc" id="L660">            JavaClass.this.staticInstallers = Collections.unmodifiableMap(state.staticCallbacks);</span>
<span class="fc" id="L661">            JavaClass.this.instanceInstallers = Collections.unmodifiableMap(state.instanceCallbacks);</span>
<span class="fc" id="L662">            JavaClass.this.constantFields = Collections.unmodifiableList(state.constantFields);</span>
<span class="fc" id="L663">        }</span>
    }

    private static class InitializerState {
        public final Map&lt;String, AssignedName&gt; staticNames;
        public final Map&lt;String, AssignedName&gt; instanceNames;
<span class="fc" id="L669">        public final Map&lt;String, NamedInstaller&gt; staticCallbacks = new HashMap&lt;String, NamedInstaller&gt;();</span>
<span class="fc" id="L670">        public final Map&lt;String, NamedInstaller&gt; instanceCallbacks = new HashMap&lt;String, NamedInstaller&gt;();</span>
<span class="fc" id="L671">        public final List&lt;ConstantField&gt; constantFields = new ArrayList&lt;ConstantField&gt;();</span>

<span class="fc" id="L673">        public InitializerState(Ruby runtime, Class superclass) {</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">            if (superclass == null) {</span>
<span class="fc" id="L675">                staticNames = new HashMap&lt;String, AssignedName&gt;();</span>
<span class="fc" id="L676">                instanceNames = new HashMap&lt;String, AssignedName&gt;();</span>
            } else {
<span class="fc" id="L678">                JavaClass superJavaClass = get(runtime,superclass);</span>
<span class="fc" id="L679">                staticNames = new HashMap&lt;String, AssignedName&gt;(superJavaClass.getStaticAssignedNames());</span>
<span class="fc" id="L680">                instanceNames = new HashMap&lt;String, AssignedName&gt;(superJavaClass.getInstanceAssignedNames());</span>
            }
<span class="fc" id="L682">            staticNames.putAll(STATIC_RESERVED_NAMES);</span>
<span class="fc" id="L683">            instanceNames.putAll(INSTANCE_RESERVED_NAMES);</span>
<span class="fc" id="L684">        }</span>
    }

<span class="fc" id="L687">    private static final Initializer DUMMY_INITIALIZER = new Initializer() {</span>
        public synchronized void initialize() {
            // anything useful we could do here?
<span class="fc" id="L690">        }</span>
    };
    
    public void setupProxy(final RubyClass proxy) {
<span class="pc bpc" id="L694" title="3 of 4 branches missed.">        assert proxyLock.isHeldByCurrentThread();</span>
        
<span class="fc" id="L696">        initializer.initialize();</span>

<span class="fc" id="L698">        proxy.addMethod(&quot;__jsend!&quot;, new org.jruby.internal.runtime.methods.JavaMethod.JavaMethodNBlock(proxy, PUBLIC) {</span>
            @Override
            public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="nc" id="L701">                String callName = args[0].asJavaString();</span>
                
<span class="nc" id="L703">                DynamicMethod method = self.getMetaClass().searchMethod(callName);</span>
<span class="nc" id="L704">                int v = method.getArity().getValue();</span>
                
<span class="nc" id="L706">                IRubyObject[] newArgs = new IRubyObject[args.length - 1];</span>
<span class="nc" id="L707">                System.arraycopy(args, 1, newArgs, 0, newArgs.length);</span>

<span class="nc bnc" id="L709" title="All 4 branches missed.">                if(v &lt; 0 || v == (newArgs.length)) {</span>
<span class="nc" id="L710">                    return Helpers.invoke(context, self, callName, newArgs, Block.NULL_BLOCK);</span>
                } else {
<span class="nc" id="L712">                    RubyClass superClass = self.getMetaClass().getSuperClass();</span>
<span class="nc" id="L713">                    return Helpers.invokeAs(context, superClass, self, callName, newArgs, Block.NULL_BLOCK);</span>
                }
            }
        });
        
<span class="fc" id="L718">        final Class&lt;?&gt; javaClass = javaClass();</span>
<span class="pc bpc" id="L719" title="1 of 2 branches missed.">        if (javaClass.isInterface()) {</span>
<span class="nc" id="L720">            setupInterfaceProxy(proxy);</span>
<span class="nc" id="L721">            return;</span>
        }

<span class="fc" id="L724">        proxy.setReifiedClass(javaClass);</span>
        
<span class="pc bpc" id="L726" title="3 of 4 branches missed.">        assert this.proxyClass == null;</span>
<span class="fc" id="L727">        this.unfinishedProxyClass = proxy;</span>
<span class="fc bfc" id="L728" title="All 4 branches covered.">        if (javaClass.isArray() || javaClass.isPrimitive()) {</span>
            // see note below re: 2-field kludge
<span class="fc" id="L730">            this.proxyClass = proxy;</span>
<span class="fc" id="L731">            this.proxyModule = proxy;</span>
<span class="fc" id="L732">            return;</span>
        }

<span class="fc" id="L735">        installClassFields(proxy);</span>
<span class="fc" id="L736">        installClassMethods(proxy);</span>
<span class="fc" id="L737">        installClassConstructors(proxy);</span>
<span class="fc" id="L738">        installClassClasses(javaClass, proxy);</span>
        
        // flag the class as a Java class proxy.
<span class="fc" id="L741">        proxy.setJavaProxy(true);</span>
<span class="fc" id="L742">        proxy.getSingletonClass().setJavaProxy(true);</span>

        // set the Java class name and package
<span class="fc" id="L745">        proxy.setBaseName(javaClass.getSimpleName());</span>

        // set parent to either package module or outer class
        RubyModule parent;
<span class="fc bfc" id="L749" title="All 2 branches covered.">        if (javaClass.getEnclosingClass() != null) {</span>
<span class="fc" id="L750">            parent = Java.getProxyClass(getRuntime(), javaClass.getEnclosingClass());</span>
        } else {
<span class="fc" id="L752">            parent = Java.getJavaPackageModule(getRuntime(), javaClass.getPackage());</span>
        }
<span class="fc" id="L754">        proxy.setParent(parent);</span>

        // FIXME: bit of a kludge here (non-interface classes assigned to both
        // class and module fields). simplifies proxy extender code, will go away
        // when JI is overhauled (and proxy extenders are deprecated).
<span class="fc" id="L759">        this.proxyClass = proxy;</span>
<span class="fc" id="L760">        this.proxyModule = proxy;</span>

<span class="fc" id="L762">        applyProxyExtenders();</span>

        // TODO: we can probably release our references to the constantFields
        // array and static/instance callback hashes at this point. 
<span class="fc" id="L766">    }</span>

    private static void assignAliases(MethodInstaller installer, Map&lt;String, AssignedName&gt; assignedNames) {
<span class="fc" id="L769">        String name = installer.name;</span>
<span class="fc" id="L770">        String rubyCasedName = JavaUtil.getRubyCasedName(name);</span>
<span class="fc" id="L771">        addUnassignedAlias(rubyCasedName,assignedNames,installer);</span>

<span class="fc" id="L773">        String javaPropertyName = JavaUtil.getJavaPropertyName(name);</span>
<span class="fc" id="L774">        String rubyPropertyName = null;</span>

<span class="fc bfc" id="L776" title="All 2 branches covered.">        for (Method method: installer.methods) {</span>
<span class="fc" id="L777">            Class&lt;?&gt;[] argTypes = method.getParameterTypes();</span>
<span class="fc" id="L778">            Class&lt;?&gt; resultType = method.getReturnType();</span>
<span class="fc" id="L779">            int argCount = argTypes.length;</span>

            // Add scala aliases for apply/update to roughly equivalent Ruby names
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">            if (rubyCasedName.equals(&quot;apply&quot;)) {</span>
<span class="nc" id="L783">                addUnassignedAlias(&quot;[]&quot;, assignedNames, installer);</span>
            }
<span class="pc bpc" id="L785" title="3 of 4 branches missed.">            if (rubyCasedName.equals(&quot;update&quot;) &amp;&amp; argCount == 2) {</span>
<span class="nc" id="L786">                addUnassignedAlias(&quot;[]=&quot;, assignedNames, installer);</span>
            }

            // Scala aliases for $ method names
<span class="pc bpc" id="L790" title="1 of 2 branches missed.">            if (name.startsWith(&quot;$&quot;)) {</span>
<span class="nc" id="L791">                addUnassignedAlias(fixScalaNames(name), assignedNames, installer);</span>
            }

            // Add property name aliases
<span class="fc bfc" id="L795" title="All 2 branches covered.">            if (javaPropertyName != null) {</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">                if (rubyCasedName.startsWith(&quot;get_&quot;)) {</span>
<span class="fc" id="L797">                    rubyPropertyName = rubyCasedName.substring(4);</span>
<span class="fc bfc" id="L798" title="All 6 branches covered.">                    if (argCount == 0 ||                                // getFoo      =&gt; foo</span>
                        argCount == 1 &amp;&amp; argTypes[0] == int.class) {    // getFoo(int) =&gt; foo(int)

<span class="fc" id="L801">                        addUnassignedAlias(javaPropertyName,assignedNames,installer);</span>
<span class="fc" id="L802">                        addUnassignedAlias(rubyPropertyName,assignedNames,installer);</span>
                    }
<span class="fc bfc" id="L804" title="All 2 branches covered.">                } else if (rubyCasedName.startsWith(&quot;set_&quot;)) {</span>
<span class="fc" id="L805">                    rubyPropertyName = rubyCasedName.substring(4);</span>
<span class="pc bpc" id="L806" title="1 of 4 branches missed.">                    if (argCount == 1 &amp;&amp; resultType == void.class) {    // setFoo(Foo) =&gt; foo=(Foo)</span>
<span class="fc" id="L807">                        addUnassignedAlias(javaPropertyName+'=',assignedNames,installer);</span>
<span class="fc" id="L808">                        addUnassignedAlias(rubyPropertyName+'=',assignedNames,installer);</span>
                    }
<span class="fc bfc" id="L810" title="All 2 branches covered.">                } else if (rubyCasedName.startsWith(&quot;is_&quot;)) {</span>
<span class="fc" id="L811">                    rubyPropertyName = rubyCasedName.substring(3);</span>
<span class="pc bpc" id="L812" title="1 of 2 branches missed.">                    if (resultType == boolean.class) {                  // isFoo() =&gt; foo, isFoo(*) =&gt; foo(*)</span>
<span class="fc" id="L813">                        addUnassignedAlias(javaPropertyName,assignedNames,installer);</span>
<span class="fc" id="L814">                        addUnassignedAlias(rubyPropertyName,assignedNames,installer);</span>
                    }
                }
            }

            // Additionally add ?-postfixed aliases to any boolean methods and properties.
<span class="fc bfc" id="L820" title="All 2 branches covered.">            if (resultType == boolean.class) {</span>
                // is_something?, contains_thing?
<span class="fc" id="L822">                addUnassignedAlias(rubyCasedName+'?',assignedNames,installer);</span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">                if (rubyPropertyName != null) {</span>
                    // something?
<span class="fc" id="L825">                    addUnassignedAlias(rubyPropertyName+'?',assignedNames,installer);</span>
                }
            }
<span class="fc" id="L828">        }</span>
<span class="fc" id="L829">    }</span>
    
    private static void addUnassignedAlias(String name, Map&lt;String, AssignedName&gt; assignedNames,
            MethodInstaller installer) {
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">        if (name == null) return;</span>

<span class="fc" id="L835">        AssignedName assignedName = assignedNames.get(name);</span>
        // TODO: missing additional logic for dealing with conflicting protected fields.
<span class="fc bfc" id="L837" title="All 2 branches covered.">        if (Priority.ALIAS.moreImportantThan(assignedName)) {</span>
<span class="fc" id="L838">            installer.addAlias(name);</span>
<span class="fc" id="L839">            assignedNames.put(name, new AssignedName(name, Priority.ALIAS));</span>
<span class="fc bfc" id="L840" title="All 2 branches covered.">        } else if (Priority.ALIAS.asImportantAs(assignedName)) {</span>
<span class="fc" id="L841">            installer.addAlias(name);</span>
        }
<span class="fc" id="L843">    }</span>

    private void installClassClasses(final Class&lt;?&gt; javaClass, final RubyModule proxy) {
        // setup constants for public inner classes
<span class="fc" id="L847">        Class&lt;?&gt;[] classes = getDeclaredClasses(javaClass);</span>

<span class="fc bfc" id="L849" title="All 2 branches covered.">        for (int i = classes.length; --i &gt;= 0; ) {</span>
<span class="pc bpc" id="L850" title="1 of 2 branches missed.">            if (javaClass == classes[i].getDeclaringClass()) {</span>
<span class="fc" id="L851">                Class&lt;?&gt; clazz = classes[i];</span>

                // no non-public inner classes
<span class="fc bfc" id="L854" title="All 2 branches covered.">                if (!Modifier.isPublic(clazz.getModifiers())) continue;</span>
                
<span class="fc" id="L856">                String simpleName = getSimpleName(clazz);</span>
<span class="pc bpc" id="L857" title="1 of 2 branches missed.">                if (simpleName.length() == 0) continue;</span>

<span class="fc" id="L859">                final IRubyObject innerProxy = Java.get_proxy_class(JAVA_UTILITIES,get(getRuntime(),clazz));</span>

<span class="pc bpc" id="L861" title="1 of 2 branches missed.">                if (IdUtil.isConstant(simpleName)) {</span>
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">                    if (proxy.getConstantAt(simpleName) == null) {</span>
<span class="nc" id="L863">                        proxy.const_set(getRuntime().newString(simpleName), innerProxy);</span>
                    }
                } else {
                    // lower-case name
<span class="nc bnc" id="L867" title="All 2 branches missed.">                    if (!proxy.respondsTo(simpleName)) {</span>
                        // define a class method
<span class="nc" id="L869">                        proxy.getSingletonClass().addMethod(simpleName, new JavaMethodZero(proxy.getSingletonClass(), Visibility.PUBLIC) {</span>
                            @Override
                            public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name) {
<span class="nc" id="L872">                                return innerProxy;</span>
                            }
                        });
                    }
                }
<span class="fc" id="L877">            }</span>
        }
<span class="fc" id="L879">    }</span>

    private synchronized void installClassConstructors(final RubyClass proxy) {
<span class="pc bpc" id="L882" title="1 of 2 branches missed.">        if (constructorInstaller != null) {</span>
<span class="fc" id="L883">            constructorInstaller.install(proxy);</span>
<span class="fc" id="L884">            constructorInstaller = null;</span>
        }
<span class="fc" id="L886">    }</span>

    private synchronized void installClassFields(final RubyClass proxy) {
<span class="pc bpc" id="L889" title="3 of 4 branches missed.">        assert constantFields != null;</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">        for (ConstantField field : constantFields) {</span>
<span class="fc" id="L891">            field.install(proxy);</span>
<span class="fc" id="L892">        }</span>
<span class="fc" id="L893">        constantFields = null;</span>
<span class="fc" id="L894">    }</span>

    private synchronized void installClassMethods(final RubyClass proxy) {
<span class="pc bpc" id="L897" title="3 of 4 branches missed.">        assert staticInstallers != null;</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">        for (NamedInstaller installer : staticInstallers.values()) {</span>
<span class="fc" id="L899">            installer.install(proxy);</span>
<span class="fc" id="L900">        }</span>
<span class="fc" id="L901">        staticInstallers = null;</span>

<span class="pc bpc" id="L903" title="3 of 4 branches missed.">        assert instanceInstallers != null;</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">        for (NamedInstaller installer : instanceInstallers.values()) {</span>
<span class="fc" id="L905">            installer.install(proxy);</span>
<span class="fc" id="L906">        }</span>
<span class="fc" id="L907">        instanceInstallers = null;</span>
<span class="fc" id="L908">    }</span>

    private void setupClassConstructors(Class&lt;?&gt; javaClass) {
        // TODO: protected methods.  this is going to require a rework
        // of some of the mechanism.
<span class="fc" id="L913">        Constructor[] clsConstructors = getConstructors(javaClass);</span>
        
        // create constructorInstaller; if there are no constructors, it will disable construction
<span class="fc" id="L916">        constructorInstaller = new ConstructorInvokerInstaller(&quot;__jcreate!&quot;);</span>

<span class="fc bfc" id="L918" title="All 2 branches covered.">        for (int i = clsConstructors.length; --i &gt;= 0;) {</span>
            // we need to collect all methods, though we'll only
            // install the ones that are named in this class
<span class="fc" id="L921">            Constructor ctor = clsConstructors[i];</span>
<span class="fc" id="L922">            constructorInstaller.addConstructor(ctor, javaClass);</span>
<span class="fc" id="L923">        }</span>
<span class="fc" id="L924">    }</span>
    
    private void addField(Map &lt;String, NamedInstaller&gt; callbacks, Map&lt;String, AssignedName&gt; names,
            Field field, boolean isFinal, boolean isStatic) {
<span class="fc" id="L928">        String name = field.getName();</span>

<span class="pc bpc" id="L930" title="1 of 2 branches missed.">        if (Priority.FIELD.lessImportantThan(names.get(name))) return;</span>

<span class="fc" id="L932">        names.put(name, new AssignedName(name, Priority.FIELD));</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">        callbacks.put(name, isStatic ? new StaticFieldGetterInstaller(name, field) :</span>
            new InstanceFieldGetterInstaller(name, field));

<span class="fc bfc" id="L936" title="All 2 branches covered.">        if (!isFinal) {</span>
<span class="fc" id="L937">            String setName = name + '=';</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">            callbacks.put(setName, isStatic ? new StaticFieldSetterInstaller(setName, field) :</span>
                new InstanceFieldSetterInstaller(setName, field));
        }
<span class="fc" id="L941">    }</span>
    
    private void setupClassFields(Class&lt;?&gt; javaClass, InitializerState state) {
<span class="fc" id="L944">        Field[] fields = getFields(javaClass);</span>
        
<span class="fc bfc" id="L946" title="All 2 branches covered.">        for (int i = fields.length; --i &gt;= 0;) {</span>
<span class="fc" id="L947">            Field field = fields[i];</span>
<span class="fc bfc" id="L948" title="All 2 branches covered.">            if (javaClass != field.getDeclaringClass()) continue;</span>

<span class="fc bfc" id="L950" title="All 2 branches covered.">            if (ConstantField.isConstant(field)) {</span>
<span class="fc" id="L951">                state.constantFields.add(new ConstantField(field));</span>
<span class="fc" id="L952">                continue;</span>
            }

<span class="fc" id="L955">            int modifiers = field.getModifiers();</span>
<span class="fc bfc" id="L956" title="All 2 branches covered.">            if (Modifier.isStatic(modifiers)) {</span>
<span class="fc" id="L957">                addField(state.staticCallbacks, state.staticNames, field, Modifier.isFinal(modifiers), true);</span>
            } else {
<span class="fc" id="L959">                addField(state.instanceCallbacks, state.instanceNames, field, Modifier.isFinal(modifiers), false);</span>
            }
<span class="fc" id="L961">        }</span>
<span class="fc" id="L962">    }</span>

    private static String fixScalaNames(String name) {
<span class="nc" id="L965">        String s = name;</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">        for (Map.Entry&lt;String, String&gt; entry : SCALA_OPERATORS.entrySet()) {</span>
<span class="nc" id="L967">            s = s.replaceAll(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L968">        }</span>

<span class="nc" id="L970">        return s;</span>
    }

    private static final Map&lt;String, String&gt; SCALA_OPERATORS;
    static {
<span class="fc" id="L975">        Map&lt;String, String&gt; tmp = new HashMap();</span>
<span class="fc" id="L976">        tmp.put(&quot;\\$plus&quot;, &quot;+&quot;);</span>
<span class="fc" id="L977">        tmp.put(&quot;\\$minus&quot;, &quot;-&quot;);</span>
<span class="fc" id="L978">        tmp.put(&quot;\\$colon&quot;, &quot;:&quot;);</span>
<span class="fc" id="L979">        tmp.put(&quot;\\$div&quot;, &quot;/&quot;);</span>
<span class="fc" id="L980">        tmp.put(&quot;\\$eq&quot;, &quot;=&quot;);</span>
<span class="fc" id="L981">        tmp.put(&quot;\\$less&quot;, &quot;&lt;&quot;);</span>
<span class="fc" id="L982">        tmp.put(&quot;\\$greater&quot;, &quot;&gt;&quot;);</span>
<span class="fc" id="L983">        tmp.put(&quot;\\$bslash&quot;, &quot;\\\\&quot;);</span>
<span class="fc" id="L984">        tmp.put(&quot;\\$hash&quot;, &quot;#&quot;);</span>
<span class="fc" id="L985">        tmp.put(&quot;\\$times&quot;, &quot;*&quot;);</span>
<span class="fc" id="L986">        tmp.put(&quot;\\$bang&quot;, &quot;!&quot;);</span>
<span class="fc" id="L987">        tmp.put(&quot;\\$at&quot;, &quot;@&quot;);</span>
<span class="fc" id="L988">        tmp.put(&quot;\\$percent&quot;, &quot;%&quot;);</span>
<span class="fc" id="L989">        tmp.put(&quot;\\$up&quot;, &quot;^&quot;);</span>
<span class="fc" id="L990">        tmp.put(&quot;\\$amp&quot;, &quot;&amp;&quot;);</span>
<span class="fc" id="L991">        tmp.put(&quot;\\$tilde&quot;, &quot;~&quot;);</span>
<span class="fc" id="L992">        tmp.put(&quot;\\$qmark&quot;, &quot;?&quot;);</span>
<span class="fc" id="L993">        tmp.put(&quot;\\$bar&quot;, &quot;|&quot;);</span>
<span class="fc" id="L994">        SCALA_OPERATORS = Collections.unmodifiableMap(tmp);</span>
    }

    private void setupClassMethods(Class&lt;?&gt; javaClass, InitializerState state) {
        // TODO: protected methods.  this is going to require a rework of some of the mechanism.
<span class="fc" id="L999">        Method[] methods = getMethods(javaClass);</span>

<span class="fc bfc" id="L1001" title="All 2 branches covered.">        for (int i = methods.length; --i &gt;= 0;) {</span>
            // we need to collect all methods, though we'll only
            // install the ones that are named in this class
<span class="fc" id="L1004">            Method method = methods[i];</span>
<span class="fc" id="L1005">            String name = method.getName();</span>

<span class="fc bfc" id="L1007" title="All 2 branches covered.">            if (Modifier.isStatic(method.getModifiers())) {</span>
<span class="fc" id="L1008">                prepareStaticMethod(javaClass, state, method, name);</span>
            } else {
<span class="fc" id="L1010">                prepareInstanceMethod(javaClass, state, method, name);</span>
            }
<span class="fc" id="L1012">        }</span>

        // try to wire up Scala singleton logic if present
<span class="fc" id="L1015">        handleScalaSingletons(javaClass, state);</span>

        // now iterate over all installers and make sure they also have appropriate aliases
<span class="fc" id="L1018">        assignStaticAliases(state);</span>
<span class="fc" id="L1019">        assignInstanceAliases(state);</span>
<span class="fc" id="L1020">    }</span>

    private void prepareInstanceMethod(Class&lt;?&gt; javaClass, InitializerState state, Method method, String name) {
<span class="fc" id="L1023">        AssignedName assignedName = state.instanceNames.get(name);</span>

        // For JRUBY-4505, restore __method methods for reserved names
<span class="fc bfc" id="L1026" title="All 2 branches covered.">        if (INSTANCE_RESERVED_NAMES.containsKey(method.getName())) {</span>
<span class="fc" id="L1027">            installInstanceMethods(state.instanceCallbacks, javaClass, method, name + METHOD_MANGLE);</span>
<span class="fc" id="L1028">            return;</span>
        }

<span class="fc bfc" id="L1031" title="All 2 branches covered.">        if (assignedName == null) {</span>
<span class="fc" id="L1032">            state.instanceNames.put(name, new AssignedName(name, Priority.METHOD));</span>
        } else {
<span class="pc bpc" id="L1034" title="1 of 2 branches missed.">            if (Priority.METHOD.lessImportantThan(assignedName)) return;</span>
<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">            if (!Priority.METHOD.asImportantAs(assignedName)) {</span>
<span class="nc" id="L1036">                state.instanceCallbacks.remove(name);</span>
<span class="nc" id="L1037">                state.instanceCallbacks.remove(name + '=');</span>
<span class="nc" id="L1038">                state.instanceNames.put(name, new AssignedName(name, Priority.METHOD));</span>
            }
        }
<span class="fc" id="L1041">        installInstanceMethods(state.instanceCallbacks, javaClass, method, name);</span>
<span class="fc" id="L1042">    }</span>

    private void assignInstanceAliases(InitializerState state) {
<span class="fc bfc" id="L1045" title="All 2 branches covered.">        for (Map.Entry&lt;String, NamedInstaller&gt; entry : state.instanceCallbacks.entrySet()) {</span>
<span class="fc bfc" id="L1046" title="All 2 branches covered.">            if (entry.getValue().type == NamedInstaller.INSTANCE_METHOD) {</span>
<span class="fc" id="L1047">                MethodInstaller methodInstaller = (MethodInstaller)entry.getValue();</span>

                // no aliases for __method methods
<span class="fc bfc" id="L1050" title="All 2 branches covered.">                if (entry.getKey().endsWith(&quot;__method&quot;)) continue;</span>

<span class="fc bfc" id="L1052" title="All 2 branches covered.">                if (methodInstaller.hasLocalMethod()) {</span>
<span class="fc" id="L1053">                    assignAliases(methodInstaller, state.instanceNames);</span>
                }

                // JRUBY-6967: Types with java.lang.Comparable were using Ruby Comparable#== instead of dispatching directly to
                // java.lang.Object.equals. We force an alias here to ensure we always use equals.
<span class="fc bfc" id="L1058" title="All 2 branches covered.">                if (entry.getKey().equals(&quot;equals&quot;)) {</span>
                    // we only install &quot;local&quot; methods, but need to force this so it will bind
<span class="fc" id="L1060">                    methodInstaller.setLocalMethod(true);</span>
<span class="fc" id="L1061">                    methodInstaller.addAlias(&quot;==&quot;);</span>
                }
            }
<span class="fc" id="L1064">        }</span>
<span class="fc" id="L1065">    }</span>

    private void setupInterfaceMethods(Class&lt;?&gt; javaClass, InitializerState state) {
        // TODO: protected methods.  this is going to require a rework of some of the mechanism.
<span class="fc" id="L1069">        Method[] methods = getMethods(javaClass);</span>

<span class="fc bfc" id="L1071" title="All 2 branches covered.">        for (int i = methods.length; --i &gt;= 0;) {</span>
            // Java 8 introduced static methods on interfaces, so we just look for those
<span class="fc" id="L1073">            Method method = methods[i];</span>
<span class="fc" id="L1074">            String name = method.getName();</span>

<span class="fc bfc" id="L1076" title="All 2 branches covered.">            if (!Modifier.isStatic(method.getModifiers())) continue;</span>

<span class="fc" id="L1078">            prepareStaticMethod(javaClass, state, method, name);</span>
<span class="fc" id="L1079">        }</span>

        // now iterate over all installers and make sure they also have appropriate aliases
<span class="fc" id="L1082">        assignStaticAliases(state);</span>
<span class="fc" id="L1083">    }</span>

    private void assignStaticAliases(InitializerState state) {
<span class="fc bfc" id="L1086" title="All 2 branches covered.">        for (Map.Entry&lt;String, NamedInstaller&gt; entry : state.staticCallbacks.entrySet()) {</span>
            // no aliases for __method methods
<span class="pc bpc" id="L1088" title="1 of 2 branches missed.">            if (entry.getKey().endsWith(&quot;__method&quot;)) continue;</span>

<span class="pc bpc" id="L1090" title="1 of 4 branches missed.">            if (entry.getValue().type == NamedInstaller.STATIC_METHOD &amp;&amp; entry.getValue().hasLocalMethod()) {</span>
<span class="fc" id="L1091">                assignAliases((MethodInstaller) entry.getValue(), state.staticNames);</span>
            }
<span class="fc" id="L1093">        }</span>
<span class="fc" id="L1094">    }</span>

    private void prepareStaticMethod(Class&lt;?&gt; javaClass, InitializerState state, Method method, String name) {
<span class="fc" id="L1097">        AssignedName assignedName = state.staticNames.get(name);</span>

        // For JRUBY-4505, restore __method methods for reserved names
<span class="pc bpc" id="L1100" title="1 of 2 branches missed.">        if (STATIC_RESERVED_NAMES.containsKey(method.getName())) {</span>
<span class="nc" id="L1101">            installStaticMethods(state.staticCallbacks, javaClass, method, name + METHOD_MANGLE);</span>
<span class="nc" id="L1102">            return;</span>
        }

<span class="fc bfc" id="L1105" title="All 2 branches covered.">        if (assignedName == null) {</span>
<span class="fc" id="L1106">            state.staticNames.put(name, new AssignedName(name, Priority.METHOD));</span>
        } else {
<span class="pc bpc" id="L1108" title="1 of 2 branches missed.">            if (Priority.METHOD.lessImportantThan(assignedName)) return;</span>
<span class="pc bpc" id="L1109" title="1 of 2 branches missed.">            if (!Priority.METHOD.asImportantAs(assignedName)) {</span>
<span class="nc" id="L1110">                state.staticCallbacks.remove(name);</span>
<span class="nc" id="L1111">                state.staticCallbacks.remove(name + '=');</span>
<span class="nc" id="L1112">                state.staticNames.put(name, new AssignedName(name, Priority.METHOD));</span>
            }
        }
<span class="fc" id="L1115">        installStaticMethods(state.staticCallbacks, javaClass, method, name);</span>
<span class="fc" id="L1116">    }</span>

    private void installInstanceMethods(Map&lt;String, NamedInstaller&gt; methodCallbacks, Class&lt;?&gt; javaClass, Method method, String name) {
<span class="fc" id="L1119">        MethodInstaller invoker = (MethodInstaller) methodCallbacks.get(name);</span>
<span class="fc bfc" id="L1120" title="All 2 branches covered.">        if (invoker == null) {</span>
<span class="fc" id="L1121">            invoker = new InstanceMethodInvokerInstaller(name);</span>
<span class="fc" id="L1122">            methodCallbacks.put(name, invoker);</span>
        }
<span class="fc" id="L1124">        invoker.addMethod(method, javaClass);</span>
<span class="fc" id="L1125">    }</span>

    private void installStaticMethods(Map&lt;String, NamedInstaller&gt; methodCallbacks, Class&lt;?&gt; javaClass, Method method, String name) {
<span class="fc" id="L1128">        MethodInstaller invoker = (MethodInstaller) methodCallbacks.get(name);</span>
<span class="fc bfc" id="L1129" title="All 2 branches covered.">        if (invoker == null) {</span>
<span class="fc" id="L1130">            invoker = new StaticMethodInvokerInstaller(name);</span>
<span class="fc" id="L1131">            methodCallbacks.put(name, invoker);</span>
        }
<span class="fc" id="L1133">        invoker.addMethod(method, javaClass);</span>
<span class="fc" id="L1134">    }</span>
    
    private void installSingletonMethods(Map&lt;String, NamedInstaller&gt; methodCallbacks, Class&lt;?&gt; javaClass, Object singleton, Method method, String name) {
<span class="nc" id="L1137">        MethodInstaller invoker = (MethodInstaller) methodCallbacks.get(name);</span>
<span class="nc bnc" id="L1138" title="All 2 branches missed.">        if (invoker == null) {</span>
<span class="nc" id="L1139">            invoker = new SingletonMethodInvokerInstaller(name, singleton);</span>
<span class="nc" id="L1140">            methodCallbacks.put(name, invoker);</span>
        }
<span class="nc" id="L1142">        invoker.addMethod(method, javaClass);</span>
<span class="nc" id="L1143">    }</span>
    
    // old (quasi-deprecated) interface class
    private void setupInterfaceProxy(final RubyClass proxy) {
<span class="nc bnc" id="L1147" title="All 4 branches missed.">        assert javaClass().isInterface();</span>
<span class="nc bnc" id="L1148" title="All 4 branches missed.">        assert proxyLock.isHeldByCurrentThread();</span>
<span class="nc bnc" id="L1149" title="All 4 branches missed.">        assert this.proxyClass == null;</span>
        
<span class="nc" id="L1151">        initializer.initialize();</span>
<span class="nc" id="L1152">        this.proxyClass = proxy;</span>
        // nothing else to here - the module version will be
        // included in the class.
<span class="nc" id="L1155">    }</span>
    
    public void setupInterfaceModule(final RubyModule module) {
<span class="pc bpc" id="L1158" title="3 of 4 branches missed.">        assert javaClass().isInterface();</span>
<span class="pc bpc" id="L1159" title="3 of 4 branches missed.">        assert proxyLock.isHeldByCurrentThread();</span>
<span class="pc bpc" id="L1160" title="3 of 4 branches missed.">        assert this.proxyModule == null;</span>
        
<span class="fc" id="L1162">        initializer.initialize();</span>
        
<span class="fc" id="L1164">        this.unfinishedProxyModule = module;</span>
<span class="fc" id="L1165">        Class&lt;?&gt; javaClass = javaClass();</span>
<span class="fc bfc" id="L1166" title="All 2 branches covered.">        for (ConstantField field: constantFields) {</span>
<span class="fc" id="L1167">            field.install(module);</span>
<span class="fc" id="L1168">        }</span>
<span class="fc bfc" id="L1169" title="All 2 branches covered.">        for (NamedInstaller installer : staticInstallers.values()) {</span>
<span class="fc" id="L1170">            installer.install(module);</span>
<span class="fc" id="L1171">        }</span>

<span class="fc" id="L1173">        installClassClasses(javaClass, module);</span>
        
        // flag the class as a Java class proxy.
<span class="fc" id="L1176">        module.setJavaProxy(true);</span>
<span class="fc" id="L1177">        module.getSingletonClass().setJavaProxy(true);</span>
        
<span class="fc" id="L1179">        this.proxyModule = module;</span>
<span class="fc" id="L1180">        applyProxyExtenders();</span>
<span class="fc" id="L1181">    }</span>

    public void addProxyExtender(final IRubyObject extender) {
<span class="nc" id="L1184">        lockProxy();</span>
        try {
<span class="nc bnc" id="L1186" title="All 2 branches missed.">            if (!extender.respondsTo(&quot;extend_proxy&quot;)) {</span>
<span class="nc" id="L1187">                throw getRuntime().newTypeError(&quot;proxy extender must have an extend_proxy method&quot;);</span>
            }
<span class="nc bnc" id="L1189" title="All 2 branches missed.">            if (proxyModule == null) {</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">                if (proxyExtenders == null) {</span>
<span class="nc" id="L1191">                    proxyExtenders = new ArrayList&lt;IRubyObject&gt;();</span>
                }
<span class="nc" id="L1193">                proxyExtenders.add(extender);</span>
            } else {
<span class="nc" id="L1195">                getRuntime().getWarnings().warn(ID.PROXY_EXTENDED_LATE, &quot; proxy extender added after proxy class created for &quot; + this);</span>
<span class="nc" id="L1196">                extendProxy(extender);</span>
            }
        } finally {
<span class="nc" id="L1199">            unlockProxy();</span>
<span class="nc" id="L1200">        }</span>
<span class="nc" id="L1201">    }</span>
    
    private void applyProxyExtenders() {
        ArrayList&lt;IRubyObject&gt; extenders;
<span class="pc bpc" id="L1205" title="1 of 2 branches missed.">        if ((extenders = proxyExtenders) != null) {</span>
<span class="nc bnc" id="L1206" title="All 2 branches missed.">            for (IRubyObject extender : extenders) {</span>
<span class="nc" id="L1207">                extendProxy(extender);</span>
<span class="nc" id="L1208">            }</span>
<span class="nc" id="L1209">            proxyExtenders = null;</span>
        }
<span class="fc" id="L1211">    }</span>

    private void extendProxy(IRubyObject extender) {
<span class="nc" id="L1214">        extender.callMethod(getRuntime().getCurrentContext(), &quot;extend_proxy&quot;, proxyModule);</span>
<span class="nc" id="L1215">    }</span>
    
    @JRubyMethod(required = 1)
    public IRubyObject extend_proxy(IRubyObject extender) {
<span class="nc" id="L1219">        addProxyExtender(extender);</span>
<span class="nc" id="L1220">        return getRuntime().getNil();</span>
    }
    
    public static JavaClass get(Ruby runtime, Class&lt;?&gt; klass) {
<span class="fc" id="L1224">        return runtime.getJavaSupport().getJavaClassFromCache(klass);</span>
    }
    
    public static RubyArray getRubyArray(Ruby runtime, Class&lt;?&gt;[] classes) {
<span class="nc" id="L1228">        IRubyObject[] javaClasses = new IRubyObject[classes.length];</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">        for (int i = classes.length; --i &gt;= 0; ) {</span>
<span class="nc" id="L1230">            javaClasses[i] = get(runtime, classes[i]);</span>
        }
<span class="nc" id="L1232">        return runtime.newArrayNoCopy(javaClasses);</span>
    }

    public static RubyClass createJavaClassClass(Ruby runtime, RubyModule javaModule) {
        // FIXME: Determine if a real allocator is needed here. Do people want to extend
        // JavaClass? Do we want them to do that? Can you Class.new(JavaClass)? Should
        // you be able to?
        // TODO: NOT_ALLOCATABLE_ALLOCATOR is probably ok here, since we don't intend for people to monkey with
        // this type and it can't be marshalled. Confirm. JRUBY-415
<span class="fc" id="L1241">        RubyClass result = javaModule.defineClassUnder(&quot;JavaClass&quot;, javaModule.getClass(&quot;JavaObject&quot;), ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR); </span>
        
<span class="fc" id="L1243">        result.includeModule(runtime.getModule(&quot;Comparable&quot;));</span>
        
<span class="fc" id="L1245">        result.defineAnnotatedMethods(JavaClass.class);</span>

<span class="fc" id="L1247">        result.getMetaClass().undefineMethod(&quot;new&quot;);</span>
<span class="fc" id="L1248">        result.getMetaClass().undefineMethod(&quot;allocate&quot;);</span>

<span class="fc" id="L1250">        return result;</span>
    }

<span class="fc" id="L1253">    private static Map&lt;String, Class&gt; PRIMITIVE_TO_CLASS = new HashMap&lt;String,Class&gt;();</span>

    static {
<span class="fc" id="L1256">        PRIMITIVE_TO_CLASS.put(&quot;byte&quot;, byte.class);</span>
<span class="fc" id="L1257">        PRIMITIVE_TO_CLASS.put(&quot;boolean&quot;, boolean.class);</span>
<span class="fc" id="L1258">        PRIMITIVE_TO_CLASS.put(&quot;short&quot;, short.class);</span>
<span class="fc" id="L1259">        PRIMITIVE_TO_CLASS.put(&quot;char&quot;, char.class);</span>
<span class="fc" id="L1260">        PRIMITIVE_TO_CLASS.put(&quot;int&quot;, int.class);</span>
<span class="fc" id="L1261">        PRIMITIVE_TO_CLASS.put(&quot;long&quot;, long.class);</span>
<span class="fc" id="L1262">        PRIMITIVE_TO_CLASS.put(&quot;float&quot;, float.class);</span>
<span class="fc" id="L1263">        PRIMITIVE_TO_CLASS.put(&quot;double&quot;, double.class);</span>
<span class="fc" id="L1264">    }</span>
    
    public static synchronized JavaClass forNameVerbose(Ruby runtime, String className) {
<span class="fc" id="L1267">        Class &lt;?&gt; klass = null;</span>
<span class="pc bpc" id="L1268" title="3 of 4 branches missed.">        if (className.indexOf(&quot;.&quot;) == -1 &amp;&amp; Character.isLowerCase(className.charAt(0))) {</span>
            // one word type name that starts lower-case...it may be a primitive type
<span class="nc" id="L1270">            klass = PRIMITIVE_TO_CLASS.get(className);</span>
        }

<span class="pc bpc" id="L1273" title="1 of 2 branches missed.">        if (klass == null) {</span>
<span class="fc" id="L1274">            klass = runtime.getJavaSupport().loadJavaClassVerbose(className);</span>
        }
<span class="fc" id="L1276">        return JavaClass.get(runtime, klass);</span>
    }
    
    public static synchronized JavaClass forNameQuiet(Ruby runtime, String className) {
<span class="nc" id="L1280">        Class klass = runtime.getJavaSupport().loadJavaClassQuiet(className);</span>
<span class="nc" id="L1281">        return JavaClass.get(runtime, klass);</span>
    }

    @JRubyMethod(name = &quot;for_name&quot;, required = 1, meta = true)
    public static JavaClass for_name(IRubyObject recv, IRubyObject name) {
<span class="fc" id="L1286">        return forNameVerbose(recv.getRuntime(), name.asJavaString());</span>
    }

    @JRubyMethod
    public RubyModule ruby_class() {
        // Java.getProxyClass deals with sync issues, so we won't duplicate the logic here
<span class="nc" id="L1292">        return Java.getProxyClass(getRuntime(), javaClass());</span>
    }

    @JRubyMethod(name = &quot;public?&quot;)
    public RubyBoolean public_p() {
<span class="nc" id="L1297">        return getRuntime().newBoolean(Modifier.isPublic(javaClass().getModifiers()));</span>
    }

    @JRubyMethod(name = &quot;protected?&quot;)
    public RubyBoolean protected_p() {
<span class="nc" id="L1302">        return getRuntime().newBoolean(Modifier.isProtected(javaClass().getModifiers()));</span>
    }

    @JRubyMethod(name = &quot;private?&quot;)
    public RubyBoolean private_p() {
<span class="nc" id="L1307">        return getRuntime().newBoolean(Modifier.isPrivate(javaClass().getModifiers()));</span>
    }

    public Class javaClass() {
<span class="fc" id="L1311">        return (Class) getValue();</span>
    }

    @JRubyMethod(name = &quot;final?&quot;)
    public RubyBoolean final_p() {
<span class="nc" id="L1316">        return getRuntime().newBoolean(Modifier.isFinal(javaClass().getModifiers()));</span>
    }

    @JRubyMethod(name = &quot;interface?&quot;)
    public RubyBoolean interface_p() {
<span class="nc" id="L1321">        return getRuntime().newBoolean(javaClass().isInterface());</span>
    }

    @JRubyMethod(name = &quot;array?&quot;)
    public RubyBoolean array_p() {
<span class="nc" id="L1326">        return getRuntime().newBoolean(javaClass().isArray());</span>
    }
    
    @JRubyMethod(name = &quot;enum?&quot;)
    public RubyBoolean enum_p() {
<span class="nc" id="L1331">        return getRuntime().newBoolean(javaClass().isEnum());</span>
    }
    
    @JRubyMethod(name = &quot;annotation?&quot;)
    public RubyBoolean annotation_p() {
<span class="nc" id="L1336">        return getRuntime().newBoolean(javaClass().isAnnotation());</span>
    }
    
    @JRubyMethod(name = &quot;anonymous_class?&quot;)
    public RubyBoolean anonymous_class_p() {
<span class="nc" id="L1341">        return getRuntime().newBoolean(javaClass().isAnonymousClass());</span>
    }
    
    @JRubyMethod(name = &quot;local_class?&quot;)
    public RubyBoolean local_class_p() {
<span class="nc" id="L1346">        return getRuntime().newBoolean(javaClass().isLocalClass());</span>
    }
    
    @JRubyMethod(name = &quot;member_class?&quot;)
    public RubyBoolean member_class_p() {
<span class="nc" id="L1351">        return getRuntime().newBoolean(javaClass().isMemberClass());</span>
    }
    
    @JRubyMethod(name = &quot;synthetic?&quot;)
    public IRubyObject synthetic_p() {
<span class="nc" id="L1356">        return getRuntime().newBoolean(javaClass().isSynthetic());</span>
    }

    @JRubyMethod(name = {&quot;name&quot;, &quot;to_s&quot;})
    public RubyString name() {
<span class="nc" id="L1361">        return getRuntime().newString(javaClass().getName());</span>
    }

    @JRubyMethod
    @Override
    public RubyString inspect() {
<span class="nc" id="L1367">        return getRuntime().newString(&quot;class &quot; + javaClass().getName());</span>
    }

    @JRubyMethod
    public IRubyObject canonical_name() {
<span class="nc" id="L1372">        String canonicalName = javaClass().getCanonicalName();</span>
<span class="nc bnc" id="L1373" title="All 2 branches missed.">        if (canonicalName != null) {</span>
<span class="nc" id="L1374">            return getRuntime().newString(canonicalName);</span>
        }
<span class="nc" id="L1376">        return getRuntime().getNil();</span>
    }
    
    @JRubyMethod(name = &quot;package&quot;)
    public IRubyObject get_package() {
<span class="nc" id="L1381">        return Java.getInstance(getRuntime(), javaClass().getPackage());</span>
    }

    @JRubyMethod
    public IRubyObject class_loader() {
<span class="nc" id="L1386">        return Java.getInstance(getRuntime(), javaClass().getClassLoader());</span>
    }

    @JRubyMethod
    public IRubyObject protection_domain() {
<span class="nc" id="L1391">        return Java.getInstance(getRuntime(), javaClass().getProtectionDomain());</span>
    }
    
    @JRubyMethod(required = 1)
    public IRubyObject resource(IRubyObject name) {
<span class="nc" id="L1396">        return Java.getInstance(getRuntime(), javaClass().getResource(name.asJavaString()));</span>
    }

    @JRubyMethod(required = 1)
    public IRubyObject resource_as_stream(IRubyObject name) {
<span class="nc" id="L1401">        return Java.getInstance(getRuntime(), javaClass().getResourceAsStream(name.asJavaString()));</span>
    }
    
    @JRubyMethod(required = 1)
    public IRubyObject resource_as_string(IRubyObject name) {
<span class="nc" id="L1406">        InputStream in = javaClass().getResourceAsStream(name.asJavaString());</span>
<span class="nc bnc" id="L1407" title="All 2 branches missed.">        if (in == null) return getRuntime().getNil();</span>
<span class="nc" id="L1408">        ByteArrayOutputStream out = new ByteArrayOutputStream();</span>
        try {
            int len;
<span class="nc" id="L1411">            byte[] buf = new byte[4096];</span>
<span class="nc bnc" id="L1412" title="All 2 branches missed.">            while ((len = in.read(buf)) &gt;= 0) {</span>
<span class="nc" id="L1413">                out.write(buf, 0, len);</span>
            }
<span class="nc" id="L1415">        } catch (IOException e) {</span>
<span class="nc" id="L1416">            throw getRuntime().newIOErrorFromException(e);</span>
        } finally {
<span class="nc" id="L1418">            try {in.close();} catch (IOException ioe) {}</span>
<span class="nc" id="L1419">        }</span>
<span class="nc" id="L1420">        return getRuntime().newString(new ByteList(out.toByteArray(), false));</span>
    }
    
    @SuppressWarnings(&quot;unchecked&quot;)
    @JRubyMethod(required = 1)
    public IRubyObject annotation(IRubyObject annoClass) {
<span class="nc bnc" id="L1426" title="All 2 branches missed.">        if (!(annoClass instanceof JavaClass)) {</span>
<span class="nc" id="L1427">            throw getRuntime().newTypeError(annoClass, getRuntime().getJavaSupport().getJavaClassClass());</span>
        }
<span class="nc" id="L1429">        return Java.getInstance(getRuntime(), javaClass().getAnnotation(((JavaClass)annoClass).javaClass()));</span>
    }
    
    @JRubyMethod
    public IRubyObject annotations() {
        // note: intentionally returning the actual array returned from Java, rather
        // than wrapping it in a RubyArray. wave of the future, when java_class will
        // return the actual class, rather than a JavaClass wrapper.
<span class="nc" id="L1437">        return Java.getInstance(getRuntime(), javaClass().getAnnotations());</span>
    }
    
    @JRubyMethod(name = &quot;annotations?&quot;)
    public RubyBoolean annotations_p() {
<span class="nc bnc" id="L1442" title="All 2 branches missed.">        return getRuntime().newBoolean(javaClass().getAnnotations().length &gt; 0);</span>
    }
    
    @JRubyMethod
    public IRubyObject declared_annotations() {
        // see note above re: return type
<span class="nc" id="L1448">        return Java.getInstance(getRuntime(), javaClass().getDeclaredAnnotations());</span>
    }
    
    @JRubyMethod(name = &quot;declared_annotations?&quot;)
    public RubyBoolean declared_annotations_p() {
<span class="nc bnc" id="L1453" title="All 2 branches missed.">        return getRuntime().newBoolean(javaClass().getDeclaredAnnotations().length &gt; 0);</span>
    }
    
    @SuppressWarnings(&quot;unchecked&quot;)
    @JRubyMethod(name = &quot;annotation_present?&quot;, required = 1)
    public IRubyObject annotation_present_p(IRubyObject annoClass) {
<span class="nc bnc" id="L1459" title="All 2 branches missed.">        if (!(annoClass instanceof JavaClass)) {</span>
<span class="nc" id="L1460">            throw getRuntime().newTypeError(annoClass, getRuntime().getJavaSupport().getJavaClassClass());</span>
        }
<span class="nc" id="L1462">        return getRuntime().newBoolean(javaClass().isAnnotationPresent(((JavaClass)annoClass).javaClass()));</span>
    }
    
    @JRubyMethod
    public IRubyObject modifiers() {
<span class="nc" id="L1467">        return getRuntime().newFixnum(javaClass().getModifiers());</span>
    }

    @JRubyMethod
    public IRubyObject declaring_class() {
<span class="fc" id="L1472">        Class&lt;?&gt; clazz = javaClass().getDeclaringClass();</span>
<span class="pc bpc" id="L1473" title="1 of 2 branches missed.">        if (clazz != null) {</span>
<span class="fc" id="L1474">            return JavaClass.get(getRuntime(), clazz);</span>
        }
<span class="nc" id="L1476">        return getRuntime().getNil();</span>
    }

    @JRubyMethod
    public IRubyObject enclosing_class() {
<span class="nc" id="L1481">        return Java.getInstance(getRuntime(), javaClass().getEnclosingClass());</span>
    }
    
    @JRubyMethod
    public IRubyObject enclosing_constructor() {
<span class="nc" id="L1486">        Constructor&lt;?&gt; ctor = javaClass().getEnclosingConstructor();</span>
<span class="nc bnc" id="L1487" title="All 2 branches missed.">        if (ctor != null) {</span>
<span class="nc" id="L1488">            return new JavaConstructor(getRuntime(), ctor);</span>
        }
<span class="nc" id="L1490">        return getRuntime().getNil();</span>
    }

    @JRubyMethod
    public IRubyObject enclosing_method() {
<span class="nc" id="L1495">        Method meth = javaClass().getEnclosingMethod();</span>
<span class="nc bnc" id="L1496" title="All 2 branches missed.">        if (meth != null) {</span>
<span class="nc" id="L1497">            return new JavaMethod(getRuntime(), meth);</span>
        }
<span class="nc" id="L1499">        return getRuntime().getNil();</span>
    }

    @JRubyMethod
    public IRubyObject enum_constants() {
<span class="nc" id="L1504">        return Java.getInstance(getRuntime(), javaClass().getEnumConstants());</span>
    }

    @JRubyMethod
    public IRubyObject generic_interfaces() {
<span class="nc" id="L1509">        return Java.getInstance(getRuntime(), javaClass().getGenericInterfaces());</span>
    }
    
    @JRubyMethod
    public IRubyObject generic_superclass() {
<span class="nc" id="L1514">        return Java.getInstance(getRuntime(), javaClass().getGenericSuperclass());</span>
    }
    
    @JRubyMethod
    public IRubyObject type_parameters() {
<span class="nc" id="L1519">        return Java.getInstance(getRuntime(), javaClass().getTypeParameters());</span>
    }
    
    @JRubyMethod
    public IRubyObject signers() {
<span class="nc" id="L1524">        return Java.getInstance(getRuntime(), javaClass().getSigners());</span>
    }
    
    private static String getSimpleName(Class&lt;?&gt; clazz) {
<span class="pc bpc" id="L1528" title="1 of 2 branches missed."> 		if (clazz.isArray()) {</span>
<span class="nc" id="L1529"> 			return getSimpleName(clazz.getComponentType()) + &quot;[]&quot;;</span>
 		}
 
<span class="fc" id="L1532"> 		String className = clazz.getName();</span>
<span class="fc" id="L1533"> 		int len = className.length();</span>
<span class="fc" id="L1534">        int i = className.lastIndexOf('$');</span>
<span class="fc bfc" id="L1535" title="All 2 branches covered."> 		if (i != -1) {</span>
            do {
<span class="fc" id="L1537"> 				i++;</span>
<span class="pc bpc" id="L1538" title="2 of 4 branches missed."> 			} while (i &lt; len &amp;&amp; Character.isDigit(className.charAt(i)));</span>
<span class="fc" id="L1539"> 			return className.substring(i);</span>
 		}
 
<span class="fc" id="L1542"> 		return className.substring(className.lastIndexOf('.') + 1);</span>
 	}

    @JRubyMethod
    public RubyString simple_name() {
<span class="fc" id="L1547">        return getRuntime().newString(getSimpleName(javaClass()));</span>
    }

    @JRubyMethod
    public IRubyObject superclass() {
<span class="nc" id="L1552">        Class&lt;?&gt; superclass = javaClass().getSuperclass();</span>
<span class="nc bnc" id="L1553" title="All 2 branches missed.">        if (superclass == null) {</span>
<span class="nc" id="L1554">            return getRuntime().getNil();</span>
        }
<span class="nc" id="L1556">        return JavaClass.get(getRuntime(), superclass);</span>
    }

    @JRubyMethod(name = &quot;&lt;=&gt;&quot;, required = 1)
    public IRubyObject op_cmp(IRubyObject other) {
<span class="nc" id="L1561">        Class me = javaClass();</span>
<span class="nc" id="L1562">        Class them = null;</span>

        // dig out the other class
<span class="nc bnc" id="L1565" title="All 2 branches missed.">        if (other instanceof JavaClass) {</span>
<span class="nc" id="L1566">            JavaClass otherClass = (JavaClass) other;</span>
<span class="nc" id="L1567">            them = otherClass.javaClass();</span>
<span class="nc bnc" id="L1568" title="All 2 branches missed.">        } else if (other instanceof ConcreteJavaProxy) {</span>
<span class="nc" id="L1569">            ConcreteJavaProxy proxy = (ConcreteJavaProxy)other;</span>
<span class="nc bnc" id="L1570" title="All 2 branches missed.">            if (proxy.getObject() instanceof Class) {</span>
<span class="nc" id="L1571">                them = (Class)proxy.getObject();</span>
            }
        }

<span class="nc bnc" id="L1575" title="All 2 branches missed.">        if (them != null) {</span>
<span class="nc bnc" id="L1576" title="All 2 branches missed.">            if (this.javaClass() == them) {</span>
<span class="nc" id="L1577">                return getRuntime().newFixnum(0);</span>
            }
<span class="nc bnc" id="L1579" title="All 2 branches missed.">            if (them.isAssignableFrom(me)) {</span>
<span class="nc" id="L1580">                return getRuntime().newFixnum(-1);</span>
            }
<span class="nc bnc" id="L1582" title="All 2 branches missed.">            if (me.isAssignableFrom(them)) {</span>
<span class="nc" id="L1583">                return getRuntime().newFixnum(1);</span>
            }
        }

        // can't do a comparison
<span class="nc" id="L1588">        return getRuntime().getNil();</span>
    }

    @JRubyMethod
    public RubyArray java_instance_methods() {
<span class="nc" id="L1593">        return java_methods(javaClass().getMethods(), false);</span>
    }

    @JRubyMethod
    public RubyArray declared_instance_methods() {
<span class="nc" id="L1598">        return java_methods(javaClass().getDeclaredMethods(), false);</span>
    }

    private RubyArray java_methods(Method[] methods, boolean isStatic) {
<span class="nc" id="L1602">        RubyArray result = getRuntime().newArray(methods.length);</span>
<span class="nc bnc" id="L1603" title="All 2 branches missed.">        for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="nc" id="L1604">            Method method = methods[i];</span>
<span class="nc bnc" id="L1605" title="All 2 branches missed.">            if (isStatic == Modifier.isStatic(method.getModifiers())) {</span>
<span class="nc" id="L1606">                result.append(JavaMethod.create(getRuntime(), method));</span>
            }
        }
<span class="nc" id="L1609">        return result;</span>
    }

    @JRubyMethod
    public RubyArray java_class_methods() {
<span class="nc" id="L1614">        return java_methods(javaClass().getMethods(), true);</span>
    }

    @JRubyMethod
    public RubyArray declared_class_methods() {
<span class="nc" id="L1619">        return java_methods(javaClass().getDeclaredMethods(), true);</span>
    }

    @JRubyMethod(required = 1, rest = true)
    public JavaMethod java_method(IRubyObject[] args) {
<span class="nc" id="L1624">        String methodName = args[0].asJavaString();</span>
        try {
<span class="nc" id="L1626">            Class&lt;?&gt;[] argumentTypes = buildArgumentTypes(args);</span>
<span class="nc" id="L1627">            return JavaMethod.create(getRuntime(), javaClass(), methodName, argumentTypes);</span>
<span class="nc" id="L1628">        } catch (ClassNotFoundException cnfe) {</span>
<span class="nc" id="L1629">            throw getRuntime().newNameError(&quot;undefined method '&quot; + methodName + &quot;' for class '&quot; + javaClass().getName() + &quot;'&quot;,</span>
                methodName);
        }

    }

    @JRubyMethod(required = 1, rest = true)
    public JavaMethod declared_method(IRubyObject[] args) {
<span class="nc" id="L1637">        String methodName = args[0].asJavaString();</span>
        try {
<span class="nc" id="L1639">            Class&lt;?&gt;[] argumentTypes = buildArgumentTypes(args);</span>
<span class="nc" id="L1640">            return JavaMethod.createDeclared(getRuntime(), javaClass(), methodName, argumentTypes);</span>
<span class="nc" id="L1641">        } catch (ClassNotFoundException cnfe) {</span>
<span class="nc" id="L1642">            throw getRuntime().newNameError(&quot;undefined method '&quot; + methodName + &quot;' for class '&quot; + javaClass().getName() + &quot;'&quot;,</span>
                methodName);
        }
    }

    @JRubyMethod(required = 1, rest = true)
    public JavaCallable declared_method_smart(IRubyObject[] args) {
<span class="nc" id="L1649">        String methodName = args[0].asJavaString();</span>

        try {
<span class="nc" id="L1652">            Class&lt;?&gt;[] argumentTypes = buildArgumentTypes(args);</span>

<span class="nc" id="L1654">            JavaCallable callable = getMatchingCallable(getRuntime(), javaClass(), methodName, argumentTypes);</span>

<span class="nc bnc" id="L1656" title="All 2 branches missed.">            if (callable != null) return callable;</span>
<span class="nc" id="L1657">        } catch (ClassNotFoundException cnfe) {</span>
            // fall through to error below
<span class="nc" id="L1659">        }</span>

<span class="nc" id="L1661">        throw getRuntime().newNameError(&quot;undefined method '&quot; + methodName + &quot;' for class '&quot; + javaClass().getName() + &quot;'&quot;,</span>
                methodName);
    }
    
    public static JavaCallable getMatchingCallable(Ruby runtime, Class&lt;?&gt; javaClass, String methodName, Class&lt;?&gt;[] argumentTypes) {
<span class="nc bnc" id="L1666" title="All 2 branches missed.">        if (&quot;&lt;init&gt;&quot;.equals(methodName)) {</span>
<span class="nc" id="L1667">            return JavaConstructor.getMatchingConstructor(runtime, javaClass, argumentTypes);</span>
        } else {
            // FIXME: do we really want 'declared' methods?  includes private/protected, and does _not_
            // include superclass methods
<span class="nc" id="L1671">            return JavaMethod.getMatchingDeclaredMethod(runtime, javaClass, methodName, argumentTypes);</span>
        }
    }

    private Class&lt;?&gt;[] buildArgumentTypes(IRubyObject[] args) throws ClassNotFoundException {
<span class="nc bnc" id="L1676" title="All 2 branches missed.">        if (args.length &lt; 1) {</span>
<span class="nc" id="L1677">            throw getRuntime().newArgumentError(args.length, 1);</span>
        }
<span class="nc" id="L1679">        Class&lt;?&gt;[] argumentTypes = new Class[args.length - 1];</span>
<span class="nc bnc" id="L1680" title="All 2 branches missed.">        for (int i = 1; i &lt; args.length; i++) {</span>
            JavaClass type;
<span class="nc bnc" id="L1682" title="All 2 branches missed.">            if (args[i] instanceof JavaClass) {</span>
<span class="nc" id="L1683">                type = (JavaClass)args[i];</span>
<span class="nc bnc" id="L1684" title="All 2 branches missed.">            } else if (args[i].respondsTo(&quot;java_class&quot;)) {</span>
<span class="nc" id="L1685">                type = (JavaClass)args[i].callMethod(getRuntime().getCurrentContext(), &quot;java_class&quot;);</span>
            } else {
<span class="nc" id="L1687">                type = for_name(this, args[i]);</span>
            }
<span class="nc" id="L1689">            argumentTypes[i - 1] = type.javaClass();</span>
        }
<span class="nc" id="L1691">        return argumentTypes;</span>
    }

    @JRubyMethod
    public RubyArray constructors() {
        RubyArray ctors;
<span class="nc bnc" id="L1697" title="All 2 branches missed.">        if ((ctors = constructors) != null) return ctors;</span>
<span class="nc" id="L1698">        return constructors = buildConstructors(javaClass().getConstructors());</span>
    }
    
    @JRubyMethod
    public RubyArray classes() {
<span class="nc" id="L1703">        return JavaClass.getRubyArray(getRuntime(), javaClass().getClasses());</span>
    }

    @JRubyMethod
    public RubyArray declared_classes() {
<span class="nc" id="L1708">        Ruby runtime = getRuntime();</span>
<span class="nc" id="L1709">        RubyArray result = runtime.newArray();</span>
<span class="nc" id="L1710">        Class&lt;?&gt; javaClass = javaClass();</span>
        try {
<span class="nc" id="L1712">            Class&lt;?&gt;[] classes = javaClass.getDeclaredClasses();</span>
<span class="nc bnc" id="L1713" title="All 2 branches missed.">            for (int i = 0; i &lt; classes.length; i++) {</span>
<span class="nc bnc" id="L1714" title="All 2 branches missed.">                if (Modifier.isPublic(classes[i].getModifiers())) {</span>
<span class="nc" id="L1715">                    result.append(get(runtime, classes[i]));</span>
                }
            }
<span class="nc" id="L1718">        } catch (SecurityException e) {</span>
            // restrictive security policy; no matter, we only want public
            // classes anyway
            try {
<span class="nc" id="L1722">                Class&lt;?&gt;[] classes = javaClass.getClasses();</span>
<span class="nc bnc" id="L1723" title="All 2 branches missed.">                for (int i = 0; i &lt; classes.length; i++) {</span>
<span class="nc bnc" id="L1724" title="All 2 branches missed.">                    if (javaClass == classes[i].getDeclaringClass()) {</span>
<span class="nc" id="L1725">                        result.append(get(runtime, classes[i]));</span>
                    }
                }
<span class="nc" id="L1728">            } catch (SecurityException e2) {</span>
                // very restrictive policy (disallows Member.PUBLIC)
                // we'd never actually get this far in that case
<span class="nc" id="L1731">            }</span>
<span class="nc" id="L1732">        }</span>
<span class="nc" id="L1733">        return result;</span>
    }

    @JRubyMethod
    public RubyArray declared_constructors() {
<span class="nc" id="L1738">        return buildConstructors(javaClass().getDeclaredConstructors());</span>
    }

    private RubyArray buildConstructors(Constructor&lt;?&gt;[] constructors) {
<span class="nc" id="L1742">        RubyArray result = getRuntime().newArray(constructors.length);</span>
<span class="nc bnc" id="L1743" title="All 2 branches missed.">        for (int i = 0; i &lt; constructors.length; i++) {</span>
<span class="nc" id="L1744">            result.append(new JavaConstructor(getRuntime(), constructors[i]));</span>
        }
<span class="nc" id="L1746">        return result;</span>
    }

    @JRubyMethod(rest = true)
    public JavaConstructor constructor(IRubyObject[] args) {
        try {
<span class="nc" id="L1752">            Class&lt;?&gt;[] parameterTypes = buildClassArgs(args);</span>
<span class="nc" id="L1753">            Constructor&lt;?&gt; constructor = javaClass().getConstructor(parameterTypes);</span>
<span class="nc" id="L1754">            return new JavaConstructor(getRuntime(), constructor);</span>
<span class="nc" id="L1755">        } catch (NoSuchMethodException nsme) {</span>
<span class="nc" id="L1756">            throw getRuntime().newNameError(&quot;no matching java constructor&quot;, null);</span>
        }
    }

    @JRubyMethod(rest = true)
    public JavaConstructor declared_constructor(IRubyObject[] args) {
        try {
<span class="nc" id="L1763">            Class&lt;?&gt;[] parameterTypes = buildClassArgs(args);</span>
<span class="nc" id="L1764">            Constructor&lt;?&gt; constructor = javaClass().getDeclaredConstructor (parameterTypes);</span>
<span class="nc" id="L1765">            return new JavaConstructor(getRuntime(), constructor);</span>
<span class="nc" id="L1766">        } catch (NoSuchMethodException nsme) {</span>
<span class="nc" id="L1767">            throw getRuntime().newNameError(&quot;no matching java constructor&quot;, null);</span>
        }
    }

    private Class&lt;?&gt;[] buildClassArgs(IRubyObject[] args) {
<span class="nc" id="L1772">        Class&lt;?&gt;[] parameterTypes = new Class&lt;?&gt;[args.length];</span>
<span class="nc bnc" id="L1773" title="All 2 branches missed.">        for (int i = 0; i &lt; args.length; i++) {</span>
            JavaClass type;
<span class="nc bnc" id="L1775" title="All 2 branches missed.">            if (args[i] instanceof JavaClass) {</span>
<span class="nc" id="L1776">                type = (JavaClass)args[i];</span>
<span class="nc bnc" id="L1777" title="All 2 branches missed.">            } else if (args[i].respondsTo(&quot;java_class&quot;)) {</span>
<span class="nc" id="L1778">                type = (JavaClass)args[i].callMethod(getRuntime().getCurrentContext(), &quot;java_class&quot;);</span>
            } else {
<span class="nc" id="L1780">                type = for_name(this, args[i]);</span>
            }
<span class="nc" id="L1782">            parameterTypes[i] = type.javaClass();</span>
        }
<span class="nc" id="L1784">        return parameterTypes;</span>
    }

    @JRubyMethod
    public JavaClass array_class() {
<span class="fc" id="L1789">        return JavaClass.get(getRuntime(), Array.newInstance(javaClass(), 0).getClass());</span>
    }
   
    @JRubyMethod(required = 1)
    public JavaObject new_array(IRubyObject lengthArgument) {
<span class="nc bnc" id="L1794" title="All 2 branches missed.">        if (lengthArgument instanceof RubyInteger) {</span>
            // one-dimensional array
<span class="nc" id="L1796">            int length = (int) ((RubyInteger) lengthArgument).getLongValue();</span>
<span class="nc" id="L1797">            return new JavaArray(getRuntime(), Array.newInstance(javaClass(), length));</span>
<span class="nc bnc" id="L1798" title="All 2 branches missed.">        } else if (lengthArgument instanceof RubyArray) {</span>
            // n-dimensional array
<span class="nc" id="L1800">            List list = ((RubyArray)lengthArgument).getList();</span>
<span class="nc" id="L1801">            int length = list.size();</span>
<span class="nc bnc" id="L1802" title="All 2 branches missed.">            if (length == 0) {</span>
<span class="nc" id="L1803">                throw getRuntime().newArgumentError(&quot;empty dimensions specifier for java array&quot;);</span>
            }
<span class="nc" id="L1805">            int[] dimensions = new int[length];</span>
<span class="nc bnc" id="L1806" title="All 2 branches missed.">            for (int i = length; --i &gt;= 0; ) {</span>
<span class="nc" id="L1807">                IRubyObject dimensionLength = (IRubyObject)list.get(i);</span>
<span class="nc bnc" id="L1808" title="All 2 branches missed.">                if ( !(dimensionLength instanceof RubyInteger) ) {</span>
<span class="nc" id="L1809">                    throw getRuntime()</span>
<span class="nc" id="L1810">                    .newTypeError(dimensionLength, getRuntime().getInteger());</span>
                }
<span class="nc" id="L1812">                dimensions[i] = (int) ((RubyInteger) dimensionLength).getLongValue();</span>
<span class="nc" id="L1813">            }</span>
<span class="nc" id="L1814">            return new JavaArray(getRuntime(), Array.newInstance(javaClass(), dimensions));</span>
        } else {
<span class="nc" id="L1816">            throw getRuntime().newArgumentError(</span>
                    &quot;invalid length or dimensions specifier for java array&quot; +
            &quot; - must be Integer or Array of Integer&quot;);
        }
    }
   
    public IRubyObject emptyJavaArray(ThreadContext context) {
<span class="nc" id="L1823">        return ArrayUtils.emptyJavaArrayDirect(context, javaClass());</span>
    }
   
    public IRubyObject javaArraySubarray(ThreadContext context, JavaArray fromArray, int index, int size) {
<span class="nc" id="L1827">        return ArrayUtils.javaArraySubarrayDirect(context, getValue(), index, size);</span>
    }
   
    /**
     * Contatenate two Java arrays into a new one. The component type of the
     * additional array must be assignable to the component type of the
     * original array.
     * 
     * @param context
     * @param original
     * @param additional
     * @return
     */
    public IRubyObject concatArrays(ThreadContext context, JavaArray original, JavaArray additional) {
<span class="nc" id="L1841">        return ArrayUtils.concatArraysDirect(context, original.getValue(), additional.getValue());</span>
    }
   
    /**
     * The slow version for when concatenating a Java array of a different type.
     * 
     * @param context
     * @param original
     * @param additional
     * @return
     */
    public IRubyObject concatArrays(ThreadContext context, JavaArray original, IRubyObject additional) {
<span class="nc" id="L1853">        return ArrayUtils.concatArraysDirect(context, original.getValue(), additional);</span>
    }

    public IRubyObject javaArrayFromRubyArray(ThreadContext context, IRubyObject fromArray) {
<span class="nc" id="L1857">        Ruby runtime = context.runtime;</span>
<span class="nc bnc" id="L1858" title="All 2 branches missed.">        if (!(fromArray instanceof RubyArray)) {</span>
<span class="nc" id="L1859">            throw runtime.newTypeError(fromArray, runtime.getArray());</span>
        }
        
<span class="nc" id="L1862">        Object newArray = javaArrayFromRubyArrayDirect(context, fromArray);</span>
        
<span class="nc" id="L1864">        return new ArrayJavaProxy(runtime, Java.getProxyClassForObject(runtime, newArray), newArray, JavaUtil.getJavaConverter(javaClass()));</span>
    }

    public Object javaArrayFromRubyArrayDirect(ThreadContext context, IRubyObject fromArray) {
<span class="nc" id="L1868">        Ruby runtime = context.runtime;</span>
<span class="nc bnc" id="L1869" title="All 2 branches missed.">        if (!(fromArray instanceof RubyArray)) {</span>
<span class="nc" id="L1870">            throw runtime.newTypeError(fromArray, runtime.getArray());</span>
        }
<span class="nc" id="L1872">        RubyArray rubyArray = (RubyArray)fromArray;</span>
<span class="nc" id="L1873">        Object newArray = Array.newInstance(javaClass(), rubyArray.size());</span>
        
<span class="nc bnc" id="L1875" title="All 2 branches missed.">        if (javaClass().isArray()) {</span>
            // if it's an array of arrays, recurse with the component type
<span class="nc bnc" id="L1877" title="All 2 branches missed.">            for (int i = 0; i &lt; rubyArray.size(); i++) {</span>
<span class="nc" id="L1878">                JavaClass componentType = component_type();</span>
<span class="nc" id="L1879">                Object componentArray = componentType.javaArrayFromRubyArrayDirect(context, rubyArray.eltInternal(i));</span>
<span class="nc" id="L1880">                ArrayUtils.setWithExceptionHandlingDirect(runtime, newArray, i, componentArray);</span>
            }
        } else {
<span class="nc" id="L1883">            ArrayUtils.copyDataToJavaArrayDirect(context, rubyArray, newArray);</span>
        }
        
<span class="nc" id="L1886">        return newArray;</span>
    }

    @JRubyMethod
    public RubyArray fields() {
<span class="nc" id="L1891">        return buildFieldResults(javaClass().getFields());</span>
    }

    @JRubyMethod
    public RubyArray declared_fields() {
<span class="nc" id="L1896">        return buildFieldResults(javaClass().getDeclaredFields());</span>
    }

    private RubyArray buildFieldResults(Field[] fields) {
<span class="nc" id="L1900">        RubyArray result = getRuntime().newArray(fields.length);</span>
<span class="nc bnc" id="L1901" title="All 2 branches missed.">        for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="nc" id="L1902">            result.append(new JavaField(getRuntime(), fields[i]));</span>
        }
<span class="nc" id="L1904">        return result;</span>
    }

    @JRubyMethod(required = 1)
    public JavaField field(ThreadContext context, IRubyObject name) {
<span class="nc" id="L1909">        Class&lt;?&gt; javaClass = javaClass();</span>
<span class="nc" id="L1910">        Ruby runtime = context.runtime;</span>
<span class="nc" id="L1911">        String stringName = name.asJavaString();</span>

        try {
<span class="nc" id="L1914">            return new JavaField(runtime, javaClass.getField(stringName));</span>
<span class="nc" id="L1915">        } catch (NoSuchFieldException nsfe) {</span>
<span class="nc" id="L1916">            String newName = JavaUtil.getJavaCasedName(stringName);</span>
<span class="nc bnc" id="L1917" title="All 2 branches missed.">            if(newName != null) {</span>
                try {
<span class="nc" id="L1919">                    return new JavaField(runtime, javaClass.getField(newName));</span>
<span class="nc" id="L1920">                } catch (NoSuchFieldException nsfe2) {}</span>
            }
<span class="nc" id="L1922">            throw undefinedFieldError(runtime, javaClass.getName(), stringName);</span>
         }
    }

    @JRubyMethod(required = 1)
    public JavaField declared_field(ThreadContext context, IRubyObject name) {
<span class="nc" id="L1928">        Class&lt;?&gt; javaClass = javaClass();</span>
<span class="nc" id="L1929">        Ruby runtime = context.runtime;</span>
<span class="nc" id="L1930">        String stringName = name.asJavaString();</span>
        
        try {
<span class="nc" id="L1933">            return new JavaField(runtime, javaClass.getDeclaredField(stringName));</span>
<span class="nc" id="L1934">        } catch (NoSuchFieldException nsfe) {</span>
<span class="nc" id="L1935">            String newName = JavaUtil.getJavaCasedName(stringName);</span>
<span class="nc bnc" id="L1936" title="All 2 branches missed.">            if(newName != null) {</span>
                try {
<span class="nc" id="L1938">                    return new JavaField(runtime, javaClass.getDeclaredField(newName));</span>
<span class="nc" id="L1939">                } catch (NoSuchFieldException nsfe2) {}</span>
            }
<span class="nc" id="L1941">            throw undefinedFieldError(runtime, javaClass.getName(), stringName);</span>
        }
    }
    
    public static RaiseException undefinedFieldError(Ruby runtime, String javaClassName, String name) {
<span class="nc" id="L1946">        return runtime.newNameError(&quot;undefined field '&quot; + name + &quot;' for class '&quot; + javaClassName + &quot;'&quot;, name);</span>
    }

    @JRubyMethod
    public RubyArray interfaces() {
<span class="nc" id="L1951">        return JavaClass.getRubyArray(getRuntime(), javaClass().getInterfaces());</span>
    }

    @JRubyMethod(name = &quot;primitive?&quot;)
    public RubyBoolean primitive_p() {
<span class="nc" id="L1956">        return getRuntime().newBoolean(isPrimitive());</span>
    }

    @JRubyMethod(name = &quot;assignable_from?&quot;, required = 1)
    public RubyBoolean assignable_from_p(IRubyObject other) {
<span class="nc bnc" id="L1961" title="All 2 branches missed.">        if (! (other instanceof JavaClass)) {</span>
<span class="nc" id="L1962">            throw getRuntime().newTypeError(&quot;assignable_from requires JavaClass (&quot; + other.getType() + &quot; given)&quot;);</span>
        }

<span class="nc" id="L1965">        Class&lt;?&gt; otherClass = ((JavaClass) other).javaClass();</span>
<span class="nc bnc" id="L1966" title="All 2 branches missed.">        return assignable(javaClass(), otherClass) ? getRuntime().getTrue() : getRuntime().getFalse();</span>
    }

    public static boolean assignable(Class&lt;?&gt; thisClass, Class&lt;?&gt; otherClass) {
<span class="nc bnc" id="L1970" title="All 4 branches missed.">        if(!thisClass.isPrimitive() &amp;&amp; otherClass == Void.TYPE ||</span>
<span class="nc bnc" id="L1971" title="All 2 branches missed.">            thisClass.isAssignableFrom(otherClass)) {</span>
<span class="nc" id="L1972">            return true;</span>
        }

<span class="nc" id="L1975">        otherClass = JavaUtil.primitiveToWrapper(otherClass);</span>
<span class="nc" id="L1976">        thisClass = JavaUtil.primitiveToWrapper(thisClass);</span>

<span class="nc bnc" id="L1978" title="All 2 branches missed.">        if(thisClass.isAssignableFrom(otherClass)) {</span>
<span class="nc" id="L1979">            return true;</span>
        }
<span class="nc bnc" id="L1981" title="All 2 branches missed.">        if(Number.class.isAssignableFrom(thisClass)) {</span>
<span class="nc bnc" id="L1982" title="All 2 branches missed.">            if(Number.class.isAssignableFrom(otherClass)) {</span>
<span class="nc" id="L1983">                return true;</span>
            }
<span class="nc bnc" id="L1985" title="All 2 branches missed.">            if(otherClass.equals(Character.class)) {</span>
<span class="nc" id="L1986">                return true;</span>
            }
        }
<span class="nc bnc" id="L1989" title="All 2 branches missed.">        if(thisClass.equals(Character.class)) {</span>
<span class="nc bnc" id="L1990" title="All 2 branches missed.">            if(Number.class.isAssignableFrom(otherClass)) {</span>
<span class="nc" id="L1991">                return true;</span>
            }
        }
<span class="nc" id="L1994">        return false;</span>
    }

    private boolean isPrimitive() {
<span class="nc" id="L1998">        return javaClass().isPrimitive();</span>
    }

    @JRubyMethod
    public JavaClass component_type() {
<span class="nc bnc" id="L2003" title="All 2 branches missed.">        if (! javaClass().isArray()) {</span>
<span class="nc" id="L2004">            throw getRuntime().newTypeError(&quot;not a java array-class&quot;);</span>
        }
<span class="nc" id="L2006">        return JavaClass.get(getRuntime(), javaClass().getComponentType());</span>
    }
    
    private static Constructor[] getConstructors(Class&lt;?&gt; javaClass) {
        try {
<span class="fc" id="L2011">            return javaClass.getConstructors();</span>
<span class="nc" id="L2012">        } catch (SecurityException e) {</span>
<span class="nc" id="L2013">            return new Constructor[] {};</span>
        }        
    }

    private static Class&lt;?&gt;[] getDeclaredClasses(Class&lt;?&gt; javaClass) {
        try {
<span class="fc" id="L2019">            return javaClass.getDeclaredClasses();</span>
<span class="nc" id="L2020">        } catch (SecurityException e) {</span>
<span class="nc" id="L2021">            return new Class&lt;?&gt;[] {};</span>
<span class="nc" id="L2022">        } catch (NoClassDefFoundError cnfe) {</span>
            // This is a Scala-specific hack, since Scala uses peculiar
            // naming conventions and class attributes that confuse Java's
            // reflection logic and cause a blow up in getDeclaredClasses.
            // See http://lampsvn.epfl.ch/trac/scala/ticket/2749
<span class="nc" id="L2027">            return new Class&lt;?&gt;[] {};</span>
        }
    }
    
    private static Class&lt;?&gt;[] getClasses(Class&lt;?&gt; javaClass) {
        try {
<span class="nc" id="L2033">            return javaClass.getClasses();</span>
<span class="nc" id="L2034">        } catch (SecurityException e) {</span>
<span class="nc" id="L2035">            return new Class&lt;?&gt;[] {};</span>
        }
    }

    public static Field[] getDeclaredFields(Class&lt;?&gt; javaClass) {
        try {
<span class="fc" id="L2041">            return javaClass.getDeclaredFields();</span>
<span class="nc" id="L2042">        } catch (SecurityException e) {</span>
<span class="nc" id="L2043">            return getFields(javaClass);</span>
        }
    }

    public static Field[] getFields(Class&lt;?&gt; javaClass) {
        try {
<span class="fc" id="L2049">            return javaClass.getFields();</span>
<span class="nc" id="L2050">        } catch (SecurityException e) {</span>
<span class="nc" id="L2051">            return new Field[] {};</span>
        }
    }
    
    private static boolean methodsAreEquivalent(Method child, Method parent) {
<span class="fc bfc" id="L2056" title="All 2 branches covered.">        return parent.getDeclaringClass().isAssignableFrom(child.getDeclaringClass())</span>
<span class="fc bfc" id="L2057" title="All 2 branches covered.">                &amp;&amp; child.getReturnType() == parent.getReturnType()</span>
<span class="fc bfc" id="L2058" title="All 2 branches covered.">                &amp;&amp; child.isVarArgs() == parent.isVarArgs()</span>
<span class="fc bfc" id="L2059" title="All 2 branches covered.">                &amp;&amp; Modifier.isPublic(child.getModifiers()) == Modifier.isPublic(parent.getModifiers())</span>
<span class="pc bpc" id="L2060" title="1 of 2 branches missed.">                &amp;&amp; Modifier.isProtected(child.getModifiers()) == Modifier.isProtected(parent.getModifiers())</span>
<span class="fc bfc" id="L2061" title="All 2 branches covered.">                &amp;&amp; Modifier.isStatic(child.getModifiers()) == Modifier.isStatic(parent.getModifiers())</span>
<span class="fc bfc" id="L2062" title="All 2 branches covered.">                &amp;&amp; Arrays.equals(child.getParameterTypes(), parent.getParameterTypes());</span>
    }
    
    private static int addNewMethods(HashMap&lt;String, List&lt;Method&gt;&gt; nameMethods, Method[] methods, boolean includeStatic, boolean removeDuplicate) {
<span class="fc" id="L2066">        int added = 0;</span>
<span class="fc bfc" id="L2067" title="All 2 branches covered.">        Methods: for (Method m : methods) {</span>
            // Skip private methods, since they may mess with dispatch
<span class="fc bfc" id="L2069" title="All 2 branches covered.">            if (Modifier.isPrivate(m.getModifiers())) continue;</span>

            // ignore bridge methods because we'd rather directly call methods that this method
            // is bridging (and such methods are by definition always available.)
<span class="fc bfc" id="L2073" title="All 2 branches covered.">            if ((m.getModifiers()&amp;ACC_BRIDGE)!=0)</span>
<span class="fc" id="L2074">                continue;</span>

<span class="fc bfc" id="L2076" title="All 4 branches covered.">            if (!includeStatic &amp;&amp; Modifier.isStatic(m.getModifiers())) {</span>
                // Skip static methods if we're not suppose to include them.
                // Generally for superclasses; we only bind statics from the actual
                // class.
<span class="fc" id="L2080">                continue;</span>
            }
<span class="fc" id="L2082">            List&lt;Method&gt; childMethods = nameMethods.get(m.getName());</span>
<span class="fc bfc" id="L2083" title="All 2 branches covered.">            if (childMethods == null) {</span>
                // first method of this name, add a collection for it
<span class="fc" id="L2085">                childMethods = new ArrayList&lt;Method&gt;(1);</span>
<span class="fc" id="L2086">                childMethods.add(m);</span>
<span class="fc" id="L2087">                nameMethods.put(m.getName(), childMethods);</span>
<span class="fc" id="L2088">                added++;</span>
            } else {
                // we have seen other methods; check if we already have
                // an equivalent one
<span class="fc bfc" id="L2092" title="All 2 branches covered.">                for (ListIterator&lt;Method&gt; iter = childMethods.listIterator(); iter.hasNext();) {</span>
<span class="fc" id="L2093">                    Method m2 = iter.next();</span>
<span class="fc bfc" id="L2094" title="All 2 branches covered.">                    if (methodsAreEquivalent(m2, m)) {</span>
<span class="fc bfc" id="L2095" title="All 2 branches covered.">                        if (removeDuplicate) {</span>
                            // Replace the existing method, since the super call is more general
                            // and virtual dispatch will call the subclass impl anyway.
                            // Used for instance methods, for which we usually want to use the highest-up
                            // callable implementation.
<span class="fc" id="L2100">                            iter.set(m);</span>
                        } else {
                            // just skip the new method, since we don't need it (already found one)
                            // used for interface methods, which we want to add unconditionally
                            // but only if we need them
                        }
                        continue Methods;
                    }
<span class="fc" id="L2108">                }</span>
                // no equivalent; add it
<span class="fc" id="L2110">                childMethods.add(m);</span>
<span class="fc" id="L2111">                added++;</span>
            }
        }
<span class="fc" id="L2114">        return added;</span>
    }
    
    public static Method[] getMethods(Class&lt;?&gt; javaClass) {
<span class="fc" id="L2118">        HashMap&lt;String, List&lt;Method&gt;&gt; nameMethods = new HashMap&lt;String, List&lt;Method&gt;&gt;(30);</span>

        // to better size the final ArrayList below
<span class="fc" id="L2121">        int total = 0;</span>
        
        // we scan all superclasses, but avoid adding superclass methods with
        // same name+signature as subclass methods (see JRUBY-3130)
<span class="fc bfc" id="L2125" title="All 2 branches covered.">        for (Class c = javaClass; c != null; c = c.getSuperclass()) {</span>
            // only add class's methods if it's public or we can set accessible
            // (see JRUBY-4799)
<span class="pc bpc" id="L2128" title="1 of 4 branches missed.">            if (Modifier.isPublic(c.getModifiers()) || CAN_SET_ACCESSIBLE) {</span>
                // for each class, scan declared methods for new signatures
                try {
                    // add methods, including static if this is the actual class,
                    // and replacing child methods with equivalent parent methods
<span class="fc bfc" id="L2133" title="All 2 branches covered.">                    total += addNewMethods(nameMethods, c.getDeclaredMethods(), c == javaClass, true);</span>
<span class="nc" id="L2134">                } catch (SecurityException e) {</span>
<span class="fc" id="L2135">                }</span>
            }

            // then do the same for each interface
<span class="fc bfc" id="L2139" title="All 2 branches covered.">            for (Class i : c.getInterfaces()) {</span>
                try {
                    // add methods, not including static (should be none on
                    // interfaces anyway) and not replacing child methods with
                    // parent methods
<span class="fc" id="L2144">                    total += addNewMethods(nameMethods, i.getMethods(), false, false);</span>
<span class="nc" id="L2145">                } catch (SecurityException e) {</span>
<span class="fc" id="L2146">                }</span>
            }
        }
        
        // now only bind the ones that remain
<span class="fc" id="L2151">        ArrayList&lt;Method&gt; finalList = new ArrayList&lt;Method&gt;(total);</span>

<span class="fc bfc" id="L2153" title="All 2 branches covered.">        for (Map.Entry&lt;String, List&lt;Method&gt;&gt; entry : nameMethods.entrySet()) {</span>
<span class="fc" id="L2154">            finalList.addAll(entry.getValue());</span>
<span class="fc" id="L2155">        }</span>
        
<span class="fc" id="L2157">        return finalList.toArray(new Method[finalList.size()]);</span>
    }

    private static final int ACC_BRIDGE    = 0x00000040;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>