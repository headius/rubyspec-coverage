<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Java.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby.javasupport</a> &gt; <span class="el_source">Java.java</span></div><h1>Java.java</h1><pre class="source lang-java linenums">/***** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2002 Jan Arne Petersen &lt;jpetersen@uni-bonn.de&gt;
 * Copyright (C) 2002-2004 Anders Bengtsson &lt;ndrsbngtssn@yahoo.se&gt;
 * Copyright (C) 2004 Stefan Matthias Aust &lt;sma@3plus4.de&gt;
 * Copyright (C) 2004 David Corbin &lt;dcorbin@users.sourceforge.net&gt;
 * Copyright (C) 2004-2005 Thomas E Enebo &lt;enebo@acm.org&gt;
 * Copyright (C) 2006 Kresten Krab Thorup &lt;krab@gnu.org&gt;
 * Copyright (C) 2007 William N Dortch &lt;bill.dortch@gmail.com&gt;
 * 
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby.javasupport;

import org.jruby.java.util.BlankSlateWrapper;
import org.jruby.java.util.SystemPropertiesMap;
import org.jruby.java.proxies.JavaInterfaceTemplate;
import org.jruby.java.addons.KernelJavaAddons;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Proxy;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import org.jcodings.Encoding;

import org.jruby.MetaClass;
import org.jruby.Ruby;
import org.jruby.RubyArray;
import org.jruby.RubyBasicObject;
import org.jruby.RubyClass;
import org.jruby.RubyClassPathVariable;
import org.jruby.RubyException;
import org.jruby.RubyInstanceConfig;
import org.jruby.RubyMethod;
import org.jruby.RubyModule;
import org.jruby.RubyObject;
import org.jruby.RubyString;
import org.jruby.RubyUnboundMethod;
import org.jruby.exceptions.RaiseException;
import org.jruby.javasupport.proxy.JavaProxyClass;
import org.jruby.javasupport.proxy.JavaProxyConstructor;
import org.jruby.runtime.Helpers;
import org.jruby.runtime.Arity;
import org.jruby.runtime.Block;
import org.jruby.runtime.ThreadContext;
import static org.jruby.runtime.Visibility.*;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.runtime.load.Library;
import org.jruby.util.*;
import org.jruby.anno.JRubyMethod;
import org.jruby.anno.JRubyModule;
import org.jruby.internal.runtime.methods.JavaMethod.JavaMethodN;
import org.jruby.internal.runtime.methods.JavaMethod.JavaMethodZero;
import org.jruby.java.addons.ArrayJavaAddons;
import org.jruby.java.addons.IOJavaAddons;
import org.jruby.java.addons.StringJavaAddons;
import org.jruby.java.codegen.RealClassGenerator;
import org.jruby.java.dispatch.CallableSelector;
import org.jruby.java.invokers.InstanceMethodInvoker;
import org.jruby.java.invokers.MethodInvoker;
import org.jruby.java.invokers.StaticMethodInvoker;
import org.jruby.java.proxies.ArrayJavaProxy;
import org.jruby.java.proxies.ArrayJavaProxyCreator;
import org.jruby.java.proxies.ConcreteJavaProxy;
import org.jruby.java.proxies.MapJavaProxy;
import org.jruby.java.proxies.InterfaceJavaProxy;
import org.jruby.java.proxies.JavaProxy;
import org.jruby.java.proxies.RubyObjectHolderProxy;
import org.jruby.javasupport.proxy.JavaProxyClassFactory;
import org.jruby.util.OneShotClassLoader;
import org.jruby.util.cli.Options;

@JRubyModule(name = &quot;Java&quot;)
<span class="fc" id="L108">public class Java implements Library {</span>
<span class="fc" id="L109">    public static final boolean NEW_STYLE_EXTENSION = Options.JI_NEWSTYLEEXTENSION.load();</span>
<span class="fc" id="L110">    public static final boolean OBJECT_PROXY_CACHE = Options.JI_OBJECTPROXYCACHE.load();</span>

    public void load(Ruby runtime, boolean wrap) {
<span class="fc" id="L113">        createJavaModule(runtime);</span>

<span class="fc" id="L115">        RubyModule jpmt = runtime.defineModule(&quot;JavaPackageModuleTemplate&quot;);</span>
<span class="fc" id="L116">        jpmt.getSingletonClass().setSuperClass(new BlankSlateWrapper(runtime, jpmt.getMetaClass().getSuperClass(), runtime.getKernel()));</span>

        // load Ruby parts of the 'java' library
<span class="fc" id="L119">        runtime.getLoadService().load(&quot;jruby/java.rb&quot;, false);</span>
        
        // rewite ArrayJavaProxy superclass to point at Object, so it inherits Object behaviors
<span class="fc" id="L122">        RubyClass ajp = runtime.getClass(&quot;ArrayJavaProxy&quot;);</span>
<span class="fc" id="L123">        ajp.setSuperClass(runtime.getJavaSupport().getObjectJavaClass().getProxyClass());</span>
<span class="fc" id="L124">        ajp.includeModule(runtime.getEnumerable());</span>
        
<span class="fc" id="L126">        RubyClassPathVariable.createClassPathVariable(runtime);</span>
        
<span class="fc" id="L128">        runtime.setJavaProxyClassFactory(JavaProxyClassFactory.createFactory());</span>

        // modify ENV_JAVA to be a read/write version
<span class="fc" id="L131">        Map systemProps = new SystemPropertiesMap();</span>
<span class="fc" id="L132">        runtime.getObject().setConstantQuiet(</span>
                &quot;ENV_JAVA&quot;,
                new MapJavaProxy(
                        runtime,
<span class="fc" id="L136">                        (RubyClass)Java.getProxyClass(runtime, SystemPropertiesMap.class),</span>
                        systemProps));
<span class="fc" id="L138">    }</span>

    public static RubyModule createJavaModule(Ruby runtime) {
<span class="fc" id="L141">        ThreadContext context = runtime.getCurrentContext();</span>
<span class="fc" id="L142">        RubyModule javaModule = runtime.defineModule(&quot;Java&quot;);</span>
        
<span class="fc" id="L144">        javaModule.defineAnnotatedMethods(Java.class);</span>

<span class="fc" id="L146">        JavaObject.createJavaObjectClass(runtime, javaModule);</span>
<span class="fc" id="L147">        JavaArray.createJavaArrayClass(runtime, javaModule);</span>
<span class="fc" id="L148">        JavaClass.createJavaClassClass(runtime, javaModule);</span>
<span class="fc" id="L149">        JavaMethod.createJavaMethodClass(runtime, javaModule);</span>
<span class="fc" id="L150">        JavaConstructor.createJavaConstructorClass(runtime, javaModule);</span>
<span class="fc" id="L151">        JavaField.createJavaFieldClass(runtime, javaModule);</span>
        
        // set of utility methods for Java-based proxy objects
<span class="fc" id="L154">        JavaProxyMethods.createJavaProxyMethods(context);</span>
        
        // the proxy (wrapper) type hierarchy
<span class="fc" id="L157">        JavaProxy.createJavaProxy(context);</span>
<span class="fc" id="L158">        ArrayJavaProxyCreator.createArrayJavaProxyCreator(context);</span>
<span class="fc" id="L159">        ConcreteJavaProxy.createConcreteJavaProxy(context);</span>
<span class="fc" id="L160">        InterfaceJavaProxy.createInterfaceJavaProxy(context);</span>
<span class="fc" id="L161">        ArrayJavaProxy.createArrayJavaProxy(context);</span>

        // creates ruby's hash methods' proxy for Map interface
<span class="fc" id="L164">        MapJavaProxy.createMapJavaProxy(context);</span>

        // also create the JavaProxy* classes
<span class="fc" id="L167">        JavaProxyClass.createJavaProxyModule(runtime);</span>

        // The template for interface modules
<span class="fc" id="L170">        JavaInterfaceTemplate.createJavaInterfaceTemplateModule(context);</span>

<span class="fc" id="L172">        RubyModule javaUtils = runtime.defineModule(&quot;JavaUtilities&quot;);</span>
        
<span class="fc" id="L174">        javaUtils.defineAnnotatedMethods(JavaUtilities.class);</span>

<span class="fc" id="L176">        JavaArrayUtilities.createJavaArrayUtilitiesModule(runtime);</span>
        
        // Now attach Java-related extras to core classes
<span class="fc" id="L179">        runtime.getArray().defineAnnotatedMethods(ArrayJavaAddons.class);</span>
<span class="fc" id="L180">        runtime.getKernel().defineAnnotatedMethods(KernelJavaAddons.class);</span>
<span class="fc" id="L181">        runtime.getString().defineAnnotatedMethods(StringJavaAddons.class);</span>
<span class="fc" id="L182">        runtime.getIO().defineAnnotatedMethods(IOJavaAddons.class);</span>

<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if (runtime.getObject().isConstantDefined(&quot;StringIO&quot;)) {</span>
<span class="nc" id="L185">            ((RubyClass)runtime.getObject().getConstant(&quot;StringIO&quot;)).defineAnnotatedMethods(IOJavaAddons.AnyIO.class);</span>
        }
        
        // add all name-to-class mappings
<span class="fc" id="L189">        addNameClassMappings(runtime, runtime.getJavaSupport().getNameClassMap());</span>
        
        // add some base Java classes everyone will need
<span class="fc" id="L192">        runtime.getJavaSupport().setObjectJavaClass(JavaClass.get(runtime, Object.class));</span>

<span class="fc" id="L194">        return javaModule;</span>
    }

<span class="nc" id="L197">    public static class OldStyleExtensionInherited {</span>
        @JRubyMethod
        public static IRubyObject inherited(IRubyObject recv, IRubyObject arg0) {
<span class="nc" id="L200">            return Java.concrete_proxy_inherited(recv, arg0);</span>
        }
    };

<span class="nc" id="L204">    public static class NewStyleExtensionInherited {</span>
        @JRubyMethod
        public static IRubyObject inherited(IRubyObject recv, IRubyObject arg0) {
<span class="nc bnc" id="L207" title="All 2 branches missed.">            if (!(arg0 instanceof RubyClass)) {</span>
<span class="nc" id="L208">                throw recv.getRuntime().newTypeError(arg0, recv.getRuntime().getClassClass());</span>
            }
            
<span class="nc" id="L211">            JavaInterfaceTemplate.addRealImplClassNew((RubyClass)arg0);</span>
<span class="nc" id="L212">            return recv.getRuntime().getNil();</span>
        }
    };
    
    /**
     * This populates the master map from short-cut names to JavaClass instances for
     * a number of core Java types.
     * 
     * @param runtime
     * @param nameClassMap
     */
    private static void addNameClassMappings(Ruby runtime, Map&lt;String, JavaClass&gt; nameClassMap) {
<span class="fc" id="L224">        JavaClass booleanPrimClass = JavaClass.get(runtime, Boolean.TYPE);</span>
<span class="fc" id="L225">        JavaClass booleanClass = JavaClass.get(runtime, Boolean.class);</span>
<span class="fc" id="L226">        nameClassMap.put(&quot;boolean&quot;, booleanPrimClass);</span>
<span class="fc" id="L227">        nameClassMap.put(&quot;Boolean&quot;, booleanClass);</span>
<span class="fc" id="L228">        nameClassMap.put(&quot;java.lang.Boolean&quot;, booleanClass);</span>
        
<span class="fc" id="L230">        JavaClass bytePrimClass = JavaClass.get(runtime, Byte.TYPE);</span>
<span class="fc" id="L231">        JavaClass byteClass = JavaClass.get(runtime, Byte.class);</span>
<span class="fc" id="L232">        nameClassMap.put(&quot;byte&quot;, bytePrimClass);</span>
<span class="fc" id="L233">        nameClassMap.put(&quot;Byte&quot;, byteClass);</span>
<span class="fc" id="L234">        nameClassMap.put(&quot;java.lang.Byte&quot;, byteClass);</span>
        
<span class="fc" id="L236">        JavaClass shortPrimClass = JavaClass.get(runtime, Short.TYPE);</span>
<span class="fc" id="L237">        JavaClass shortClass = JavaClass.get(runtime, Short.class);</span>
<span class="fc" id="L238">        nameClassMap.put(&quot;short&quot;, shortPrimClass);</span>
<span class="fc" id="L239">        nameClassMap.put(&quot;Short&quot;, shortClass);</span>
<span class="fc" id="L240">        nameClassMap.put(&quot;java.lang.Short&quot;, shortClass);</span>
        
<span class="fc" id="L242">        JavaClass charPrimClass = JavaClass.get(runtime, Character.TYPE);</span>
<span class="fc" id="L243">        JavaClass charClass = JavaClass.get(runtime, Character.class);</span>
<span class="fc" id="L244">        nameClassMap.put(&quot;char&quot;, charPrimClass);</span>
<span class="fc" id="L245">        nameClassMap.put(&quot;Character&quot;, charClass);</span>
<span class="fc" id="L246">        nameClassMap.put(&quot;Char&quot;, charClass);</span>
<span class="fc" id="L247">        nameClassMap.put(&quot;java.lang.Character&quot;, charClass);</span>
        
<span class="fc" id="L249">        JavaClass intPrimClass = JavaClass.get(runtime, Integer.TYPE);</span>
<span class="fc" id="L250">        JavaClass intClass = JavaClass.get(runtime, Integer.class);</span>
<span class="fc" id="L251">        nameClassMap.put(&quot;int&quot;, intPrimClass);</span>
<span class="fc" id="L252">        nameClassMap.put(&quot;Integer&quot;, intClass);</span>
<span class="fc" id="L253">        nameClassMap.put(&quot;Int&quot;, intClass);</span>
<span class="fc" id="L254">        nameClassMap.put(&quot;java.lang.Integer&quot;, intClass);</span>
        
<span class="fc" id="L256">        JavaClass longPrimClass = JavaClass.get(runtime, Long.TYPE);</span>
<span class="fc" id="L257">        JavaClass longClass = JavaClass.get(runtime, Long.class);</span>
<span class="fc" id="L258">        nameClassMap.put(&quot;long&quot;, longPrimClass);</span>
<span class="fc" id="L259">        nameClassMap.put(&quot;Long&quot;, longClass);</span>
<span class="fc" id="L260">        nameClassMap.put(&quot;java.lang.Long&quot;, longClass);</span>
        
<span class="fc" id="L262">        JavaClass floatPrimClass = JavaClass.get(runtime, Float.TYPE);</span>
<span class="fc" id="L263">        JavaClass floatClass = JavaClass.get(runtime, Float.class);</span>
<span class="fc" id="L264">        nameClassMap.put(&quot;float&quot;, floatPrimClass);</span>
<span class="fc" id="L265">        nameClassMap.put(&quot;Float&quot;, floatClass);</span>
<span class="fc" id="L266">        nameClassMap.put(&quot;java.lang.Float&quot;, floatClass);</span>
        
<span class="fc" id="L268">        JavaClass doublePrimClass = JavaClass.get(runtime, Double.TYPE);</span>
<span class="fc" id="L269">        JavaClass doubleClass = JavaClass.get(runtime, Double.class);</span>
<span class="fc" id="L270">        nameClassMap.put(&quot;double&quot;, doublePrimClass);</span>
<span class="fc" id="L271">        nameClassMap.put(&quot;Double&quot;, doubleClass);</span>
<span class="fc" id="L272">        nameClassMap.put(&quot;java.lang.Double&quot;, doubleClass);</span>
        
<span class="fc" id="L274">        JavaClass bigintClass = JavaClass.get(runtime, BigInteger.class);</span>
<span class="fc" id="L275">        nameClassMap.put(&quot;big_int&quot;, bigintClass);</span>
<span class="fc" id="L276">        nameClassMap.put(&quot;big_integer&quot;, bigintClass);</span>
<span class="fc" id="L277">        nameClassMap.put(&quot;BigInteger&quot;, bigintClass);</span>
<span class="fc" id="L278">        nameClassMap.put(&quot;java.math.BigInteger&quot;, bigintClass);</span>
        
<span class="fc" id="L280">        JavaClass bigdecimalClass = JavaClass.get(runtime, BigDecimal.class);</span>
<span class="fc" id="L281">        nameClassMap.put(&quot;big_decimal&quot;, bigdecimalClass);</span>
<span class="fc" id="L282">        nameClassMap.put(&quot;BigDecimal&quot;, bigdecimalClass);</span>
<span class="fc" id="L283">        nameClassMap.put(&quot;java.math.BigDecimal&quot;, bigdecimalClass);</span>
        
<span class="fc" id="L285">        JavaClass objectClass = JavaClass.get(runtime, Object.class);</span>
<span class="fc" id="L286">        nameClassMap.put(&quot;object&quot;, objectClass);</span>
<span class="fc" id="L287">        nameClassMap.put(&quot;Object&quot;, objectClass);</span>
<span class="fc" id="L288">        nameClassMap.put(&quot;java.lang.Object&quot;, objectClass);</span>
        
<span class="fc" id="L290">        JavaClass stringClass = JavaClass.get(runtime, String.class);</span>
<span class="fc" id="L291">        nameClassMap.put(&quot;string&quot;, stringClass);</span>
<span class="fc" id="L292">        nameClassMap.put(&quot;String&quot;, stringClass);</span>
<span class="fc" id="L293">        nameClassMap.put(&quot;java.lang.String&quot;, stringClass);</span>
<span class="fc" id="L294">    }</span>

<span class="fc" id="L296">    private static final ClassProvider JAVA_PACKAGE_CLASS_PROVIDER = new ClassProvider() {</span>

        public RubyClass defineClassUnder(RubyModule pkg, String name, RubyClass superClazz) {
            // shouldn't happen, but if a superclass is specified, it's not ours
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">            if (superClazz != null) {</span>
<span class="nc" id="L301">                return null;</span>
            }
            IRubyObject packageName;
            // again, shouldn't happen. TODO: might want to throw exception instead.
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">            if ((packageName = pkg.getInstanceVariables().getInstanceVariable(&quot;@package_name&quot;)) == null) {</span>
<span class="nc" id="L306">                return null;</span>
            }
<span class="fc" id="L308">            Ruby runtime = pkg.getRuntime();</span>
<span class="fc" id="L309">            return (RubyClass) get_proxy_class(</span>
<span class="fc" id="L310">                    runtime.getJavaSupport().getJavaUtilitiesModule(),</span>
<span class="fc" id="L311">                    JavaClass.forNameVerbose(runtime, packageName.asJavaString() + name));</span>
        }

        public RubyModule defineModuleUnder(RubyModule pkg, String name) {
            IRubyObject packageName;
            // again, shouldn't happen. TODO: might want to throw exception instead.
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">            if ((packageName = pkg.getInstanceVariables().getInstanceVariable(&quot;@package_name&quot;)) == null) {</span>
<span class="nc" id="L318">                return null;</span>
            }
<span class="fc" id="L320">            Ruby runtime = pkg.getRuntime();</span>
<span class="fc" id="L321">            return (RubyModule) get_interface_module(</span>
                    runtime,
<span class="fc" id="L323">                    JavaClass.forNameVerbose(runtime, packageName.asJavaString() + name));</span>
        }
    };

<span class="fc" id="L327">    private static final Map&lt;String, Boolean&gt; JAVA_PRIMITIVES = new HashMap&lt;String, Boolean&gt;();</span>
    static {
<span class="fc" id="L329">        String[] primitives = {&quot;boolean&quot;, &quot;byte&quot;, &quot;char&quot;, &quot;short&quot;, &quot;int&quot;, &quot;long&quot;, &quot;float&quot;, &quot;double&quot;};</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">        for (String primitive : primitives) {</span>
<span class="fc" id="L331">            JAVA_PRIMITIVES.put(primitive, Boolean.TRUE);</span>
        }
    }

    public static IRubyObject create_proxy_class(
            IRubyObject recv,
            IRubyObject constant,
            IRubyObject javaClass,
            IRubyObject module) {
<span class="nc" id="L340">        Ruby runtime = recv.getRuntime();</span>

<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (!(module instanceof RubyModule)) {</span>
<span class="nc" id="L343">            throw runtime.newTypeError(module, runtime.getModule());</span>
        }
<span class="nc" id="L345">        IRubyObject proxyClass = get_proxy_class(recv, javaClass);</span>
<span class="nc" id="L346">        RubyModule m = (RubyModule)module;</span>
<span class="nc" id="L347">        String constName = constant.asJavaString();</span>
<span class="nc" id="L348">        IRubyObject existing = m.getConstantNoConstMissing(constName);</span>

<span class="nc bnc" id="L350" title="All 6 branches missed.">        if (existing != null</span>
                &amp;&amp; existing != RubyBasicObject.UNDEF
                &amp;&amp; existing != proxyClass) {
<span class="nc" id="L353">            runtime.getWarnings().warn(&quot;replacing &quot; + existing + &quot; with &quot; + proxyClass + &quot; in constant '&quot; + constName + &quot; on class/module &quot; + m);</span>
        }
        
<span class="nc" id="L356">        return ((RubyModule) module).setConstantQuiet(constant.asJavaString(), get_proxy_class(recv, javaClass));</span>
    }

    public static IRubyObject get_java_class(IRubyObject recv, IRubyObject name) {
        try {
<span class="nc" id="L361">            return JavaClass.for_name(recv, name);</span>
<span class="nc" id="L362">        } catch (Exception e) {</span>
<span class="nc" id="L363">            recv.getRuntime().getJavaSupport().handleNativeException(e, null);</span>
<span class="nc" id="L364">            return recv.getRuntime().getNil();</span>
        }
    }

    /**
     * Same as Java#getInstance(runtime, rawJavaObject, false).
     */
    public static IRubyObject getInstance(Ruby runtime, Object rawJavaObject) {
<span class="fc" id="L372">        return getInstance(runtime, rawJavaObject, false);</span>
    }
    
    /**
     * Returns a new proxy instance of a type corresponding to rawJavaObject's class,
     * or the cached proxy if we've already seen this object.  Note that primitives
     * and strings are &lt;em&gt;not&lt;/em&gt; coerced to corresponding Ruby types; use
     * JavaUtil.convertJavaToUsableRubyObject to get coerced types or proxies as
     * appropriate.
     * 
     * @param runtime the JRuby runtime
     * @param rawJavaObject the object to get a wrapper for
     * @param forceCache whether to force the use of the proxy cache
     * @return the new (or cached) proxy for the specified Java object
     * @see JavaUtil#convertJavaToUsableRubyObject
     */
    public static IRubyObject getInstance(Ruby runtime, Object rawJavaObject, boolean forceCache) {
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        if (rawJavaObject != null) {</span>
<span class="fc" id="L390">            RubyClass proxyClass = (RubyClass) getProxyClass(runtime, rawJavaObject.getClass());</span>

<span class="pc bpc" id="L392" title="3 of 6 branches missed.">            if (OBJECT_PROXY_CACHE || forceCache || proxyClass.getCacheProxy()) {</span>
<span class="nc" id="L393">                return runtime.getJavaSupport().getObjectProxyCache().getOrCreate(rawJavaObject, proxyClass);</span>
            } else {
<span class="fc" id="L395">                return allocateProxy(rawJavaObject, proxyClass);</span>
            }
        }
<span class="nc" id="L398">        return runtime.getNil();</span>
    }

    public static RubyModule getInterfaceModule(Ruby runtime, JavaClass javaClass) {
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">        if (!javaClass.javaClass().isInterface()) {</span>
<span class="nc" id="L403">            throw runtime.newArgumentError(javaClass.toString() + &quot; is not an interface&quot;);</span>
        }
        RubyModule interfaceModule;
<span class="fc bfc" id="L406" title="All 2 branches covered.">        if ((interfaceModule = javaClass.getProxyModule()) != null) {</span>
<span class="fc" id="L407">            return interfaceModule;</span>
        }
<span class="fc" id="L409">        javaClass.lockProxy();</span>
        try {
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">            if ((interfaceModule = javaClass.getProxyModule()) == null) {</span>
<span class="fc" id="L412">                interfaceModule = (RubyModule) runtime.getJavaSupport().getJavaInterfaceTemplate().dup();</span>
<span class="fc" id="L413">                interfaceModule.setInstanceVariable(&quot;@java_class&quot;, javaClass);</span>
<span class="fc" id="L414">                javaClass.setupInterfaceModule(interfaceModule);</span>
                // include any interfaces we extend
<span class="fc" id="L416">                Class&lt;?&gt;[] extended = javaClass.javaClass().getInterfaces();</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">                for (int i = extended.length; --i &gt;= 0;) {</span>
<span class="fc" id="L418">                    JavaClass extendedClass = JavaClass.get(runtime, extended[i]);</span>
<span class="fc" id="L419">                    RubyModule extModule = getInterfaceModule(runtime, extendedClass);</span>
<span class="fc" id="L420">                    interfaceModule.includeModule(extModule);</span>
<span class="fc" id="L421">                }</span>
<span class="fc" id="L422">                addToJavaPackageModule(interfaceModule, javaClass);</span>
            }
        } finally {
<span class="pc" id="L425">            javaClass.unlockProxy();</span>
<span class="fc" id="L426">        }</span>
<span class="fc" id="L427">        return interfaceModule;</span>
    }

    public static IRubyObject get_interface_module(Ruby runtime, IRubyObject javaClassObject) {
        JavaClass javaClass;
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">        if (javaClassObject instanceof RubyString) {</span>
<span class="nc" id="L433">            javaClass = JavaClass.forNameVerbose(runtime, javaClassObject.asJavaString());</span>
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">        } else if (javaClassObject instanceof JavaClass) {</span>
<span class="fc" id="L435">            javaClass = (JavaClass) javaClassObject;</span>
        } else {
<span class="nc" id="L437">            throw runtime.newArgumentError(&quot;expected JavaClass, got &quot; + javaClassObject);</span>
        }
<span class="fc" id="L439">        return getInterfaceModule(runtime, javaClass);</span>
    }

    public static RubyClass getProxyClassForObject(Ruby runtime, Object object) {
<span class="nc" id="L443">        return (RubyClass)getProxyClass(runtime, object.getClass());</span>
    }

    public static RubyModule getProxyClass(Ruby runtime, JavaClass javaClass) {
<span class="fc" id="L447">        return getProxyClass(runtime, javaClass.javaClass());</span>
    }

    public static RubyModule getProxyClass(Ruby runtime, Class c) {
<span class="fc" id="L451">        return runtime.getJavaSupport().getProxyClassFromCache(c);</span>
    }
    
    public static RubyModule createProxyClassForClass(Ruby runtime, final Class c) {
        RubyModule proxyClass;
<span class="fc" id="L456">        JavaClass javaClass = runtime.getJavaSupport().getJavaClassFromCache(c);</span>
        
<span class="fc bfc" id="L458" title="All 2 branches covered.">        if (c.isInterface()) {</span>
<span class="fc" id="L459">            return Java.getInterfaceModule(runtime, javaClass);</span>
        }
        
<span class="fc" id="L462">        javaClass.lockProxy();</span>
        try {
<span class="fc bfc" id="L464" title="All 2 branches covered.">            if ((proxyClass = javaClass.getProxyClass()) == null) {</span>

<span class="fc bfc" id="L466" title="All 2 branches covered.">                if (c.isArray()) {</span>
<span class="fc" id="L467">                    proxyClass = Java.createProxyClass(runtime,</span>
<span class="fc" id="L468">                            runtime.getJavaSupport().getArrayProxyClass(),</span>
                            javaClass, true);

                    // FIXME: Organizationally this might be nicer in a specialized class
<span class="fc bfc" id="L472" title="All 2 branches covered.">                    if (c.getComponentType() == byte.class) {</span>
<span class="fc" id="L473">                        final Encoding ascii8bit = runtime.getEncodingService().getAscii8bitEncoding();</span>
                        
                        // All bytes can be considered raw strings and forced to particular codings if not 8bitascii
<span class="fc" id="L476">                        proxyClass.addMethod(&quot;to_s&quot;, new JavaMethodZero(proxyClass, PUBLIC) {</span>
                            @Override
                            public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name) {
<span class="nc" id="L479">                                ByteList bytes = new ByteList((byte[]) ((ArrayJavaProxy) self).getObject(), ascii8bit);</span>
<span class="nc" id="L480">                                return RubyString.newStringLight(context.runtime, bytes);</span>
                            }
                        });
<span class="fc" id="L483">                    }   </span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">                } else if (c.isPrimitive()) {</span>
<span class="fc" id="L485">                    proxyClass = createProxyClass(runtime,</span>
<span class="fc" id="L486">                            runtime.getJavaSupport().getConcreteProxyClass(),</span>
                            javaClass, true);

<span class="fc bfc" id="L489" title="All 2 branches covered.">                } else if (c == Object.class) {</span>
                    // java.lang.Object is added at root of java proxy classes
<span class="fc" id="L491">                    proxyClass = createProxyClass(runtime,</span>
<span class="fc" id="L492">                            runtime.getJavaSupport().getConcreteProxyClass(),</span>
                            javaClass, true);
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">                    if (NEW_STYLE_EXTENSION) {</span>
<span class="nc" id="L495">                        proxyClass.getMetaClass().defineAnnotatedMethods(Java.NewStyleExtensionInherited.class);</span>
                    } else {
<span class="fc" id="L497">                        proxyClass.getMetaClass().defineAnnotatedMethods(Java.OldStyleExtensionInherited.class);</span>
                    }
<span class="fc" id="L499">                    addToJavaPackageModule(proxyClass, javaClass);</span>

                } else {
                    // other java proxy classes added under their superclass' java proxy
<span class="fc" id="L503">                    proxyClass = createProxyClass(runtime,</span>
<span class="fc" id="L504">                        (RubyClass) getProxyClass(runtime, c.getSuperclass()),</span>
                        javaClass, false);
                    // include interface modules into the proxy class
<span class="fc" id="L507">                    Class&lt;?&gt;[] interfaces = c.getInterfaces();</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">                    for (int i = interfaces.length; --i &gt;= 0;) {</span>
<span class="fc" id="L509">                        JavaClass ifc = JavaClass.get(runtime, interfaces[i]);</span>
                        // java.util.Map type object has its own proxy, but following
                        // is needed. Unless kind_of?(is_a?) test will fail.
                        //if (interfaces[i] != java.util.Map.class) {
<span class="fc" id="L513">                            proxyClass.includeModule(getInterfaceModule(runtime, ifc));</span>
                        //}
<span class="fc" id="L515">                    }</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">                    if (Modifier.isPublic(c.getModifiers())) {</span>
<span class="fc" id="L517">                        addToJavaPackageModule(proxyClass, javaClass);</span>
                    }
                }

                // JRUBY-1000, fail early when attempting to subclass a final Java class;
                // solved here by adding an exception-throwing &quot;inherited&quot;
<span class="fc bfc" id="L523" title="All 2 branches covered.">                if (Modifier.isFinal(c.getModifiers())) {</span>
<span class="fc" id="L524">                    proxyClass.getMetaClass().addMethod(&quot;inherited&quot;, new org.jruby.internal.runtime.methods.JavaMethod(proxyClass, PUBLIC) {</span>
                        @Override
                        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="nc" id="L527">                            throw context.runtime.newTypeError(&quot;can not extend final Java class: &quot; + c.getCanonicalName());</span>
                        }
                    });
                }
            }
        } finally {
<span class="pc" id="L533">            javaClass.unlockProxy();</span>
<span class="fc" id="L534">        }</span>
        
<span class="fc" id="L536">        return proxyClass;</span>
    }

    public static IRubyObject get_proxy_class(IRubyObject recv, IRubyObject java_class_object) {
<span class="fc" id="L540">        Ruby runtime = recv.getRuntime();</span>
        JavaClass javaClass;
<span class="fc bfc" id="L542" title="All 2 branches covered.">        if (java_class_object instanceof RubyString) {</span>
<span class="fc" id="L543">            javaClass = JavaClass.for_name(recv, java_class_object);</span>
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">        } else if (java_class_object instanceof JavaClass) {</span>
<span class="fc" id="L545">            javaClass = (JavaClass) java_class_object;</span>
        } else {
<span class="nc" id="L547">            throw runtime.newTypeError(java_class_object, runtime.getJavaSupport().getJavaClassClass());</span>
        }
<span class="fc" id="L549">        return getProxyClass(runtime, javaClass);</span>
    }

    private static RubyClass createProxyClass(Ruby runtime, RubyClass baseType,
            JavaClass javaClass, boolean invokeInherited) {
        // JRUBY-2938 the proxy class might already exist
<span class="fc" id="L555">        RubyClass proxyClass = javaClass.getProxyClass();</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">        if (proxyClass != null) return proxyClass;</span>

        // this needs to be split, since conditional calling #inherited doesn't fit standard ruby semantics
<span class="fc" id="L559">        RubyClass.checkInheritable(baseType);</span>
<span class="fc" id="L560">        RubyClass superClass = (RubyClass) baseType;</span>
<span class="fc" id="L561">        proxyClass = RubyClass.newClass(runtime, superClass);</span>
<span class="fc" id="L562">        proxyClass.makeMetaClass(superClass.getMetaClass());</span>

<span class="fc bfc" id="L564" title="All 2 branches covered.">        if (Map.class.isAssignableFrom(javaClass.javaClass())) {</span>
<span class="fc" id="L565">            proxyClass.setAllocator(runtime.getJavaSupport().getMapJavaProxyClass().getAllocator());</span>
<span class="fc" id="L566">            proxyClass.defineAnnotatedMethods(MapJavaProxy.class);</span>
<span class="fc" id="L567">            proxyClass.includeModule(runtime.getEnumerable());</span>
        } else {
<span class="fc" id="L569">            proxyClass.setAllocator(superClass.getAllocator());</span>
        }
<span class="fc bfc" id="L571" title="All 2 branches covered.">        if (invokeInherited) {</span>
<span class="fc" id="L572">            proxyClass.inherit(superClass);</span>
        }
<span class="fc" id="L574">        proxyClass.callMethod(runtime.getCurrentContext(), &quot;java_class=&quot;, javaClass);</span>
<span class="fc" id="L575">        javaClass.setupProxy(proxyClass);</span>

        // add java_method for unbound use
<span class="fc" id="L578">        proxyClass.defineAnnotatedMethods(JavaProxyClassMethods.class);</span>
<span class="fc" id="L579">        return proxyClass;</span>
    }

<span class="pc" id="L582">    public static class JavaProxyClassMethods {</span>
        @JRubyMethod(meta = true)
        public static IRubyObject java_method(ThreadContext context, IRubyObject proxyClass, IRubyObject rubyName) {
<span class="nc" id="L585">            String name = rubyName.asJavaString();</span>

<span class="nc" id="L587">            return getRubyMethod(context, proxyClass, name);</span>
        }

        @JRubyMethod(meta = true)
        public static IRubyObject java_method(ThreadContext context, IRubyObject proxyClass, IRubyObject rubyName, IRubyObject argTypes) {
<span class="nc" id="L592">            String name = rubyName.asJavaString();</span>
<span class="nc" id="L593">            RubyArray argTypesAry = argTypes.convertToArray();</span>
<span class="nc" id="L594">            Class[] argTypesClasses = (Class[])argTypesAry.toArray(new Class[argTypesAry.size()]);</span>

<span class="nc" id="L596">            return getRubyMethod(context, proxyClass, name, argTypesClasses);</span>
        }

        @JRubyMethod(meta = true)
        public static IRubyObject java_send(ThreadContext context, IRubyObject recv, IRubyObject rubyName) {
<span class="nc" id="L601">            String name = rubyName.asJavaString();</span>
<span class="nc" id="L602">            Ruby runtime = context.runtime;</span>

<span class="nc" id="L604">            JavaMethod method = new JavaMethod(runtime, getMethodFromClass(runtime, recv, name));</span>
<span class="nc" id="L605">            return method.invokeStaticDirect(context);</span>
        }

        @JRubyMethod(meta = true)
        public static IRubyObject java_send(ThreadContext context, IRubyObject recv, IRubyObject rubyName, IRubyObject argTypes) {
<span class="nc" id="L610">            String name = rubyName.asJavaString();</span>
<span class="nc" id="L611">            RubyArray argTypesAry = argTypes.convertToArray();</span>
<span class="nc" id="L612">            Ruby runtime = context.runtime;</span>

<span class="nc bnc" id="L614" title="All 2 branches missed.">            if (argTypesAry.size() != 0) {</span>
<span class="nc" id="L615">                Class[] argTypesClasses = (Class[]) argTypesAry.toArray(new Class[argTypesAry.size()]);</span>
<span class="nc" id="L616">                throw JavaMethod.newArgSizeMismatchError(runtime, argTypesClasses);</span>
            }

<span class="nc" id="L619">            JavaMethod method = new JavaMethod(runtime, getMethodFromClass(runtime, recv, name));</span>
<span class="nc" id="L620">            return method.invokeStaticDirect(context);</span>
        }

        @JRubyMethod(meta = true)
        public static IRubyObject java_send(ThreadContext context, IRubyObject recv, IRubyObject rubyName, IRubyObject argTypes, IRubyObject arg0) {
<span class="nc" id="L625">            String name = rubyName.asJavaString();</span>
<span class="nc" id="L626">            RubyArray argTypesAry = argTypes.convertToArray();</span>
<span class="nc" id="L627">            Ruby runtime = context.runtime;</span>

<span class="nc bnc" id="L629" title="All 2 branches missed.">            if (argTypesAry.size() != 1) {</span>
<span class="nc" id="L630">                throw JavaMethod.newArgSizeMismatchError(runtime, (Class) argTypesAry.eltInternal(0).toJava(Class.class));</span>
            }

<span class="nc" id="L633">            Class argTypeClass = (Class) argTypesAry.eltInternal(0).toJava(Class.class);</span>

<span class="nc" id="L635">            JavaMethod method = new JavaMethod(runtime, getMethodFromClass(runtime, recv, name, argTypeClass));</span>
<span class="nc" id="L636">            return method.invokeStaticDirect(context, arg0.toJava(argTypeClass));</span>
        }

        @JRubyMethod(required = 1, rest = true, meta = true)
        public static IRubyObject java_send(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="nc" id="L641">            Ruby runtime = context.runtime;</span>

<span class="nc" id="L643">            String name = args[0].asJavaString();</span>
<span class="nc" id="L644">            RubyArray argTypesAry = args[1].convertToArray();</span>
<span class="nc" id="L645">            int argsLen = args.length - 2;</span>

<span class="nc bnc" id="L647" title="All 2 branches missed.">            if (argTypesAry.size() != argsLen) {</span>
<span class="nc" id="L648">                throw JavaMethod.newArgSizeMismatchError(runtime, (Class[]) argTypesAry.toArray(new Class[argTypesAry.size()]));</span>
            }

<span class="nc" id="L651">            Class[] argTypesClasses = (Class[]) argTypesAry.toArray(new Class[argsLen]);</span>

<span class="nc" id="L653">            Object[] argsAry = new Object[argsLen];</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">            for (int i = 0; i &lt; argsLen; i++) {</span>
<span class="nc" id="L655">                argsAry[i] = args[i + 2].toJava(argTypesClasses[i]);</span>
            }

<span class="nc" id="L658">            JavaMethod method = new JavaMethod(runtime, getMethodFromClass(runtime, recv, name, argTypesClasses));</span>
<span class="nc" id="L659">            return method.invokeStaticDirect(context, argsAry);</span>
        }

        @JRubyMethod(meta = true, visibility = PRIVATE)
        public static IRubyObject java_alias(ThreadContext context, IRubyObject proxyClass, IRubyObject newName, IRubyObject rubyName) {
<span class="nc" id="L664">            return java_alias(context, proxyClass, newName, rubyName, context.runtime.newEmptyArray());</span>
        }

        @JRubyMethod(meta = true, visibility = PRIVATE)
        public static IRubyObject java_alias(ThreadContext context, IRubyObject proxyClass, IRubyObject newName, IRubyObject rubyName, IRubyObject argTypes) {
<span class="fc" id="L669">            String name = rubyName.asJavaString();</span>
<span class="fc" id="L670">            String newNameStr = newName.asJavaString();</span>
<span class="fc" id="L671">            RubyArray argTypesAry = argTypes.convertToArray();</span>
<span class="fc" id="L672">            Class[] argTypesClasses = (Class[])argTypesAry.toArray(new Class[argTypesAry.size()]);</span>
<span class="fc" id="L673">            Ruby runtime = context.runtime;</span>
            RubyClass rubyClass;

<span class="pc bpc" id="L676" title="1 of 2 branches missed.">            if (proxyClass instanceof RubyClass) {</span>
<span class="fc" id="L677">                rubyClass = (RubyClass)proxyClass;</span>
            } else {
<span class="nc" id="L679">                throw runtime.newTypeError(proxyClass, runtime.getModule());</span>
            }

<span class="fc" id="L682">            Method method = getMethodFromClass(runtime, proxyClass, name, argTypesClasses);</span>
<span class="fc" id="L683">            MethodInvoker invoker = getMethodInvokerForMethod(rubyClass, method);</span>

<span class="pc bpc" id="L685" title="1 of 2 branches missed.">            if (Modifier.isStatic(method.getModifiers())) {</span>
                // add alias to meta
<span class="fc" id="L687">                rubyClass.getSingletonClass().addMethod(newNameStr, invoker);</span>
            } else {
<span class="nc" id="L689">                rubyClass.addMethod(newNameStr, invoker);</span>
            }

<span class="fc" id="L692">            return runtime.getNil();</span>
        }
    }

    private static IRubyObject getRubyMethod(ThreadContext context, IRubyObject proxyClass, String name, Class... argTypesClasses) {
<span class="nc" id="L697">        Ruby runtime = context.runtime;</span>
        RubyClass rubyClass;
        
<span class="nc bnc" id="L700" title="All 2 branches missed.">        if (proxyClass instanceof RubyClass) {</span>
<span class="nc" id="L701">            rubyClass = (RubyClass)proxyClass;</span>
        } else {
<span class="nc" id="L703">            throw runtime.newTypeError(proxyClass, runtime.getModule());</span>
        }

<span class="nc" id="L706">        Method jmethod = getMethodFromClass(runtime, proxyClass, name, argTypesClasses);</span>
<span class="nc" id="L707">        String prettyName = name + CodegenUtils.prettyParams(argTypesClasses);</span>
        
<span class="nc bnc" id="L709" title="All 2 branches missed.">        if (Modifier.isStatic(jmethod.getModifiers())) {</span>
<span class="nc" id="L710">            MethodInvoker invoker = new StaticMethodInvoker(rubyClass, jmethod);</span>
<span class="nc" id="L711">            return RubyMethod.newMethod(rubyClass, prettyName, rubyClass, name, invoker, proxyClass);</span>
        } else {
<span class="nc" id="L713">            MethodInvoker invoker = new InstanceMethodInvoker(rubyClass, jmethod);</span>
<span class="nc" id="L714">            return RubyUnboundMethod.newUnboundMethod(rubyClass, prettyName, rubyClass, name, invoker);</span>
        }
    }

    public static Method getMethodFromClass(Ruby runtime, IRubyObject proxyClass, String name, Class... argTypes) {
<span class="fc" id="L719">        Class jclass = (Class)((JavaClass)proxyClass.callMethod(runtime.getCurrentContext(), &quot;java_class&quot;)).getValue();</span>

        try {
<span class="fc" id="L722">            return jclass.getMethod(name, argTypes);</span>
<span class="nc" id="L723">        } catch (NoSuchMethodException nsme) {</span>
<span class="nc" id="L724">            String prettyName = name + CodegenUtils.prettyParams(argTypes);</span>
<span class="nc" id="L725">            String errorName = jclass.getName() + &quot;.&quot; + prettyName;</span>
<span class="nc" id="L726">            throw runtime.newNameError(&quot;Java method not found: &quot; + errorName, name);</span>
        }
    }

    private static MethodInvoker getMethodInvokerForMethod(RubyClass metaClass, Method method) {
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">        if (Modifier.isStatic(method.getModifiers())) {</span>
<span class="fc" id="L732">            return new StaticMethodInvoker(metaClass.getMetaClass(), method);</span>
        } else {
<span class="nc" id="L734">            return new InstanceMethodInvoker(metaClass, method);</span>
        }
    }

    public static IRubyObject concrete_proxy_inherited(IRubyObject recv, IRubyObject subclass) {
<span class="nc" id="L739">        Ruby runtime = recv.getRuntime();</span>
<span class="nc" id="L740">        ThreadContext tc = runtime.getCurrentContext();</span>
<span class="nc" id="L741">        JavaSupport javaSupport = runtime.getJavaSupport();</span>
<span class="nc" id="L742">        RubyClass javaProxyClass = javaSupport.getJavaProxyClass().getMetaClass();</span>
<span class="nc" id="L743">        Helpers.invokeAs(tc, javaProxyClass, recv, &quot;inherited&quot;, subclass,</span>
                Block.NULL_BLOCK);
<span class="nc" id="L745">        return setupJavaSubclass(tc, subclass, recv.callMethod(tc, &quot;java_class&quot;));</span>
    }

    private static IRubyObject setupJavaSubclass(ThreadContext context, IRubyObject subclass, IRubyObject java_class) {
<span class="nc" id="L749">        final Ruby runtime = context.runtime;</span>

<span class="nc bnc" id="L751" title="All 2 branches missed.">        if (!(subclass instanceof RubyClass)) {</span>
<span class="nc" id="L752">            throw runtime.newTypeError(subclass, runtime.getClassClass());</span>
        }
<span class="nc" id="L754">        RubyClass rubySubclass = (RubyClass)subclass;</span>
<span class="nc" id="L755">        rubySubclass.getInstanceVariables().setInstanceVariable(&quot;@java_proxy_class&quot;, runtime.getNil());</span>

        // Subclasses of Java classes can safely use ivars, so we set this to silence warnings
<span class="nc" id="L758">        rubySubclass.setCacheProxy(true);</span>

<span class="nc" id="L760">        RubyClass subclassSingleton = rubySubclass.getSingletonClass();</span>
<span class="nc" id="L761">        subclassSingleton.addReadWriteAttribute(context, &quot;java_proxy_class&quot;);</span>
<span class="nc" id="L762">        subclassSingleton.addMethod(&quot;java_interfaces&quot;, new JavaMethodZero(subclassSingleton, PUBLIC) {</span>
            @Override
            public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name) {
<span class="nc" id="L765">                IRubyObject javaInterfaces = self.getInstanceVariables().getInstanceVariable(&quot;@java_interfaces&quot;);</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">                if (javaInterfaces != null) return javaInterfaces.dup();</span>
<span class="nc" id="L767">                return context.runtime.getNil();</span>
            }
        });

<span class="nc" id="L771">        rubySubclass.addMethod(&quot;__jcreate!&quot;, new JavaMethodN(subclassSingleton, PUBLIC) {</span>
<span class="nc" id="L772">            private final Map&lt;Integer, ParameterTypes&gt; methodCache = new HashMap&lt;Integer, ParameterTypes&gt;();</span>
            @Override
            public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args) {
<span class="nc" id="L775">                IRubyObject proxyClass = self.getMetaClass().getInstanceVariables().getInstanceVariable(&quot;@java_proxy_class&quot;);</span>
<span class="nc bnc" id="L776" title="All 4 branches missed.">                if (proxyClass == null || proxyClass.isNil()) {</span>
<span class="nc" id="L777">                    proxyClass = JavaProxyClass.get_with_class(self, self.getMetaClass());</span>
<span class="nc" id="L778">                    self.getMetaClass().getInstanceVariables().setInstanceVariable(&quot;@java_proxy_class&quot;, proxyClass);</span>
                }
                
<span class="nc" id="L781">                JavaProxyClass realProxyClass = (JavaProxyClass)proxyClass;</span>
<span class="nc" id="L782">                RubyArray constructors = realProxyClass.constructors();</span>
<span class="nc" id="L783">                ArrayList&lt;JavaProxyConstructor&gt; forArity = new ArrayList&lt;JavaProxyConstructor&gt;();</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">                for (int i = 0; i &lt; constructors.size(); i++) {</span>
<span class="nc" id="L785">                    JavaProxyConstructor constructor = (JavaProxyConstructor)constructors.eltInternal(i);</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">                    if (constructor.getParameterTypes().length == args.length) {</span>
<span class="nc" id="L787">                        forArity.add(constructor);</span>
                    }
                }
                
<span class="nc bnc" id="L791" title="All 2 branches missed.">                if (forArity.size() == 0) {</span>
<span class="nc" id="L792">                    throw runtime.newArgumentError(&quot;wrong number of arguments for constructor&quot;);</span>
                }

<span class="nc" id="L795">                JavaProxyConstructor matching = (JavaProxyConstructor)CallableSelector.matchingCallableArityN(</span>
                        runtime, methodCache,
<span class="nc" id="L797">                        forArity.toArray(new JavaProxyConstructor[forArity.size()]), args, args.length);</span>

<span class="nc bnc" id="L799" title="All 2 branches missed.">                if (matching == null) {</span>
<span class="nc" id="L800">                    throw runtime.newArgumentError(&quot;wrong number of arguments for constructor&quot;);</span>
                }

<span class="nc" id="L803">                Object[] newArgs = new Object[args.length];</span>
<span class="nc" id="L804">                Class[] parameterTypes = matching.getParameterTypes();</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">                for (int i = 0; i &lt; args.length; i++) {</span>
<span class="nc" id="L806">                    newArgs[i] = args[i].toJava(parameterTypes[i]);</span>
                }
                
<span class="nc" id="L809">                JavaObject newObject = matching.newInstance(self, newArgs);</span>
<span class="nc" id="L810">                return JavaUtilities.set_java_object(self, self, newObject);</span>
            }
        });

<span class="nc" id="L814">        return runtime.getNil();</span>
    }

    // package scheme 2: separate module for each full package name, constructed 
    // from the camel-cased package segments: Java::JavaLang::Object, 
    private static void addToJavaPackageModule(RubyModule proxyClass, JavaClass javaClass) {
<span class="fc" id="L820">        Ruby runtime = proxyClass.getRuntime();</span>
<span class="fc" id="L821">        Class&lt;?&gt; clazz = javaClass.javaClass();</span>
        String fullName;
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">        if ((fullName = clazz.getName()) == null) {</span>
<span class="nc" id="L824">            return;</span>
        }
<span class="fc" id="L826">        int endPackage = fullName.lastIndexOf('.');</span>
        RubyModule parentModule;
        String className;

        // inner classes must be nested
<span class="fc bfc" id="L831" title="All 2 branches covered.">        if (fullName.indexOf('$') != -1) {</span>
<span class="fc" id="L832">            IRubyObject declClass = javaClass.declaring_class();</span>
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">            if (declClass.isNil()) {</span>
                // no containing class for a $ class; treat it as internal and don't define a constant
<span class="nc" id="L835">                return;</span>
            }
<span class="fc" id="L837">            parentModule = getProxyClass(runtime, (JavaClass)declClass);</span>
<span class="fc" id="L838">            className = clazz.getSimpleName();</span>
<span class="fc" id="L839">        } else {</span>
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">            String packageString = endPackage &lt; 0 ? &quot;&quot; : fullName.substring(0, endPackage);</span>
<span class="fc" id="L841">            parentModule = getJavaPackageModule(runtime, packageString);</span>
<span class="pc bpc" id="L842" title="1 of 2 branches missed.">            className = parentModule == null ? fullName : fullName.substring(endPackage + 1);</span>
        }
        
<span class="pc bpc" id="L845" title="2 of 4 branches missed.">        if (parentModule != null &amp;&amp; IdUtil.isConstant(className)) {</span>
<span class="pc bpc" id="L846" title="1 of 2 branches missed.">            if (parentModule.getConstantAt(className) == null) {</span>
<span class="fc" id="L847">                parentModule.setConstant(className, proxyClass);</span>
            }
        }
<span class="fc" id="L850">    }</span>

    public static RubyModule getJavaPackageModule(Ruby runtime, Package pkg) {
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">        return pkg == null ?</span>
<span class="pc" id="L854">                getJavaPackageModule(runtime, &quot;&quot;) :</span>
<span class="fc" id="L855">                getJavaPackageModule(runtime, pkg.getName());</span>
    }

    private static RubyModule getJavaPackageModule(Ruby runtime, String packageString) {
        String packageName;
<span class="fc" id="L860">        int length = packageString.length();</span>
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">        if (length == 0) {</span>
<span class="nc" id="L862">            packageName = &quot;Default&quot;;</span>
        } else {
<span class="fc" id="L864">            StringBuilder buf = new StringBuilder();</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">            for (int start = 0, offset = 0; start &lt; length; start = offset + 1) {</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">                if ((offset = packageString.indexOf('.', start)) == -1) {</span>
<span class="fc" id="L867">                    offset = length;</span>
                }
<span class="fc" id="L869">                buf.append(Character.toUpperCase(packageString.charAt(start))).append(packageString.substring(start + 1, offset));</span>
            }
<span class="fc" id="L871">            packageName = buf.toString();</span>
        }

<span class="fc" id="L874">        RubyModule javaModule = runtime.getJavaSupport().getJavaModule();</span>
<span class="fc" id="L875">        IRubyObject packageModule = javaModule.getConstantAt(packageName);</span>
<span class="fc bfc" id="L876" title="All 2 branches covered.">        if (packageModule == null) {</span>
<span class="fc" id="L877">            return createPackageModule(javaModule, packageName, packageString);</span>
<span class="pc bpc" id="L878" title="1 of 2 branches missed.">        } else if (packageModule instanceof RubyModule) {</span>
<span class="fc" id="L879">            return (RubyModule) packageModule;</span>
        } else {
<span class="nc" id="L881">            return null;</span>
        }
    }

    private static RubyModule createPackageModule(RubyModule parent, String name, String packageString) {
<span class="fc" id="L886">        Ruby runtime = parent.getRuntime();</span>
<span class="fc" id="L887">        RubyModule packageModule = (RubyModule) runtime.getJavaSupport().getPackageModuleTemplate().dup();</span>
<span class="fc" id="L888">        packageModule.setInstanceVariable(&quot;@package_name&quot;, runtime.newString(</span>
<span class="fc bfc" id="L889" title="All 2 branches covered.">                packageString.length() &gt; 0 ? packageString + '.' : packageString));</span>

        // this is where we'll get connected when classes are opened using
        // package module syntax.
<span class="fc" id="L893">        packageModule.addClassProvider(JAVA_PACKAGE_CLASS_PROVIDER);</span>

<span class="fc" id="L895">        parent.const_set(runtime.newSymbol(name), packageModule);</span>
<span class="fc" id="L896">        MetaClass metaClass = (MetaClass) packageModule.getMetaClass();</span>
<span class="fc" id="L897">        metaClass.setAttached(packageModule);</span>
<span class="fc" id="L898">        return packageModule;</span>
    }
<span class="fc" id="L900">    private static final Pattern CAMEL_CASE_PACKAGE_SPLITTER = Pattern.compile(&quot;([a-z][0-9]*)([A-Z])&quot;);</span>

    private static RubyModule getPackageModule(Ruby runtime, String name) {
<span class="fc" id="L903">        RubyModule javaModule = runtime.getJavaSupport().getJavaModule();</span>
        IRubyObject value;
<span class="pc bpc" id="L905" title="1 of 2 branches missed.">        if ((value = javaModule.getConstantAt(name)) instanceof RubyModule) {</span>
<span class="nc" id="L906">            return (RubyModule) value;</span>
        }
        String packageName;
<span class="pc bpc" id="L909" title="1 of 2 branches missed.">        if (&quot;Default&quot;.equals(name)) {</span>
<span class="fc" id="L910">            packageName = &quot;&quot;;</span>
        } else {
<span class="nc" id="L912">            Matcher m = CAMEL_CASE_PACKAGE_SPLITTER.matcher(name);</span>
<span class="nc" id="L913">            packageName = m.replaceAll(&quot;$1.$2&quot;).toLowerCase();</span>
        }
<span class="fc" id="L915">        return createPackageModule(javaModule, name, packageName);</span>
    }

    public static IRubyObject get_package_module(IRubyObject recv, IRubyObject symObject) {
<span class="fc" id="L919">        return getPackageModule(recv.getRuntime(), symObject.asJavaString());</span>
    }

    public static IRubyObject get_package_module_dot_format(IRubyObject recv, IRubyObject dottedName) {
<span class="fc" id="L923">        Ruby runtime = recv.getRuntime();</span>
<span class="fc" id="L924">        RubyModule module = getJavaPackageModule(runtime, dottedName.asJavaString());</span>
<span class="pc bpc" id="L925" title="1 of 2 branches missed.">        return module == null ? runtime.getNil() : module;</span>
    }

    private static RubyModule getProxyOrPackageUnderPackage(ThreadContext context, final Ruby runtime,
            RubyModule parentPackage, String sym) {
<span class="fc" id="L930">        IRubyObject packageNameObj = parentPackage.getInstanceVariable(&quot;@package_name&quot;);</span>
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">        if (packageNameObj == null) {</span>
<span class="nc" id="L932">            throw runtime.newArgumentError(&quot;invalid package module&quot;);</span>
        }
<span class="fc" id="L934">        String packageName = packageNameObj.asJavaString();</span>
<span class="fc" id="L935">        final String name = sym.trim().intern();</span>
<span class="pc bpc" id="L936" title="1 of 2 branches missed.">        if (name.length() == 0) {</span>
<span class="nc" id="L937">            throw runtime.newArgumentError(&quot;empty class or package name&quot;);</span>
        }
<span class="fc" id="L939">        String fullName = packageName + name;</span>
<span class="fc bfc" id="L940" title="All 2 branches covered.">        if (!Character.isUpperCase(name.charAt(0))) {</span>
            // filter out any Java primitive names
            // TODO: should check against all Java reserved names here, not just primitives
<span class="pc bpc" id="L943" title="1 of 2 branches missed.">            if (JAVA_PRIMITIVES.containsKey(name)) {</span>
<span class="nc" id="L944">                throw runtime.newArgumentError(&quot;illegal package name component: &quot; + name);</span>
            }
            
            // this covers the rare case of lower-case class names (and thus will
            // fail 99.999% of the time). fortunately, we'll only do this once per
            // package name. (and seriously, folks, look into best practices...)
<span class="fc" id="L950">            IRubyObject previousErrorInfo = Helpers.getErrorInfo(runtime);</span>
            try {
<span class="nc" id="L952">                return getProxyClass(runtime, runtime.getJavaSupport().loadJavaClassQuiet(fullName));</span>
<span class="fc" id="L953">            } catch (RaiseException re) { /* expected */</span>
<span class="fc" id="L954">                RubyException rubyEx = re.getException();</span>
<span class="pc bpc" id="L955" title="1 of 2 branches missed.">                if (rubyEx.kind_of_p(context, runtime.getStandardError()).isTrue()) {</span>
<span class="fc" id="L956">                    Helpers.setErrorInfo(runtime, previousErrorInfo);</span>
                }
<span class="pc" id="L958">            } catch (Exception e) { /* expected */ }</span>

            // Haven't found a class, continue on as though it were a package
<span class="fc" id="L961">            final RubyModule packageModule = getJavaPackageModule(runtime, fullName);</span>
            // TODO: decompose getJavaPackageModule so we don't parse fullName
<span class="pc bpc" id="L963" title="1 of 2 branches missed.">            if (packageModule == null) {</span>
<span class="nc" id="L964">                return null;</span>
            }

            // save package in singletonized parent, so we don't come back here
<span class="fc" id="L968">            memoizePackageOrClass(parentPackage, name, packageModule);</span>
            
<span class="fc" id="L970">            return packageModule;</span>
        } else {
            try {
                // First char is upper case, so assume it's a class name
<span class="fc" id="L974">                final RubyModule javaModule = getProxyClass(runtime, JavaClass.forNameVerbose(runtime, fullName));</span>
                
                // save class in singletonized parent, so we don't come back here
<span class="fc" id="L977">                memoizePackageOrClass(parentPackage, name, javaModule);</span>

<span class="fc" id="L979">                return javaModule;</span>
<span class="nc" id="L980">            } catch (Exception e) {</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">                if (runtime.getInstanceConfig().getAllowUppercasePackageNames()) {</span>
                    // but for those not hip to conventions and best practices,
                    // we'll try as a package
<span class="nc" id="L984">                    return getJavaPackageModule(runtime, fullName);</span>
                } else {
<span class="nc" id="L986">                    throw runtime.newNameError(&quot;missing class or uppercase package name (`&quot; + fullName + &quot;'), caused by &quot; + e.getMessage(), fullName);</span>
                }
            }

        }
    }

    public static IRubyObject get_proxy_or_package_under_package(
            ThreadContext context,
            IRubyObject recv,
            IRubyObject parentPackage,
            IRubyObject sym) {
<span class="fc" id="L998">        Ruby runtime = recv.getRuntime();</span>
<span class="pc bpc" id="L999" title="1 of 2 branches missed.">        if (!(parentPackage instanceof RubyModule)) {</span>
<span class="nc" id="L1000">            throw runtime.newTypeError(parentPackage, runtime.getModule());</span>
        }
        RubyModule result;
<span class="pc bpc" id="L1003" title="1 of 2 branches missed.">        if ((result = getProxyOrPackageUnderPackage(context, runtime,</span>
<span class="fc" id="L1004">                (RubyModule) parentPackage, sym.asJavaString())) != null) {</span>
<span class="fc" id="L1005">            return result;</span>
        }
<span class="nc" id="L1007">        return runtime.getNil();</span>
    }

    private static RubyModule getTopLevelProxyOrPackage(ThreadContext context, final Ruby runtime, String sym) {
<span class="fc" id="L1011">        final String name = sym.trim().intern();</span>
<span class="pc bpc" id="L1012" title="1 of 2 branches missed.">        if (name.length() == 0) {</span>
<span class="nc" id="L1013">            throw runtime.newArgumentError(&quot;empty class or package name&quot;);</span>
        }
<span class="pc bpc" id="L1015" title="1 of 2 branches missed.">        if (Character.isLowerCase(name.charAt(0))) {</span>
            // this covers primitives and (unlikely) lower-case class names
            try {
<span class="fc" id="L1018">                return getProxyClass(runtime, runtime.getJavaSupport().loadJavaClassQuiet(name));</span>
<span class="nc" id="L1019">            } catch (RaiseException re) { /* not primitive or lc class */</span>
<span class="nc" id="L1020">                RubyException rubyEx = re.getException();</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">                if (rubyEx.kind_of_p(context, runtime.getStandardError()).isTrue()) {</span>
<span class="nc" id="L1022">                    Helpers.setErrorInfo(runtime, runtime.getNil());</span>
                }
<span class="nc" id="L1024">            } catch (Exception e) { /* not primitive or lc class */ }</span>

            // TODO: check for Java reserved names and raise exception if encountered

<span class="nc" id="L1028">            final RubyModule packageModule = getJavaPackageModule(runtime, name);</span>
            // TODO: decompose getJavaPackageModule so we don't parse fullName
<span class="nc bnc" id="L1030" title="All 2 branches missed.">            if (packageModule == null) {</span>
<span class="nc" id="L1031">                return null;</span>
            }
<span class="nc" id="L1033">            RubyModule javaModule = runtime.getJavaSupport().getJavaModule();</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">            if (javaModule.getMetaClass().isMethodBound(name, false)) {</span>
<span class="nc" id="L1035">                return packageModule;</span>
            }

<span class="nc" id="L1038">            memoizePackageOrClass(javaModule, name, packageModule);</span>
            
<span class="nc" id="L1040">            return packageModule;</span>
        } else {
<span class="nc" id="L1042">            RubyModule javaModule = null;</span>
            try {
                // we do loadJavaClass here to handle things like LinkageError through
<span class="nc" id="L1045">                Class cls = runtime.getJavaSupport().loadJavaClass(name);</span>
<span class="nc" id="L1046">                javaModule = getProxyClass(runtime, JavaClass.get(runtime, cls));</span>
<span class="nc" id="L1047">            } catch (ExceptionInInitializerError eiie) {</span>
<span class="nc" id="L1048">                throw runtime.newNameError(&quot;cannot initialize Java class &quot; + name, name, eiie, false);</span>
<span class="nc" id="L1049">            } catch (LinkageError le) {</span>
<span class="nc" id="L1050">                throw runtime.newNameError(&quot;cannot link Java class &quot; + name, name, le, false);</span>
<span class="nc" id="L1051">            } catch (SecurityException se) {</span>
<span class="nc" id="L1052">                throw runtime.newSecurityError(se.getLocalizedMessage());</span>
<span class="nc" id="L1053">            } catch (ClassNotFoundException e) { /* not a class */ }</span>

            // upper-case package name
            // TODO: top-level upper-case package was supported in the previous (Ruby-based)
            // implementation, so leaving as is.  see note at #getProxyOrPackageUnderPackage
            // re: future approach below the top-level.
<span class="nc bnc" id="L1059" title="All 2 branches missed.">            if (javaModule == null) {</span>
<span class="nc" id="L1060">                javaModule = getPackageModule(runtime, name);</span>
            }

<span class="nc" id="L1063">            memoizePackageOrClass(runtime.getJavaSupport().getJavaModule(), name, javaModule);</span>

<span class="nc" id="L1065">            return javaModule;</span>
        }
    }

    private static void memoizePackageOrClass(final RubyModule parentPackage, final String name, final IRubyObject value) {
<span class="fc" id="L1070">        RubyClass singleton = parentPackage.getSingletonClass();</span>
<span class="fc" id="L1071">        singleton.addMethod(name, new org.jruby.internal.runtime.methods.JavaMethod(singleton, PUBLIC) {</span>
            public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="nc bnc" id="L1073" title="All 2 branches missed.">                if (args.length != 0) {</span>
<span class="nc" id="L1074">                    throw context.runtime.newArgumentError(</span>
                            &quot;Java package `&quot;
<span class="nc" id="L1076">                                    + parentPackage.callMethod(&quot;package_name&quot;)</span>
                                    + &quot;' does not have a method `&quot;
                                    + name
                                    + &quot;'&quot;);
                }
<span class="nc" id="L1081">                return call(context, self, clazz, name);</span>
            }

            public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name) {
<span class="fc" id="L1085">                return value;</span>
            }

            @Override
            public Arity getArity() {
<span class="nc" id="L1090">                return Arity.noArguments();</span>
            }
        });
<span class="fc" id="L1093">    }</span>

    public static IRubyObject get_top_level_proxy_or_package(ThreadContext context, IRubyObject recv, IRubyObject sym) {
<span class="fc" id="L1096">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L1097">        RubyModule result = getTopLevelProxyOrPackage(context, runtime, sym.asJavaString());</span>

<span class="pc bpc" id="L1099" title="1 of 2 branches missed.">        return result != null ? result : runtime.getNil();</span>
    }

    public static IRubyObject wrap(Ruby runtime, IRubyObject java_object) {
<span class="nc" id="L1103">        return getInstance(runtime, ((JavaObject) java_object).getValue());</span>
    }
    
    /**
     * High-level object conversion utility function 'java_to_primitive' is the low-level version
     */
    @Deprecated
    @JRubyMethod(module = true, visibility = PRIVATE)
    public static IRubyObject java_to_ruby(IRubyObject recv, IRubyObject object, Block unusedBlock) {
        try {
<span class="nc" id="L1113">            return JavaUtil.java_to_ruby(recv.getRuntime(), object);</span>
<span class="nc" id="L1114">        } catch (RuntimeException e) {</span>
<span class="nc" id="L1115">            recv.getRuntime().getJavaSupport().handleNativeException(e, null);</span>
            // This point is only reached if there was an exception handler installed.
<span class="nc" id="L1117">            return recv.getRuntime().getNil();</span>
        }
    }

    // TODO: Formalize conversion mechanisms between Java and Ruby
    /**
     * High-level object conversion utility.
     */
    @Deprecated
    @JRubyMethod(module = true, visibility = PRIVATE)
    public static IRubyObject ruby_to_java(final IRubyObject recv, IRubyObject object, Block unusedBlock) {
<span class="nc" id="L1128">        return JavaUtil.ruby_to_java(recv, object, unusedBlock);</span>
    }

    @Deprecated
    @JRubyMethod(module = true, visibility = PRIVATE)
    public static IRubyObject java_to_primitive(IRubyObject recv, IRubyObject object, Block unusedBlock) {
<span class="nc" id="L1134">        return JavaUtil.java_to_primitive(recv, object, unusedBlock);</span>
    }

    // TODO: Formalize conversion mechanisms between Java and Ruby
    @JRubyMethod(required = 2, module = true, visibility = PRIVATE)
    public static IRubyObject new_proxy_instance2(IRubyObject recv, final IRubyObject wrapper, IRubyObject ifcs, Block block) {
<span class="nc" id="L1140">        IRubyObject[] javaClasses = ((RubyArray)ifcs).toJavaArray();</span>

        // Create list of interface names to proxy (and make sure they really are interfaces)
        // Also build a hashcode from all classes to use for retrieving previously-created impl
<span class="nc" id="L1144">        Class[] interfaces = new Class[javaClasses.length];</span>
<span class="nc bnc" id="L1145" title="All 2 branches missed.">        for (int i = 0; i &lt; javaClasses.length; i++) {</span>
<span class="nc bnc" id="L1146" title="All 4 branches missed.">            if (!(javaClasses[i] instanceof JavaClass) || !((JavaClass) javaClasses[i]).interface_p().isTrue()) {</span>
<span class="nc" id="L1147">                throw recv.getRuntime().newArgumentError(&quot;Java interface expected. got: &quot; + javaClasses[i]);</span>
            }
<span class="nc" id="L1149">            interfaces[i] = ((JavaClass) javaClasses[i]).javaClass();</span>
        }

<span class="nc" id="L1152">        return newInterfaceImpl(wrapper, interfaces);</span>
    }

    public static IRubyObject newInterfaceImpl(final IRubyObject wrapper, Class[] interfaces) {
<span class="nc" id="L1156">        final Ruby runtime = wrapper.getRuntime();</span>
        ClassDefiningClassLoader classLoader;

<span class="nc" id="L1159">        Class[] tmp_interfaces = interfaces;</span>
<span class="nc" id="L1160">        interfaces = new Class[tmp_interfaces.length + 1];</span>
<span class="nc" id="L1161">        System.arraycopy(tmp_interfaces, 0, interfaces, 0, tmp_interfaces.length);</span>
<span class="nc" id="L1162">        interfaces[tmp_interfaces.length] = RubyObjectHolderProxy.class;</span>

        // hashcode is a combination of the interfaces and the Ruby class we're using
        // to implement them
<span class="nc bnc" id="L1166" title="All 2 branches missed.">        if (!RubyInstanceConfig.INTERFACES_USE_PROXY) {</span>
<span class="nc" id="L1167">            int interfacesHashCode = interfacesHashCode(interfaces);</span>
            // if it's a singleton class and the real class is proc, we're doing closure conversion
            // so just use Proc's hashcode
<span class="nc bnc" id="L1170" title="All 4 branches missed.">            if (wrapper.getMetaClass().isSingleton() &amp;&amp; wrapper.getMetaClass().getRealClass() == runtime.getProc()) {</span>
<span class="nc" id="L1171">                interfacesHashCode = 31 * interfacesHashCode + runtime.getProc().hashCode();</span>
<span class="nc" id="L1172">                classLoader = runtime.getJRubyClassLoader();</span>
            } else {
                // normal new class implementing interfaces
<span class="nc" id="L1175">                interfacesHashCode = 31 * interfacesHashCode + wrapper.getMetaClass().getRealClass().hashCode();</span>
<span class="nc" id="L1176">                classLoader = new OneShotClassLoader(runtime.getJRubyClassLoader());</span>
            }
<span class="nc" id="L1178">            String implClassName = &quot;org.jruby.gen.InterfaceImpl&quot; + Math.abs(interfacesHashCode);</span>
            Class proxyImplClass;
            try {
<span class="nc" id="L1181">                proxyImplClass = Class.forName(implClassName, true, runtime.getJRubyClassLoader());</span>
<span class="nc" id="L1182">            } catch (ClassNotFoundException cnfe) {</span>
<span class="nc" id="L1183">                proxyImplClass = RealClassGenerator.createOldStyleImplClass(interfaces, wrapper.getMetaClass(), runtime, implClassName, classLoader);</span>
<span class="nc" id="L1184">            }</span>

            try {
<span class="nc" id="L1187">                Constructor proxyConstructor = proxyImplClass.getConstructor(IRubyObject.class);</span>
<span class="nc" id="L1188">                return JavaObject.wrap(runtime, proxyConstructor.newInstance(wrapper));</span>
<span class="nc" id="L1189">            } catch (NoSuchMethodException nsme) {</span>
<span class="nc" id="L1190">                throw runtime.newTypeError(&quot;Exception instantiating generated interface impl:\n&quot; + nsme);</span>
<span class="nc" id="L1191">            } catch (InvocationTargetException ite) {</span>
<span class="nc" id="L1192">                throw runtime.newTypeError(&quot;Exception instantiating generated interface impl:\n&quot; + ite);</span>
<span class="nc" id="L1193">            } catch (InstantiationException ie) {</span>
<span class="nc" id="L1194">                throw runtime.newTypeError(&quot;Exception instantiating generated interface impl:\n&quot; + ie);</span>
<span class="nc" id="L1195">            } catch (IllegalAccessException iae) {</span>
<span class="nc" id="L1196">                throw runtime.newTypeError(&quot;Exception instantiating generated interface impl:\n&quot; + iae);</span>
            }
        } else {
<span class="nc" id="L1199">            Object proxyObject = Proxy.newProxyInstance(runtime.getJRubyClassLoader(), interfaces, new InvocationHandler() {</span>
<span class="nc" id="L1200">                private Map parameterTypeCache = new ConcurrentHashMap();</span>

                public Object invoke(Object proxy, Method method, Object[] nargs) throws Throwable {
<span class="nc" id="L1203">                    String methodName = method.getName();</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">                    int length = nargs == null ? 0 : nargs.length;</span>

                    // FIXME: wtf is this? Why would these use the class?
<span class="nc bnc" id="L1207" title="All 4 branches missed.">                    if (methodName.equals(&quot;toString&quot;) &amp;&amp; length == 0) {</span>
<span class="nc" id="L1208">                        return proxy.getClass().getName();</span>
<span class="nc bnc" id="L1209" title="All 4 branches missed.">                    } else if (methodName.equals(&quot;hashCode&quot;) &amp;&amp; length == 0) {</span>
<span class="nc" id="L1210">                        return Integer.valueOf(proxy.getClass().hashCode());</span>
<span class="nc bnc" id="L1211" title="All 4 branches missed.">                    } else if (methodName.equals(&quot;equals&quot;) &amp;&amp; length == 1) {</span>
<span class="nc" id="L1212">                        Class[] parameterTypes = (Class[]) parameterTypeCache.get(method);</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">                        if (parameterTypes == null) {</span>
<span class="nc" id="L1214">                            parameterTypes = method.getParameterTypes();</span>
<span class="nc" id="L1215">                            parameterTypeCache.put(method, parameterTypes);</span>
                        }
<span class="nc bnc" id="L1217" title="All 2 branches missed.">                        if (parameterTypes[0].equals(Object.class)) {</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">                            return Boolean.valueOf(proxy == nargs[0]);</span>
                        }
<span class="nc bnc" id="L1220" title="All 4 branches missed.">                    } else if (methodName == &quot;__ruby_object&quot; &amp;&amp; length == 0) {</span>
<span class="nc" id="L1221">                        return wrapper;</span>
                    }

<span class="nc" id="L1224">                    IRubyObject[] rubyArgs = JavaUtil.convertJavaArrayToRuby(runtime, nargs);</span>
                    try {
<span class="nc" id="L1226">                        return Helpers.invoke(runtime.getCurrentContext(), wrapper, methodName, rubyArgs).toJava(method.getReturnType());</span>
<span class="nc" id="L1227">                    } catch (RuntimeException e) { e.printStackTrace(); throw e; }</span>
                }
            });
<span class="nc" id="L1230">            return JavaObject.wrap(runtime, proxyObject);</span>
        }
    }

    public static Class generateRealClass(final RubyClass clazz) {
<span class="nc" id="L1235">        final Ruby runtime = clazz.getRuntime();</span>
<span class="nc" id="L1236">        final Class[] interfaces = getInterfacesFromRubyClass(clazz);</span>

        // hashcode is a combination of the interfaces and the Ruby class we're using
        // to implement them
<span class="nc" id="L1240">        int interfacesHashCode = interfacesHashCode(interfaces);</span>
        // normal new class implementing interfaces
<span class="nc" id="L1242">        interfacesHashCode = 31 * interfacesHashCode + clazz.hashCode();</span>
        
        String implClassName;
<span class="nc bnc" id="L1245" title="All 2 branches missed.">        if (clazz.getBaseName() == null) {</span>
            // no-name class, generate a bogus name for it
<span class="nc" id="L1247">            implClassName = &quot;anon_class&quot; + Math.abs(System.identityHashCode(clazz)) + &quot;_&quot; + Math.abs(interfacesHashCode);</span>
        } else {
<span class="nc" id="L1249">            implClassName = clazz.getName().replaceAll(&quot;::&quot;, &quot;\\$\\$&quot;) + &quot;_&quot; + Math.abs(interfacesHashCode);</span>
        }
        Class proxyImplClass;
        try {
<span class="nc" id="L1253">            proxyImplClass = Class.forName(implClassName, true, runtime.getJRubyClassLoader());</span>
<span class="nc" id="L1254">        } catch (ClassNotFoundException cnfe) {</span>
            // try to use super's reified class; otherwise, RubyObject (for now)
<span class="nc" id="L1256">            Class superClass = clazz.getSuperClass().getRealClass().getReifiedClass();</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">            if (superClass == null) {</span>
<span class="nc" id="L1258">                superClass = RubyObject.class;</span>
            }
<span class="nc" id="L1260">            proxyImplClass = RealClassGenerator.createRealImplClass(superClass, interfaces, clazz, runtime, implClassName);</span>
            
            // add a default initialize if one does not already exist and this is a Java-hierarchy class
<span class="nc bnc" id="L1263" title="All 2 branches missed.">            if (NEW_STYLE_EXTENSION &amp;&amp;</span>
<span class="nc bnc" id="L1264" title="All 4 branches missed.">                    !(RubyBasicObject.class.isAssignableFrom(proxyImplClass) || clazz.getMethods().containsKey(&quot;initialize&quot;))</span>
                    ) {
<span class="nc" id="L1266">                clazz.addMethod(&quot;initialize&quot;, new JavaMethodZero(clazz, PRIVATE) {</span>
                    @Override
                    public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name) {
<span class="nc" id="L1269">                        return context.runtime.getNil();</span>
                    }
                });
            }
<span class="nc" id="L1273">        }</span>
<span class="nc" id="L1274">        clazz.setReifiedClass(proxyImplClass);</span>
<span class="nc" id="L1275">        clazz.setRubyClassAllocator(proxyImplClass);</span>

<span class="nc" id="L1277">        return proxyImplClass;</span>
    }

    public static Constructor getRealClassConstructor(Ruby runtime, Class proxyImplClass) {
        try {
<span class="nc" id="L1282">            return proxyImplClass.getConstructor(Ruby.class, RubyClass.class);</span>
<span class="nc" id="L1283">        } catch (NoSuchMethodException nsme) {</span>
<span class="nc" id="L1284">            throw runtime.newTypeError(&quot;Exception instantiating generated interface impl:\n&quot; + nsme);</span>
        }
    }

    public static IRubyObject constructProxy(Ruby runtime, Constructor proxyConstructor, RubyClass clazz) {
        try {
<span class="nc" id="L1290">            return (IRubyObject)proxyConstructor.newInstance(runtime, clazz);</span>
<span class="nc" id="L1291">        } catch (InvocationTargetException ite) {</span>
<span class="nc" id="L1292">            ite.printStackTrace();</span>
<span class="nc" id="L1293">            throw runtime.newTypeError(&quot;Exception instantiating generated interface impl:\n&quot; + ite);</span>
<span class="nc" id="L1294">        } catch (InstantiationException ie) {</span>
<span class="nc" id="L1295">            throw runtime.newTypeError(&quot;Exception instantiating generated interface impl:\n&quot; + ie);</span>
<span class="nc" id="L1296">        } catch (IllegalAccessException iae) {</span>
<span class="nc" id="L1297">            throw runtime.newTypeError(&quot;Exception instantiating generated interface impl:\n&quot; + iae);</span>
        }
    }
    
    public static IRubyObject allocateProxy(Object javaObject, RubyClass clazz) {
        // Arrays are never stored in OPC
<span class="fc bfc" id="L1303" title="All 2 branches covered.">        if (clazz.getSuperClass() == clazz.getRuntime().getJavaSupport().getArrayProxyClass()) {</span>
<span class="fc" id="L1304">            return new ArrayJavaProxy(clazz.getRuntime(), clazz, javaObject, JavaUtil.getJavaConverter(javaObject.getClass().getComponentType()));</span>
        }
        
<span class="fc" id="L1307">        IRubyObject proxy = clazz.allocate();</span>
<span class="pc bpc" id="L1308" title="1 of 2 branches missed.">        if (proxy instanceof JavaProxy) {</span>
<span class="fc" id="L1309">            ((JavaProxy)proxy).setObject(javaObject);</span>
        } else {
<span class="nc" id="L1311">            JavaObject wrappedObject = JavaObject.wrap(clazz.getRuntime(), javaObject);</span>
<span class="nc" id="L1312">            proxy.dataWrapStruct(wrappedObject);</span>
        }

<span class="fc" id="L1315">        return proxy;</span>
    }

    public static IRubyObject wrapJavaObject(Ruby runtime, Object object) {
<span class="nc" id="L1319">        return allocateProxy(object, getProxyClassForObject(runtime, object));</span>
    }

    public static Class[] getInterfacesFromRubyClass(RubyClass klass) {
<span class="nc" id="L1323">        Set&lt;Class&gt; interfaces = new HashSet&lt;Class&gt;();</span>
        // walk all superclasses aggregating interfaces
<span class="nc bnc" id="L1325" title="All 2 branches missed.">        while (klass != null) {</span>
<span class="nc" id="L1326">            IRubyObject maybeInterfaces = klass.getInstanceVariables().getInstanceVariable(&quot;@java_interfaces&quot;);</span>
<span class="nc bnc" id="L1327" title="All 2 branches missed.">            if (maybeInterfaces instanceof RubyArray) {</span>
<span class="nc" id="L1328">                RubyArray moreInterfaces = (RubyArray)maybeInterfaces;</span>
<span class="nc bnc" id="L1329" title="All 2 branches missed.">                if (!moreInterfaces.isFrozen()) moreInterfaces.setFrozen(true);</span>

<span class="nc" id="L1331">                interfaces.addAll(moreInterfaces);</span>
            }
<span class="nc" id="L1333">            klass = klass.getSuperClass();</span>
<span class="nc" id="L1334">        }</span>

<span class="nc" id="L1336">        return interfaces.toArray(new Class[interfaces.size()]);</span>
    }
    
    private static int interfacesHashCode(Class[] a) {
<span class="nc bnc" id="L1340" title="All 2 branches missed.">        if (a == null) {</span>
<span class="nc" id="L1341">            return 0;</span>
        }

<span class="nc" id="L1344">        int result = 1;</span>

<span class="nc bnc" id="L1346" title="All 2 branches missed.">        for (Class element : a)</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">            result = 31 * result + (element == null ? 0 : element.hashCode());</span>

<span class="nc" id="L1349">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>