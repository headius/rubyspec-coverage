<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ModuleNodes.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby.truffle.nodes.core</a> &gt; <span class="el_source">ModuleNodes.java</span></div><h1>ModuleNodes.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013, 2014 Oracle and/or its affiliates. All rights reserved. This
 * code is released under a tri EPL/GPL/LGPL license. You can use it,
 * redistribute it and/or modify it under the terms of the:
 *
 * Eclipse Public License version 1.0
 * GNU General Public License version 2
 * GNU Lesser General Public License version 2.1
 */
package org.jruby.truffle.nodes.core;

import com.oracle.truffle.api.CallTarget;
import com.oracle.truffle.api.CompilerDirectives;
import com.oracle.truffle.api.Truffle;
import com.oracle.truffle.api.dsl.Specialization;
import com.oracle.truffle.api.frame.Frame;
import com.oracle.truffle.api.frame.FrameInstance;
import com.oracle.truffle.api.frame.FrameSlot;
import com.oracle.truffle.api.frame.VirtualFrame;
import com.oracle.truffle.api.source.Source;
import com.oracle.truffle.api.source.SourceSection;

import org.jcodings.Encoding;
import org.jruby.runtime.Visibility;
import org.jruby.truffle.nodes.RubyNode;
import org.jruby.truffle.nodes.RubyRootNode;
import org.jruby.truffle.nodes.cast.BooleanCastNode;
import org.jruby.truffle.nodes.cast.BooleanCastNodeFactory;
import org.jruby.truffle.nodes.control.SequenceNode;
import org.jruby.truffle.nodes.dispatch.Dispatch;
import org.jruby.truffle.nodes.dispatch.DispatchHeadNode;
import org.jruby.truffle.nodes.methods.arguments.CheckArityNode;
import org.jruby.truffle.nodes.methods.arguments.MissingArgumentBehaviour;
import org.jruby.truffle.nodes.methods.arguments.ReadPreArgumentNode;
import org.jruby.truffle.nodes.objects.ReadInstanceVariableNode;
import org.jruby.truffle.nodes.objects.SelfNode;
import org.jruby.truffle.nodes.objects.WriteInstanceVariableNode;
import org.jruby.truffle.nodes.yield.YieldDispatchHeadNode;
import org.jruby.truffle.runtime.*;
import org.jruby.truffle.runtime.control.RaiseException;
import org.jruby.truffle.runtime.core.*;
import org.jruby.truffle.runtime.methods.Arity;
import org.jruby.truffle.runtime.methods.MethodLike;
import org.jruby.truffle.runtime.methods.RubyMethod;
import org.jruby.truffle.runtime.methods.SharedMethodInfo;
import org.jruby.truffle.translator.TranslatorDriver;
import org.jruby.util.IdUtil;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@CoreClass(name = &quot;Module&quot;)
<span class="nc" id="L54">public abstract class ModuleNodes {</span>

    @CoreMethod(names = &quot;===&quot;, required = 1)
    public abstract static class ContainsInstanceNode extends CoreMethodNode {

        public ContainsInstanceNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L60">            super(context, sourceSection);</span>
<span class="nc" id="L61">        }</span>

        public ContainsInstanceNode(ContainsInstanceNode prev) {
<span class="nc" id="L64">            super(prev);</span>
<span class="nc" id="L65">        }</span>

        @Specialization
        public boolean containsInstance(RubyModule module, RubyBasicObject instance) {
<span class="nc" id="L69">            notDesignedForCompilation();</span>

<span class="nc" id="L71">            return ModuleOperations.includesModule(instance.getMetaClass(), module);</span>
        }

        @Specialization
        public boolean containsInstance(RubyModule module, Object instance) {
<span class="nc" id="L76">            notDesignedForCompilation();</span>

<span class="nc" id="L78">            return ModuleOperations.includesModule(getContext().getCoreLibrary().getMetaClass(instance), module);</span>
        }
    }

    @CoreMethod(names = &quot;&lt;=&quot;, required = 1)
    public abstract static class IsSubclassOfNode extends CoreMethodNode {

        public IsSubclassOfNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L86">            super(context, sourceSection);</span>
<span class="nc" id="L87">        }</span>

        public IsSubclassOfNode(IsSubclassOfNode prev) {
<span class="nc" id="L90">            super(prev);</span>
<span class="nc" id="L91">        }</span>

        public abstract Object executeIsSubclassOf(VirtualFrame frame, RubyModule self, RubyModule other);

        @Specialization
        public Object isSubclassOf(VirtualFrame frame, RubyModule self, RubyModule other) {
<span class="nc" id="L97">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L99" title="All 4 branches missed.">            if (self == other || ModuleOperations.includesModule(self, other)) {</span>
<span class="nc" id="L100">                return true;</span>
            }

<span class="nc bnc" id="L103" title="All 2 branches missed.">            if (ModuleOperations.includesModule(other, self)) {</span>
<span class="nc" id="L104">                return false;</span>
            }

<span class="nc" id="L107">            return getContext().getCoreLibrary().getNilObject();</span>
        }

        @Specialization
        public Object isSubclassOf(VirtualFrame frame, RubyModule self, RubyBasicObject other) {
<span class="nc" id="L112">            notDesignedForCompilation();</span>

<span class="nc" id="L114">            throw new RaiseException(getContext().getCoreLibrary().typeError(&quot;compared with non class/module&quot;, this));</span>
        }

    }

    @CoreMethod(names = &quot;&lt;=&gt;&quot;, required = 1)
    public abstract static class CompareNode extends CoreMethodNode {

        @Child protected IsSubclassOfNode subclassNode;
        @Child protected BooleanCastNode booleanCastNode;

        public CompareNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L126">            super(context, sourceSection);</span>
<span class="nc" id="L127">        }</span>

        public CompareNode(CompareNode prev) {
<span class="nc" id="L130">            super(prev);</span>
<span class="nc" id="L131">        }</span>

        private Object isSubclass(VirtualFrame frame, RubyModule self, RubyModule other) {
<span class="nc bnc" id="L134" title="All 2 branches missed.">            if (subclassNode == null) {</span>
<span class="nc" id="L135">                CompilerDirectives.transferToInterpreterAndInvalidate();</span>
<span class="nc" id="L136">                subclassNode = insert(ModuleNodesFactory.IsSubclassOfNodeFactory.create(getContext(), getSourceSection(), new RubyNode[]{null, null}));</span>
            }
<span class="nc" id="L138">            return subclassNode.executeIsSubclassOf(frame, self, other);</span>
        }

        private boolean booleanCast(VirtualFrame frame, Object value) {
<span class="nc bnc" id="L142" title="All 2 branches missed.">            if (booleanCastNode == null) {</span>
<span class="nc" id="L143">                CompilerDirectives.transferToInterpreterAndInvalidate();</span>
<span class="nc" id="L144">                booleanCastNode = insert(BooleanCastNodeFactory.create(getContext(), getSourceSection(), null));</span>
            }
<span class="nc" id="L146">            return booleanCastNode.executeBoolean(frame, value);</span>
        }

        @Specialization
        public Object compare(VirtualFrame frame, RubyModule self, RubyModule other) {
<span class="nc" id="L151">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L153" title="All 2 branches missed.">            if (self == other) {</span>
<span class="nc" id="L154">                return 0;</span>
            }

<span class="nc" id="L157">            final Object isSubclass = isSubclass(frame, self, other);</span>

<span class="nc bnc" id="L159" title="All 2 branches missed.">            if (isSubclass instanceof RubyNilClass) {</span>
<span class="nc" id="L160">                return getContext().getCoreLibrary().getNilObject();</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">            } else if (booleanCast(frame, isSubclass)) {</span>
<span class="nc" id="L162">                return -1;</span>
            }
<span class="nc" id="L164">            return 1;</span>
        }

        @Specialization
        public Object compare(VirtualFrame frame, RubyModule self, RubyBasicObject other) {
<span class="nc" id="L169">            notDesignedForCompilation();</span>

<span class="nc" id="L171">            return getContext().getCoreLibrary().getNilObject();</span>
        }

    }

    @CoreMethod(names = &quot;alias_method&quot;, required = 2)
    public abstract static class AliasMethodNode extends CoreMethodNode {

        public AliasMethodNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L180">            super(context, sourceSection);</span>
<span class="nc" id="L181">        }</span>

        public AliasMethodNode(AliasMethodNode prev) {
<span class="nc" id="L184">            super(prev);</span>
<span class="nc" id="L185">        }</span>

        @Specialization
        public RubyModule aliasMethod(RubyModule module, RubySymbol newName, RubySymbol oldName) {
<span class="nc" id="L189">            notDesignedForCompilation();</span>

<span class="nc" id="L191">            module.alias(this, newName.toString(), oldName.toString());</span>
<span class="nc" id="L192">            return module;</span>
        }
    }

    @CoreMethod(names = &quot;ancestors&quot;)
    public abstract static class AncestorsNode extends CoreMethodNode {

        public AncestorsNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L200">            super(context, sourceSection);</span>
<span class="nc" id="L201">        }</span>

        public AncestorsNode(AncestorsNode prev) {
<span class="nc" id="L204">            super(prev);</span>
<span class="nc" id="L205">        }</span>

        @Specialization
        public RubyArray ancestors(RubyModule self) {
<span class="nc" id="L209">            notDesignedForCompilation();</span>

<span class="nc" id="L211">            final List&lt;RubyModule&gt; ancestors = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            for (RubyModule module : self.ancestors()) {</span>
<span class="nc" id="L213">                ancestors.add(module);</span>
<span class="nc" id="L214">            }</span>

<span class="nc" id="L216">            return RubyArray.fromObjects(getContext().getCoreLibrary().getArrayClass(), ancestors.toArray(new Object[ancestors.size()]));</span>
        }
    }

    @CoreMethod(names = &quot;append_features&quot;, required = 1)
    public abstract static class AppendFeaturesNode extends CoreMethodNode {

        public AppendFeaturesNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L224">            super(context, sourceSection);</span>
<span class="nc" id="L225">        }</span>

        public AppendFeaturesNode(AppendFeaturesNode prev) {
<span class="nc" id="L228">            super(prev);</span>
<span class="nc" id="L229">        }</span>

        @Specialization
        public RubyNilClass appendFeatures(RubyModule module, RubyModule other) {
<span class="nc" id="L233">            notDesignedForCompilation();</span>

<span class="nc" id="L235">            module.appendFeatures(this, other);</span>
<span class="nc" id="L236">            return getContext().getCoreLibrary().getNilObject();</span>
        }
    }

    @CoreMethod(names = &quot;attr_reader&quot;, argumentsAsArray = true)
    public abstract static class AttrReaderNode extends CoreMethodNode {

        public AttrReaderNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L244">            super(context, sourceSection);</span>
<span class="nc" id="L245">        }</span>

        public AttrReaderNode(AttrReaderNode prev) {
<span class="nc" id="L248">            super(prev);</span>
<span class="nc" id="L249">        }</span>

        @Specialization
        public RubyNilClass attrReader(RubyModule module, Object[] args) {
<span class="nc" id="L253">            notDesignedForCompilation();</span>

<span class="nc" id="L255">            final SourceSection sourceSection = Truffle.getRuntime().getCallerFrame().getCallNode().getEncapsulatingSourceSection();</span>

<span class="nc bnc" id="L257" title="All 2 branches missed.">            for (Object arg : args) {</span>
                final String accessorName;

<span class="nc bnc" id="L260" title="All 2 branches missed.">                if (arg instanceof RubySymbol) {</span>
<span class="nc" id="L261">                    accessorName = ((RubySymbol) arg).toString();</span>
                } else {
<span class="nc" id="L263">                    throw new UnsupportedOperationException();</span>
                }

<span class="nc" id="L266">                attrReader(this, getContext(), sourceSection, module, accessorName);</span>
            }

<span class="nc" id="L269">            return getContext().getCoreLibrary().getNilObject();</span>
        }

        public static void attrReader(RubyNode currentNode, RubyContext context, SourceSection sourceSection, RubyModule module, String name) {
<span class="nc" id="L273">            CompilerDirectives.transferToInterpreter();</span>

<span class="nc" id="L275">            final CheckArityNode checkArity = new CheckArityNode(context, sourceSection, new Arity(0, 0, false, false));</span>

<span class="nc" id="L277">            final SelfNode self = new SelfNode(context, sourceSection);</span>
<span class="nc" id="L278">            final ReadInstanceVariableNode readInstanceVariable = new ReadInstanceVariableNode(context, sourceSection, &quot;@&quot; + name, self, false);</span>

<span class="nc" id="L280">            final RubyNode block = SequenceNode.sequence(context, sourceSection, checkArity, readInstanceVariable);</span>

<span class="nc" id="L282">            final String indicativeName = name + &quot;(attr_reader)&quot;;</span>

<span class="nc" id="L284">            final SharedMethodInfo sharedMethodInfo = new SharedMethodInfo(sourceSection, null, indicativeName, false, null, false);</span>
<span class="nc" id="L285">            final RubyRootNode rootNode = new RubyRootNode(context, sourceSection, null, sharedMethodInfo, block);</span>
<span class="nc" id="L286">            final CallTarget callTarget = Truffle.getRuntime().createCallTarget(rootNode);</span>
<span class="nc" id="L287">            final RubyMethod method = new RubyMethod(sharedMethodInfo, name, module, Visibility.PUBLIC, false, callTarget, null);</span>
<span class="nc" id="L288">            module.addMethod(currentNode, method);</span>
<span class="nc" id="L289">        }</span>
    }

    @CoreMethod(names = &quot;attr_writer&quot;, argumentsAsArray = true)
    public abstract static class AttrWriterNode extends CoreMethodNode {

        public AttrWriterNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L296">            super(context, sourceSection);</span>
<span class="nc" id="L297">        }</span>

        public AttrWriterNode(AttrWriterNode prev) {
<span class="nc" id="L300">            super(prev);</span>
<span class="nc" id="L301">        }</span>

        @Specialization
        public RubyNilClass attrWriter(RubyModule module, Object[] args) {
<span class="nc" id="L305">            notDesignedForCompilation();</span>

<span class="nc" id="L307">            final SourceSection sourceSection = Truffle.getRuntime().getCallerFrame().getCallNode().getEncapsulatingSourceSection();</span>

<span class="nc bnc" id="L309" title="All 2 branches missed.">            for (Object arg : args) {</span>
                final String accessorName;

<span class="nc bnc" id="L312" title="All 2 branches missed.">                if (arg instanceof RubySymbol) {</span>
<span class="nc" id="L313">                    accessorName = ((RubySymbol) arg).toString();</span>
                } else {
<span class="nc" id="L315">                    throw new UnsupportedOperationException();</span>
                }

<span class="nc" id="L318">                attrWriter(this, getContext(), sourceSection, module, accessorName);</span>
            }

<span class="nc" id="L321">            return getContext().getCoreLibrary().getNilObject();</span>
        }

        public static void attrWriter(RubyNode currentNode, RubyContext context, SourceSection sourceSection, RubyModule module, String name) {
<span class="nc" id="L325">            CompilerDirectives.transferToInterpreter();</span>

<span class="nc" id="L327">            final CheckArityNode checkArity = new CheckArityNode(context, sourceSection, new Arity(1, 0, false, false));</span>

<span class="nc" id="L329">            final SelfNode self = new SelfNode(context, sourceSection);</span>
<span class="nc" id="L330">            final ReadPreArgumentNode readArgument = new ReadPreArgumentNode(context, sourceSection, 0, MissingArgumentBehaviour.RUNTIME_ERROR);</span>
<span class="nc" id="L331">            final WriteInstanceVariableNode writeInstanceVariable = new WriteInstanceVariableNode(context, sourceSection, &quot;@&quot; + name, self, readArgument, false);</span>

<span class="nc" id="L333">            final RubyNode block = SequenceNode.sequence(context, sourceSection, checkArity, writeInstanceVariable);</span>

<span class="nc" id="L335">            final String indicativeName = name + &quot;(attr_writer)&quot;;</span>

<span class="nc" id="L337">            final SharedMethodInfo sharedMethodInfo = new SharedMethodInfo(sourceSection, null, indicativeName, false, null, false);</span>
<span class="nc" id="L338">            final RubyRootNode rootNode = new RubyRootNode(context, sourceSection, null, sharedMethodInfo, block);</span>
<span class="nc" id="L339">            final CallTarget callTarget = Truffle.getRuntime().createCallTarget(rootNode);</span>
<span class="nc" id="L340">            final RubyMethod method = new RubyMethod(sharedMethodInfo, name + &quot;=&quot;, module, Visibility.PUBLIC, false, callTarget, null);</span>
<span class="nc" id="L341">            module.addMethod(currentNode, method);</span>
<span class="nc" id="L342">        }</span>
    }

    @CoreMethod(names = {&quot;attr_accessor&quot;, &quot;attr&quot;}, argumentsAsArray = true)
    public abstract static class AttrAccessorNode extends CoreMethodNode {

        public AttrAccessorNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L349">            super(context, sourceSection);</span>
<span class="nc" id="L350">        }</span>

        public AttrAccessorNode(AttrAccessorNode prev) {
<span class="nc" id="L353">            super(prev);</span>
<span class="nc" id="L354">        }</span>

        @Specialization
        public RubyNilClass attrAccessor(RubyModule module, Object[] args) {
<span class="nc" id="L358">            notDesignedForCompilation();</span>

<span class="nc" id="L360">            final SourceSection sourceSection = Truffle.getRuntime().getCallerFrame().getCallNode().getEncapsulatingSourceSection();</span>

<span class="nc bnc" id="L362" title="All 2 branches missed.">            for (Object arg : args) {</span>
                final String accessorName;

<span class="nc bnc" id="L365" title="All 2 branches missed.">                if (arg instanceof RubySymbol) {</span>
<span class="nc" id="L366">                    accessorName = ((RubySymbol) arg).toString();</span>
                } else {
<span class="nc" id="L368">                    throw new UnsupportedOperationException();</span>
                }

<span class="nc" id="L371">                attrAccessor(this, getContext(), sourceSection, module, accessorName);</span>
            }

<span class="nc" id="L374">            return getContext().getCoreLibrary().getNilObject();</span>
        }

        public static void attrAccessor(RubyNode currentNode, RubyContext context, SourceSection sourceSection, RubyModule module, String name) {
<span class="nc" id="L378">            CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L379">            AttrReaderNode.attrReader(currentNode, context, sourceSection, module, name);</span>
<span class="nc" id="L380">            AttrWriterNode.attrWriter(currentNode, context, sourceSection, module, name);</span>
<span class="nc" id="L381">        }</span>

    }

    @CoreMethod(names = {&quot;class_eval&quot;,&quot;module_eval&quot;}, optional = 3, needsBlock = true)
    public abstract static class ClassEvalNode extends CoreMethodNode {

        @Child protected YieldDispatchHeadNode yield;

        public ClassEvalNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L391">            super(context, sourceSection);</span>
<span class="nc" id="L392">            yield = new YieldDispatchHeadNode(context);</span>
<span class="nc" id="L393">        }</span>

        public ClassEvalNode(ClassEvalNode prev) {
<span class="nc" id="L396">            super(prev);</span>
<span class="nc" id="L397">            yield = prev.yield;</span>
<span class="nc" id="L398">        }</span>

        @Specialization
        public Object classEval(VirtualFrame frame, RubyModule module, RubyString code, @SuppressWarnings(&quot;unused&quot;) UndefinedPlaceholder file, @SuppressWarnings(&quot;unused&quot;) UndefinedPlaceholder line, @SuppressWarnings(&quot;unused&quot;) UndefinedPlaceholder block) {
<span class="nc" id="L402">            notDesignedForCompilation();</span>

<span class="nc" id="L404">            final Source source = Source.fromText(code.getBytes(), &quot;(eval)&quot;);</span>
<span class="nc" id="L405">            return classEvalSource(frame, module, source, code.getBytes().getEncoding());</span>
        }

        @Specialization
        public Object classEval(VirtualFrame frame, RubyModule module, RubyString code, RubyString file, @SuppressWarnings(&quot;unused&quot;) UndefinedPlaceholder line, @SuppressWarnings(&quot;unused&quot;) UndefinedPlaceholder block) {
<span class="nc" id="L410">            notDesignedForCompilation();</span>

<span class="nc" id="L412">            final Source source = Source.asPseudoFile(code.getBytes(), file.toString());</span>
<span class="nc" id="L413">            return classEvalSource(frame, module, source, code.getBytes().getEncoding());</span>
        }

        @Specialization
        public Object classEval(VirtualFrame frame, RubyModule module, RubyString code, RubyString file, @SuppressWarnings(&quot;unused&quot;) int line, @SuppressWarnings(&quot;unused&quot;) UndefinedPlaceholder block) {
<span class="nc" id="L418">            notDesignedForCompilation();</span>

<span class="nc" id="L420">            final Source source = Source.asPseudoFile(code.getBytes(), file.toString());</span>
<span class="nc" id="L421">            return classEvalSource(frame, module, source, code.getBytes().getEncoding());</span>
        }

        private Object classEvalSource(VirtualFrame frame, RubyModule module, Source source, Encoding encoding) {
<span class="nc" id="L425">            return getContext().execute(getContext(), source, encoding, TranslatorDriver.ParserContext.MODULE, module, frame.materialize(), this);</span>
        }

        @Specialization
        public Object classEval(VirtualFrame frame, RubyModule self, @SuppressWarnings(&quot;unused&quot;) UndefinedPlaceholder code, @SuppressWarnings(&quot;unused&quot;) UndefinedPlaceholder file, @SuppressWarnings(&quot;unused&quot;) UndefinedPlaceholder line, RubyProc block) {
<span class="nc" id="L430">            notDesignedForCompilation();</span>

<span class="nc" id="L432">            return yield.dispatchWithModifiedSelf(frame, block, self);</span>
        }

        @Specialization
        public Object classEval(RubyModule self, UndefinedPlaceholder code, UndefinedPlaceholder file, UndefinedPlaceholder line, UndefinedPlaceholder block) {
<span class="nc" id="L437">            notDesignedForCompilation();</span>

<span class="nc" id="L439">            throw new RaiseException(getContext().getCoreLibrary().argumentError(0, 1, 2, this));</span>
        }

    }

    @CoreMethod(names = {&quot;class_exec&quot;,&quot;module_exec&quot;}, argumentsAsArray = true, needsBlock = true)
    public abstract static class ClassExecNode extends CoreMethodNode {

        @Child protected YieldDispatchHeadNode yield;

        public ClassExecNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L450">            super(context, sourceSection);</span>
<span class="nc" id="L451">            yield = new YieldDispatchHeadNode(context);</span>
<span class="nc" id="L452">        }</span>

        public ClassExecNode(ClassExecNode prev) {
<span class="nc" id="L455">            super(prev);</span>
<span class="nc" id="L456">            yield = prev.yield;</span>
<span class="nc" id="L457">        }</span>

        public abstract Object executeClassEval(VirtualFrame frame, RubyModule self, Object[] args, RubyProc block);

        @Specialization
        public Object classEval(VirtualFrame frame, RubyModule self, Object[] args, RubyProc block) {
<span class="nc" id="L463">            notDesignedForCompilation();</span>

            // TODO: deal with args

<span class="nc" id="L467">            return yield.dispatchWithModifiedSelf(frame, block, self);</span>
        }

    }

    @CoreMethod(names = &quot;class_variable_defined?&quot;, required = 1)
    public abstract static class ClassVariableDefinedNode extends CoreMethodNode {

        public ClassVariableDefinedNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L476">            super(context, sourceSection);</span>
<span class="nc" id="L477">        }</span>

        public ClassVariableDefinedNode(ClassVariableDefinedNode prev) {
<span class="nc" id="L480">            super(prev);</span>
<span class="nc" id="L481">        }</span>

        @Specialization
        public boolean isClassVariableDefined(RubyModule module, RubyString name) {
<span class="nc" id="L485">            notDesignedForCompilation();</span>

<span class="nc" id="L487">            return module.getClassVariables().containsKey(name.toString());</span>
        }

        @Specialization
        public boolean isClassVariableDefined(RubyModule module, RubySymbol name) {
<span class="nc" id="L492">            notDesignedForCompilation();</span>

<span class="nc" id="L494">            return module.getClassVariables().containsKey(name.toString());</span>
        }

    }

    @CoreMethod(names = &quot;class_variable_get&quot;, required = 1)
    public abstract static class ClassVariableGetNode extends CoreMethodNode {

        public ClassVariableGetNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L503">            super(context, sourceSection);</span>
<span class="nc" id="L504">        }</span>

        public ClassVariableGetNode(ClassVariableGetNode prev) {
<span class="nc" id="L507">            super(prev);</span>
<span class="nc" id="L508">        }</span>

        @Specialization
        public Object getClassVariable(RubyModule module, RubyString name) {
<span class="nc" id="L512">            notDesignedForCompilation();</span>
<span class="nc" id="L513">            return ModuleOperations.lookupClassVariable(module, RubyContext.checkClassVariableName(getContext(), name.toString(), this));</span>
        }

        @Specialization
        public Object getClassVariable(RubyModule module, RubySymbol name) {
<span class="nc" id="L518">            notDesignedForCompilation();</span>
<span class="nc" id="L519">            return ModuleOperations.lookupClassVariable(module, RubyContext.checkClassVariableName(getContext(), name.toString(), this));</span>
        }

    }

    @CoreMethod(names = &quot;class_variables&quot;)
    public abstract static class ClassVariablesNode extends CoreMethodNode {

        public ClassVariablesNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L528">            super(context, sourceSection);</span>
<span class="nc" id="L529">        }</span>

        public ClassVariablesNode(ClassVariablesNode prev) {
<span class="nc" id="L532">            super(prev);</span>
<span class="nc" id="L533">        }</span>

        @Specialization
        public RubyArray getClassVariables(RubyModule module) {
<span class="nc" id="L537">            notDesignedForCompilation();</span>

<span class="nc" id="L539">            final RubyArray array = new RubyArray(module.getContext().getCoreLibrary().getArrayClass());</span>

<span class="nc bnc" id="L541" title="All 2 branches missed.">            for (String variable : ModuleOperations.getAllClassVariables(module).keySet()) {</span>
<span class="nc" id="L542">                array.slowPush(RubySymbol.newSymbol(module.getContext(), variable));</span>
<span class="nc" id="L543">            }</span>
<span class="nc" id="L544">            return array;</span>
        }
    }

    @CoreMethod(names = &quot;constants&quot;, optional = 1)
    public abstract static class ConstantsNode extends CoreMethodNode {

        public ConstantsNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L552">            super(context, sourceSection);</span>
<span class="nc" id="L553">        }</span>

        public ConstantsNode(ConstantsNode prev) {
<span class="nc" id="L556">            super(prev);</span>
<span class="nc" id="L557">        }</span>

        @Specialization
        public RubyArray constants(RubyModule module, UndefinedPlaceholder unused) {
<span class="nc" id="L561">            return constants(module, true);</span>
        }

        @Specialization
        public RubyArray constants(RubyModule module, boolean inherit) {
<span class="nc" id="L566">            notDesignedForCompilation();</span>

<span class="nc" id="L568">            final RubyArray array = new RubyArray(getContext().getCoreLibrary().getArrayClass());</span>

            // TODO(cs): handle inherit
<span class="nc bnc" id="L571" title="All 2 branches missed.">            for (String constant : module.getConstants().keySet()) {</span>
<span class="nc" id="L572">                array.slowPush(getContext().newSymbol(constant));</span>
<span class="nc" id="L573">            }</span>

<span class="nc" id="L575">            return array;</span>
        }
    }

    @CoreMethod(names = &quot;const_defined?&quot;, required = 1, optional = 1)
    public abstract static class ConstDefinedNode extends CoreMethodNode {

        public ConstDefinedNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L583">            super(context, sourceSection);</span>
<span class="nc" id="L584">        }</span>

        public ConstDefinedNode(ConstDefinedNode prev) {
<span class="nc" id="L587">            super(prev);</span>
<span class="nc" id="L588">        }</span>

        @Specialization
        public boolean isConstDefined(RubyModule module, RubyString name, @SuppressWarnings(&quot;unused&quot;) UndefinedPlaceholder inherit) {
<span class="nc" id="L592">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L594" title="All 2 branches missed.">            return ModuleOperations.lookupConstant(getContext(), LexicalScope.NONE, module, name.toString()) != null;</span>
        }

        @Specialization
        public boolean isConstDefined(RubyModule module, RubyString name, boolean inherit) {
<span class="nc" id="L599">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L601" title="All 2 branches missed.">            if (inherit) {</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">                return ModuleOperations.lookupConstant(getContext(), LexicalScope.NONE, module, name.toString()) != null;</span>
            } else {
<span class="nc" id="L604">                return module.getConstants().containsKey(name.toString());</span>
            }
        }

        @Specialization
        public boolean isConstDefined(RubyModule module, RubySymbol name, @SuppressWarnings(&quot;unused&quot;) UndefinedPlaceholder inherit) {
<span class="nc" id="L610">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L612" title="All 2 branches missed.">            return ModuleOperations.lookupConstant(getContext(), LexicalScope.NONE, module, name.toString()) != null;</span>
        }

    }

    @CoreMethod(names = &quot;const_get&quot;, required = 1)
    public abstract static class ConstGetNode extends CoreMethodNode {

        @Child protected DispatchHeadNode dispatch;

        public ConstGetNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L623">            super(context, sourceSection);</span>
<span class="nc" id="L624">            dispatch = new DispatchHeadNode(context, Dispatch.MissingBehavior.CALL_CONST_MISSING);</span>
<span class="nc" id="L625">        }</span>

        public ConstGetNode(ConstGetNode prev) {
<span class="nc" id="L628">            super(prev);</span>
<span class="nc" id="L629">            dispatch = prev.dispatch;</span>
<span class="nc" id="L630">        }</span>

        @Specialization
        public Object getConstant(VirtualFrame frame, RubyModule module, RubyString name) {
<span class="nc" id="L634">            notDesignedForCompilation();</span>

<span class="nc" id="L636">            return dispatch.dispatch(</span>
                    frame,
                    null,
                    module,
                    name,
                    null,
                    new Object[]{},
                    Dispatch.DispatchAction.READ_CONSTANT);
        }

        @Specialization
        public Object getConstant(VirtualFrame frame, RubyModule module, RubySymbol name) {
<span class="nc" id="L648">            notDesignedForCompilation();</span>

<span class="nc" id="L650">            return dispatch.dispatch(</span>
                    frame,
                    null,
                    module,
                    name,
                    null,
                    new Object[]{},
                    Dispatch.DispatchAction.READ_CONSTANT);
        }
    }

    @CoreMethod(names = &quot;const_missing&quot;, required = 1)
    public abstract static class ConstMissingNode extends CoreMethodNode {

        public ConstMissingNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L665">            super(context, sourceSection);</span>
<span class="nc" id="L666">        }</span>

        public ConstMissingNode(ConstMissingNode prev) {
<span class="nc" id="L669">            super(prev);</span>
<span class="nc" id="L670">        }</span>

        @Specialization
        public Object methodMissing(RubyModule module, RubySymbol name) {
<span class="nc" id="L674">            throw new RaiseException(getContext().getCoreLibrary().nameErrorUninitializedConstant(module, name.toString(), this));</span>
        }

    }

    @CoreMethod(names = &quot;const_set&quot;, required = 2)
    public abstract static class ConstSetNode extends CoreMethodNode {

        public ConstSetNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L683">            super(context, sourceSection);</span>
<span class="nc" id="L684">        }</span>

        public ConstSetNode(ConstSetNode prev) {
<span class="nc" id="L687">            super(prev);</span>
<span class="nc" id="L688">        }</span>

        @Specialization
        public RubyModule setConstant(RubyModule module, RubyString name, Object object) {
<span class="nc" id="L692">            notDesignedForCompilation();</span>
<span class="nc" id="L693">            setConstant(module, name.toString(), object);</span>
<span class="nc" id="L694">            return module;</span>
        }

        @Specialization
        public RubyModule setConstant(RubyModule module, RubySymbol name, Object object) {
<span class="nc" id="L699">            notDesignedForCompilation();</span>
<span class="nc" id="L700">            setConstant(module, name.toString(), object);</span>
<span class="nc" id="L701">            return module;</span>
        }

        public void setConstant(RubyModule module, String name, Object object) {
<span class="nc bnc" id="L705" title="All 2 branches missed.">            if (!IdUtil.isConstant(name)) {</span>
<span class="nc" id="L706">                throw new RaiseException(getContext().getCoreLibrary().nameError(String.format(&quot;wrong constant name %s&quot;, name), this));</span>
            }

<span class="nc bnc" id="L709" title="All 2 branches missed.">            if (object instanceof RubyModule) {</span>
<span class="nc" id="L710">                final RubyModule setModule = (RubyModule) object;</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">                if (setModule.getName() == null) {</span>
<span class="nc" id="L712">                    setModule.setLexicalScope(new LexicalScope(null, module));</span>
<span class="nc" id="L713">                    setModule.setName(name);</span>
                }
            }

<span class="nc" id="L717">            module.setConstant(this, name, object);</span>
<span class="nc" id="L718">        }</span>

    }

    @CoreMethod(names = &quot;define_method&quot;, needsBlock = true, required = 1, optional = 1)
    public abstract static class DefineMethodNode extends CoreMethodNode {

        public DefineMethodNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L726">            super(context, sourceSection);</span>
<span class="nc" id="L727">        }</span>

        public DefineMethodNode(DefineMethodNode prev) {
<span class="nc" id="L730">            super(prev);</span>
<span class="nc" id="L731">        }</span>

        @Specialization
        public RubySymbol defineMethod(RubyModule module, RubyString name, @SuppressWarnings(&quot;unused&quot;) UndefinedPlaceholder proc, RubyProc block) {
<span class="nc" id="L735">            notDesignedForCompilation();</span>

<span class="nc" id="L737">            return defineMethod(module, name, block, UndefinedPlaceholder.INSTANCE);</span>
        }

        @Specialization
        public RubySymbol defineMethod(RubyModule module, RubyString name, RubyProc proc, @SuppressWarnings(&quot;unused&quot;) UndefinedPlaceholder block) {
<span class="nc" id="L742">            notDesignedForCompilation();</span>

<span class="nc" id="L744">            final RubySymbol symbol = getContext().getSymbolTable().getSymbol(name.getBytes());</span>
<span class="nc" id="L745">            defineMethod(module, symbol, proc);</span>
<span class="nc" id="L746">            return symbol;</span>
        }

        @Specialization
        public RubySymbol defineMethod(RubyModule module, RubySymbol name, @SuppressWarnings(&quot;unused&quot;) UndefinedPlaceholder proc, RubyProc block) {
<span class="nc" id="L751">            notDesignedForCompilation();</span>

<span class="nc" id="L753">            return defineMethod(module, name, block, UndefinedPlaceholder.INSTANCE);</span>
        }

        @Specialization
        public RubySymbol defineMethod(RubyModule module, RubySymbol name, RubyProc proc, @SuppressWarnings(&quot;unused&quot;) UndefinedPlaceholder block) {
<span class="nc" id="L758">            notDesignedForCompilation();</span>

<span class="nc" id="L760">            defineMethod(module, name, proc);</span>
<span class="nc" id="L761">            return name;</span>
        }

        private void defineMethod(RubyModule module, RubySymbol name, RubyProc proc) {
<span class="nc" id="L765">            notDesignedForCompilation();</span>

<span class="nc" id="L767">            final CallTarget modifiedCallTarget = proc.getCallTargetForMethods();</span>
<span class="nc" id="L768">            final RubyMethod modifiedMethod = new RubyMethod(proc.getSharedMethodInfo(), name.toString(), module, Visibility.PUBLIC, false, modifiedCallTarget, proc.getDeclarationFrame());</span>
<span class="nc" id="L769">            module.addMethod(this, modifiedMethod);</span>
<span class="nc" id="L770">        }</span>

    }

    @CoreMethod(names = &quot;initialize&quot;, needsBlock = true)
    public abstract static class InitializeNode extends CoreMethodNode {

        @Child protected ModuleNodes.ClassExecNode classExecNode;

        public InitializeNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L780">            super(context, sourceSection);</span>
<span class="nc" id="L781">        }</span>

        public InitializeNode(InitializeNode prev) {
<span class="nc" id="L784">            super(prev);</span>
<span class="nc" id="L785">        }</span>

        public abstract RubyModule executeInitialize(VirtualFrame frame, RubyModule module, RubyProc block);

        void classEval(VirtualFrame frame, RubyModule module, RubyProc block) {
<span class="nc bnc" id="L790" title="All 2 branches missed.">            if (classExecNode == null) {</span>
<span class="nc" id="L791">                CompilerDirectives.transferToInterpreterAndInvalidate();</span>
<span class="nc" id="L792">                classExecNode = insert(ModuleNodesFactory.ClassExecNodeFactory.create(getContext(), getSourceSection(), new RubyNode[]{null,null,null}));</span>
            }
<span class="nc" id="L794">            classExecNode.executeClassEval(frame, module, new Object[]{}, block);</span>
<span class="nc" id="L795">        }</span>

        @Specialization
        public RubyModule initialize(RubyModule module, UndefinedPlaceholder block) {
<span class="nc" id="L799">            return module;</span>
        }

        @Specialization
        public RubyModule initialize(VirtualFrame frame, RubyModule module, RubyProc block) {
<span class="nc" id="L804">            classEval(frame, module, block);</span>
<span class="nc" id="L805">            return module;</span>
        }

    }

    @CoreMethod(names = &quot;initialize_copy&quot;, visibility = Visibility.PRIVATE, required = 1)
    public abstract static class InitializeCopyNode extends CoreMethodNode {

        public InitializeCopyNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L814">            super(context, sourceSection);</span>
<span class="nc" id="L815">        }</span>

        public InitializeCopyNode(InitializeCopyNode prev) {
<span class="nc" id="L818">            super(prev);</span>
<span class="nc" id="L819">        }</span>

        @Specialization
        public Object initializeCopy(RubyModule self, RubyModule other) {
<span class="nc" id="L823">            notDesignedForCompilation();</span>

<span class="nc" id="L825">            self.initCopy(other);</span>
<span class="nc" id="L826">            return getContext().getCoreLibrary().getNilObject();</span>
        }

    }

    @CoreMethod(names = &quot;include&quot;, argumentsAsArray = true, required = 1)
    public abstract static class IncludeNode extends CoreMethodNode {

        @Child protected DispatchHeadNode appendFeaturesNode;

        public IncludeNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L837">            super(context, sourceSection);</span>
<span class="nc" id="L838">            appendFeaturesNode = new DispatchHeadNode(context);</span>
<span class="nc" id="L839">        }</span>

        public IncludeNode(IncludeNode prev) {
<span class="nc" id="L842">            super(prev);</span>
<span class="nc" id="L843">            appendFeaturesNode = prev.appendFeaturesNode;</span>
<span class="nc" id="L844">        }</span>

        public abstract RubyNilClass executeInclude(VirtualFrame frame, RubyModule module, Object[] args);

        @Specialization
        public RubyNilClass include(VirtualFrame frame, RubyModule module, Object[] args) {
<span class="nc" id="L850">            notDesignedForCompilation();</span>

            // Note that we traverse the arguments backwards

<span class="nc bnc" id="L854" title="All 2 branches missed.">            for (int n = args.length - 1; n &gt;= 0; n--) {</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">                if (args[n] instanceof RubyModule) {</span>
<span class="nc" id="L856">                    final RubyModule included = (RubyModule) args[n];</span>

<span class="nc" id="L858">                    appendFeaturesNode.call(frame, included, &quot;append_features&quot;, null, module);</span>

                    // TODO(cs): call included hook
                }
            }

<span class="nc" id="L864">            return getContext().getCoreLibrary().getNilObject();</span>
        }
    }

    @CoreMethod(names = &quot;include?&quot;, required = 1)
    public abstract static class IncludePNode extends CoreMethodNode {

        @Child protected DispatchHeadNode appendFeaturesNode;

        public IncludePNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L874">            super(context, sourceSection);</span>
<span class="nc" id="L875">            appendFeaturesNode = new DispatchHeadNode(context);</span>
<span class="nc" id="L876">        }</span>

        public IncludePNode(IncludePNode prev) {
<span class="nc" id="L879">            super(prev);</span>
<span class="nc" id="L880">            appendFeaturesNode = prev.appendFeaturesNode;</span>
<span class="nc" id="L881">        }</span>

        @Specialization
        public boolean include(RubyModule module, RubyModule included) {
<span class="nc" id="L885">            notDesignedForCompilation();</span>

<span class="nc" id="L887">            ModuleChain ancestor = module.getParentModule();</span>

<span class="nc bnc" id="L889" title="All 2 branches missed.">            while (ancestor != null) {</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">                if (ancestor.getActualModule() == included) {</span>
<span class="nc" id="L891">                    return true;</span>
                }

<span class="nc" id="L894">                ancestor = ancestor.getParentModule();</span>
            }

<span class="nc" id="L897">            return false;</span>
        }
    }

    @CoreMethod(names = &quot;method_defined?&quot;, required = 1, optional = 1)
    public abstract static class MethodDefinedNode extends CoreMethodNode {

        public MethodDefinedNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L905">            super(context, sourceSection);</span>
<span class="nc" id="L906">        }</span>

        public MethodDefinedNode(MethodDefinedNode prev) {
<span class="nc" id="L909">            super(prev);</span>
<span class="nc" id="L910">        }</span>

        @Specialization
        public boolean isMethodDefined(RubyModule module, RubyString name, @SuppressWarnings(&quot;unused&quot;) UndefinedPlaceholder inherit) {
<span class="nc" id="L914">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L916" title="All 2 branches missed.">            return ModuleOperations.lookupMethod(module, name.toString()) != null;</span>
        }

        @Specialization
        public boolean isMethodDefined(RubyModule module, RubyString name, boolean inherit) {
<span class="nc" id="L921">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L923" title="All 2 branches missed.">            if (inherit) {</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">                return ModuleOperations.lookupMethod(module, name.toString()) != null;</span>
            } else {
<span class="nc" id="L926">                return module.getMethods().containsKey(name.toString());</span>
            }
        }

        @Specialization
        public boolean isMethodDefined(RubyModule module, RubySymbol name, @SuppressWarnings(&quot;unused&quot;) UndefinedPlaceholder inherit) {
<span class="nc" id="L932">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L934" title="All 2 branches missed.">            return ModuleOperations.lookupMethod(module, name.toString()) != null;</span>
        }
    }

    @CoreMethod(names = &quot;module_function&quot;, argumentsAsArray = true)
    public abstract static class ModuleFunctionNode extends CoreMethodNode {

        public ModuleFunctionNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L942">            super(context, sourceSection);</span>
<span class="nc" id="L943">        }</span>

        public ModuleFunctionNode(ModuleFunctionNode prev) {
<span class="nc" id="L946">            super(prev);</span>
<span class="nc" id="L947">        }</span>

        @Specialization
        public RubyNilClass moduleFunction(RubyModule module, Object... args) {
<span class="nc" id="L951">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L953" title="All 2 branches missed.">            if (args.length == 0) {</span>
<span class="nc" id="L954">                final Frame unpacked = Truffle.getRuntime().getCallerFrame().getFrame(FrameInstance.FrameAccess.READ_WRITE, false);</span>

<span class="nc" id="L956">                final FrameSlot slot = unpacked.getFrameDescriptor().findFrameSlot(RubyModule.MODULE_FUNCTION_FLAG_FRAME_SLOT_ID);</span>

                /*
                 * setObject, even though it's a boolean, so we can getObject and either get the
                 * default Nil or the boolean value without triggering deoptimization.
                 */

<span class="nc" id="L963">                unpacked.setObject(slot, true);</span>
<span class="nc" id="L964">            } else {</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">                for (Object argument : args) {</span>
                    final String methodName;

<span class="nc bnc" id="L968" title="All 2 branches missed.">                    if (argument instanceof RubySymbol) {</span>
<span class="nc" id="L969">                        methodName = ((RubySymbol) argument).toString();</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">                    } else if (argument instanceof RubyString) {</span>
<span class="nc" id="L971">                        methodName = ((RubyString) argument).toString();</span>
                    } else {
<span class="nc" id="L973">                        throw new UnsupportedOperationException();</span>
                    }

                    // TODO(cs): make this instance method private
<span class="nc" id="L977">                    final RubyMethod method = ModuleOperations.lookupMethod(module, methodName);</span>

<span class="nc bnc" id="L979" title="All 2 branches missed.">                    if (method == null) {</span>
<span class="nc" id="L980">                        throw new UnsupportedOperationException();</span>
                    }

<span class="nc" id="L983">                    module.getSingletonClass(this).addMethod(this, method.withVisibility(Visibility.PUBLIC));</span>
                }
            }

<span class="nc" id="L987">            return getContext().getCoreLibrary().getNilObject();</span>
        }
    }

    @CoreMethod(names = &quot;name&quot;)
    public abstract static class NameNode extends CoreMethodNode {

        public NameNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L995">            super(context, sourceSection);</span>
<span class="nc" id="L996">        }</span>

        public NameNode(NameNode prev) {
<span class="nc" id="L999">            super(prev);</span>
<span class="nc" id="L1000">        }</span>

        @Specialization
        public Object name(RubyModule module) {
<span class="nc" id="L1004">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L1006" title="All 2 branches missed.">            if (module.getName() == null) {</span>
<span class="nc" id="L1007">                return getContext().getCoreLibrary().getNilObject();</span>
            }

<span class="nc" id="L1010">            final StringBuilder builder = new StringBuilder();</span>

<span class="nc" id="L1012">            builder.append(module.getName());</span>

<span class="nc" id="L1014">            LexicalScope lexicalScope = module.getLexicalScope();</span>

<span class="nc bnc" id="L1016" title="All 4 branches missed.">            while (lexicalScope != null &amp;&amp; lexicalScope.getLiveModule() != getContext().getCoreLibrary().getObjectClass()) {</span>
<span class="nc" id="L1017">                builder.insert(0, &quot;::&quot;);</span>
<span class="nc" id="L1018">                builder.insert(0, lexicalScope.getLiveModule().getName());</span>
<span class="nc" id="L1019">                lexicalScope = lexicalScope.getParent();</span>
            }

<span class="nc" id="L1022">            return getContext().makeString(builder.toString());</span>
        }
    }

    @CoreMethod(names = &quot;nesting&quot;, onSingleton = true)
    public abstract static class NestingNode extends CoreMethodNode {

        public NestingNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1030">            super(context, sourceSection);</span>
<span class="nc" id="L1031">        }</span>

        public NestingNode(NestingNode prev) {
<span class="nc" id="L1034">            super(prev);</span>
<span class="nc" id="L1035">        }</span>

        @Specialization
        public RubyArray nesting() {
<span class="nc" id="L1039">            notDesignedForCompilation();</span>

<span class="nc" id="L1041">            final List&lt;RubyModule&gt; modules = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L1043">            MethodLike method = RubyCallStack.getCallingMethod();</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">            LexicalScope lexicalScope = method == null ? null : method.getSharedMethodInfo().getLexicalScope();</span>
<span class="nc" id="L1045">            RubyClass object = getContext().getCoreLibrary().getObjectClass();</span>

<span class="nc bnc" id="L1047" title="All 2 branches missed.">            while (lexicalScope != null) {</span>
<span class="nc" id="L1048">                RubyModule enclosing = lexicalScope.getLiveModule();</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">                if (enclosing == object)</span>
<span class="nc" id="L1050">                    break;</span>
<span class="nc" id="L1051">                modules.add(enclosing);</span>
<span class="nc" id="L1052">                lexicalScope = lexicalScope.getParent();</span>
<span class="nc" id="L1053">            }</span>

<span class="nc" id="L1055">            return RubyArray.fromObjects(getContext().getCoreLibrary().getArrayClass(), modules.toArray(new Object[modules.size()]));</span>
        }
    }

    @CoreMethod(names = &quot;public&quot;, argumentsAsArray = true)
    public abstract static class PublicNode extends CoreMethodNode {

        public PublicNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1063">            super(context, sourceSection);</span>
<span class="nc" id="L1064">        }</span>

        public PublicNode(PublicNode prev) {
<span class="nc" id="L1067">            super(prev);</span>
<span class="nc" id="L1068">        }</span>

        public abstract RubyModule executePublic(VirtualFrame frame, RubyModule module, Object[] args);

        @Specialization
        public RubyModule doPublic(RubyModule module, Object[] args) {
<span class="nc" id="L1074">            notDesignedForCompilation();</span>

<span class="nc" id="L1076">            module.visibilityMethod(this, args, Visibility.PUBLIC);</span>
<span class="nc" id="L1077">            return module;</span>
        }
    }

    @CoreMethod(names = &quot;public_class_method&quot;, argumentsAsArray = true)
    public abstract static class PublicClassMethodNode extends CoreMethodNode {

        public PublicClassMethodNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1085">            super(context, sourceSection);</span>
<span class="nc" id="L1086">        }</span>

        public PublicClassMethodNode(PublicClassMethodNode prev) {
<span class="nc" id="L1089">            super(prev);</span>
<span class="nc" id="L1090">        }</span>

        @Specialization
        public RubyModule publicClassMethod(RubyModule module, Object... args) {
<span class="nc" id="L1094">            notDesignedForCompilation();</span>

<span class="nc" id="L1096">            final RubyClass moduleSingleton = module.getSingletonClass(this);</span>

<span class="nc bnc" id="L1098" title="All 2 branches missed.">            for (Object arg : args) {</span>
                final String methodName;

<span class="nc bnc" id="L1101" title="All 2 branches missed.">                if (arg instanceof RubySymbol) {</span>
<span class="nc" id="L1102">                    methodName = arg.toString();</span>
                } else {
<span class="nc" id="L1104">                    throw new UnsupportedOperationException();</span>
                }

<span class="nc" id="L1107">                final RubyMethod method = ModuleOperations.lookupMethod(moduleSingleton, methodName);</span>

<span class="nc bnc" id="L1109" title="All 2 branches missed.">                if (method == null) {</span>
<span class="nc" id="L1110">                    throw new RuntimeException(&quot;Couldn't find method &quot; + arg.toString());</span>
                }

<span class="nc" id="L1113">                moduleSingleton.addMethod(this, method.withVisibility(Visibility.PUBLIC));</span>
            }

<span class="nc" id="L1116">            return module;</span>
        }
    }

    @CoreMethod(names = &quot;private&quot;, argumentsAsArray = true)
    public abstract static class PrivateNode extends CoreMethodNode {

        public PrivateNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1124">            super(context, sourceSection);</span>
<span class="nc" id="L1125">        }</span>

        public PrivateNode(PrivateNode prev) {
<span class="nc" id="L1128">            super(prev);</span>
<span class="nc" id="L1129">        }</span>

        public abstract RubyModule executePrivate(VirtualFrame frame, RubyModule module, Object[] args);

        @Specialization
        public RubyModule doPrivate(RubyModule module, Object[] args) {
<span class="nc" id="L1135">            notDesignedForCompilation();</span>

<span class="nc" id="L1137">            module.visibilityMethod(this, args, Visibility.PRIVATE);</span>
<span class="nc" id="L1138">            return module;</span>
        }
    }

    @CoreMethod(names = &quot;private_class_method&quot;, argumentsAsArray = true)
    public abstract static class PrivateClassMethodNode extends CoreMethodNode {

        public PrivateClassMethodNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1146">            super(context, sourceSection);</span>
<span class="nc" id="L1147">        }</span>

        public PrivateClassMethodNode(PrivateClassMethodNode prev) {
<span class="nc" id="L1150">            super(prev);</span>
<span class="nc" id="L1151">        }</span>

        @Specialization
        public RubyModule privateClassMethod(RubyModule module, Object... args) {
<span class="nc" id="L1155">            notDesignedForCompilation();</span>

<span class="nc" id="L1157">            final RubyClass moduleSingleton = module.getSingletonClass(this);</span>

<span class="nc bnc" id="L1159" title="All 2 branches missed.">            for (Object arg : args) {</span>
                final String methodName;

<span class="nc bnc" id="L1162" title="All 2 branches missed.">                if (arg instanceof RubySymbol) {</span>
<span class="nc" id="L1163">                    methodName = arg.toString();</span>
                } else {
<span class="nc" id="L1165">                    throw new UnsupportedOperationException();</span>
                }

<span class="nc" id="L1168">                final RubyMethod method = ModuleOperations.lookupMethod(moduleSingleton, methodName);</span>

<span class="nc bnc" id="L1170" title="All 2 branches missed.">                if (method == null) {</span>
<span class="nc" id="L1171">                    throw new RuntimeException(&quot;Couldn't find method &quot; + arg.toString());</span>
                }

<span class="nc" id="L1174">                moduleSingleton.addMethod(this, method.withVisibility(Visibility.PRIVATE));</span>
            }

<span class="nc" id="L1177">            return module;</span>
        }
    }

    @CoreMethod(names = &quot;private_instance_methods&quot;, optional = 1)
    public abstract static class PrivateInstanceMethodsNode extends CoreMethodNode {

        public PrivateInstanceMethodsNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1185">            super(context, sourceSection);</span>
<span class="nc" id="L1186">        }</span>

        public PrivateInstanceMethodsNode(PrivateInstanceMethodsNode prev) {
<span class="nc" id="L1189">            super(prev);</span>
<span class="nc" id="L1190">        }</span>

        @Specialization
        public RubyArray privateInstanceMethods(RubyModule module, UndefinedPlaceholder argument) {
<span class="nc" id="L1194">            return privateInstanceMethods(module, false);</span>
        }

        @Specialization
        public RubyArray privateInstanceMethods(RubyModule module, boolean includeAncestors) {
<span class="nc" id="L1199">            notDesignedForCompilation();</span>

<span class="nc" id="L1201">            final RubyArray array = new RubyArray(getContext().getCoreLibrary().getArrayClass());</span>
<span class="nc" id="L1202">            final List&lt;RubyMethod&gt; methods = new ArrayList&lt;&gt;(module.getMethods().values());</span>

<span class="nc bnc" id="L1204" title="All 2 branches missed.">            if (includeAncestors) {</span>
<span class="nc bnc" id="L1205" title="All 2 branches missed.">                for (RubyModule parent : module.parentAncestors()) {</span>
<span class="nc" id="L1206">                    methods.addAll(parent.getMethods().values());</span>
<span class="nc" id="L1207">                }</span>
            }
<span class="nc bnc" id="L1209" title="All 2 branches missed.">            for (RubyMethod method : methods) {</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">                if (method.getVisibility() == Visibility.PRIVATE){</span>
<span class="nc" id="L1211">                    RubySymbol m = getContext().newSymbol(method.getName());</span>
<span class="nc" id="L1212">                    array.slowPush(m);</span>
                }
<span class="nc" id="L1214">            }</span>
<span class="nc" id="L1215">            return array;</span>
        }
    }

    @CoreMethod(names = &quot;public_instance_methods&quot;, optional = 1)
    public abstract static class PublicInstanceMethodsNode extends CoreMethodNode {

        public PublicInstanceMethodsNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1223">            super(context, sourceSection);</span>
<span class="nc" id="L1224">        }</span>

        public PublicInstanceMethodsNode(PublicInstanceMethodsNode prev) {
<span class="nc" id="L1227">            super(prev);</span>
<span class="nc" id="L1228">        }</span>

        @Specialization
        public RubyArray publicInstanceMethods(RubyModule module, UndefinedPlaceholder argument) {
<span class="nc" id="L1232">            return publicInstanceMethods(module, false);</span>
        }

        @Specialization
        public RubyArray publicInstanceMethods(RubyModule module, boolean includeAncestors) {
<span class="nc" id="L1237">            notDesignedForCompilation();</span>

<span class="nc" id="L1239">            final RubyArray array = new RubyArray(getContext().getCoreLibrary().getArrayClass());</span>
<span class="nc" id="L1240">            final List&lt;RubyMethod&gt; methods = new ArrayList&lt;&gt;(module.getMethods().values());</span>
<span class="nc bnc" id="L1241" title="All 2 branches missed.">            if (includeAncestors) {</span>
<span class="nc bnc" id="L1242" title="All 2 branches missed.">                for (RubyModule parent : module.parentAncestors()) {</span>
<span class="nc" id="L1243">                    methods.addAll(parent.getMethods().values());</span>
<span class="nc" id="L1244">                }</span>
            }
<span class="nc bnc" id="L1246" title="All 2 branches missed.">            for (RubyMethod method : methods) {</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">                if (method.getVisibility() == Visibility.PUBLIC){</span>
<span class="nc" id="L1248">                    RubySymbol m = getContext().newSymbol(method.getName());</span>
<span class="nc" id="L1249">                    array.slowPush(m);</span>
                }
<span class="nc" id="L1251">            }</span>
<span class="nc" id="L1252">            return array;</span>
        }
    }

    @CoreMethod(names = &quot;instance_methods&quot;, optional = 1)
    public abstract static class InstanceMethodsNode extends CoreMethodNode {

        public InstanceMethodsNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1260">            super(context, sourceSection);</span>
<span class="nc" id="L1261">        }</span>

        public InstanceMethodsNode(InstanceMethodsNode prev) {
<span class="nc" id="L1264">            super(prev);</span>
<span class="nc" id="L1265">        }</span>

        @Specialization
        public RubyArray instanceMethods(RubyModule module, UndefinedPlaceholder argument) {
<span class="nc" id="L1269">            notDesignedForCompilation();</span>

<span class="nc" id="L1271">            return instanceMethods(module, true);</span>
        }

        @Specialization
        public RubyArray instanceMethods(RubyModule module, boolean includeAncestors) {
<span class="nc" id="L1276">            notDesignedForCompilation();</span>

            Map&lt;String, RubyMethod&gt; methods;

<span class="nc bnc" id="L1280" title="All 2 branches missed.">            if (includeAncestors) {</span>
<span class="nc" id="L1281">                methods = ModuleOperations.getAllMethods(module);</span>
            } else {
<span class="nc" id="L1283">                methods = module.getMethods();</span>
            }

<span class="nc" id="L1286">            final RubyArray array = new RubyArray(getContext().getCoreLibrary().getArrayClass());</span>
<span class="nc bnc" id="L1287" title="All 2 branches missed.">            for (RubyMethod method : methods.values()) {</span>
<span class="nc bnc" id="L1288" title="All 4 branches missed.">                if (method.getVisibility() != Visibility.PRIVATE &amp;&amp; !method.isUndefined()) {</span>
                    // TODO(CS): shoudln't be using this
<span class="nc" id="L1290">                    array.slowPush(getContext().newSymbol(method.getName()));</span>
                }
<span class="nc" id="L1292">            }</span>

<span class="nc" id="L1294">            return array;</span>
        }
    }

    @CoreMethod(names = &quot;private_constant&quot;, argumentsAsArray = true)
    public abstract static class PrivateConstantNode extends CoreMethodNode {

        public PrivateConstantNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1302">            super(context, sourceSection);</span>
<span class="nc" id="L1303">        }</span>

        public PrivateConstantNode(PrivateConstantNode prev) {
<span class="nc" id="L1306">            super(prev);</span>
<span class="nc" id="L1307">        }</span>

        @Specialization
        public RubyModule privateConstant(RubyModule module, Object[] args) {
<span class="nc" id="L1311">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L1313" title="All 2 branches missed.">            for (Object ob : args) {</span>
<span class="nc bnc" id="L1314" title="All 2 branches missed.">                if (ob instanceof RubySymbol){</span>
<span class="nc" id="L1315">                    module.changeConstantVisibility(this, (RubySymbol) ob, true);</span>
                }
            }
<span class="nc" id="L1318">            return module;</span>
        }
    }

    @CoreMethod(names = &quot;public_constant&quot;, argumentsAsArray = true)
    public abstract static class PublicConstantNode extends CoreMethodNode {

        public PublicConstantNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1326">            super(context, sourceSection);</span>
<span class="nc" id="L1327">        }</span>

        public PublicConstantNode(PublicConstantNode prev) {
<span class="nc" id="L1330">            super(prev);</span>
<span class="nc" id="L1331">        }</span>

        @Specialization
        public RubyModule publicConstant(RubyModule module, Object[] args) {
<span class="nc" id="L1335">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L1337" title="All 2 branches missed.">            for (Object ob : args) {</span>
<span class="nc bnc" id="L1338" title="All 2 branches missed.">                if (ob instanceof RubySymbol){</span>
<span class="nc" id="L1339">                    module.changeConstantVisibility(this, (RubySymbol) ob, false);</span>
                }
            }
<span class="nc" id="L1342">            return module;</span>
        }
    }

    @CoreMethod(names = &quot;protected&quot;, argumentsAsArray = true)
    public abstract static class ProtectedNode extends CoreMethodNode {

        public ProtectedNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1350">            super(context, sourceSection);</span>
<span class="nc" id="L1351">        }</span>

        public ProtectedNode(ProtectedNode prev) {
<span class="nc" id="L1354">            super(prev);</span>
<span class="nc" id="L1355">        }</span>

        @Specialization
        public RubyModule doProtected(VirtualFrame frame, RubyModule module, Object... args) {
<span class="nc" id="L1359">            notDesignedForCompilation();</span>

<span class="nc" id="L1361">            module.visibilityMethod(this, args, Visibility.PROTECTED);</span>
<span class="nc" id="L1362">            return module;</span>
        }
    }

    @CoreMethod(names = &quot;remove_class_variable&quot;, required = 1)
    public abstract static class RemoveClassVariableNode extends CoreMethodNode {

        public RemoveClassVariableNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1370">            super(context, sourceSection);</span>
<span class="nc" id="L1371">        }</span>

        public RemoveClassVariableNode(RemoveClassVariableNode prev) {
<span class="nc" id="L1374">            super(prev);</span>
<span class="nc" id="L1375">        }</span>

        @Specialization
        public RubyModule removeClassVariable(RubyModule module, RubyString name) {
<span class="nc" id="L1379">            notDesignedForCompilation();</span>

<span class="nc" id="L1381">            module.removeClassVariable(this, name.toString());</span>
<span class="nc" id="L1382">            return module;</span>
        }

        @Specialization
        public RubyModule removeClassVariable(RubyModule module, RubySymbol name) {
<span class="nc" id="L1387">            notDesignedForCompilation();</span>

<span class="nc" id="L1389">            module.removeClassVariable(this, name.toString());</span>
<span class="nc" id="L1390">            return module;</span>
        }

    }

    @CoreMethod(names = &quot;remove_method&quot;, required = 1)
    public abstract static class RemoveMethodNode extends CoreMethodNode {

        public RemoveMethodNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1399">            super(context, sourceSection);</span>
<span class="nc" id="L1400">        }</span>

        public RemoveMethodNode(RemoveMethodNode prev) {
<span class="nc" id="L1403">            super(prev);</span>
<span class="nc" id="L1404">        }</span>

        @Specialization
        public RubyModule removeMethod(RubyModule module, RubyString name) {
<span class="nc" id="L1408">            notDesignedForCompilation();</span>

<span class="nc" id="L1410">            module.removeMethod(this, name.toString());</span>
<span class="nc" id="L1411">            return module;</span>
        }

        @Specialization
        public RubyModule removeMethod(RubyModule module, RubySymbol name) {
<span class="nc" id="L1416">            notDesignedForCompilation();</span>

<span class="nc" id="L1418">            module.removeMethod(this, name.toString());</span>
<span class="nc" id="L1419">            return module;</span>
        }

    }

<span class="nc" id="L1424">    @CoreMethod(names = &quot;undef_method&quot;, required = 1)</span>
    public abstract static class UndefMethodNode extends CoreMethodNode {

        public UndefMethodNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1428">            super(context, sourceSection);</span>
<span class="nc" id="L1429">        }</span>

        public UndefMethodNode(UndefMethodNode prev) {
<span class="nc" id="L1432">            super(prev);</span>
<span class="nc" id="L1433">        }</span>

        @Specialization
        public RubyModule undefMethod(RubyClass rubyClass, RubyString name) {
<span class="nc" id="L1437">            notDesignedForCompilation();</span>

<span class="nc" id="L1439">            final RubyMethod method = ModuleOperations.lookupMethod(rubyClass, name.toString());</span>
<span class="nc bnc" id="L1440" title="All 2 branches missed.">            if (method == null) {</span>
<span class="nc" id="L1441">                throw new RaiseException(getContext().getCoreLibrary().noMethodError(name.toString(), rubyClass.toString(), this));</span>
            }
<span class="nc" id="L1443">            rubyClass.undefMethod(this, method);</span>
<span class="nc" id="L1444">            return rubyClass;</span>
        }

        @Specialization
        public RubyModule undefMethod(RubyClass rubyClass, RubySymbol name) {
<span class="nc" id="L1449">            notDesignedForCompilation();</span>

<span class="nc" id="L1451">            final RubyMethod method = ModuleOperations.lookupMethod(rubyClass, name.toString());</span>
<span class="nc bnc" id="L1452" title="All 2 branches missed.">            if (method == null) {</span>
<span class="nc" id="L1453">                throw new RaiseException(getContext().getCoreLibrary().noMethodError(name.toString(), rubyClass.toString(), this));</span>
            }
<span class="nc" id="L1455">            rubyClass.undefMethod(this, method);</span>
<span class="nc" id="L1456">            return rubyClass;</span>
        }

        @Specialization
        public RubyModule undefMethod(RubyModule module, RubyString name) {
<span class="nc" id="L1461">            notDesignedForCompilation();</span>

<span class="nc" id="L1463">            final RubyMethod method = ModuleOperations.lookupMethod(module, name.toString());</span>
<span class="nc bnc" id="L1464" title="All 2 branches missed.">            if (method == null) {</span>
<span class="nc" id="L1465">                throw new RaiseException(getContext().getCoreLibrary().noMethodError(name.toString(), module.toString(), this));</span>
            }
<span class="nc" id="L1467">            module.undefMethod(this, method);</span>
<span class="nc" id="L1468">            return module;</span>
        }

        @Specialization
        public RubyModule undefMethod(RubyModule module, RubySymbol name) {
<span class="nc" id="L1473">            notDesignedForCompilation();</span>

<span class="nc" id="L1475">            final RubyMethod method = ModuleOperations.lookupMethod(module, name.toString());</span>
<span class="nc bnc" id="L1476" title="All 2 branches missed.">            if (method == null) {</span>
<span class="nc" id="L1477">                throw new RaiseException(getContext().getCoreLibrary().noMethodError(name.toString(), module.toString(), this));</span>
            }
<span class="nc" id="L1479">            module.undefMethod(this, method);</span>
<span class="nc" id="L1480">            return module;</span>
        }

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>