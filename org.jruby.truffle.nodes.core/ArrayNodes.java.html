<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ArrayNodes.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby.truffle.nodes.core</a> &gt; <span class="el_source">ArrayNodes.java</span></div><h1>ArrayNodes.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013, 2014 Oracle and/or its affiliates. All rights reserved. This
 * code is released under a tri EPL/GPL/LGPL license. You can use it,
 * redistribute it and/or modify it under the terms of the:
 *
 * Eclipse Public License version 1.0
 * GNU General Public License version 2
 * GNU Lesser General Public License version 2.1
 */
package org.jruby.truffle.nodes.core;

import com.oracle.truffle.api.CallTarget;
import com.oracle.truffle.api.CompilerDirectives;
import com.oracle.truffle.api.Truffle;
import com.oracle.truffle.api.dsl.ImportGuards;
import com.oracle.truffle.api.dsl.Specialization;
import com.oracle.truffle.api.frame.FrameDescriptor;
import com.oracle.truffle.api.frame.FrameSlot;
import com.oracle.truffle.api.frame.VirtualFrame;
import com.oracle.truffle.api.nodes.ExplodeLoop;
import com.oracle.truffle.api.nodes.UnexpectedResultException;
import com.oracle.truffle.api.source.SourceSection;
import com.oracle.truffle.api.utilities.BranchProfile;
import org.jruby.runtime.Visibility;
import org.jruby.truffle.nodes.CoreSourceSection;
import org.jruby.truffle.nodes.RubyNode;
import org.jruby.truffle.nodes.RubyRootNode;
import org.jruby.truffle.nodes.dispatch.Dispatch;
import org.jruby.truffle.nodes.dispatch.DispatchHeadNode;
import org.jruby.truffle.nodes.dispatch.PredicateDispatchHeadNode;
import org.jruby.truffle.nodes.methods.arguments.MissingArgumentBehaviour;
import org.jruby.truffle.nodes.methods.arguments.ReadPreArgumentNode;
import org.jruby.truffle.nodes.methods.locals.ReadLevelVariableNodeFactory;
import org.jruby.truffle.nodes.yield.YieldDispatchHeadNode;
import org.jruby.truffle.runtime.DebugOperations;
import org.jruby.truffle.runtime.RubyArguments;
import org.jruby.truffle.runtime.RubyContext;
import org.jruby.truffle.runtime.UndefinedPlaceholder;
import org.jruby.truffle.runtime.control.BreakException;
import org.jruby.truffle.runtime.control.NextException;
import org.jruby.truffle.runtime.control.RaiseException;
import org.jruby.truffle.runtime.control.RedoException;
import org.jruby.truffle.runtime.core.*;
import org.jruby.truffle.runtime.methods.MethodLike;
import org.jruby.truffle.runtime.methods.SharedMethodInfo;
import org.jruby.truffle.runtime.util.ArrayUtils;
import org.jruby.util.Memo;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

@CoreClass(name = &quot;Array&quot;)
<span class="nc" id="L55">public abstract class ArrayNodes {</span>

    @CoreMethod(names = &quot;+&quot;, required = 1)
    public abstract static class AddNode extends ArrayCoreMethodNode {

        public AddNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L61">            super(context, sourceSection);</span>
<span class="nc" id="L62">        }</span>

        public AddNode(AddNode prev) {
<span class="nc" id="L65">            super(prev);</span>
<span class="nc" id="L66">        }</span>

        @Specialization(guards = {&quot;isObject&quot;, &quot;isOtherNull&quot;})
        public RubyArray addObjectNull(RubyArray a, RubyArray b) {
<span class="nc" id="L70">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), Arrays.copyOf((Object[]) a.getStore(), a.getSize()), a.getSize());</span>
        }

        @Specialization(guards = &quot;areBothIntegerFixnum&quot;)
        public RubyArray addBothIntegerFixnum(RubyArray a, RubyArray b) {
<span class="nc" id="L75">            final int combinedSize = a.getSize() + b.getSize();</span>
<span class="nc" id="L76">            final int[] combined = new int[combinedSize];</span>
<span class="nc" id="L77">            System.arraycopy(a.getStore(), 0, combined, 0, a.getSize());</span>
<span class="nc" id="L78">            System.arraycopy(b.getStore(), 0, combined, a.getSize(), b.getSize());</span>
<span class="nc" id="L79">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), combined, combinedSize);</span>
        }

        @Specialization(guards = &quot;areBothLongFixnum&quot;)
        public RubyArray addBothLongFixnum(RubyArray a, RubyArray b) {
<span class="nc" id="L84">            final int combinedSize = a.getSize() + b.getSize();</span>
<span class="nc" id="L85">            final long[] combined = new long[combinedSize];</span>
<span class="nc" id="L86">            System.arraycopy(a.getStore(), 0, combined, 0, a.getSize());</span>
<span class="nc" id="L87">            System.arraycopy(b.getStore(), 0, combined, a.getSize(), b.getSize());</span>
<span class="nc" id="L88">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), combined, combinedSize);</span>
        }

        @Specialization(guards = &quot;areBothFloat&quot;)
        public RubyArray addBothFloat(RubyArray a, RubyArray b) {
<span class="nc" id="L93">            final int combinedSize = a.getSize() + b.getSize();</span>
<span class="nc" id="L94">            final double[] combined = new double[combinedSize];</span>
<span class="nc" id="L95">            System.arraycopy(a.getStore(), 0, combined, 0, a.getSize());</span>
<span class="nc" id="L96">            System.arraycopy(b.getStore(), 0, combined, a.getSize(), b.getSize());</span>
<span class="nc" id="L97">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), combined, combinedSize);</span>
        }

        @Specialization(guards = &quot;areBothObject&quot;)
        public RubyArray addBothObject(RubyArray a, RubyArray b) {
<span class="nc" id="L102">            final int combinedSize = a.getSize() + b.getSize();</span>
<span class="nc" id="L103">            final Object[] combined = new Object[combinedSize];</span>
<span class="nc" id="L104">            System.arraycopy(a.getStore(), 0, combined, 0, a.getSize());</span>
<span class="nc" id="L105">            System.arraycopy(b.getStore(), 0, combined, a.getSize(), b.getSize());</span>
<span class="nc" id="L106">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), combined, combinedSize);</span>
        }

        @Specialization(guards = {&quot;isNull&quot;, &quot;isOtherIntegerFixnum&quot;})
        public RubyArray addNullIntegerFixnum(RubyArray a, RubyArray b) {
<span class="nc" id="L111">            final int size = b.getSize();</span>
<span class="nc" id="L112">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), Arrays.copyOf((int[]) b.getStore(), size), size);</span>
        }

        @Specialization(guards = {&quot;isNull&quot;, &quot;isOtherLongFixnum&quot;})
        public RubyArray addNullLongFixnum(RubyArray a, RubyArray b) {
<span class="nc" id="L117">            final int size = b.getSize();</span>
<span class="nc" id="L118">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), Arrays.copyOf((long[]) b.getStore(), size), size);</span>
        }

        @Specialization(guards = {&quot;isNull&quot;, &quot;isOtherObject&quot;})
        public RubyArray addNullObject(RubyArray a, RubyArray b) {
<span class="nc" id="L123">            final int size = b.getSize();</span>
<span class="nc" id="L124">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), Arrays.copyOf((Object[]) b.getStore(), size), size);</span>
        }

    }

    @CoreMethod(names = &quot;-&quot;, required = 1)
    public abstract static class SubNode extends ArrayCoreMethodNode {

        public SubNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L133">            super(context, sourceSection);</span>
<span class="nc" id="L134">        }</span>

        public SubNode(SubNode prev) {
<span class="nc" id="L137">            super(prev);</span>
<span class="nc" id="L138">        }</span>

        @Specialization(guards = &quot;areBothIntegerFixnum&quot;)
        public RubyArray subIntegerFixnum(RubyArray a, RubyArray b) {
<span class="nc" id="L142">            notDesignedForCompilation();</span>

<span class="nc" id="L144">            final int[] as = (int[]) a.getStore();</span>
<span class="nc" id="L145">            final int[] bs = (int[]) b.getStore();</span>

<span class="nc" id="L147">            final int[] sub = new int[a.getSize()];</span>

<span class="nc" id="L149">            int i = 0;</span>

<span class="nc bnc" id="L151" title="All 2 branches missed.">            for (int n = 0; n &lt; a.getSize(); n++) {</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">                if (!ArrayUtils.contains(bs, as[n])) {</span>
<span class="nc" id="L153">                    sub[i] = as[n];</span>
<span class="nc" id="L154">                    i++;</span>
                }
            }

<span class="nc" id="L158">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), sub, i);</span>
        }

        @Specialization(guards = &quot;areBothLongFixnum&quot;)
        public RubyArray subLongFixnum(RubyArray a, RubyArray b) {
<span class="nc" id="L163">            notDesignedForCompilation();</span>

<span class="nc" id="L165">            final long[] as = (long[]) a.getStore();</span>
<span class="nc" id="L166">            final long[] bs = (long[]) b.getStore();</span>

<span class="nc" id="L168">            final long[] sub = new long[a.getSize()];</span>

<span class="nc" id="L170">            int i = 0;</span>

<span class="nc bnc" id="L172" title="All 2 branches missed.">            for (int n = 0; n &lt; a.getSize(); n++) {</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">                if (!ArrayUtils.contains(bs, as[n])) {</span>
<span class="nc" id="L174">                    sub[i] = as[n];</span>
<span class="nc" id="L175">                    i++;</span>
                }
            }

<span class="nc" id="L179">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), sub, i);</span>
        }

        @Specialization(guards = &quot;areBothFloat&quot;)
        public RubyArray subDouble(RubyArray a, RubyArray b) {
<span class="nc" id="L184">            notDesignedForCompilation();</span>

<span class="nc" id="L186">            final double[] as = (double[]) a.getStore();</span>
<span class="nc" id="L187">            final double[] bs = (double[]) b.getStore();</span>

<span class="nc" id="L189">            final double[] sub = new double[a.getSize()];</span>

<span class="nc" id="L191">            int i = 0;</span>

<span class="nc bnc" id="L193" title="All 2 branches missed.">            for (int n = 0; n &lt; a.getSize(); n++) {</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">                if (!ArrayUtils.contains(bs, as[n])) {</span>
<span class="nc" id="L195">                    sub[i] = as[n];</span>
<span class="nc" id="L196">                    i++;</span>
                }
            }

<span class="nc" id="L200">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), sub, i);</span>
        }

        @Specialization(guards = &quot;areBothObject&quot;)
        public RubyArray subObject(RubyArray a, RubyArray b) {
<span class="nc" id="L205">            notDesignedForCompilation();</span>

<span class="nc" id="L207">            final Object[] as = (Object[]) a.getStore();</span>
<span class="nc" id="L208">            final Object[] bs = (Object[]) b.getStore();</span>

<span class="nc" id="L210">            final Object[] sub = new Object[a.getSize()];</span>

<span class="nc" id="L212">            int i = 0;</span>

<span class="nc bnc" id="L214" title="All 2 branches missed.">            for (int n = 0; n &lt; a.getSize(); n++) {</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                if (!ArrayUtils.contains(bs, b.getSize(), as[n])) {</span>
<span class="nc" id="L216">                    sub[i] = as[n];</span>
<span class="nc" id="L217">                    i++;</span>
                }
            }

<span class="nc" id="L221">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), sub, i);</span>
        }

        @Specialization(guards = {&quot;isObject&quot;, &quot;isOtherIntegerFixnum&quot;})
        public RubyArray subObjectIntegerFixnum(RubyArray a, RubyArray b) {
<span class="nc" id="L226">            notDesignedForCompilation();</span>

<span class="nc" id="L228">            final Object[] as = (Object[]) a.getStore();</span>
<span class="nc" id="L229">            final Object[] bs = ArrayUtils.box((int[]) b.getStore());</span>

<span class="nc" id="L231">            final Object[] sub = new Object[a.getSize()];</span>

<span class="nc" id="L233">            int i = 0;</span>

<span class="nc bnc" id="L235" title="All 2 branches missed.">            for (int n = 0; n &lt; a.getSize(); n++) {</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">                if (!ArrayUtils.contains(bs, b.getSize(), as[n])) {</span>
<span class="nc" id="L237">                    sub[i] = as[n];</span>
<span class="nc" id="L238">                    i++;</span>
                }
            }

<span class="nc" id="L242">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), sub, i);</span>
        }

        @Specialization
        public RubyArray sub(RubyArray a, RubyArray b) {
<span class="nc" id="L247">            notDesignedForCompilation();</span>

<span class="nc" id="L249">            final Object[] as = a.slowToArray();</span>
<span class="nc" id="L250">            final Object[] bs = b.slowToArray();</span>

<span class="nc" id="L252">            final Object[] sub = new Object[a.getSize()];</span>

<span class="nc" id="L254">            int i = 0;</span>

<span class="nc bnc" id="L256" title="All 2 branches missed.">            for (int n = 0; n &lt; a.getSize(); n++) {</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">                if (!ArrayUtils.contains(bs, b.getSize(), as[n])) {</span>
<span class="nc" id="L258">                    sub[i] = as[n];</span>
<span class="nc" id="L259">                    i++;</span>
                }
            }

<span class="nc" id="L263">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), sub, i);</span>
        }

    }

    @CoreMethod(names = &quot;*&quot;, required = 1, lowerFixnumParameters = 0)
    public abstract static class MulNode extends ArrayCoreMethodNode {

        public MulNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L272">            super(context, sourceSection);</span>
<span class="nc" id="L273">        }</span>

        public MulNode(MulNode prev) {
<span class="nc" id="L276">            super(prev);</span>
<span class="nc" id="L277">        }</span>

        @Specialization(guards = &quot;isNull&quot;)
        public RubyArray mulEmpty(RubyArray array, int count) {
<span class="nc" id="L281">            return new RubyArray(getContext().getCoreLibrary().getArrayClass());</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public RubyArray mulIntegerFixnum(RubyArray array, int count) {
<span class="nc" id="L286">            final int[] store = (int[]) array.getStore();</span>
<span class="nc" id="L287">            final int storeLength = store.length;</span>
<span class="nc" id="L288">            final int newStoreLength = storeLength * count;</span>
<span class="nc" id="L289">            final int[] newStore = new int[newStoreLength];</span>

<span class="nc bnc" id="L291" title="All 2 branches missed.">            for (int n = 0; n &lt; count; n++) {</span>
<span class="nc" id="L292">                System.arraycopy(store, 0, newStore, storeLength * n, storeLength);</span>
            }

<span class="nc" id="L295">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), array.getAllocationSite(), newStore, newStoreLength);</span>
        }

        @Specialization(guards = &quot;isLongFixnum&quot;)
        public RubyArray mulLongFixnum(RubyArray array, int count) {
<span class="nc" id="L300">            final long[] store = (long[]) array.getStore();</span>
<span class="nc" id="L301">            final int storeLength = store.length;</span>
<span class="nc" id="L302">            final int newStoreLength = storeLength * count;</span>
<span class="nc" id="L303">            final long[] newStore = new long[newStoreLength];</span>

<span class="nc bnc" id="L305" title="All 2 branches missed.">            for (int n = 0; n &lt; count; n++) {</span>
<span class="nc" id="L306">                System.arraycopy(store, 0, newStore, storeLength * n, storeLength);</span>
            }

<span class="nc" id="L309">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), array.getAllocationSite(), newStore, newStoreLength);</span>
        }

        @Specialization(guards = &quot;isFloat&quot;)
        public RubyArray mulFloat(RubyArray array, int count) {
<span class="nc" id="L314">            final double[] store = (double[]) array.getStore();</span>
<span class="nc" id="L315">            final int storeLength = store.length;</span>
<span class="nc" id="L316">            final int newStoreLength = storeLength * count;</span>
<span class="nc" id="L317">            final double[] newStore = new double[newStoreLength];</span>

<span class="nc bnc" id="L319" title="All 2 branches missed.">            for (int n = 0; n &lt; count; n++) {</span>
<span class="nc" id="L320">                System.arraycopy(store, 0, newStore, storeLength * n, storeLength);</span>
            }

<span class="nc" id="L323">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), array.getAllocationSite(), newStore, newStoreLength);</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public RubyArray mulObject(RubyArray array, int count) {
<span class="nc" id="L328">            final Object[] store = (Object[]) array.getStore();</span>
<span class="nc" id="L329">            final int storeLength = store.length;</span>
<span class="nc" id="L330">            final int newStoreLength = storeLength * count;</span>
<span class="nc" id="L331">            final Object[] newStore = new Object[newStoreLength];</span>

<span class="nc bnc" id="L333" title="All 2 branches missed.">            for (int n = 0; n &lt; count; n++) {</span>
<span class="nc" id="L334">                System.arraycopy(store, 0, newStore, storeLength * n, storeLength);</span>
            }

<span class="nc" id="L337">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), array.getAllocationSite(), newStore, newStoreLength);</span>
        }

    }

    @CoreMethod(names = &quot;|&quot;, required = 1)
    public abstract static class UnionNode extends ArrayCoreMethodNode {

        public UnionNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L346">            super(context, sourceSection);</span>
<span class="nc" id="L347">        }</span>

        public UnionNode(UnionNode prev) {
<span class="nc" id="L350">            super(prev);</span>
<span class="nc" id="L351">        }</span>

        @Specialization(guards = &quot;areBothIntegerFixnum&quot;)
        public RubyArray orIntegerFixnum(RubyArray a, RubyArray b) {
<span class="nc" id="L355">            notDesignedForCompilation();</span>

<span class="nc" id="L357">            final int[] as = (int[]) a.getStore();</span>
<span class="nc" id="L358">            final int[] bs = (int[]) b.getStore();</span>

<span class="nc" id="L360">            final int[] or = Arrays.copyOf(as, a.getSize() + b.getSize());</span>

<span class="nc" id="L362">            int i = a.getSize();</span>

<span class="nc bnc" id="L364" title="All 2 branches missed.">            for (int n = 0; n &lt; b.getSize(); n++) {</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                if (!ArrayUtils.contains(as, bs[n])) {</span>
<span class="nc" id="L366">                    or[i] = bs[n];</span>
<span class="nc" id="L367">                    i++;</span>
                }
            }

<span class="nc" id="L371">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), or, i);</span>
        }

        @Specialization(guards = &quot;areBothLongFixnum&quot;)
        public RubyArray orLongFixnum(RubyArray a, RubyArray b) {
<span class="nc" id="L376">            notDesignedForCompilation();</span>

<span class="nc" id="L378">            final long[] as = (long[]) a.getStore();</span>
<span class="nc" id="L379">            final long[] bs = (long[]) b.getStore();</span>

<span class="nc" id="L381">            final long[] or = Arrays.copyOf(as, a.getSize() + b.getSize());</span>

<span class="nc" id="L383">            int i = a.getSize();</span>

<span class="nc bnc" id="L385" title="All 2 branches missed.">            for (int n = 0; n &lt; b.getSize(); n++) {</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">                if (!ArrayUtils.contains(as, bs[n])) {</span>
<span class="nc" id="L387">                    or[i] = bs[n];</span>
<span class="nc" id="L388">                    i++;</span>
                }
            }

<span class="nc" id="L392">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), or, i);</span>
        }

        @Specialization(guards = &quot;areBothFloat&quot;)
        public RubyArray orDouble(RubyArray a, RubyArray b) {
<span class="nc" id="L397">            notDesignedForCompilation();</span>

<span class="nc" id="L399">            final double[] as = (double[]) a.getStore();</span>
<span class="nc" id="L400">            final double[] bs = (double[]) b.getStore();</span>

<span class="nc" id="L402">            final double[] or = Arrays.copyOf(as, a.getSize() + b.getSize());</span>

<span class="nc" id="L404">            int i = a.getSize();</span>

<span class="nc bnc" id="L406" title="All 2 branches missed.">            for (int n = 0; n &lt; b.getSize(); n++) {</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">                if (!ArrayUtils.contains(as, bs[n])) {</span>
<span class="nc" id="L408">                    or[i] = bs[n];</span>
<span class="nc" id="L409">                    i++;</span>
                }
            }

<span class="nc" id="L413">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), or, i);</span>
        }

        @Specialization(guards = &quot;areBothObject&quot;)
        public RubyArray orObject(RubyArray a, RubyArray b) {
<span class="nc" id="L418">            notDesignedForCompilation();</span>

<span class="nc" id="L420">            final Object[] as = (Object[]) a.getStore();</span>
<span class="nc" id="L421">            final Object[] bs = (Object[]) b.getStore();</span>

<span class="nc" id="L423">            final Object[] or = Arrays.copyOf(as, a.getSize() + b.getSize());</span>

<span class="nc" id="L425">            int i = a.getSize();</span>

<span class="nc bnc" id="L427" title="All 2 branches missed.">            for (int n = 0; n &lt; b.getSize(); n++) {</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">                if (!ArrayUtils.contains(as, a.getSize(), bs[n])) {</span>
<span class="nc" id="L429">                    or[i] = bs[n];</span>
<span class="nc" id="L430">                    i++;</span>
                }
            }

<span class="nc" id="L434">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), or, i);</span>
        }

    }

    @CoreMethod(names = {&quot;==&quot;, &quot;eql?&quot;}, required = 1)
    public abstract static class EqualNode extends ArrayCoreMethodNode {

        @Child protected PredicateDispatchHeadNode equals;

        public EqualNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L445">            super(context, sourceSection);</span>
<span class="nc" id="L446">            equals = new PredicateDispatchHeadNode(context);</span>
<span class="nc" id="L447">        }</span>

        public EqualNode(EqualNode prev) {
<span class="nc" id="L450">            super(prev);</span>
<span class="nc" id="L451">            equals = prev.equals;</span>
<span class="nc" id="L452">        }</span>

        @Specialization(guards = &quot;areBothIntegerFixnum&quot;)
        public boolean equalIntegerFixnum(RubyArray a, RubyArray b) {
<span class="nc" id="L456">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L458" title="All 2 branches missed.">            if (a == b) {</span>
<span class="nc" id="L459">                return true;</span>
            }

<span class="nc bnc" id="L462" title="All 2 branches missed.">            if (a.getSize() != b.getSize()) {</span>
<span class="nc" id="L463">                return false;</span>
            }

<span class="nc" id="L466">            return Arrays.equals((int[]) a.getStore(), (int[]) b.getStore());</span>
        }

        @Specialization(guards = &quot;areBothLongFixnum&quot;)
        public boolean equalLongFixnum(RubyArray a, RubyArray b) {
<span class="nc" id="L471">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L473" title="All 2 branches missed.">            if (a == b) {</span>
<span class="nc" id="L474">                return true;</span>
            }

<span class="nc bnc" id="L477" title="All 2 branches missed.">            if (a.getSize() != b.getSize()) {</span>
<span class="nc" id="L478">                return false;</span>
            }

<span class="nc" id="L481">            return Arrays.equals((long[]) a.getStore(), (long[]) b.getStore());</span>
        }

        @Specialization(guards = &quot;areBothFloat&quot;)
        public boolean equalFloat(RubyArray a, RubyArray b) {
<span class="nc" id="L486">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L488" title="All 2 branches missed.">            if (a == b) {</span>
<span class="nc" id="L489">                return true;</span>
            }

<span class="nc bnc" id="L492" title="All 2 branches missed.">            if (a.getSize() != b.getSize()) {</span>
<span class="nc" id="L493">                return false;</span>
            }

<span class="nc" id="L496">            return Arrays.equals((double[]) a.getStore(), (double[]) b.getStore());</span>
        }

        @Specialization
        public boolean equal(VirtualFrame frame, RubyArray a, RubyArray b) {
<span class="nc" id="L501">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L503" title="All 2 branches missed.">            if (a == b) {</span>
<span class="nc" id="L504">                return true;</span>
            }

<span class="nc bnc" id="L507" title="All 2 branches missed.">            if (a.getSize() != b.getSize()) {</span>
<span class="nc" id="L508">                return false;</span>
            }

<span class="nc" id="L511">            final Object[] as = a.slowToArray();</span>
<span class="nc" id="L512">            final Object[] bs = b.slowToArray();</span>

<span class="nc bnc" id="L514" title="All 2 branches missed.">            for (int n = 0; n &lt; a.getSize(); n++) {</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">                if (!equals.call(frame, as[n], &quot;==&quot;, null, bs[n])) {</span>
<span class="nc" id="L516">                    return false;</span>
                }
            }

<span class="nc" id="L520">            return true;</span>
        }

        @Specialization
        public boolean equal(VirtualFrame frame, RubyArray a, Object b) {
<span class="nc" id="L525">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L527" title="All 2 branches missed.">            if (!(b instanceof RubyArray)) {</span>
<span class="nc" id="L528">                return false;</span>
            } else {
<span class="nc" id="L530">                return equal(frame, a, (RubyArray) b);</span>
            }
        }

    }

    @CoreMethod(names = {&quot;[]&quot;, &quot;at&quot;}, required = 1, optional = 1, lowerFixnumParameters = {0, 1})
    public abstract static class IndexNode extends ArrayCoreMethodNode {

        public IndexNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L540">            super(context, sourceSection);</span>
<span class="nc" id="L541">        }</span>

        public IndexNode(IndexNode prev) {
<span class="nc" id="L544">            super(prev);</span>
<span class="nc" id="L545">        }</span>

        @Specialization(guards = &quot;isNull&quot;)
        public RubyNilClass getNull(RubyArray array, int index, UndefinedPlaceholder undefined) {
<span class="nc" id="L549">            return getContext().getCoreLibrary().getNilObject();</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;, rewriteOn=UnexpectedResultException.class)
        public int getIntegerFixnumInBounds(RubyArray array, int index, UndefinedPlaceholder undefined) throws UnexpectedResultException {
<span class="nc" id="L554">            int normalisedIndex = array.normaliseIndex(index);</span>

<span class="nc bnc" id="L556" title="All 4 branches missed.">            if (normalisedIndex &lt; 0 || normalisedIndex &gt;= array.getSize()) {</span>
<span class="nc" id="L557">                throw new UnexpectedResultException(getContext().getCoreLibrary().getNilObject());</span>
            } else {
<span class="nc" id="L559">                return ((int[]) array.getStore())[normalisedIndex];</span>
            }
        }

        @Specialization(contains = &quot;getIntegerFixnumInBounds&quot;, guards = &quot;isIntegerFixnum&quot;)
        public Object getIntegerFixnum(RubyArray array, int index, UndefinedPlaceholder undefined) {
<span class="nc" id="L565">            int normalisedIndex = array.normaliseIndex(index);</span>

<span class="nc bnc" id="L567" title="All 4 branches missed.">            if (normalisedIndex &lt; 0 || normalisedIndex &gt;= array.getSize()) {</span>
<span class="nc" id="L568">                return getContext().getCoreLibrary().getNilObject();</span>
            } else {
<span class="nc" id="L570">                return ((int[]) array.getStore())[normalisedIndex];</span>
            }
        }

        @Specialization(guards = &quot;isLongFixnum&quot;, rewriteOn=UnexpectedResultException.class)
        public long getLongFixnumInBounds(RubyArray array, int index, UndefinedPlaceholder undefined) throws UnexpectedResultException {
<span class="nc" id="L576">            int normalisedIndex = array.normaliseIndex(index);</span>

<span class="nc bnc" id="L578" title="All 4 branches missed.">            if (normalisedIndex &lt; 0 || normalisedIndex &gt;= array.getSize()) {</span>
<span class="nc" id="L579">                throw new UnexpectedResultException(getContext().getCoreLibrary().getNilObject());</span>
            } else {
<span class="nc" id="L581">                return ((long[]) array.getStore())[normalisedIndex];</span>
            }
        }

        @Specialization(contains = &quot;getLongFixnumInBounds&quot;, guards = &quot;isLongFixnum&quot;)
        public Object getLongFixnum(RubyArray array, int index, UndefinedPlaceholder undefined) {

<span class="nc" id="L588">            int normalisedIndex = array.normaliseIndex(index);</span>

<span class="nc bnc" id="L590" title="All 4 branches missed.">            if (normalisedIndex &lt; 0 || normalisedIndex &gt;= array.getSize()) {</span>
<span class="nc" id="L591">                return getContext().getCoreLibrary().getNilObject();</span>
            } else {
<span class="nc" id="L593">                return ((long[]) array.getStore())[normalisedIndex];</span>
            }
        }

        @Specialization(guards = &quot;isFloat&quot;, rewriteOn=UnexpectedResultException.class)
        public double getFloatInBounds(RubyArray array, int index, UndefinedPlaceholder undefined) throws UnexpectedResultException {
<span class="nc" id="L599">            int normalisedIndex = array.normaliseIndex(index);</span>

<span class="nc bnc" id="L601" title="All 4 branches missed.">            if (normalisedIndex &lt; 0 || normalisedIndex &gt;= array.getSize()) {</span>
<span class="nc" id="L602">                throw new UnexpectedResultException(getContext().getCoreLibrary().getNilObject());</span>
            } else {
<span class="nc" id="L604">                return ((double[]) array.getStore())[normalisedIndex];</span>
            }
        }

        @Specialization(contains = &quot;getFloatInBounds&quot;, guards = &quot;isFloat&quot;)
        public Object getFloat(RubyArray array, int index, UndefinedPlaceholder undefined) {
<span class="nc" id="L610">            int normalisedIndex = array.normaliseIndex(index);</span>

<span class="nc bnc" id="L612" title="All 4 branches missed.">            if (normalisedIndex &lt; 0 || normalisedIndex &gt;= array.getSize()) {</span>
<span class="nc" id="L613">                return getContext().getCoreLibrary().getNilObject();</span>
            } else {
<span class="nc" id="L615">                return ((double[]) array.getStore())[normalisedIndex];</span>
            }
        }

        @Specialization(guards = &quot;isObject&quot;)
        public Object getObject(RubyArray array, int index, UndefinedPlaceholder undefined) {
<span class="nc" id="L621">            int normalisedIndex = array.normaliseIndex(index);</span>

<span class="nc bnc" id="L623" title="All 4 branches missed.">            if (normalisedIndex &lt; 0 || normalisedIndex &gt;= array.getSize()) {</span>
<span class="nc" id="L624">                return getContext().getCoreLibrary().getNilObject();</span>
            } else {
<span class="nc" id="L626">                return ((Object[]) array.getStore())[normalisedIndex];</span>
            }
        }

        @Specialization(guards = &quot;isObject&quot;)
        public Object getObject(RubyArray array, int index, int length) {
<span class="nc" id="L632">            notDesignedForCompilation();</span>

<span class="nc" id="L634">            int normalisedIndex = array.normaliseIndex(index);</span>

<span class="nc bnc" id="L636" title="All 4 branches missed.">            if (normalisedIndex &lt; 0 || normalisedIndex &gt;= array.getSize()) {</span>
<span class="nc" id="L637">                return getContext().getCoreLibrary().getNilObject();</span>
            } else {
<span class="nc" id="L639">                return new RubyArray(getContext().getCoreLibrary().getArrayClass(), Arrays.copyOfRange((Object[]) array.getStore(), normalisedIndex, normalisedIndex + length), length);</span>
            }
        }

        @Specialization(guards = &quot;isObject&quot;)
        public Object getObject(RubyArray array, RubyRange.IntegerFixnumRange range, UndefinedPlaceholder undefined) {
<span class="nc" id="L645">            notDesignedForCompilation();</span>

<span class="nc" id="L647">            final int normalisedIndex = array.normaliseIndex(range.getBegin());</span>

<span class="nc bnc" id="L649" title="All 4 branches missed.">            if (normalisedIndex &lt; 0 || normalisedIndex &gt;= array.getSize()) {</span>
<span class="nc" id="L650">                return getContext().getCoreLibrary().getNilObject();</span>
            } else {
<span class="nc" id="L652">                final int end = array.normaliseIndex(range.getEnd());</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">                final int excludingEnd = array.clampExclusiveIndex(range.doesExcludeEnd() ? end : end+1);</span>

<span class="nc" id="L655">                return new RubyArray(getContext().getCoreLibrary().getArrayClass(), Arrays.copyOfRange((Object[]) array.getStore(), normalisedIndex, excludingEnd), excludingEnd - normalisedIndex);</span>
            }
        }

    }

    @CoreMethod(names = &quot;[]=&quot;, required = 2, optional = 1, lowerFixnumParameters = 0)
    public abstract static class IndexSetNode extends ArrayCoreMethodNode {

<span class="nc" id="L664">        private final BranchProfile tooSmallBranch = BranchProfile.create();</span>
<span class="nc" id="L665">        private final BranchProfile pastEndBranch = BranchProfile.create();</span>
<span class="nc" id="L666">        private final BranchProfile appendBranch = BranchProfile.create();</span>
<span class="nc" id="L667">        private final BranchProfile beyondBranch = BranchProfile.create();</span>
<span class="nc" id="L668">        private final BranchProfile reallocateBranch = BranchProfile.create();</span>

        public IndexSetNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L671">            super(context, sourceSection);</span>
<span class="nc" id="L672">        }</span>

        public IndexSetNode(IndexSetNode prev) {
<span class="nc" id="L675">            super(prev);</span>
<span class="nc" id="L676">        }</span>

        @Specialization(guards = &quot;isNull&quot;)
        public Object setNullIntegerFixnum(RubyArray array, int index, int value, UndefinedPlaceholder unused) {
<span class="nc bnc" id="L680" title="All 2 branches missed.">            if (index == 0) {</span>
<span class="nc" id="L681">                array.setStore(new int[]{value}, 1);</span>
            } else {
<span class="nc" id="L683">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L684">                throw new UnsupportedOperationException();</span>
            }

<span class="nc" id="L687">            return value;</span>
        }

        @Specialization(guards = &quot;isNull&quot;)
        public Object setNullLongFixnum(RubyArray array, int index, long value, UndefinedPlaceholder unused) {
<span class="nc bnc" id="L692" title="All 2 branches missed.">            if (index == 0) {</span>
<span class="nc" id="L693">                array.setStore(new long[]{value}, 1);</span>
            } else {
<span class="nc" id="L695">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L696">                throw new UnsupportedOperationException();</span>
            }

<span class="nc" id="L699">            return value;</span>
        }

        @Specialization(guards = &quot;isNull&quot;)
        public Object setNullObject(RubyArray array, int index, Object value, UndefinedPlaceholder unused) {
<span class="nc" id="L704">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L706" title="All 2 branches missed.">            if (index == 0) {</span>
<span class="nc" id="L707">                array.slowPush(value);</span>
            } else {
<span class="nc" id="L709">                throw new UnsupportedOperationException();</span>
            }

<span class="nc" id="L712">            return value;</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public int setIntegerFixnum(RubyArray array, int index, int value, UndefinedPlaceholder unused) {
<span class="nc" id="L717">            final int normalisedIndex = array.normaliseIndex(index);</span>
<span class="nc" id="L718">            int[] store = (int[]) array.getStore();</span>

<span class="nc bnc" id="L720" title="All 2 branches missed.">            if (normalisedIndex &lt; 0) {</span>
<span class="nc" id="L721">                tooSmallBranch.enter();</span>
<span class="nc" id="L722">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L723">                throw new RaiseException(getContext().getCoreLibrary().indexTooSmallError(&quot;array&quot;, index, array.getSize(), this));</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">            } else if (normalisedIndex &gt;= array.getSize()) {</span>
<span class="nc" id="L725">                pastEndBranch.enter();</span>

<span class="nc bnc" id="L727" title="All 2 branches missed.">                if (normalisedIndex == array.getSize()) {</span>
<span class="nc" id="L728">                    appendBranch.enter();</span>

<span class="nc bnc" id="L730" title="All 2 branches missed.">                    if (normalisedIndex &gt;= store.length) {</span>
<span class="nc" id="L731">                        reallocateBranch.enter();</span>
<span class="nc" id="L732">                        array.setStore(store = Arrays.copyOf(store, ArrayUtils.capacity(store.length, normalisedIndex + 1)), array.getSize());</span>
                    }

<span class="nc" id="L735">                    store[normalisedIndex] = value;</span>
<span class="nc" id="L736">                    array.setSize(array.getSize() + 1);</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">                } else if (normalisedIndex &gt; array.getSize()) {</span>
<span class="nc" id="L738">                    beyondBranch.enter();</span>
<span class="nc" id="L739">                    throw new UnsupportedOperationException();</span>
                }
            } else {
<span class="nc" id="L742">                store[normalisedIndex] = value;</span>
            }

<span class="nc" id="L745">            return value;</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public long setLongInIntegerFixnum(RubyArray array, int index, long value, UndefinedPlaceholder unused) {
<span class="nc bnc" id="L750" title="All 2 branches missed.">            if (array.getAllocationSite() != null) {</span>
<span class="nc" id="L751">                array.getAllocationSite().convertedIntToLong();</span>
            }

<span class="nc" id="L754">            final int normalisedIndex = array.normaliseIndex(index);</span>

<span class="nc" id="L756">            long[] store = ArrayUtils.longCopyOf((int[]) array.getStore());</span>
<span class="nc" id="L757">            array.setStore(store, array.getSize());</span>

<span class="nc bnc" id="L759" title="All 2 branches missed.">            if (normalisedIndex &lt; 0) {</span>
<span class="nc" id="L760">                tooSmallBranch.enter();</span>
<span class="nc" id="L761">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L762">                throw new RaiseException(getContext().getCoreLibrary().indexTooSmallError(&quot;array&quot;, index, array.getSize(), this));</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">            } else if (normalisedIndex &gt;= array.getSize()) {</span>
<span class="nc" id="L764">                pastEndBranch.enter();</span>

<span class="nc bnc" id="L766" title="All 2 branches missed.">                if (normalisedIndex == array.getSize()) {</span>
<span class="nc" id="L767">                    appendBranch.enter();</span>

<span class="nc bnc" id="L769" title="All 2 branches missed.">                    if (normalisedIndex &gt;= store.length) {</span>
<span class="nc" id="L770">                        reallocateBranch.enter();</span>
<span class="nc" id="L771">                        array.setStore(store = Arrays.copyOf(store, ArrayUtils.capacity(store.length, normalisedIndex + 1)), array.getSize());</span>
                    }

<span class="nc" id="L774">                    store[normalisedIndex] = value;</span>
<span class="nc" id="L775">                    array.setSize(array.getSize() + 1);</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">                } else if (normalisedIndex &gt; array.getSize()) {</span>
<span class="nc" id="L777">                    beyondBranch.enter();</span>
<span class="nc" id="L778">                    throw new UnsupportedOperationException();</span>
                }
            } else {
<span class="nc" id="L781">                store[normalisedIndex] = value;</span>
            }

<span class="nc" id="L784">            return value;</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public RubyArray setIntegerFixnum(RubyArray array, int start, int length, RubyArray value) {
<span class="nc" id="L789">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L791" title="All 2 branches missed.">            if (length &lt; 0) {</span>
<span class="nc" id="L792">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L793">                throw new RaiseException(getContext().getCoreLibrary().indexNegativeLength(length, this));</span>
            }

<span class="nc bnc" id="L796" title="All 2 branches missed.">            if (value.getSize() == 0) {</span>
<span class="nc" id="L797">                final int begin = array.normaliseIndex(start);</span>
<span class="nc" id="L798">                final int exclusiveEnd = begin + length;</span>
<span class="nc" id="L799">                int[] store = (int[]) array.getStore();</span>

<span class="nc bnc" id="L801" title="All 2 branches missed.">                if (begin &lt; 0) {</span>
<span class="nc" id="L802">                    tooSmallBranch.enter();</span>
<span class="nc" id="L803">                    CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L804">                    throw new RaiseException(getContext().getCoreLibrary().indexTooSmallError(&quot;array&quot;, start, array.getSize(), this));</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">                } else if (exclusiveEnd &gt; array.getSize()) {</span>
<span class="nc" id="L806">                    throw new UnsupportedOperationException();</span>
                }

                // TODO: This is a moving overlapping memory, should we use sth else instead?
<span class="nc" id="L810">                System.arraycopy(store, exclusiveEnd, store, begin, array.getSize() - exclusiveEnd);</span>
<span class="nc" id="L811">                array.setSize(array.getSize() - length);</span>

<span class="nc" id="L813">                return value;</span>
            } else {
<span class="nc" id="L815">                throw new UnsupportedOperationException();</span>
            }
        }

        @Specialization(guards = &quot;isLongFixnum&quot;)
        public int setLongFixnum(RubyArray array, int index, int value, UndefinedPlaceholder unused) {
<span class="nc" id="L821">            setLongFixnum(array, index, (long) value, unused);</span>
<span class="nc" id="L822">            return value;</span>
        }

        @Specialization(guards = &quot;isLongFixnum&quot;)
        public long setLongFixnum(RubyArray array, int index, long value, UndefinedPlaceholder unused) {
<span class="nc" id="L827">            final int normalisedIndex = array.normaliseIndex(index);</span>
<span class="nc" id="L828">            long[] store = (long[]) array.getStore();</span>

<span class="nc bnc" id="L830" title="All 2 branches missed.">            if (normalisedIndex &lt; 0) {</span>
<span class="nc" id="L831">                tooSmallBranch.enter();</span>
<span class="nc" id="L832">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L833">                throw new RaiseException(getContext().getCoreLibrary().indexTooSmallError(&quot;array&quot;, index, array.getSize(), this));</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">            } else if (normalisedIndex &gt;= array.getSize()) {</span>
<span class="nc" id="L835">                pastEndBranch.enter();</span>

<span class="nc bnc" id="L837" title="All 2 branches missed.">                if (normalisedIndex == array.getSize()) {</span>
<span class="nc" id="L838">                    appendBranch.enter();</span>

<span class="nc bnc" id="L840" title="All 2 branches missed.">                    if (normalisedIndex &gt;= store.length) {</span>
<span class="nc" id="L841">                        reallocateBranch.enter();</span>
<span class="nc" id="L842">                        array.setStore(store = Arrays.copyOf(store, ArrayUtils.capacity(store.length, normalisedIndex + 1)), array.getSize());</span>
                    }

<span class="nc" id="L845">                    store[normalisedIndex] = value;</span>
<span class="nc" id="L846">                    array.setSize(array.getSize() + 1);</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">                } else if (normalisedIndex &gt; array.getSize()) {</span>
<span class="nc" id="L848">                    beyondBranch.enter();</span>
<span class="nc" id="L849">                    throw new UnsupportedOperationException();</span>
                }
            } else {
<span class="nc" id="L852">                store[normalisedIndex] = value;</span>
            }

<span class="nc" id="L855">            return value;</span>
        }

        @Specialization(guards = &quot;isFloat&quot;)
        public double setFloat(RubyArray array, int index, double value, UndefinedPlaceholder unused) {
<span class="nc" id="L860">            final int normalisedIndex = array.normaliseIndex(index);</span>
<span class="nc" id="L861">            double[] store = (double[]) array.getStore();</span>

<span class="nc bnc" id="L863" title="All 2 branches missed.">            if (normalisedIndex &lt; 0) {</span>
<span class="nc" id="L864">                tooSmallBranch.enter();</span>
<span class="nc" id="L865">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L866">                throw new RaiseException(getContext().getCoreLibrary().indexTooSmallError(&quot;array&quot;, index, array.getSize(), this));</span>
<span class="nc bnc" id="L867" title="All 2 branches missed.">            } else if (normalisedIndex &gt;= array.getSize()) {</span>
<span class="nc" id="L868">                pastEndBranch.enter();</span>

<span class="nc bnc" id="L870" title="All 2 branches missed.">                if (normalisedIndex == array.getSize()) {</span>
<span class="nc" id="L871">                    appendBranch.enter();</span>

<span class="nc bnc" id="L873" title="All 2 branches missed.">                    if (normalisedIndex &gt;= store.length) {</span>
<span class="nc" id="L874">                        reallocateBranch.enter();</span>
<span class="nc" id="L875">                        array.setStore(store = Arrays.copyOf(store, ArrayUtils.capacity(store.length, normalisedIndex + 1)), array.getSize());</span>
                    }

<span class="nc" id="L878">                    store[normalisedIndex] = value;</span>
<span class="nc" id="L879">                    array.setSize(array.getSize() + 1);</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">                } else if (normalisedIndex &gt; array.getSize()) {</span>
<span class="nc" id="L881">                    beyondBranch.enter();</span>
<span class="nc" id="L882">                    throw new UnsupportedOperationException();</span>
                }
            } else {
<span class="nc" id="L885">                store[normalisedIndex] = value;</span>
            }

<span class="nc" id="L888">            return value;</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public Object setObject(RubyArray array, int index, Object value, UndefinedPlaceholder unused) {
<span class="nc" id="L893">            final int normalisedIndex = array.normaliseIndex(index);</span>
<span class="nc" id="L894">            Object[] store = (Object[]) array.getStore();</span>

<span class="nc bnc" id="L896" title="All 2 branches missed.">            if (normalisedIndex &lt; 0) {</span>
<span class="nc" id="L897">                tooSmallBranch.enter();</span>
<span class="nc" id="L898">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L899">                throw new RaiseException(getContext().getCoreLibrary().indexTooSmallError(&quot;array&quot;, index, array.getSize(), this));</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">            } else if (normalisedIndex &gt;= array.getSize()) {</span>
<span class="nc" id="L901">                pastEndBranch.enter();</span>

<span class="nc bnc" id="L903" title="All 2 branches missed.">                if (normalisedIndex == array.getSize()) {</span>
<span class="nc" id="L904">                    appendBranch.enter();</span>

<span class="nc bnc" id="L906" title="All 2 branches missed.">                    if (normalisedIndex &gt;= store.length) {</span>
<span class="nc" id="L907">                        reallocateBranch.enter();</span>
<span class="nc" id="L908">                        array.setStore(store = Arrays.copyOf(store, ArrayUtils.capacity(store.length, normalisedIndex + 1)), array.getSize());</span>
                    }

<span class="nc" id="L911">                    store[normalisedIndex] = value;</span>
<span class="nc" id="L912">                    array.setSize(array.getSize() + 1);</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">                } else if (normalisedIndex &gt; array.getSize()) {</span>
<span class="nc" id="L914">                    beyondBranch.enter();</span>
<span class="nc" id="L915">                    throw new UnsupportedOperationException();</span>
                }
            } else {
<span class="nc" id="L918">                store[normalisedIndex] = value;</span>
            }

<span class="nc" id="L921">            return value;</span>
        }

        @Specialization(guards = {&quot;isObject&quot;, &quot;!isRubyArray(arguments[3])&quot;})
        public Object setObject(RubyArray array, int start, int length, Object value) {
<span class="nc" id="L926">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L928" title="All 2 branches missed.">            if (length &lt; 0) {</span>
<span class="nc" id="L929">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L930">                throw new RaiseException(getContext().getCoreLibrary().indexNegativeLength(length, this));</span>
            }

<span class="nc" id="L933">            final int begin = array.normaliseIndex(start);</span>

<span class="nc bnc" id="L935" title="All 2 branches missed.">            if (begin &gt;= array.getSize()) {</span>
                // We don't care of length in this case
<span class="nc" id="L937">                return setObject(array, start, value, UndefinedPlaceholder.INSTANCE);</span>
            } else {
<span class="nc" id="L939">                throw  new UnsupportedOperationException();</span>
            }
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public RubyArray setIntegerFixnumRange(RubyArray array, RubyRange.IntegerFixnumRange range, RubyArray other, UndefinedPlaceholder unused) {
<span class="nc bnc" id="L945" title="All 2 branches missed.">            if (range.doesExcludeEnd()) {</span>
<span class="nc" id="L946">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L947">                throw new UnsupportedOperationException();</span>
            } else {
<span class="nc" id="L949">                int normalisedBegin = array.normaliseIndex(range.getBegin());</span>
<span class="nc" id="L950">                int normalisedEnd = array.normaliseIndex(range.getEnd());</span>

<span class="nc bnc" id="L952" title="All 4 branches missed.">                if (normalisedBegin == 0 &amp;&amp; normalisedEnd == array.getSize() - 1) {</span>
<span class="nc" id="L953">                    array.setStore(Arrays.copyOf((int[]) other.getStore(), other.getSize()), other.getSize());</span>
                } else {
<span class="nc" id="L955">                    throw new RuntimeException();</span>
                }
            }

<span class="nc" id="L959">            return other;</span>
        }

    }

    @CoreMethod(names = &quot;all?&quot;, needsBlock = true)
    @ImportGuards(ArrayGuards.class)
    public abstract static class AllNode extends YieldingCoreMethodNode {

        public AllNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L969">            super(context, sourceSection);</span>
<span class="nc" id="L970">        }</span>

        public AllNode(AllNode prev) {
<span class="nc" id="L973">            super(prev);</span>
<span class="nc" id="L974">        }</span>

        @Specialization(guards = &quot;isNull&quot;)
        public boolean allNull(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L978">            return true;</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public boolean allIntegerFixnum(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L983">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L985" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">                if (!yieldIsTruthy(frame, block, ((int[]) array.getStore())[n])) {</span>
<span class="nc" id="L987">                    return false;</span>
                }
            }

<span class="nc" id="L991">            return true;</span>
        }

        @Specialization(guards = &quot;isLongFixnum&quot;)
        public boolean allLongFixnum(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L996">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L998" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">                if (!yieldIsTruthy(frame, block, ((long[]) array.getStore())[n])) {</span>
<span class="nc" id="L1000">                    return false;</span>
                }
            }

<span class="nc" id="L1004">            return true;</span>
        }

        @Specialization(guards = &quot;isFloat&quot;)
        public boolean allFloat(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1009">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L1011" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">                if (!yieldIsTruthy(frame, block, ((double[]) array.getStore())[n])) {</span>
<span class="nc" id="L1013">                    return false;</span>
                }
            }

<span class="nc" id="L1017">            return true;</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public boolean allObject(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1022">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L1024" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">                if (!yieldIsTruthy(frame, block, ((Object[]) array.getStore())[n])) {</span>
<span class="nc" id="L1026">                    return false;</span>
                }
            }

<span class="nc" id="L1030">            return true;</span>
        }

    }

    @CoreMethod(names = &quot;any?&quot;, needsBlock = true)
    @ImportGuards(ArrayGuards.class)
    public abstract static class AnyNode extends YieldingCoreMethodNode {

        public AnyNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1040">            super(context, sourceSection);</span>
<span class="nc" id="L1041">        }</span>

        public AnyNode(AnyNode prev) {
<span class="nc" id="L1044">            super(prev);</span>
<span class="nc" id="L1045">        }</span>

        @Specialization(guards = &quot;isNull&quot;)
        public boolean anyNull(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1049">            return false;</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public boolean allIntegerFixnum(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1054">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L1056" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">                if (yieldIsTruthy(frame, block, ((int[]) array.getStore())[n])) {</span>
<span class="nc" id="L1058">                    return true;</span>
                }
            }

<span class="nc" id="L1062">            return false;</span>
        }

        @Specialization(guards = &quot;isLongFixnum&quot;)
        public boolean anyLongFixnum(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1067">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L1069" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">                if (yieldIsTruthy(frame, block, ((long[]) array.getStore())[n])) {</span>
<span class="nc" id="L1071">                    return true;</span>
                }
            }

<span class="nc" id="L1075">            return false;</span>
        }

        @Specialization(guards = &quot;isFloat&quot;)
        public boolean anyFloat(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1080">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L1082" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">                if (yieldIsTruthy(frame, block, ((double[]) array.getStore())[n])) {</span>
<span class="nc" id="L1084">                    return true;</span>
                }
            }

<span class="nc" id="L1088">            return false;</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public boolean anyObject(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1093">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L1095" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">                if (yieldIsTruthy(frame, block, ((Object[]) array.getStore())[n])) {</span>
<span class="nc" id="L1097">                    return true;</span>
                }
            }

<span class="nc" id="L1101">            return false;</span>
        }

    }

    @CoreMethod(names = &quot;clear&quot;)
    public abstract static class ClearNode extends ArrayCoreMethodNode {

        public ClearNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1110">            super(context, sourceSection);</span>
<span class="nc" id="L1111">        }</span>

        public ClearNode(ClearNode prev) {
<span class="nc" id="L1114">            super(prev);</span>
<span class="nc" id="L1115">        }</span>

        @Specialization
        public RubyArray clear(RubyArray array) {
<span class="nc" id="L1119">            notDesignedForCompilation();</span>
<span class="nc" id="L1120">            array.setSize(0);</span>
<span class="nc" id="L1121">            return array;</span>
        }

    }

    @CoreMethod(names = &quot;compact&quot;)
    public abstract static class CompactNode extends ArrayCoreMethodNode {

        public CompactNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1130">            super(context, sourceSection);</span>
<span class="nc" id="L1131">        }</span>

        public CompactNode(CompactNode prev) {
<span class="nc" id="L1134">            super(prev);</span>
<span class="nc" id="L1135">        }</span>

        @Specialization(guards = &quot;!isObject&quot;)
        public RubyArray compatNotObjects(RubyArray array) {
<span class="nc" id="L1139">            return array;</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public RubyArray compatObjects(RubyArray array) {
<span class="nc" id="L1144">            notDesignedForCompilation();</span>

<span class="nc" id="L1146">            final Object[] compacted = new Object[array.getSize()];</span>
<span class="nc" id="L1147">            int compactedSize = 0;</span>

<span class="nc bnc" id="L1149" title="All 2 branches missed.">            for (Object object : array.slowToArray()) {</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">                if (object != getContext().getCoreLibrary().getNilObject()) {</span>
<span class="nc" id="L1151">                    compacted[compactedSize] = object;</span>
<span class="nc" id="L1152">                    compactedSize++;</span>
                }
            }

<span class="nc" id="L1156">            array.setStore(compacted, compactedSize);</span>

<span class="nc" id="L1158">            return array;</span>
        }

    }

    @CoreMethod(names = &quot;concat&quot;, required = 1)
    public abstract static class ConcatNode extends ArrayCoreMethodNode {

        public ConcatNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1167">            super(context, sourceSection);</span>
<span class="nc" id="L1168">        }</span>

        public ConcatNode(ConcatNode prev) {
<span class="nc" id="L1171">            super(prev);</span>
<span class="nc" id="L1172">        }</span>

        @Specialization(guards = &quot;areBothNull&quot;)
        public RubyArray concatNull(RubyArray array, RubyArray other) {
<span class="nc" id="L1176">            return array;</span>
        }

        @Specialization(guards = &quot;areBothIntegerFixnum&quot;)
        public RubyArray concatIntegerFixnum(RubyArray array, RubyArray other) {
<span class="nc" id="L1181">            notDesignedForCompilation();</span>

            // TODO(CS): is there already space in array?
<span class="nc" id="L1184">            array.setStore(Arrays.copyOf((int[]) array.getStore(), array.getSize() + other.getSize()), array.getSize());</span>
<span class="nc" id="L1185">            System.arraycopy(other.getStore(), 0, array.getStore(), array.getSize(), other.getSize());</span>
<span class="nc" id="L1186">            array.setSize(array.getSize() + other.getSize());</span>
<span class="nc" id="L1187">            return array;</span>
        }

        @Specialization(guards = &quot;areBothLongFixnum&quot;)
        public RubyArray concatLongFixnum(RubyArray array, RubyArray other) {
<span class="nc" id="L1192">            notDesignedForCompilation();</span>

            // TODO(CS): is there already space in array?
<span class="nc" id="L1195">            array.setStore(Arrays.copyOf((long[]) array.getStore(), array.getSize() + other.getSize()), array.getSize());</span>
<span class="nc" id="L1196">            System.arraycopy(other.getStore(), 0, array.getStore(), array.getSize(), other.getSize());</span>
<span class="nc" id="L1197">            array.setSize(array.getSize() + other.getSize());</span>
<span class="nc" id="L1198">            return array;</span>
        }

        @Specialization(guards = &quot;areBothFloat&quot;)
        public RubyArray concatDouble(RubyArray array, RubyArray other) {
<span class="nc" id="L1203">            notDesignedForCompilation();</span>

            // TODO(CS): is there already space in array?
<span class="nc" id="L1206">            array.setStore(Arrays.copyOf((double[]) array.getStore(), array.getSize() + other.getSize()), array.getSize());</span>
<span class="nc" id="L1207">            System.arraycopy(other.getStore(), 0, array.getStore(), array.getSize(), other.getSize());</span>
<span class="nc" id="L1208">            array.setSize(array.getSize() + other.getSize());</span>
<span class="nc" id="L1209">            return array;</span>
        }

        @Specialization(guards = &quot;areBothObject&quot;)
        public RubyArray concatObject(RubyArray array, RubyArray other) {
<span class="nc" id="L1214">            notDesignedForCompilation();</span>

            // TODO(CS): is there already space in array?
<span class="nc" id="L1217">            array.setStore(Arrays.copyOf((Object[]) array.getStore(), array.getSize() + other.getSize()), array.getSize());</span>
<span class="nc" id="L1218">            System.arraycopy(other.getStore(), 0, array.getStore(), array.getSize(), other.getSize());</span>
<span class="nc" id="L1219">            array.setSize(array.getSize() + other.getSize());</span>
<span class="nc" id="L1220">            return array;</span>
        }

        @Specialization
        public RubyArray concat(RubyArray array, RubyArray other) {
<span class="nc" id="L1225">            notDesignedForCompilation();</span>

            // TODO(CS): is there already space in array?
            // TODO(CS): if array is Object[], use Arrays.copyOf
<span class="nc" id="L1229">            final Object[] newStore = new Object[array.getSize() + other.getSize()];</span>
<span class="nc" id="L1230">            ArrayUtils.copy(array.getStore(), newStore, 0, array.getSize());</span>
<span class="nc" id="L1231">            ArrayUtils.copy(other.getStore(), newStore, array.getSize(), other.getSize());</span>
<span class="nc" id="L1232">            array.setStore(newStore, array.getSize() + other.getSize());</span>
<span class="nc" id="L1233">            return array;</span>
        }

    }

    @CoreMethod(names = &quot;delete&quot;, required = 1)
    public abstract static class DeleteNode extends ArrayCoreMethodNode {

        @Child protected KernelNodes.SameOrEqualNode equalNode;

        public DeleteNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1244">            super(context, sourceSection);</span>
<span class="nc" id="L1245">            equalNode = KernelNodesFactory.SameOrEqualNodeFactory.create(context, sourceSection, new RubyNode[]{null,null});</span>
<span class="nc" id="L1246">        }</span>

        public DeleteNode(DeleteNode prev) {
<span class="nc" id="L1249">            super(prev);</span>
<span class="nc" id="L1250">            equalNode = prev.equalNode;</span>
<span class="nc" id="L1251">        }</span>

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public Object deleteIntegerFixnum(VirtualFrame frame, RubyArray array, Object value) {
<span class="nc" id="L1255">            final int[] store = (int[]) array.getStore();</span>

<span class="nc" id="L1257">            Object found = getContext().getCoreLibrary().getNilObject();</span>

<span class="nc" id="L1259">            int i = 0;</span>

<span class="nc bnc" id="L1261" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc" id="L1262">                final Object stored = store[n];</span>

<span class="nc bnc" id="L1264" title="All 2 branches missed.">                if (equalNode.executeSameOrEqual(frame, stored, value)) {</span>
<span class="nc" id="L1265">                    found = store[n];</span>
<span class="nc" id="L1266">                    continue;</span>
                }

<span class="nc bnc" id="L1269" title="All 2 branches missed.">                if (i != n) {</span>
<span class="nc" id="L1270">                    store[i] = store[n];</span>
                }

<span class="nc" id="L1273">                i++;</span>
            }

<span class="nc" id="L1276">            array.setSize(i);</span>
<span class="nc" id="L1277">            return found;</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public Object deleteObject(VirtualFrame frame, RubyArray array, Object value) {
<span class="nc" id="L1282">            final Object[] store = (Object[]) array.getStore();</span>

<span class="nc" id="L1284">            Object found = getContext().getCoreLibrary().getNilObject();</span>

<span class="nc" id="L1286">            int i = 0;</span>

<span class="nc bnc" id="L1288" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc" id="L1289">                final Object stored = store[n];</span>

<span class="nc bnc" id="L1291" title="All 2 branches missed.">                if (equalNode.executeSameOrEqual(frame, stored, value)) {</span>
<span class="nc" id="L1292">                    found = store[n];</span>
<span class="nc" id="L1293">                    continue;</span>
                }

<span class="nc bnc" id="L1296" title="All 2 branches missed.">                if (i != n) {</span>
<span class="nc" id="L1297">                    store[i] = store[n];</span>
                }

<span class="nc" id="L1300">                i++;</span>
            }

<span class="nc" id="L1303">            array.setSize(i);</span>
<span class="nc" id="L1304">            return found;</span>
        }

    }

    @CoreMethod(names = &quot;delete_at&quot;, required = 1)
    public abstract static class DeleteAtNode extends ArrayCoreMethodNode {

<span class="nc" id="L1312">        private static final BranchProfile tooSmallBranch = BranchProfile.create();</span>
<span class="nc" id="L1313">        private static final BranchProfile beyondEndBranch = BranchProfile.create();</span>

        public DeleteAtNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1316">            super(context, sourceSection);</span>
<span class="nc" id="L1317">        }</span>

        public DeleteAtNode(DeleteAtNode prev) {
<span class="nc" id="L1320">            super(prev);</span>
<span class="nc" id="L1321">        }</span>

        @Specialization(guards = &quot;isIntegerFixnum&quot;, rewriteOn = UnexpectedResultException.class)
        public int deleteAtIntegerFixnumInBounds(RubyArray array, int index) throws UnexpectedResultException {
<span class="nc" id="L1325">            final int normalisedIndex = array.normaliseIndex(index);</span>

<span class="nc bnc" id="L1327" title="All 2 branches missed.">            if (normalisedIndex &lt; 0) {</span>
<span class="nc" id="L1328">                throw new UnexpectedResultException(getContext().getCoreLibrary().getNilObject());</span>
<span class="nc bnc" id="L1329" title="All 2 branches missed.">            } else if (normalisedIndex &gt;= array.getSize()) {</span>
<span class="nc" id="L1330">                throw new UnexpectedResultException(getContext().getCoreLibrary().getNilObject());</span>
            } else {
<span class="nc" id="L1332">                final int[] store = (int[]) array.getStore();</span>
<span class="nc" id="L1333">                final int value = store[normalisedIndex];</span>
<span class="nc" id="L1334">                System.arraycopy(store, normalisedIndex + 1, store, normalisedIndex, array.getSize() - normalisedIndex - 1);</span>
<span class="nc" id="L1335">                array.setSize(array.getSize() - 1);</span>
<span class="nc" id="L1336">                return value;</span>
            }
        }

        @Specialization(contains = &quot;deleteAtIntegerFixnumInBounds&quot;, guards = &quot;isIntegerFixnum&quot;)
        public Object deleteAtIntegerFixnum(RubyArray array, int index) {
<span class="nc" id="L1342">            notDesignedForCompilation();</span>

<span class="nc" id="L1344">            int normalisedIndex = index;</span>

<span class="nc bnc" id="L1346" title="All 2 branches missed.">            if (normalisedIndex &lt; 0) {</span>
<span class="nc" id="L1347">                normalisedIndex = array.getSize() + index;</span>
            }

<span class="nc bnc" id="L1350" title="All 2 branches missed.">            if (normalisedIndex &lt; 0) {</span>
<span class="nc" id="L1351">                tooSmallBranch.enter();</span>
<span class="nc" id="L1352">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L1353">                throw new UnsupportedOperationException();</span>
<span class="nc bnc" id="L1354" title="All 2 branches missed.">            } else if (normalisedIndex &gt;= array.getSize()) {</span>
<span class="nc" id="L1355">                beyondEndBranch.enter();</span>
<span class="nc" id="L1356">                throw new UnsupportedOperationException();</span>
            } else {
<span class="nc" id="L1358">                final int[] store = (int[]) array.getStore();</span>
<span class="nc" id="L1359">                final int value = store[normalisedIndex];</span>
<span class="nc" id="L1360">                System.arraycopy(store, normalisedIndex + 1, store, normalisedIndex, array.getSize() - normalisedIndex - 1);</span>
<span class="nc" id="L1361">                array.setSize(array.getSize() - 1);</span>
<span class="nc" id="L1362">                return value;</span>
            }
        }

    }

    @CoreMethod(names = &quot;each&quot;, needsBlock = true)
    @ImportGuards(ArrayGuards.class)
    public abstract static class EachNode extends YieldingCoreMethodNode {

<span class="nc" id="L1372">        private final BranchProfile breakProfile = BranchProfile.create();</span>
<span class="nc" id="L1373">        private final BranchProfile nextProfile = BranchProfile.create();</span>
<span class="nc" id="L1374">        private final BranchProfile redoProfile = BranchProfile.create();</span>

        public EachNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1377">            super(context, sourceSection);</span>
<span class="nc" id="L1378">        }</span>

        public EachNode(EachNode prev) {
<span class="nc" id="L1381">            super(prev);</span>
<span class="nc" id="L1382">        }</span>

        @Specialization(guards = &quot;isNull&quot;)
        public Object eachNull(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1386">            return getContext().getCoreLibrary().getNilObject();</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public Object eachIntegerFixnum(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1391">            final int[] store = (int[]) array.getStore();</span>

<span class="nc" id="L1393">            int count = 0;</span>

            try {
                outer:
<span class="nc bnc" id="L1397" title="All 2 branches missed.">                for (int n = 0; n &lt; array.getSize(); n++) {</span>
                    while (true) {
<span class="nc bnc" id="L1399" title="All 2 branches missed.">                        if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L1400">                            count++;</span>
                        }

                        try {
<span class="nc" id="L1404">                            yield(frame, block, store[n]);</span>
<span class="nc" id="L1405">                            continue outer;</span>
<span class="nc" id="L1406">                        } catch (BreakException e) {</span>
<span class="nc" id="L1407">                            breakProfile.enter();</span>
<span class="nc" id="L1408">                            return e.getResult();</span>
<span class="nc" id="L1409">                        } catch (NextException e) {</span>
<span class="nc" id="L1410">                            nextProfile.enter();</span>
<span class="nc" id="L1411">                            continue outer;</span>
<span class="nc" id="L1412">                        } catch (RedoException e) {</span>
<span class="nc" id="L1413">                            redoProfile.enter();</span>
<span class="nc" id="L1414">                        }</span>
                    }
                }
            } finally {
<span class="nc bnc" id="L1418" title="All 6 branches missed.">                if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L1419">                    ((RubyRootNode) getRootNode()).reportLoopCount(count);</span>
                }
            }

<span class="nc" id="L1423">            return array;</span>
        }

        @Specialization(guards = &quot;isLongFixnum&quot;)
        public Object eachLongFixnum(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1428">            final long[] store = (long[]) array.getStore();</span>

<span class="nc" id="L1430">            int count = 0;</span>

            try {
                outer:
<span class="nc bnc" id="L1434" title="All 2 branches missed.">                for (int n = 0; n &lt; array.getSize(); n++) {</span>
                    while (true) {
<span class="nc bnc" id="L1436" title="All 2 branches missed.">                        if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L1437">                            count++;</span>
                        }

                        try {
<span class="nc" id="L1441">                            yield(frame, block, store[n]);</span>
<span class="nc" id="L1442">                            continue outer;</span>
<span class="nc" id="L1443">                        } catch (BreakException e) {</span>
<span class="nc" id="L1444">                            breakProfile.enter();</span>
<span class="nc" id="L1445">                            return e.getResult();</span>
<span class="nc" id="L1446">                        } catch (NextException e) {</span>
<span class="nc" id="L1447">                            nextProfile.enter();</span>
<span class="nc" id="L1448">                            continue outer;</span>
<span class="nc" id="L1449">                        } catch (RedoException e) {</span>
<span class="nc" id="L1450">                            redoProfile.enter();</span>
<span class="nc" id="L1451">                        }</span>
                    }
                }
            } finally {
<span class="nc bnc" id="L1455" title="All 6 branches missed.">                if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L1456">                    ((RubyRootNode) getRootNode()).reportLoopCount(count);</span>
                }
            }

<span class="nc" id="L1460">            return array;</span>
        }

        @Specialization(guards = &quot;isFloat&quot;)
        public Object eachFloat(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1465">            final double[] store = (double[]) array.getStore();</span>

<span class="nc" id="L1467">            int count = 0;</span>

            try {
                outer:
<span class="nc bnc" id="L1471" title="All 2 branches missed.">                for (int n = 0; n &lt; array.getSize(); n++) {</span>
                    while (true) {
<span class="nc bnc" id="L1473" title="All 2 branches missed.">                        if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L1474">                            count++;</span>
                        }

                        try {
<span class="nc" id="L1478">                            yield(frame, block, store[n]);</span>
<span class="nc" id="L1479">                            continue outer;</span>
<span class="nc" id="L1480">                        } catch (BreakException e) {</span>
<span class="nc" id="L1481">                            breakProfile.enter();</span>
<span class="nc" id="L1482">                            return e.getResult();</span>
<span class="nc" id="L1483">                        } catch (NextException e) {</span>
<span class="nc" id="L1484">                            nextProfile.enter();</span>
<span class="nc" id="L1485">                            continue outer;</span>
<span class="nc" id="L1486">                        } catch (RedoException e) {</span>
<span class="nc" id="L1487">                            redoProfile.enter();</span>
<span class="nc" id="L1488">                        }</span>
                    }
                }
            } finally {
<span class="nc bnc" id="L1492" title="All 6 branches missed.">                if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L1493">                    ((RubyRootNode) getRootNode()).reportLoopCount(count);</span>
                }
            }

<span class="nc" id="L1497">            return array;</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public Object eachObject(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1502">            final Object[] store = (Object[]) array.getStore();</span>

<span class="nc" id="L1504">            int count = 0;</span>

            try {
                outer:
<span class="nc bnc" id="L1508" title="All 2 branches missed.">                for (int n = 0; n &lt; array.getSize(); n++) {</span>
                    while (true) {
<span class="nc bnc" id="L1510" title="All 2 branches missed.">                        if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L1511">                            count++;</span>
                        }

                        try {
<span class="nc" id="L1515">                            yield(frame, block, store[n]);</span>
<span class="nc" id="L1516">                            continue outer;</span>
<span class="nc" id="L1517">                        } catch (BreakException e) {</span>
<span class="nc" id="L1518">                            breakProfile.enter();</span>
<span class="nc" id="L1519">                            return e.getResult();</span>
<span class="nc" id="L1520">                        } catch (NextException e) {</span>
<span class="nc" id="L1521">                            nextProfile.enter();</span>
<span class="nc" id="L1522">                            continue outer;</span>
<span class="nc" id="L1523">                        } catch (RedoException e) {</span>
<span class="nc" id="L1524">                            redoProfile.enter();</span>
<span class="nc" id="L1525">                        }</span>
                    }
                }
            } finally {
<span class="nc bnc" id="L1529" title="All 6 branches missed.">                if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L1530">                    ((RubyRootNode) getRootNode()).reportLoopCount(count);</span>
                }
            }

<span class="nc" id="L1534">            return array;</span>
        }

    }

    @CoreMethod(names = &quot;each_with_index&quot;, needsBlock = true)
    @ImportGuards(ArrayGuards.class)
    public abstract static class EachWithIndexNode extends YieldingCoreMethodNode {

<span class="nc" id="L1543">        private final BranchProfile breakProfile = BranchProfile.create();</span>
<span class="nc" id="L1544">        private final BranchProfile nextProfile = BranchProfile.create();</span>
<span class="nc" id="L1545">        private final BranchProfile redoProfile = BranchProfile.create();</span>

        public EachWithIndexNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1548">            super(context, sourceSection);</span>
<span class="nc" id="L1549">        }</span>

        public EachWithIndexNode(EachWithIndexNode prev) {
<span class="nc" id="L1552">            super(prev);</span>
<span class="nc" id="L1553">        }</span>

        @Specialization(guards = &quot;isNull&quot;)
        public RubyArray eachWithEmpty(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1557">            return array;</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public Object eachWithIndexObject(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1562">            final Object[] store = (Object[]) array.getStore();</span>

<span class="nc" id="L1564">            int count = 0;</span>

            try {
                outer:
<span class="nc bnc" id="L1568" title="All 2 branches missed.">                for (int n = 0; n &lt; array.getSize(); n++) {</span>
                    while (true) {
<span class="nc bnc" id="L1570" title="All 2 branches missed.">                        if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L1571">                            count++;</span>
                        }

                        try {
<span class="nc" id="L1575">                            yield(frame, block, store[n], n);</span>
<span class="nc" id="L1576">                            continue outer;</span>
<span class="nc" id="L1577">                        } catch (BreakException e) {</span>
<span class="nc" id="L1578">                            breakProfile.enter();</span>
<span class="nc" id="L1579">                            return e.getResult();</span>
<span class="nc" id="L1580">                        } catch (NextException e) {</span>
<span class="nc" id="L1581">                            nextProfile.enter();</span>
<span class="nc" id="L1582">                            continue outer;</span>
<span class="nc" id="L1583">                        } catch (RedoException e) {</span>
<span class="nc" id="L1584">                            redoProfile.enter();</span>
<span class="nc" id="L1585">                        }</span>
                    }
                }
            } finally {
<span class="nc bnc" id="L1589" title="All 6 branches missed.">                if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L1590">                    ((RubyRootNode) getRootNode()).reportLoopCount(count);</span>
                }
            }

<span class="nc" id="L1594">            return array;</span>
        }

    }

    @CoreMethod(names = &quot;empty?&quot;)
    public abstract static class EmptyNode extends ArrayCoreMethodNode {

        public EmptyNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1603">            super(context, sourceSection);</span>
<span class="nc" id="L1604">        }</span>

        public EmptyNode(EmptyNode prev) {
<span class="nc" id="L1607">            super(prev);</span>
<span class="nc" id="L1608">        }</span>

        @Specialization
        public boolean isEmpty(RubyArray array) {
<span class="nc bnc" id="L1612" title="All 2 branches missed.">            return array.getSize() == 0;</span>
        }

    }

    @CoreMethod(names = &quot;find&quot;, needsBlock = true)
    @ImportGuards(ArrayGuards.class)
    public abstract static class FindNode extends YieldingCoreMethodNode {

        public FindNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1622">            super(context, sourceSection);</span>
<span class="nc" id="L1623">        }</span>

        public FindNode(FindNode prev) {
<span class="nc" id="L1626">            super(prev);</span>
<span class="nc" id="L1627">        }</span>

        @Specialization(guards = &quot;isNull&quot;)
        public Object findNull(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1631">            return getContext().getCoreLibrary().getNilObject();</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public Object findIntegerFixnum(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1636">            notDesignedForCompilation();</span>

<span class="nc" id="L1638">            final int[] store = (int[]) array.getStore();</span>

<span class="nc bnc" id="L1640" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
                try {
<span class="nc" id="L1642">                    final Object value = store[n];</span>

<span class="nc bnc" id="L1644" title="All 2 branches missed.">                    if (yieldIsTruthy(frame, block, value)) {</span>
<span class="nc" id="L1645">                        return value;</span>
                    }
<span class="nc" id="L1647">                } catch (BreakException e) {</span>
<span class="nc" id="L1648">                    break;</span>
<span class="nc" id="L1649">                }</span>
            }

<span class="nc" id="L1652">            return getContext().getCoreLibrary().getNilObject();</span>
        }

        @Specialization(guards = &quot;isLongFixnum&quot;)
        public Object findLongFixnum(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1657">            notDesignedForCompilation();</span>

<span class="nc" id="L1659">            final long[] store = (long[]) array.getStore();</span>

<span class="nc bnc" id="L1661" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
                try {
<span class="nc" id="L1663">                    final Object value = store[n];</span>

<span class="nc bnc" id="L1665" title="All 2 branches missed.">                    if (yieldIsTruthy(frame, block, value)) {</span>
<span class="nc" id="L1666">                        return value;</span>
                    }
<span class="nc" id="L1668">                } catch (BreakException e) {</span>
<span class="nc" id="L1669">                    break;</span>
<span class="nc" id="L1670">                }</span>
            }

<span class="nc" id="L1673">            return getContext().getCoreLibrary().getNilObject();</span>
        }

        @Specialization(guards = &quot;isFloat&quot;)
        public Object findFloat(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1678">            notDesignedForCompilation();</span>

<span class="nc" id="L1680">            final double[] store = (double[]) array.getStore();</span>

<span class="nc bnc" id="L1682" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
                try {
<span class="nc" id="L1684">                    final Object value = store[n];</span>

<span class="nc bnc" id="L1686" title="All 2 branches missed.">                    if (yieldIsTruthy(frame, block, value)) {</span>
<span class="nc" id="L1687">                        return value;</span>
                    }
<span class="nc" id="L1689">                } catch (BreakException e) {</span>
<span class="nc" id="L1690">                    break;</span>
<span class="nc" id="L1691">                }</span>
            }

<span class="nc" id="L1694">            return getContext().getCoreLibrary().getNilObject();</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public Object findObject(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L1699">            notDesignedForCompilation();</span>

<span class="nc" id="L1701">            final Object[] store = (Object[]) array.getStore();</span>

<span class="nc bnc" id="L1703" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
                try {
<span class="nc" id="L1705">                    final Object value = store[n];</span>

<span class="nc bnc" id="L1707" title="All 2 branches missed.">                    if (yieldIsTruthy(frame, block, value)) {</span>
<span class="nc" id="L1708">                        return value;</span>
                    }
<span class="nc" id="L1710">                } catch (BreakException e) {</span>
<span class="nc" id="L1711">                    break;</span>
<span class="nc" id="L1712">                }</span>
            }

<span class="nc" id="L1715">            return getContext().getCoreLibrary().getNilObject();</span>
        }
    }

    @CoreMethod(names = &quot;first&quot;)
    public abstract static class FirstNode extends ArrayCoreMethodNode {

        public FirstNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1723">            super(context, sourceSection);</span>
<span class="nc" id="L1724">        }</span>

        public FirstNode(FirstNode prev) {
<span class="nc" id="L1727">            super(prev);</span>
<span class="nc" id="L1728">        }</span>

        @Specialization(guards = &quot;isNull&quot;)
        public RubyNilClass firstNull(RubyArray array) {
<span class="nc" id="L1732">            notDesignedForCompilation();</span>

<span class="nc" id="L1734">            return getContext().getCoreLibrary().getNilObject();</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public Object firstIntegerFixnum(RubyArray array) {
<span class="nc" id="L1739">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L1741" title="All 2 branches missed.">            if (array.getSize() == 0) {</span>
<span class="nc" id="L1742">                return getContext().getCoreLibrary().getNilObject();</span>
            } else {
<span class="nc" id="L1744">                return ((int[]) array.getStore())[0];</span>
            }
        }

        @Specialization(guards = &quot;isObject&quot;)
        public Object firstObject(RubyArray array) {
<span class="nc" id="L1750">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L1752" title="All 2 branches missed.">            if (array.getSize() == 0) {</span>
<span class="nc" id="L1753">                return getContext().getCoreLibrary().getNilObject();</span>
            } else {
<span class="nc" id="L1755">                return ((Object[]) array.getStore())[0];</span>
            }
        }

    }

    @CoreMethod(names = &quot;flatten&quot;)
    public abstract static class FlattenNode extends ArrayCoreMethodNode {

        public FlattenNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1765">            super(context, sourceSection);</span>
<span class="nc" id="L1766">        }</span>

        public FlattenNode(FlattenNode prev) {
<span class="nc" id="L1769">            super(prev);</span>
<span class="nc" id="L1770">        }</span>

        @Specialization
        public RubyArray flatten(RubyArray array) {
<span class="nc" id="L1774">            notDesignedForCompilation();</span>
<span class="nc" id="L1775">            final List&lt;Object&gt; flattened = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1776">            flatten(flattened, array.slowToArray());</span>
<span class="nc" id="L1777">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), flattened.toArray(), array.getSize());</span>
        }

        private void flatten(List&lt;Object&gt; flattened, Object[] store) {
<span class="nc bnc" id="L1781" title="All 2 branches missed.">            for (Object value : store) {</span>
<span class="nc bnc" id="L1782" title="All 2 branches missed.">                if (value instanceof RubyArray) {</span>
<span class="nc" id="L1783">                    flatten(flattened, ((RubyArray) value).slowToArray());</span>
                } else {
<span class="nc" id="L1785">                    flattened.add(value);</span>
                }
            }
<span class="nc" id="L1788">        }</span>

    }

    @CoreMethod(names = &quot;hash&quot;)
    public abstract static class HashNode extends CoreMethodNode {

        public HashNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1796">            super(context, sourceSection);</span>
<span class="nc" id="L1797">        }</span>

        public HashNode(HashNode prev) {
<span class="nc" id="L1800">            super(prev);</span>
<span class="nc" id="L1801">        }</span>

        @Specialization
        public long hashNumber(RubyArray array) {
<span class="nc" id="L1805">            return array.hashCode();</span>
        }

    }

    @CoreMethod(names = &quot;include?&quot;, required = 1)
    public abstract static class IncludeNode extends ArrayCoreMethodNode {

        @Child protected KernelNodes.SameOrEqualNode equalNode;

        public IncludeNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1816">            super(context, sourceSection);</span>
<span class="nc" id="L1817">            equalNode = KernelNodesFactory.SameOrEqualNodeFactory.create(context, sourceSection, new RubyNode[]{null,null});</span>
<span class="nc" id="L1818">        }</span>

        public IncludeNode(IncludeNode prev) {
<span class="nc" id="L1821">            super(prev);</span>
<span class="nc" id="L1822">            equalNode = prev.equalNode;</span>
<span class="nc" id="L1823">        }</span>

        @Specialization(guards = &quot;isNull&quot;)
        public boolean includeNull(VirtualFrame frame, RubyArray array, Object value) {
<span class="nc" id="L1827">            return false;</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public boolean includeIntegerFixnum(VirtualFrame frame, RubyArray array, Object value) {
<span class="nc" id="L1832">            final int[] store = (int[]) array.getStore();</span>

<span class="nc bnc" id="L1834" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc" id="L1835">                final Object stored = store[n];</span>

<span class="nc" id="L1837">                notDesignedForCompilation();</span>

<span class="nc bnc" id="L1839" title="All 2 branches missed.">                if (equalNode.executeSameOrEqual(frame, stored, value)) {</span>
<span class="nc" id="L1840">                    return true;</span>
                }
            }

<span class="nc" id="L1844">            return false;</span>
        }

        @Specialization(guards = &quot;isLongFixnum&quot;)
        public boolean includeLongFixnum(VirtualFrame frame, RubyArray array, Object value) {
<span class="nc" id="L1849">            final long[] store = (long[]) array.getStore();</span>

<span class="nc bnc" id="L1851" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc" id="L1852">                final Object stored = store[n];</span>

<span class="nc" id="L1854">                notDesignedForCompilation();</span>

<span class="nc bnc" id="L1856" title="All 2 branches missed.">                if (equalNode.executeSameOrEqual(frame, stored, value)) {</span>
<span class="nc" id="L1857">                    return true;</span>
                }
            }

<span class="nc" id="L1861">            return false;</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public boolean includeObject(VirtualFrame frame, RubyArray array, Object value) {
<span class="nc" id="L1866">            final Object[] store = (Object[]) array.getStore();</span>

<span class="nc bnc" id="L1868" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc" id="L1869">                final Object stored = store[n];</span>

<span class="nc bnc" id="L1871" title="All 2 branches missed.">                if (equalNode.executeSameOrEqual(frame, stored, value)) {</span>
<span class="nc" id="L1872">                    return true;</span>
                }
            }

<span class="nc" id="L1876">            return false;</span>
        }

    }

    @CoreMethod(names = &quot;initialize&quot;, needsBlock = true, required = 1, optional = 1)
    @ImportGuards(ArrayGuards.class)
    public abstract static class InitializeNode extends YieldingCoreMethodNode {

        @Child protected ArrayBuilderNode arrayBuilder;

        public InitializeNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1888">            super(context, sourceSection);</span>
<span class="nc" id="L1889">            arrayBuilder = new ArrayBuilderNode.UninitializedArrayBuilderNode(context);</span>
<span class="nc" id="L1890">        }</span>

        public InitializeNode(InitializeNode prev) {
<span class="nc" id="L1893">            super(prev);</span>
<span class="nc" id="L1894">            arrayBuilder = prev.arrayBuilder;</span>
<span class="nc" id="L1895">        }</span>

        @Specialization
        public RubyArray initialize(RubyArray array, int size, UndefinedPlaceholder defaultValue, UndefinedPlaceholder block) {
<span class="nc" id="L1899">            return initialize(array, size, getContext().getCoreLibrary().getNilObject(), block);</span>
        }

        @Specialization
        public RubyArray initialize(RubyArray array, long size, UndefinedPlaceholder defaultValue, UndefinedPlaceholder block) {
<span class="nc bnc" id="L1904" title="All 2 branches missed.">            if (size &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L1905">                throw new IllegalStateException();</span>
            }
<span class="nc" id="L1907">            return initialize(array, (int) size, getContext().getCoreLibrary().getNilObject(), block);</span>
        }

        @Specialization
        public RubyArray initialize(RubyArray array, int size, int defaultValue, UndefinedPlaceholder block) {
<span class="nc" id="L1912">            final int[] store = new int[size];</span>
<span class="nc" id="L1913">            Arrays.fill(store, defaultValue);</span>
<span class="nc" id="L1914">            array.setStore(store, size);</span>
<span class="nc" id="L1915">            return array;</span>
        }

        @Specialization
        public RubyArray initialize(RubyArray array, int size, long defaultValue, UndefinedPlaceholder block) {
<span class="nc" id="L1920">            final long[] store = new long[size];</span>
<span class="nc" id="L1921">            Arrays.fill(store, defaultValue);</span>
<span class="nc" id="L1922">            array.setStore(store, size);</span>
<span class="nc" id="L1923">            return array;</span>
        }

        @Specialization
        public RubyArray initialize(RubyArray array, int size, double defaultValue, UndefinedPlaceholder block) {
<span class="nc" id="L1928">            final double[] store = new double[size];</span>
<span class="nc" id="L1929">            Arrays.fill(store, defaultValue);</span>
<span class="nc" id="L1930">            array.setStore(store, size);</span>
<span class="nc" id="L1931">            return array;</span>
        }

        @Specialization
        public RubyArray initialize(RubyArray array, int size, Object defaultValue, UndefinedPlaceholder block) {
<span class="nc" id="L1936">            final Object[] store = new Object[size];</span>
<span class="nc" id="L1937">            Arrays.fill(store, defaultValue);</span>
<span class="nc" id="L1938">            array.setStore(store, size);</span>
<span class="nc" id="L1939">            return array;</span>
        }

        @Specialization
        public RubyArray initialize(VirtualFrame frame, RubyArray array, int size, UndefinedPlaceholder defaultValue, RubyProc block) {
<span class="nc" id="L1944">            Object store = arrayBuilder.start(size);</span>

<span class="nc" id="L1946">            int count = 0;</span>
            try {
<span class="nc bnc" id="L1948" title="All 2 branches missed.">                for (int n = 0; n &lt; size; n++) {</span>
<span class="nc bnc" id="L1949" title="All 2 branches missed.">                    if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L1950">                        count++;</span>
                    }

<span class="nc" id="L1953">                    store = arrayBuilder.append(store, n, yield(frame, block, n));</span>
                }
            } finally {
<span class="nc bnc" id="L1956" title="All 4 branches missed.">                if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L1957">                    getRootNode().reportLoopCount(count);</span>
                }
            }

<span class="nc" id="L1961">            array.setStore(arrayBuilder.finish(store, size), size);</span>
<span class="nc" id="L1962">            return array;</span>
        }

        @Specialization
        public RubyArray initialize(RubyArray array, RubyArray copy, UndefinedPlaceholder defaultValue, UndefinedPlaceholder block) {
<span class="nc" id="L1967">            notDesignedForCompilation();</span>
<span class="nc" id="L1968">            array.setStore(copy.slowToArray(), copy.getSize());</span>
<span class="nc" id="L1969">            return array;</span>
        }

    }

    @CoreMethod(names = &quot;initialize_copy&quot;, visibility = Visibility.PRIVATE, required = 1)
    public abstract static class InitializeCopyNode extends ArrayCoreMethodNode {
        // TODO(cs): what about allocationSite ?

        public InitializeCopyNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L1979">            super(context, sourceSection);</span>
<span class="nc" id="L1980">        }</span>

        public InitializeCopyNode(InitializeCopyNode prev) {
<span class="nc" id="L1983">            super(prev);</span>
<span class="nc" id="L1984">        }</span>

        @Specialization(guards = &quot;isOtherNull&quot;)
        public RubyArray initializeCopyNull(RubyArray self, RubyArray from) {
<span class="nc bnc" id="L1988" title="All 2 branches missed.">            if (self == from) {</span>
<span class="nc" id="L1989">                return self;</span>
            }
<span class="nc" id="L1991">            self.setStore(null, 0);</span>
<span class="nc" id="L1992">            return self;</span>
        }

        @Specialization(guards = &quot;isOtherIntegerFixnum&quot;)
        public RubyArray initializeCopyIntegerFixnum(RubyArray self, RubyArray from) {
<span class="nc bnc" id="L1997" title="All 2 branches missed.">            if (self == from) {</span>
<span class="nc" id="L1998">                return self;</span>
            }
<span class="nc" id="L2000">            self.setStore(Arrays.copyOf((int[]) from.getStore(), from.getSize()), from.getSize());</span>
<span class="nc" id="L2001">            return self;</span>
        }

        @Specialization(guards = &quot;isOtherLongFixnum&quot;)
        public RubyArray initializeCopyLongFixnum(RubyArray self, RubyArray from) {
<span class="nc bnc" id="L2006" title="All 2 branches missed.">            if (self == from) {</span>
<span class="nc" id="L2007">                return self;</span>
            }
<span class="nc" id="L2009">            self.setStore(Arrays.copyOf((long[]) from.getStore(), from.getSize()), from.getSize());</span>
<span class="nc" id="L2010">            return self;</span>
        }

        @Specialization(guards = &quot;isOtherFloat&quot;)
        public RubyArray initializeCopyFloat(RubyArray self, RubyArray from) {
<span class="nc bnc" id="L2015" title="All 2 branches missed.">            if (self == from) {</span>
<span class="nc" id="L2016">                return self;</span>
            }
<span class="nc" id="L2018">            self.setStore(Arrays.copyOf((double[]) from.getStore(), from.getSize()), from.getSize());</span>
<span class="nc" id="L2019">            return self;</span>
        }

        @Specialization(guards = &quot;isOtherObject&quot;)
        public RubyArray initializeCopyObject(RubyArray self, RubyArray from) {
<span class="nc bnc" id="L2024" title="All 2 branches missed.">            if (self == from) {</span>
<span class="nc" id="L2025">                return self;</span>
            }
<span class="nc" id="L2027">            self.setStore(Arrays.copyOf((Object[]) from.getStore(), from.getSize()), from.getSize());</span>
<span class="nc" id="L2028">            return self;</span>
        }

    }

    @CoreMethod(names = {&quot;inject&quot;, &quot;reduce&quot;}, needsBlock = true, optional = 1)
    @ImportGuards(ArrayGuards.class)
    public abstract static class InjectNode extends YieldingCoreMethodNode {

        @Child protected DispatchHeadNode dispatch;

        public InjectNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L2040">            super(context, sourceSection);</span>
<span class="nc" id="L2041">            dispatch = new DispatchHeadNode(context, Dispatch.MissingBehavior.CALL_METHOD_MISSING);</span>
<span class="nc" id="L2042">        }</span>

        public InjectNode(InjectNode prev) {
<span class="nc" id="L2045">            super(prev);</span>
<span class="nc" id="L2046">            dispatch = prev.dispatch;</span>
<span class="nc" id="L2047">        }</span>

        @Specialization(guards = &quot;isObject&quot;)
        public Object injectObject(VirtualFrame frame, RubyArray array, Object initial, RubyProc block) {
<span class="nc" id="L2051">            int count = 0;</span>

<span class="nc" id="L2053">            final Object[] store = (Object[]) array.getStore();</span>

<span class="nc" id="L2055">            Object accumulator = initial;</span>

            try {
<span class="nc bnc" id="L2058" title="All 2 branches missed.">                for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L2059" title="All 2 branches missed.">                    if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L2060">                        count++;</span>
                    }

<span class="nc" id="L2063">                    accumulator = yield(frame, block, accumulator, store[n]);</span>
                }
            } finally {
<span class="nc bnc" id="L2066" title="All 4 branches missed.">                if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L2067">                    ((RubyRootNode) getRootNode()).reportLoopCount(count);</span>
                }
            }

<span class="nc" id="L2071">            return accumulator;</span>
        }

        @Specialization
        public Object inject(VirtualFrame frame, RubyArray array, Object initial, RubyProc block) {
<span class="nc" id="L2076">            notDesignedForCompilation();</span>

<span class="nc" id="L2078">            final Object[] store = array.slowToArray();</span>

<span class="nc bnc" id="L2080" title="All 2 branches missed.">            if (store.length &lt; 2) {</span>
<span class="nc" id="L2081">                throw new UnsupportedOperationException();</span>
            }

<span class="nc" id="L2084">            Object accumulator = initial;</span>

<span class="nc bnc" id="L2086" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc" id="L2087">                accumulator = yield(frame, block, accumulator, store[n]);</span>
            }

<span class="nc" id="L2090">            return accumulator;</span>
        }

        @Specialization
        public Object inject(VirtualFrame frame, RubyArray array, RubySymbol symbol, UndefinedPlaceholder unused) {
<span class="nc" id="L2095">            notDesignedForCompilation();</span>

<span class="nc" id="L2097">            final Object[] store = array.slowToArray();</span>

<span class="nc bnc" id="L2099" title="All 2 branches missed.">            if (store.length &lt; 2) {</span>
<span class="nc" id="L2100">                throw new UnsupportedOperationException();</span>
            }

<span class="nc" id="L2103">            Object accumulator = dispatch.call(frame, store[0], symbol, null, store[1]);</span>

<span class="nc bnc" id="L2105" title="All 2 branches missed.">            for (int n = 2; n &lt; array.getSize(); n++) {</span>
<span class="nc" id="L2106">                accumulator = dispatch.call(frame, accumulator, symbol, null, store[n]);</span>
            }

<span class="nc" id="L2109">            return accumulator;</span>
        }

    }

    @CoreMethod(names = &quot;insert&quot;, required = 2)
    public abstract static class InsertNode extends ArrayCoreMethodNode {

<span class="nc" id="L2117">        private static final BranchProfile tooSmallBranch = BranchProfile.create();</span>

        public InsertNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L2120">            super(context, sourceSection);</span>
<span class="nc" id="L2121">        }</span>

        public InsertNode(InsertNode prev) {
<span class="nc" id="L2124">            super(prev);</span>
<span class="nc" id="L2125">        }</span>

        @Specialization(guards = &quot;isNull&quot;)
        public Object insert(RubyArray array, int index, Object value) {
<span class="nc" id="L2129">            notDesignedForCompilation();</span>

<span class="nc" id="L2131">            final Object[] store = new Object[index + 1];</span>
<span class="nc" id="L2132">            Arrays.fill(store, getContext().getCoreLibrary().getNilObject());</span>
<span class="nc" id="L2133">            store[index] = value;</span>
<span class="nc" id="L2134">            array.setSize(array.getSize() + 1);</span>
<span class="nc" id="L2135">            return array;</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public Object insert(RubyArray array, int index, int value) {
<span class="nc" id="L2140">            final int normalisedIndex = array.normaliseIndex(index);</span>
<span class="nc" id="L2141">            final int[] store = (int[]) array.getStore();</span>

<span class="nc bnc" id="L2143" title="All 2 branches missed.">            if (normalisedIndex &lt; 0) {</span>
<span class="nc" id="L2144">                tooSmallBranch.enter();</span>
<span class="nc" id="L2145">                throw new UnsupportedOperationException();</span>
<span class="nc bnc" id="L2146" title="All 2 branches missed.">            } else if (array.getSize() &gt; store.length + 1) {</span>
<span class="nc" id="L2147">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L2148">                throw new UnsupportedOperationException();</span>
            } else {
<span class="nc" id="L2150">                System.arraycopy(store, normalisedIndex, store, normalisedIndex + 1, array.getSize() - normalisedIndex);</span>
<span class="nc" id="L2151">                store[normalisedIndex] = value;</span>
<span class="nc" id="L2152">                array.setSize(array.getSize() + 1);</span>
            }

<span class="nc" id="L2155">            return array;</span>
        }

    }

    @CoreMethod(names = {&quot;inspect&quot;, &quot;to_s&quot;})
    public abstract static class InspectNode extends CoreMethodNode {

        @Child protected DispatchHeadNode inspect;

        public InspectNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L2166">            super(context, sourceSection);</span>
<span class="nc" id="L2167">            inspect = new DispatchHeadNode(context);</span>
<span class="nc" id="L2168">        }</span>

        public InspectNode(InspectNode prev) {
<span class="nc" id="L2171">            super(prev);</span>
<span class="nc" id="L2172">            inspect = prev.inspect;</span>
<span class="nc" id="L2173">        }</span>

        @Specialization
        public RubyString inspect(VirtualFrame frame, RubyArray array) {
<span class="nc" id="L2177">            notDesignedForCompilation();</span>

<span class="nc" id="L2179">            final StringBuilder builder = new StringBuilder();</span>
<span class="nc" id="L2180">            final Object[] objects = array.slowToArray();</span>

<span class="nc" id="L2182">            builder.append(&quot;[&quot;);</span>

<span class="nc bnc" id="L2184" title="All 2 branches missed.">            for (int n = 0; n &lt; objects.length; n++) {</span>
<span class="nc bnc" id="L2185" title="All 2 branches missed.">                if (n &gt; 0) {</span>
<span class="nc" id="L2186">                    builder.append(&quot;, &quot;);</span>
                }

                // TODO(CS): cast

<span class="nc" id="L2191">                final RubyString string = (RubyString) inspect.call(frame, objects[n], &quot;inspect&quot;, null);</span>
<span class="nc" id="L2192">                builder.append(string.getBytes().toString());</span>
            }

<span class="nc" id="L2195">            builder.append(&quot;]&quot;);</span>

<span class="nc" id="L2197">            return getContext().makeString(builder.toString());</span>
        }

    }

    @CoreMethod(names = &quot;join&quot;, optional = 1)
    public abstract static class JoinNode extends ArrayCoreMethodNode {

        public JoinNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L2206">            super(context, sourceSection);</span>
<span class="nc" id="L2207">        }</span>

        public JoinNode(JoinNode prev) {
<span class="nc" id="L2210">            super(prev);</span>
<span class="nc" id="L2211">        }</span>

        @Specialization
        public RubyString join(RubyArray array, UndefinedPlaceholder unused) {
<span class="nc" id="L2215">            Object separator = getContext().getCoreLibrary().getGlobalVariablesObject().getInstanceVariable(&quot;$,&quot;);</span>
<span class="nc bnc" id="L2216" title="All 2 branches missed.">            if (separator == getContext().getCoreLibrary().getNilObject()) {</span>
<span class="nc" id="L2217">                separator = getContext().makeString(&quot;&quot;);</span>
            }

<span class="nc bnc" id="L2220" title="All 2 branches missed.">            if (separator instanceof RubyString) {</span>
<span class="nc" id="L2221">                return join(array, (RubyString) separator);</span>
            } else {
<span class="nc" id="L2223">                throw new UnsupportedOperationException();</span>
            }
        }

        @Specialization
        public RubyString join(RubyArray array, RubyString separator) {
<span class="nc" id="L2229">            notDesignedForCompilation();</span>

<span class="nc" id="L2231">            final StringBuilder builder = new StringBuilder();</span>

<span class="nc" id="L2233">            final Object[] objects = array.slowToArray();</span>

<span class="nc bnc" id="L2235" title="All 2 branches missed.">            for (int n = 0; n &lt; objects.length; n++) {</span>
<span class="nc bnc" id="L2236" title="All 2 branches missed.">                if (n &gt; 0) {</span>
<span class="nc" id="L2237">                    builder.append(separator);</span>
                }

<span class="nc" id="L2240">                builder.append(objects[n]);</span>
            }

<span class="nc" id="L2243">            return getContext().makeString(builder.toString());</span>
        }

    }

    @CoreMethod(names = &quot;last&quot;)
    public abstract static class LastNode extends ArrayCoreMethodNode {

        public LastNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L2252">            super(context, sourceSection);</span>
<span class="nc" id="L2253">        }</span>

        public LastNode(LastNode prev) {
<span class="nc" id="L2256">            super(prev);</span>
<span class="nc" id="L2257">        }</span>

        @Specialization
        public Object last(RubyArray array) {
<span class="nc" id="L2261">            notDesignedForCompilation();</span>

<span class="nc bnc" id="L2263" title="All 2 branches missed.">            if (array.getSize() == 0) {</span>
<span class="nc" id="L2264">                return getContext().getCoreLibrary().getNilObject();</span>
            } else {
<span class="nc" id="L2266">                return array.slowToArray()[array.getSize() - 1];</span>
            }
        }

    }

    @CoreMethod(names = {&quot;map&quot;, &quot;collect&quot;}, needsBlock = true)
    @ImportGuards(ArrayGuards.class)
    public abstract static class MapNode extends YieldingCoreMethodNode {

        @Child protected ArrayBuilderNode arrayBuilder;

        public MapNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L2279">            super(context, sourceSection);</span>
<span class="nc" id="L2280">            arrayBuilder = new ArrayBuilderNode.UninitializedArrayBuilderNode(context);</span>
<span class="nc" id="L2281">        }</span>

        public MapNode(MapNode prev) {
<span class="nc" id="L2284">            super(prev);</span>
<span class="nc" id="L2285">            arrayBuilder = prev.arrayBuilder;</span>
<span class="nc" id="L2286">        }</span>

        @Specialization(guards = &quot;isNull&quot;)
        public RubyArray mapNull(RubyArray array, RubyProc block) {
<span class="nc" id="L2290">            return new RubyArray(getContext().getCoreLibrary().getArrayClass());</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public RubyArray mapIntegerFixnum(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L2295">            final int[] store = (int[]) array.getStore();</span>
<span class="nc" id="L2296">            final int arraySize = array.getSize();</span>
<span class="nc" id="L2297">            Object mappedStore = arrayBuilder.start(arraySize);</span>

<span class="nc" id="L2299">            int count = 0;</span>

            try {
<span class="nc bnc" id="L2302" title="All 2 branches missed.">                for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L2303" title="All 2 branches missed.">                    if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L2304">                        count++;</span>
                    }

<span class="nc" id="L2307">                    mappedStore = arrayBuilder.append(mappedStore, n, yield(frame, block, store[n]));</span>
                }
            } finally {
<span class="nc bnc" id="L2310" title="All 4 branches missed.">                if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L2311">                    ((RubyRootNode) getRootNode()).reportLoopCount(count);</span>
                }
            }

<span class="nc" id="L2315">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), arrayBuilder.finish(mappedStore, arraySize), arraySize);</span>
        }

        @Specialization(guards = &quot;isLongFixnum&quot;)
        public RubyArray mapLongFixnum(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L2320">            final long[] store = (long[]) array.getStore();</span>
<span class="nc" id="L2321">            final int arraySize = array.getSize();</span>
<span class="nc" id="L2322">            Object mappedStore = arrayBuilder.start(arraySize);</span>

<span class="nc" id="L2324">            int count = 0;</span>

            try {
<span class="nc bnc" id="L2327" title="All 2 branches missed.">                for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L2328" title="All 2 branches missed.">                    if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L2329">                        count++;</span>
                    }

<span class="nc" id="L2332">                    mappedStore = arrayBuilder.append(mappedStore, n, yield(frame, block, store[n]));</span>
                }
            } finally {
<span class="nc bnc" id="L2335" title="All 4 branches missed.">                if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L2336">                    ((RubyRootNode) getRootNode()).reportLoopCount(count);</span>
                }
            }

<span class="nc" id="L2340">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), arrayBuilder.finish(mappedStore, arraySize), arraySize);</span>
        }

        @Specialization(guards = &quot;isFloat&quot;)
        public RubyArray mapFloat(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L2345">            final double[] store = (double[]) array.getStore();</span>
<span class="nc" id="L2346">            final int arraySize = array.getSize();</span>
<span class="nc" id="L2347">            Object mappedStore = arrayBuilder.start(arraySize);</span>

<span class="nc" id="L2349">            int count = 0;</span>

            try {
<span class="nc bnc" id="L2352" title="All 2 branches missed.">                for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L2353" title="All 2 branches missed.">                    if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L2354">                        count++;</span>
                    }

<span class="nc" id="L2357">                    mappedStore = arrayBuilder.append(mappedStore, n, yield(frame, block, store[n]));</span>
                }
            } finally {
<span class="nc bnc" id="L2360" title="All 4 branches missed.">                if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L2361">                    getRootNode().reportLoopCount(count);</span>
                }
            }

<span class="nc" id="L2365">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), arrayBuilder.finish(mappedStore, arraySize), arraySize);</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public RubyArray mapObject(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L2370">            final Object[] store = (Object[]) array.getStore();</span>
<span class="nc" id="L2371">            final int arraySize = array.getSize();</span>
<span class="nc" id="L2372">            Object mappedStore = arrayBuilder.start(arraySize);</span>

<span class="nc" id="L2374">            int count = 0;</span>

            try {
<span class="nc bnc" id="L2377" title="All 2 branches missed.">                for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L2378" title="All 2 branches missed.">                    if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L2379">                        count++;</span>
                    }

<span class="nc" id="L2382">                    mappedStore = arrayBuilder.append(mappedStore, n, yield(frame, block, store[n]));</span>
                }
            } finally {
<span class="nc bnc" id="L2385" title="All 4 branches missed.">                if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L2386">                    ((RubyRootNode) getRootNode()).reportLoopCount(count);</span>
                }
            }

<span class="nc" id="L2390">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), arrayBuilder.finish(mappedStore, arraySize), arraySize);</span>
        }
    }

    @CoreMethod(names = {&quot;map!&quot;, &quot;collect!&quot;}, needsBlock = true)
    @ImportGuards(ArrayGuards.class)
    public abstract static class MapInPlaceNode extends YieldingCoreMethodNode {

        @Child protected ArrayBuilderNode arrayBuilder;

        public MapInPlaceNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L2401">            super(context, sourceSection);</span>
<span class="nc" id="L2402">            arrayBuilder = new ArrayBuilderNode.UninitializedArrayBuilderNode(context);</span>
<span class="nc" id="L2403">        }</span>

        public MapInPlaceNode(MapInPlaceNode prev) {
<span class="nc" id="L2406">            super(prev);</span>
<span class="nc" id="L2407">            arrayBuilder = prev.arrayBuilder;</span>
<span class="nc" id="L2408">        }</span>

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public RubyArray mapInPlaceFixnumInteger(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L2412">            final int[] store = (int[]) array.getStore();</span>
<span class="nc" id="L2413">            final int arraySize = array.getSize();</span>
<span class="nc" id="L2414">            Object mappedStore = arrayBuilder.start(arraySize);</span>

<span class="nc" id="L2416">            int count = 0;</span>

            try {
<span class="nc bnc" id="L2419" title="All 2 branches missed.">                for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L2420" title="All 2 branches missed.">                    if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L2421">                        count++;</span>
                    }

<span class="nc" id="L2424">                    mappedStore = arrayBuilder.append(mappedStore, n, yield(frame, block, store[n]));</span>
                }
            } finally {
<span class="nc bnc" id="L2427" title="All 4 branches missed.">                if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L2428">                    ((RubyRootNode) getRootNode()).reportLoopCount(count);</span>
                }
            }

<span class="nc" id="L2432">            array.setStore(arrayBuilder.finish(mappedStore, arraySize), arraySize);</span>

<span class="nc" id="L2434">            return array;</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public RubyArray mapInPlaceObject(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L2439">            final Object[] store = (Object[]) array.getStore();</span>
<span class="nc" id="L2440">            final int arraySize = array.getSize();</span>
<span class="nc" id="L2441">            Object mappedStore = arrayBuilder.start(arraySize);</span>

<span class="nc" id="L2443">            int count = 0;</span>

            try {
<span class="nc bnc" id="L2446" title="All 2 branches missed.">                for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L2447" title="All 2 branches missed.">                    if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L2448">                        count++;</span>
                    }

<span class="nc" id="L2451">                    mappedStore = arrayBuilder.append(mappedStore, n, yield(frame, block, store[n]));</span>
                }
            } finally {
<span class="nc bnc" id="L2454" title="All 4 branches missed.">                if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L2455">                    ((RubyRootNode) getRootNode()).reportLoopCount(count);</span>
                }
            }

<span class="nc" id="L2459">            array.setStore(arrayBuilder.finish(mappedStore, arraySize), arraySize);</span>

<span class="nc" id="L2461">            return array;</span>
        }
    }

    // TODO: move into Enumerable?

    @CoreMethod(names = &quot;max&quot;)
    public abstract static class MaxNode extends ArrayCoreMethodNode {

        @Child protected DispatchHeadNode eachNode;
        private final MaxBlock maxBlock;

        public MaxNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L2474">            super(context, sourceSection);</span>
<span class="nc" id="L2475">            eachNode = new DispatchHeadNode(context);</span>
<span class="nc" id="L2476">            maxBlock = context.getCoreLibrary().getArrayMaxBlock();</span>
<span class="nc" id="L2477">        }</span>

        public MaxNode(MaxNode prev) {
<span class="nc" id="L2480">            super(prev);</span>
<span class="nc" id="L2481">            eachNode = prev.eachNode;</span>
<span class="nc" id="L2482">            maxBlock = prev.maxBlock;</span>
<span class="nc" id="L2483">        }</span>

        @Specialization
        public Object max(VirtualFrame frame, RubyArray array) {
            // TODO: can we just write to the frame instead of having this indirect object?

<span class="nc" id="L2489">            final Memo&lt;Object&gt; maximum = new Memo&lt;&gt;();</span>

<span class="nc" id="L2491">            final VirtualFrame maximumClosureFrame = Truffle.getRuntime().createVirtualFrame(RubyArguments.pack(maxBlock, null, array, null, new Object[]{}), maxBlock.getFrameDescriptor());</span>
<span class="nc" id="L2492">            maximumClosureFrame.setObject(maxBlock.getFrameSlot(), maximum);</span>

<span class="nc" id="L2494">            final RubyProc block = new RubyProc(getContext().getCoreLibrary().getProcClass(), RubyProc.Type.PROC,</span>
<span class="nc" id="L2495">                    maxBlock.getSharedMethodInfo(), maxBlock.getCallTarget(), maxBlock.getCallTarget(),</span>
<span class="nc" id="L2496">                    maximumClosureFrame.materialize(), null, null, array, null);</span>

<span class="nc" id="L2498">            eachNode.call(frame, array, &quot;each&quot;, block);</span>

<span class="nc bnc" id="L2500" title="All 2 branches missed.">            if (maximum.get() == null) {</span>
<span class="nc" id="L2501">                return getContext().getCoreLibrary().getNilObject();</span>
            } else {
<span class="nc" id="L2503">                return maximum.get();</span>
            }
        }

    }

    public abstract static class MaxBlockNode extends CoreMethodNode {

        @Child protected DispatchHeadNode compareNode;

        public MaxBlockNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L2514">            super(context, sourceSection);</span>
<span class="nc" id="L2515">            compareNode = new DispatchHeadNode(context);</span>
<span class="nc" id="L2516">        }</span>

        public MaxBlockNode(MaxBlockNode prev) {
<span class="nc" id="L2519">            super(prev);</span>
<span class="nc" id="L2520">            compareNode = prev.compareNode;</span>
<span class="nc" id="L2521">        }</span>

        @Specialization
        public RubyNilClass max(VirtualFrame frame, Object maximumObject, Object value) {
<span class="nc" id="L2525">            final Memo&lt;Object&gt; maximum = (Memo&lt;Object&gt;) maximumObject;</span>

            // TODO(CS): cast

<span class="nc" id="L2529">            final Object current = maximum.get();</span>

<span class="nc bnc" id="L2531" title="All 4 branches missed.">            if (current == null || (int) compareNode.call(frame, value, &quot;&lt;=&gt;&quot;, null, current) &lt; 0) {</span>
<span class="nc" id="L2532">                maximum.set(value);</span>
            }

<span class="nc" id="L2535">            return getContext().getCoreLibrary().getNilObject();</span>
        }

    }

    public static class MaxBlock implements MethodLike {

        private final FrameDescriptor frameDescriptor;
        private final FrameSlot frameSlot;
        private final SharedMethodInfo sharedMethodInfo;
        private final CallTarget callTarget;

<span class="nc" id="L2547">        public MaxBlock(RubyContext context) {</span>
<span class="nc" id="L2548">            final SourceSection sourceSection = new CoreSourceSection(&quot;Array&quot;, &quot;max&quot;);</span>

<span class="nc" id="L2550">            frameDescriptor = new FrameDescriptor();</span>
<span class="nc" id="L2551">            frameSlot = frameDescriptor.addFrameSlot(&quot;maximum_memo&quot;);</span>

<span class="nc" id="L2553">            sharedMethodInfo = new SharedMethodInfo(sourceSection, null, &quot;max&quot;, false, null, false);</span>

<span class="nc" id="L2555">            callTarget = Truffle.getRuntime().createCallTarget(new RubyRootNode(</span>
                    context, sourceSection, null, sharedMethodInfo,
<span class="nc" id="L2557">                    ArrayNodesFactory.MaxBlockNodeFactory.create(context, sourceSection, new RubyNode[]{</span>
<span class="nc" id="L2558">                            ReadLevelVariableNodeFactory.create(context, sourceSection, frameSlot, 1),</span>
                            new ReadPreArgumentNode(context, sourceSection, 0, MissingArgumentBehaviour.RUNTIME_ERROR)
                    })));
<span class="nc" id="L2561">        }</span>

        public FrameDescriptor getFrameDescriptor() {
<span class="nc" id="L2564">            return frameDescriptor;</span>
        }

        public FrameSlot getFrameSlot() {
<span class="nc" id="L2568">            return frameSlot;</span>
        }

        @Override
        public SharedMethodInfo getSharedMethodInfo() {
<span class="nc" id="L2573">            return sharedMethodInfo;</span>
        }

        @Override
        public RubyModule getDeclaringModule() {
<span class="nc" id="L2578">            throw new UnsupportedOperationException();</span>
        }

        public CallTarget getCallTarget() {
<span class="nc" id="L2582">            return callTarget;</span>
        }
    }

    @CoreMethod(names = &quot;min&quot;)
    public abstract static class MinNode extends ArrayCoreMethodNode {

        @Child protected DispatchHeadNode eachNode;
        private final MinBlock minBlock;

        public MinNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L2593">            super(context, sourceSection);</span>
<span class="nc" id="L2594">            eachNode = new DispatchHeadNode(context);</span>
<span class="nc" id="L2595">            minBlock = context.getCoreLibrary().getArrayMinBlock();</span>
<span class="nc" id="L2596">        }</span>

        public MinNode(MinNode prev) {
<span class="nc" id="L2599">            super(prev);</span>
<span class="nc" id="L2600">            eachNode = prev.eachNode;</span>
<span class="nc" id="L2601">            minBlock = prev.minBlock;</span>
<span class="nc" id="L2602">        }</span>

        @Specialization
        public Object min(VirtualFrame frame, RubyArray array) {
            // TODO: can we just write to the frame instead of having this indirect object?

<span class="nc" id="L2608">            final Memo&lt;Object&gt; minimum = new Memo&lt;&gt;();</span>

<span class="nc" id="L2610">            final VirtualFrame minimumClosureFrame = Truffle.getRuntime().createVirtualFrame(RubyArguments.pack(minBlock, null, array, null, new Object[]{}), minBlock.getFrameDescriptor());</span>
<span class="nc" id="L2611">            minimumClosureFrame.setObject(minBlock.getFrameSlot(), minimum);</span>

<span class="nc" id="L2613">            final RubyProc block = new RubyProc(getContext().getCoreLibrary().getProcClass(), RubyProc.Type.PROC,</span>
<span class="nc" id="L2614">                    minBlock.getSharedMethodInfo(), minBlock.getCallTarget(), minBlock.getCallTarget(),</span>
<span class="nc" id="L2615">                    minimumClosureFrame.materialize(), null, null, array, null);</span>

<span class="nc" id="L2617">            eachNode.call(frame, array, &quot;each&quot;, block);</span>

<span class="nc bnc" id="L2619" title="All 2 branches missed.">            if (minimum.get() == null) {</span>
<span class="nc" id="L2620">                return getContext().getCoreLibrary().getNilObject();</span>
            } else {
<span class="nc" id="L2622">                return minimum.get();</span>
            }
        }

    }

    public abstract static class MinBlockNode extends CoreMethodNode {

        @Child protected DispatchHeadNode compareNode;

        public MinBlockNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L2633">            super(context, sourceSection);</span>
<span class="nc" id="L2634">            compareNode = new DispatchHeadNode(context);</span>
<span class="nc" id="L2635">        }</span>

        public MinBlockNode(MinBlockNode prev) {
<span class="nc" id="L2638">            super(prev);</span>
<span class="nc" id="L2639">            compareNode = prev.compareNode;</span>
<span class="nc" id="L2640">        }</span>

        @Specialization
        public RubyNilClass min(VirtualFrame frame, Object minimumObject, Object value) {
<span class="nc" id="L2644">            final Memo&lt;Object&gt; minimum = (Memo&lt;Object&gt;) minimumObject;</span>

            // TODO(CS): cast

<span class="nc" id="L2648">            final Object current = minimum.get();</span>

<span class="nc bnc" id="L2650" title="All 4 branches missed.">            if (current == null || (int) compareNode.call(frame, value, &quot;&lt;=&gt;&quot;, null, current) &lt; 0) {</span>
<span class="nc" id="L2651">                minimum.set(value);</span>
            }

<span class="nc" id="L2654">            return getContext().getCoreLibrary().getNilObject();</span>
        }

    }

    public static class MinBlock implements MethodLike {

        private final FrameDescriptor frameDescriptor;
        private final FrameSlot frameSlot;
        private final SharedMethodInfo sharedMethodInfo;
        private final CallTarget callTarget;

<span class="nc" id="L2666">        public MinBlock(RubyContext context) {</span>
<span class="nc" id="L2667">            final SourceSection sourceSection = new CoreSourceSection(&quot;Array&quot;, &quot;min&quot;);</span>

<span class="nc" id="L2669">            frameDescriptor = new FrameDescriptor();</span>
<span class="nc" id="L2670">            frameSlot = frameDescriptor.addFrameSlot(&quot;minimum_memo&quot;);</span>

<span class="nc" id="L2672">            sharedMethodInfo = new SharedMethodInfo(sourceSection, null, &quot;min&quot;, false, null, false);</span>

<span class="nc" id="L2674">            callTarget = Truffle.getRuntime().createCallTarget(new RubyRootNode(</span>
                    context, sourceSection, null, sharedMethodInfo,
<span class="nc" id="L2676">                    ArrayNodesFactory.MinBlockNodeFactory.create(context, sourceSection, new RubyNode[]{</span>
<span class="nc" id="L2677">                            ReadLevelVariableNodeFactory.create(context, sourceSection, frameSlot, 1),</span>
                            new ReadPreArgumentNode(context, sourceSection, 0, MissingArgumentBehaviour.RUNTIME_ERROR)
                    })));
<span class="nc" id="L2680">        }</span>

        public FrameDescriptor getFrameDescriptor() {
<span class="nc" id="L2683">            return frameDescriptor;</span>
        }

        public FrameSlot getFrameSlot() {
<span class="nc" id="L2687">            return frameSlot;</span>
        }

        @Override
        public SharedMethodInfo getSharedMethodInfo() {
<span class="nc" id="L2692">            return sharedMethodInfo;</span>
        }

        @Override
        public RubyModule getDeclaringModule() {
<span class="nc" id="L2697">            throw new UnsupportedOperationException();</span>
        }

        public CallTarget getCallTarget() {
<span class="nc" id="L2701">            return callTarget;</span>
        }
    }

    @CoreMethod(names = &quot;pack&quot;, required = 1)
    public abstract static class PackNode extends ArrayCoreMethodNode {

        public PackNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L2709">            super(context, sourceSection);</span>
<span class="nc" id="L2710">        }</span>

        public PackNode(PackNode prev) {
<span class="nc" id="L2713">            super(prev);</span>
<span class="nc" id="L2714">        }</span>

        @CompilerDirectives.TruffleBoundary
        @Specialization
        public RubyString pack(RubyArray array, RubyString format) {
<span class="nc" id="L2719">            notDesignedForCompilation();</span>

<span class="nc" id="L2721">            return new RubyString(</span>
<span class="nc" id="L2722">                    getContext().getCoreLibrary().getStringClass(),</span>
<span class="nc" id="L2723">                    org.jruby.util.Pack.pack(</span>
<span class="nc" id="L2724">                            getContext().getRuntime(),</span>
<span class="nc" id="L2725">                            getContext().toJRuby(array),</span>
<span class="nc" id="L2726">                            getContext().toJRuby(format).getByteList()).getByteList());</span>

        }

    }

    @CoreMethod(names = &quot;permutation&quot;, required = 1)
    public abstract static class PermutationNode extends ArrayCoreMethodNode {

        public PermutationNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L2736">            super(context, sourceSection);</span>
<span class="nc" id="L2737">        }</span>

        public PermutationNode(PermutationNode prev) {
<span class="nc" id="L2740">            super(prev);</span>
<span class="nc" id="L2741">        }</span>

        @Specialization
        public RubyArray permutation(RubyArray array, int n) {
<span class="nc" id="L2745">            notDesignedForCompilation();</span>

<span class="nc" id="L2747">            final List&lt;RubyArray&gt; permutations = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2748">            permutationCommon(n, false, array.slowToArray(), permutations);</span>
<span class="nc" id="L2749">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), permutations.toArray(), permutations.size());</span>
        }

        // Apdapted from JRuby's RubyArray - see attribution there

        private void permutationCommon(int r, boolean repeat, Object[] values, List&lt;RubyArray&gt; permutations) {
<span class="nc bnc" id="L2755" title="All 2 branches missed.">            if (r == 0) {</span>
<span class="nc" id="L2756">                permutations.add(new RubyArray(getContext().getCoreLibrary().getArrayClass(), null, 0));</span>
<span class="nc bnc" id="L2757" title="All 2 branches missed.">            } else if (r == 1) {</span>
<span class="nc bnc" id="L2758" title="All 2 branches missed.">                for (int i = 0; i &lt; values.length; i++) {</span>
<span class="nc" id="L2759">                    permutations.add(new RubyArray(getContext().getCoreLibrary().getArrayClass(), values[i], 1));</span>
                }
<span class="nc bnc" id="L2761" title="All 2 branches missed.">            } else if (r &gt;= 0) {</span>
<span class="nc" id="L2762">                int n = values.length;</span>
<span class="nc" id="L2763">                permute(n, r,</span>
                        new int[r], 0,
                        new boolean[n],
                        repeat,
                        values, permutations);
            }
<span class="nc" id="L2769">        }</span>

        private void permute(int n, int r, int[]p, int index, boolean[]used, boolean repeat, Object[] values, List&lt;RubyArray&gt; permutations) {
<span class="nc bnc" id="L2772" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc bnc" id="L2773" title="All 4 branches missed.">                if (repeat || !used[i]) {</span>
<span class="nc" id="L2774">                    p[index] = i;</span>
<span class="nc bnc" id="L2775" title="All 2 branches missed.">                    if (index &lt; r - 1) {</span>
<span class="nc" id="L2776">                        used[i] = true;</span>
<span class="nc" id="L2777">                        permute(n, r, p, index + 1, used, repeat, values, permutations);</span>
<span class="nc" id="L2778">                        used[i] = false;</span>
                    } else {
<span class="nc" id="L2780">                        Object[] result = new Object[r];</span>

<span class="nc bnc" id="L2782" title="All 2 branches missed.">                        for (int j = 0; j &lt; r; j++) {</span>
<span class="nc" id="L2783">                            result[j] = values[p[j]];</span>
                        }

<span class="nc" id="L2786">                        permutations.add(new RubyArray(getContext().getCoreLibrary().getArrayClass(), result, r));</span>
                    }
                }
            }
<span class="nc" id="L2790">        }</span>

    }

    @CoreMethod(names = &quot;pop&quot;)
    public abstract static class PopNode extends ArrayCoreMethodNode {

        public PopNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L2798">            super(context, sourceSection);</span>
<span class="nc" id="L2799">        }</span>

        public PopNode(PopNode prev) {
<span class="nc" id="L2802">            super(prev);</span>
<span class="nc" id="L2803">        }</span>

        @Specialization(guards = &quot;isNull&quot;)
        public Object popNil(RubyArray array) {
<span class="nc" id="L2807">            return getContext().getCoreLibrary().getNilObject();</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;, rewriteOn = UnexpectedResultException.class)
        public int popIntegerFixnumInBounds(RubyArray array) throws UnexpectedResultException {
<span class="nc bnc" id="L2812" title="All 4 branches missed.">            if (CompilerDirectives.injectBranchProbability(CompilerDirectives.UNLIKELY_PROBABILITY, array.getSize() == 0)) {</span>
<span class="nc" id="L2813">                throw new UnexpectedResultException(getContext().getCoreLibrary().getNilObject());</span>
            } else {
<span class="nc" id="L2815">                final int value = ((int[]) array.getStore())[array.getSize() - 1];</span>
<span class="nc" id="L2816">                array.setSize(array.getSize() - 1);</span>
<span class="nc" id="L2817">                return value;</span>
            }
        }

        @Specialization(contains = &quot;popIntegerFixnumInBounds&quot;, guards = &quot;isIntegerFixnum&quot;)
        public Object popIntegerFixnum(RubyArray array) {
<span class="nc bnc" id="L2823" title="All 4 branches missed.">            if (CompilerDirectives.injectBranchProbability(CompilerDirectives.UNLIKELY_PROBABILITY, array.getSize() == 0)) {</span>
<span class="nc" id="L2824">                return getContext().getCoreLibrary().getNilObject();</span>
            } else {
<span class="nc" id="L2826">                final int value = ((int[]) array.getStore())[array.getSize() - 1];</span>
<span class="nc" id="L2827">                array.setSize(array.getSize() - 1);</span>
<span class="nc" id="L2828">                return value;</span>
            }
        }

        @Specialization(guards = &quot;isLongFixnum&quot;, rewriteOn = UnexpectedResultException.class)
        public long popLongFixnumInBounds(RubyArray array) throws UnexpectedResultException {
<span class="nc bnc" id="L2834" title="All 4 branches missed.">            if (CompilerDirectives.injectBranchProbability(CompilerDirectives.UNLIKELY_PROBABILITY, array.getSize() == 0)) {</span>
<span class="nc" id="L2835">                throw new UnexpectedResultException(getContext().getCoreLibrary().getNilObject());</span>
            } else {
<span class="nc" id="L2837">                final long value = ((long[]) array.getStore())[array.getSize() - 1];</span>
<span class="nc" id="L2838">                array.setSize(array.getSize() - 1);</span>
<span class="nc" id="L2839">                return value;</span>
            }
        }

        @Specialization(contains = &quot;popLongFixnumInBounds&quot;, guards = &quot;isLongFixnum&quot;)
        public Object popLongFixnum(RubyArray array) {
<span class="nc bnc" id="L2845" title="All 4 branches missed.">            if (CompilerDirectives.injectBranchProbability(CompilerDirectives.UNLIKELY_PROBABILITY, array.getSize() == 0)) {</span>
<span class="nc" id="L2846">                return getContext().getCoreLibrary().getNilObject();</span>
            } else {
<span class="nc" id="L2848">                final long value = ((long[]) array.getStore())[array.getSize() - 1];</span>
<span class="nc" id="L2849">                array.setSize(array.getSize() - 1);</span>
<span class="nc" id="L2850">                return value;</span>
            }
        }

        @Specialization(guards = &quot;isFloat&quot;, rewriteOn = UnexpectedResultException.class)
        public double popFloatInBounds(RubyArray array) throws UnexpectedResultException {
<span class="nc bnc" id="L2856" title="All 4 branches missed.">            if (CompilerDirectives.injectBranchProbability(CompilerDirectives.UNLIKELY_PROBABILITY, array.getSize() == 0)) {</span>
<span class="nc" id="L2857">                throw new UnexpectedResultException(getContext().getCoreLibrary().getNilObject());</span>
            } else {
<span class="nc" id="L2859">                final double value = ((double[]) array.getStore())[array.getSize() - 1];</span>
<span class="nc" id="L2860">                array.setSize(array.getSize() - 1);</span>
<span class="nc" id="L2861">                return value;</span>
            }
        }

        @Specialization(contains = &quot;popFloatInBounds&quot;, guards = &quot;isFloat&quot;)
        public Object popFloat(RubyArray array) {
<span class="nc bnc" id="L2867" title="All 4 branches missed.">            if (CompilerDirectives.injectBranchProbability(CompilerDirectives.UNLIKELY_PROBABILITY, array.getSize() == 0)) {</span>
<span class="nc" id="L2868">                return getContext().getCoreLibrary().getNilObject();</span>
            } else {
<span class="nc" id="L2870">                final double value = ((double[]) array.getStore())[array.getSize() - 1];</span>
<span class="nc" id="L2871">                array.setSize(array.getSize() - 1);</span>
<span class="nc" id="L2872">                return value;</span>
            }
        }

        @Specialization(guards = &quot;isObject&quot;)
        public Object popObject(RubyArray array) {
<span class="nc bnc" id="L2878" title="All 4 branches missed.">            if (CompilerDirectives.injectBranchProbability(CompilerDirectives.UNLIKELY_PROBABILITY, array.getSize() == 0)) {</span>
<span class="nc" id="L2879">                return getContext().getCoreLibrary().getNilObject();</span>
            } else {
<span class="nc" id="L2881">                final Object value = ((Object[]) array.getStore())[array.getSize() - 1];</span>
<span class="nc" id="L2882">                array.setSize(array.getSize() - 1);</span>
<span class="nc" id="L2883">                return value;</span>
            }
        }

    }

    @CoreMethod(names = &quot;product&quot;, required = 1)
    public abstract static class ProductNode extends ArrayCoreMethodNode {

        public ProductNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L2893">            super(context, sourceSection);</span>
<span class="nc" id="L2894">        }</span>

        public ProductNode(ProductNode prev) {
<span class="nc" id="L2897">            super(prev);</span>
<span class="nc" id="L2898">        }</span>

        @Specialization(guards = {&quot;isObject&quot;, &quot;isOtherObject&quot;})
        public Object product(RubyArray array, RubyArray other) {
<span class="nc" id="L2902">            final Object[] a = (Object[]) array.getStore();</span>
<span class="nc" id="L2903">            final int aLength = array.getSize();</span>

<span class="nc" id="L2905">            final Object[] b = (Object[]) other.getStore();</span>
<span class="nc" id="L2906">            final int bLength = other.getSize();</span>

<span class="nc" id="L2908">            final Object[] pairs = new Object[aLength * bLength];</span>

<span class="nc bnc" id="L2910" title="All 2 branches missed.">            for (int an = 0; an &lt; aLength; an++) {</span>
<span class="nc bnc" id="L2911" title="All 2 branches missed.">                for (int bn = 0; bn &lt; bLength; bn++) {</span>
<span class="nc" id="L2912">                    pairs[an * bLength + bn] = new RubyArray(getContext().getCoreLibrary().getArrayClass(), new Object[]{a[an], b[bn]}, 2);</span>
                }
            }

<span class="nc" id="L2916">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), pairs, pairs.length);</span>
        }

    }

    @CoreMethod(names = {&quot;push&quot;, &quot;&lt;&lt;&quot;}, argumentsAsArray = true)
    public abstract static class PushNode extends ArrayCoreMethodNode {

<span class="nc" id="L2924">        private final BranchProfile extendBranch = BranchProfile.create();</span>

        public PushNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L2927">            super(context, sourceSection);</span>
<span class="nc" id="L2928">        }</span>

        public PushNode(PushNode prev) {
<span class="nc" id="L2931">            super(prev);</span>
<span class="nc" id="L2932">        }</span>

        @Specialization(guards = {&quot;isNull&quot;, &quot;isSingleIntegerFixnum&quot;})
        public RubyArray pushEmptySingleIntegerFixnum(RubyArray array, Object... values) {
<span class="nc" id="L2936">            array.setStore(new int[]{(int) values[0]}, 1);</span>
<span class="nc" id="L2937">            return array;</span>
        }

        @Specialization(guards = {&quot;isNull&quot;, &quot;isSingleLongFixnum&quot;})
        public RubyArray pushEmptySingleIntegerLong(RubyArray array, Object... values) {
<span class="nc" id="L2942">            array.setStore(new long[]{(long) values[0]}, 1);</span>
<span class="nc" id="L2943">            return array;</span>
        }

        @Specialization(guards = &quot;isNull&quot;)
        public RubyArray pushEmptyObjects(RubyArray array, Object... values) {
<span class="nc" id="L2948">            array.setStore(values, values.length);</span>
<span class="nc" id="L2949">            return array;</span>
        }

        @Specialization(guards = {&quot;isIntegerFixnum&quot;, &quot;isSingleIntegerFixnum&quot;})
        public RubyArray pushIntegerFixnumSingleIntegerFixnum(RubyArray array, Object... values) {
<span class="nc" id="L2954">            final int oldSize = array.getSize();</span>
<span class="nc" id="L2955">            final int newSize = oldSize + 1;</span>

<span class="nc" id="L2957">            int[] store = (int[]) array.getStore();</span>

<span class="nc bnc" id="L2959" title="All 2 branches missed.">            if (store.length &lt; newSize) {</span>
<span class="nc" id="L2960">                extendBranch.enter();</span>
<span class="nc" id="L2961">                store = Arrays.copyOf(store, ArrayUtils.capacity(store.length, newSize));</span>
<span class="nc" id="L2962">                array.setStore(store, array.getSize());</span>
            }

<span class="nc" id="L2965">            store[oldSize] = (int) values[0];</span>
<span class="nc" id="L2966">            array.setSize(newSize);</span>
<span class="nc" id="L2967">            return array;</span>
        }

        @Specialization(guards = {&quot;isLongFixnum&quot;, &quot;isSingleIntegerFixnum&quot;})
        public RubyArray pushLongFixnumSingleIntegerFixnum(RubyArray array, Object... values) {
<span class="nc" id="L2972">            final int oldSize = array.getSize();</span>
<span class="nc" id="L2973">            final int newSize = oldSize + 1;</span>

<span class="nc" id="L2975">            long[] store = (long[]) array.getStore();</span>

<span class="nc bnc" id="L2977" title="All 2 branches missed.">            if (store.length &lt; newSize) {</span>
<span class="nc" id="L2978">                extendBranch.enter();</span>
<span class="nc" id="L2979">                store = Arrays.copyOf(store, ArrayUtils.capacity(store.length, newSize));</span>
<span class="nc" id="L2980">                array.setStore(store, array.getSize());</span>
            }

<span class="nc" id="L2983">            store[oldSize] = (long) (int) values[0];</span>
<span class="nc" id="L2984">            array.setSize(newSize);</span>
<span class="nc" id="L2985">            return array;</span>
        }

        @Specialization(guards = {&quot;isLongFixnum&quot;, &quot;isSingleLongFixnum&quot;})
        public RubyArray pushLongFixnumSingleLongFixnum(RubyArray array, Object... values) {
<span class="nc" id="L2990">            final int oldSize = array.getSize();</span>
<span class="nc" id="L2991">            final int newSize = oldSize + 1;</span>

<span class="nc" id="L2993">            long[] store = (long[]) array.getStore();</span>

<span class="nc bnc" id="L2995" title="All 2 branches missed.">            if (store.length &lt; newSize) {</span>
<span class="nc" id="L2996">                extendBranch.enter();</span>
<span class="nc" id="L2997">                store = Arrays.copyOf(store, ArrayUtils.capacity(store.length, newSize));</span>
<span class="nc" id="L2998">                array.setStore(store, array.getSize());</span>
            }

<span class="nc" id="L3001">            store[oldSize] = (long) values[0];</span>
<span class="nc" id="L3002">            array.setSize(newSize);</span>
<span class="nc" id="L3003">            return array;</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public RubyArray pushObject(RubyArray array, Object... values) {
<span class="nc" id="L3008">            final int oldSize = array.getSize();</span>
<span class="nc" id="L3009">            final int newSize = oldSize + values.length;</span>

<span class="nc" id="L3011">            Object[] store = (Object[]) array.getStore();</span>

<span class="nc bnc" id="L3013" title="All 2 branches missed.">            if (store.length &lt; newSize) {</span>
<span class="nc" id="L3014">                extendBranch.enter();</span>
<span class="nc" id="L3015">                store = Arrays.copyOf(store, ArrayUtils.capacity(store.length, newSize));</span>
<span class="nc" id="L3016">                array.setStore(store, oldSize);</span>
            }

<span class="nc bnc" id="L3019" title="All 2 branches missed.">            for (int n = 0; n &lt; values.length; n++) {</span>
<span class="nc" id="L3020">                store[oldSize + n] = values[n];</span>
            }

<span class="nc" id="L3023">            array.setSize(newSize);</span>
<span class="nc" id="L3024">            return array;</span>
        }

        protected boolean isSingleIntegerFixnum(RubyArray array, Object... values) {
<span class="nc bnc" id="L3028" title="All 4 branches missed.">            return values.length == 1 &amp;&amp; values[0] instanceof Integer;</span>
        }

        protected boolean isSingleLongFixnum(RubyArray array, Object... values) {
<span class="nc bnc" id="L3032" title="All 4 branches missed.">            return values.length == 1 &amp;&amp; values[0] instanceof Long;</span>
        }

    }

    // Not really a core method - used internally

    public abstract static class PushOneNode extends ArrayCoreMethodNode {

<span class="nc" id="L3041">        private final BranchProfile extendBranch = BranchProfile.create();</span>

        public PushOneNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L3044">            super(context, sourceSection);</span>
<span class="nc" id="L3045">        }</span>

        public PushOneNode(PushOneNode prev) {
<span class="nc" id="L3048">            super(prev);</span>
<span class="nc" id="L3049">        }</span>

        @Specialization(guards = &quot;isNull&quot;)
        public RubyArray pushEmpty(RubyArray array, Object value) {
<span class="nc" id="L3053">            array.setStore(new Object[]{value}, 1);</span>
<span class="nc" id="L3054">            return array;</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public RubyArray pushIntegerFixnumIntegerFixnum(RubyArray array, int value) {
<span class="nc" id="L3059">            final int oldSize = array.getSize();</span>
<span class="nc" id="L3060">            final int newSize = oldSize + 1;</span>

<span class="nc" id="L3062">            int[] store = (int[]) array.getStore();</span>

<span class="nc bnc" id="L3064" title="All 2 branches missed.">            if (store.length &lt; newSize) {</span>
<span class="nc" id="L3065">                extendBranch.enter();</span>
<span class="nc" id="L3066">                array.setStore(store = Arrays.copyOf(store, ArrayUtils.capacity(store.length, newSize)), array.getSize());</span>
            }

<span class="nc" id="L3069">            store[oldSize] = value;</span>
<span class="nc" id="L3070">            array.setSize(newSize);</span>
<span class="nc" id="L3071">            return array;</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public RubyArray pushIntegerFixnumObject(RubyArray array, Object value) {
<span class="nc" id="L3076">            final int oldSize = array.getSize();</span>
<span class="nc" id="L3077">            final int newSize = oldSize + 1;</span>

<span class="nc" id="L3079">            final int[] oldStore = (int[]) array.getStore();</span>
<span class="nc" id="L3080">            final Object[] newStore = ArrayUtils.box(oldStore, newSize);</span>
<span class="nc" id="L3081">            newStore[oldSize] = value;</span>
<span class="nc" id="L3082">            array.setStore(newStore, newSize);</span>
<span class="nc" id="L3083">            return array;</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public RubyArray pushObjectObject(RubyArray array, Object value) {
<span class="nc" id="L3088">            final int oldSize = array.getSize();</span>
<span class="nc" id="L3089">            final int newSize = oldSize + 1;</span>

<span class="nc" id="L3091">            Object[] store = (Object[]) array.getStore();</span>

<span class="nc bnc" id="L3093" title="All 2 branches missed.">            if (store.length &lt; newSize) {</span>
<span class="nc" id="L3094">                extendBranch.enter();</span>
<span class="nc" id="L3095">                array.setStore(store = Arrays.copyOf(store, ArrayUtils.capacity(store.length, newSize)), array.getSize());</span>
            }

<span class="nc" id="L3098">            store[oldSize] = value;</span>
<span class="nc" id="L3099">            array.setSize(newSize);</span>
<span class="nc" id="L3100">            return array;</span>
        }

    }

    @CoreMethod(names = &quot;reject&quot;, needsBlock = true)
    @ImportGuards(ArrayGuards.class)
    public abstract static class RejectNode extends YieldingCoreMethodNode {

        @Child protected ArrayBuilderNode arrayBuilder;

        public RejectNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L3112">            super(context, sourceSection);</span>
<span class="nc" id="L3113">            arrayBuilder = new ArrayBuilderNode.UninitializedArrayBuilderNode(context);</span>
<span class="nc" id="L3114">        }</span>

        public RejectNode(RejectNode prev) {
<span class="nc" id="L3117">            super(prev);</span>
<span class="nc" id="L3118">            arrayBuilder = prev.arrayBuilder;</span>
<span class="nc" id="L3119">        }</span>

        @Specialization(guards = &quot;isNull&quot;)
        public Object selectNull(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L3123">            return new RubyArray(getContext().getCoreLibrary().getArrayClass());</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public Object selectObject(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L3128">            final Object[] store = (Object[]) array.getStore();</span>

<span class="nc" id="L3130">            Object selectedStore = arrayBuilder.start(array.getSize());</span>
<span class="nc" id="L3131">            int selectedSize = 0;</span>

<span class="nc" id="L3133">            int count = 0;</span>

            try {
<span class="nc bnc" id="L3136" title="All 2 branches missed.">                for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L3137" title="All 2 branches missed.">                    if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L3138">                        count++;</span>
                    }

<span class="nc" id="L3141">                    final Object value = store[n];</span>

<span class="nc" id="L3143">                    notDesignedForCompilation();</span>

<span class="nc bnc" id="L3145" title="All 2 branches missed.">                    if (! yieldIsTruthy(frame, block,  new Object[]{value})) {</span>
<span class="nc" id="L3146">                        selectedStore = arrayBuilder.append(selectedStore, selectedSize, value);</span>
<span class="nc" id="L3147">                        selectedSize++;</span>
                    }
                }
            } finally {
<span class="nc bnc" id="L3151" title="All 4 branches missed.">                if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L3152">                    ((RubyRootNode) getRootNode()).reportLoopCount(count);</span>
                }
            }

<span class="nc" id="L3156">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), arrayBuilder.finish(selectedStore, selectedSize), selectedSize);</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public Object selectFixnumInteger(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L3161">            final int[] store = (int[]) array.getStore();</span>

<span class="nc" id="L3163">            Object selectedStore = arrayBuilder.start(array.getSize());</span>
<span class="nc" id="L3164">            int selectedSize = 0;</span>

<span class="nc" id="L3166">            int count = 0;</span>

            try {
<span class="nc bnc" id="L3169" title="All 2 branches missed.">                for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L3170" title="All 2 branches missed.">                    if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L3171">                        count++;</span>
                    }

<span class="nc" id="L3174">                    final Object value = store[n];</span>

<span class="nc" id="L3176">                    notDesignedForCompilation();</span>

<span class="nc bnc" id="L3178" title="All 2 branches missed.">                    if (! yieldIsTruthy(frame, block, value)) {</span>
<span class="nc" id="L3179">                        selectedStore = arrayBuilder.append(selectedStore, selectedSize, value);</span>
<span class="nc" id="L3180">                        selectedSize++;</span>
                    }
                }
            } finally {
<span class="nc bnc" id="L3184" title="All 4 branches missed.">                if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L3185">                    ((RubyRootNode) getRootNode()).reportLoopCount(count);</span>
                }
            }

<span class="nc" id="L3189">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), arrayBuilder.finish(selectedStore, selectedSize), selectedSize);</span>
        }

    }

    @CoreMethod(names = &quot;reject!&quot;, needsBlock = true)
    @ImportGuards(ArrayGuards.class)
    public abstract static class RejectInPlaceNode extends YieldingCoreMethodNode {

        public RejectInPlaceNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L3199">            super(context, sourceSection);</span>
<span class="nc" id="L3200">        }</span>

        public RejectInPlaceNode(RejectInPlaceNode prev) {
<span class="nc" id="L3203">            super(prev);</span>
<span class="nc" id="L3204">        }</span>

        @Specialization(guards = &quot;isNull&quot;)
        public Object rejectInPlaceNull(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L3208">            return array;</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public Object rejectInPlaceObject(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L3213">            final Object[] store = (Object[]) array.getStore();</span>

<span class="nc" id="L3215">            int i = 0;</span>

<span class="nc bnc" id="L3217" title="All 2 branches missed.">            for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L3218" title="All 2 branches missed.">                if (yieldIsTruthy(frame, block, store[n])) {</span>
<span class="nc" id="L3219">                    continue;</span>
                }

<span class="nc bnc" id="L3222" title="All 2 branches missed.">                if (i != n) {</span>
<span class="nc" id="L3223">                    store[i] = store[n];</span>
                }

<span class="nc" id="L3226">                i++;</span>
            }

<span class="nc" id="L3229">            array.setSize(i);</span>
<span class="nc" id="L3230">            return array;</span>
        }

    }

    @CoreMethod(names = &quot;replace&quot;, required = 1)
    public abstract static class ReplaceNode extends ArrayCoreMethodNode {

        public ReplaceNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L3239">            super(context, sourceSection);</span>
<span class="nc" id="L3240">        }</span>

        public ReplaceNode(ReplaceNode prev) {
<span class="nc" id="L3243">            super(prev);</span>
<span class="nc" id="L3244">        }</span>

        @Specialization(guards = &quot;isOtherNull&quot;)
        public RubyArray replace(RubyArray array, RubyArray other) {
<span class="nc" id="L3248">            notDesignedForCompilation();</span>

<span class="nc" id="L3250">            array.setSize(0);</span>
<span class="nc" id="L3251">            return array;</span>
        }

        @Specialization(guards = &quot;isOtherIntegerFixnum&quot;)
        public RubyArray replaceIntegerFixnum(RubyArray array, RubyArray other) {
<span class="nc" id="L3256">            notDesignedForCompilation();</span>

<span class="nc" id="L3258">            array.setStore(Arrays.copyOf((int[]) other.getStore(), other.getSize()), other.getSize());</span>
<span class="nc" id="L3259">            return array;</span>
        }

        @Specialization(guards = &quot;isOtherLongFixnum&quot;)
        public RubyArray replaceLongFixnum(RubyArray array, RubyArray other) {
<span class="nc" id="L3264">            notDesignedForCompilation();</span>

<span class="nc" id="L3266">            array.setStore(Arrays.copyOf((long[]) other.getStore(), other.getSize()), other.getSize());</span>
<span class="nc" id="L3267">            return array;</span>
        }

        @Specialization(guards = &quot;isOtherFloat&quot;)
        public RubyArray replaceFloat(RubyArray array, RubyArray other) {
<span class="nc" id="L3272">            notDesignedForCompilation();</span>

<span class="nc" id="L3274">            array.setStore(Arrays.copyOf((double[]) other.getStore(), other.getSize()), other.getSize());</span>
<span class="nc" id="L3275">            return array;</span>
        }

        @Specialization(guards = &quot;isOtherObject&quot;)
        public RubyArray replaceObject(RubyArray array, RubyArray other) {
<span class="nc" id="L3280">            notDesignedForCompilation();</span>

<span class="nc" id="L3282">            array.setStore(Arrays.copyOf((Object[]) other.getStore(), other.getSize()), other.getSize());</span>
<span class="nc" id="L3283">            return array;</span>
        }

    }

    @CoreMethod(names = &quot;select&quot;, needsBlock = true)
    @ImportGuards(ArrayGuards.class)
    public abstract static class SelectNode extends YieldingCoreMethodNode {

        @Child protected ArrayBuilderNode arrayBuilder;

        public SelectNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L3295">            super(context, sourceSection);</span>
<span class="nc" id="L3296">            arrayBuilder = new ArrayBuilderNode.UninitializedArrayBuilderNode(context);</span>
<span class="nc" id="L3297">        }</span>

        public SelectNode(SelectNode prev) {
<span class="nc" id="L3300">            super(prev);</span>
<span class="nc" id="L3301">            arrayBuilder = prev.arrayBuilder;</span>
<span class="nc" id="L3302">        }</span>

        @Specialization(guards = &quot;isNull&quot;)
        public Object selectNull(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L3306">            return new RubyArray(getContext().getCoreLibrary().getArrayClass());</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public Object selectObject(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L3311">            final Object[] store = (Object[]) array.getStore();</span>

<span class="nc" id="L3313">            Object selectedStore = arrayBuilder.start(array.getSize());</span>
<span class="nc" id="L3314">            int selectedSize = 0;</span>

<span class="nc" id="L3316">            int count = 0;</span>

            try {
<span class="nc bnc" id="L3319" title="All 2 branches missed.">                for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L3320" title="All 2 branches missed.">                    if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L3321">                        count++;</span>
                    }

<span class="nc" id="L3324">                    final Object value = store[n];</span>

<span class="nc" id="L3326">                    notDesignedForCompilation();</span>

<span class="nc bnc" id="L3328" title="All 2 branches missed.">                    if (yieldIsTruthy(frame, block,  new Object[]{value})) {</span>
<span class="nc" id="L3329">                        selectedStore = arrayBuilder.append(selectedStore, selectedSize, value);</span>
<span class="nc" id="L3330">                        selectedSize++;</span>
                    }
                }
            } finally {
<span class="nc bnc" id="L3334" title="All 4 branches missed.">                if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L3335">                    ((RubyRootNode) getRootNode()).reportLoopCount(count);</span>
                }
            }

<span class="nc" id="L3339">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), arrayBuilder.finish(selectedStore, selectedSize), selectedSize);</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public Object selectFixnumInteger(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L3344">            final int[] store = (int[]) array.getStore();</span>

<span class="nc" id="L3346">            Object selectedStore = arrayBuilder.start(array.getSize());</span>
<span class="nc" id="L3347">            int selectedSize = 0;</span>

<span class="nc" id="L3349">            int count = 0;</span>

            try {
<span class="nc bnc" id="L3352" title="All 2 branches missed.">                for (int n = 0; n &lt; array.getSize(); n++) {</span>
<span class="nc bnc" id="L3353" title="All 2 branches missed.">                    if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L3354">                        count++;</span>
                    }

<span class="nc" id="L3357">                    final Object value = store[n];</span>

<span class="nc" id="L3359">                    notDesignedForCompilation();</span>

<span class="nc bnc" id="L3361" title="All 2 branches missed.">                    if (yieldIsTruthy(frame, block, value)) {</span>
<span class="nc" id="L3362">                        selectedStore = arrayBuilder.append(selectedStore, selectedSize, value);</span>
<span class="nc" id="L3363">                        selectedSize++;</span>
                    }
                }
            } finally {
<span class="nc bnc" id="L3367" title="All 4 branches missed.">                if (CompilerDirectives.inInterpreter()) {</span>
<span class="nc" id="L3368">                    ((RubyRootNode) getRootNode()).reportLoopCount(count);</span>
                }
            }

<span class="nc" id="L3372">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), arrayBuilder.finish(selectedStore, selectedSize), selectedSize);</span>
        }

    }

    @CoreMethod(names = &quot;shift&quot;)
    public abstract static class ShiftNode extends CoreMethodNode {

        public ShiftNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L3381">            super(context, sourceSection);</span>
<span class="nc" id="L3382">        }</span>

        public ShiftNode(ShiftNode prev) {
<span class="nc" id="L3385">            super(prev);</span>
<span class="nc" id="L3386">        }</span>

        @Specialization
        public Object shift(RubyArray array) {
<span class="nc" id="L3390">            notDesignedForCompilation();</span>

<span class="nc" id="L3392">            return array.slowShift();</span>
        }

    }

    @CoreMethod(names = {&quot;size&quot;, &quot;length&quot;})
    public abstract static class SizeNode extends ArrayCoreMethodNode {

        public SizeNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L3401">            super(context, sourceSection);</span>
<span class="nc" id="L3402">        }</span>

        public SizeNode(SizeNode prev) {
<span class="nc" id="L3405">            super(prev);</span>
<span class="nc" id="L3406">        }</span>

        @Specialization
        public int size(RubyArray array) {
<span class="nc" id="L3410">            return array.getSize();</span>
        }

    }

    @CoreMethod(names = &quot;slice&quot;, required = 2)
    public abstract static class SliceNode extends ArrayCoreMethodNode {

        public SliceNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L3419">            super(context, sourceSection);</span>
<span class="nc" id="L3420">        }</span>

        public SliceNode(SliceNode prev) {
<span class="nc" id="L3423">            super(prev);</span>
<span class="nc" id="L3424">        }</span>

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public RubyArray sliceIntegerFixnum(RubyArray array, int start, int length) {
<span class="nc" id="L3428">            final int[] store = (int[]) array.getStore();</span>

<span class="nc" id="L3430">            final int normalisedStart = array.normaliseIndex(start);</span>
<span class="nc" id="L3431">            final int normalisedEnd = Math.min(normalisedStart + length, array.getSize() + length);</span>
<span class="nc" id="L3432">            final int sliceLength = normalisedEnd - normalisedStart;</span>

<span class="nc" id="L3434">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), Arrays.copyOfRange(store, normalisedStart, normalisedEnd), sliceLength);</span>
        }

        @Specialization(guards = &quot;isLongFixnum&quot;)
        public RubyArray sliceLongFixnum(RubyArray array, int start, int length) {
<span class="nc" id="L3439">            final long[] store = (long[]) array.getStore();</span>

<span class="nc" id="L3441">            final int normalisedStart = array.normaliseIndex(start);</span>
<span class="nc" id="L3442">            final int normalisedEnd = Math.min(normalisedStart + length, array.getSize() + length);</span>
<span class="nc" id="L3443">            final int sliceLength = normalisedEnd - normalisedStart;</span>

<span class="nc" id="L3445">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), Arrays.copyOfRange(store, normalisedStart, normalisedEnd), sliceLength);</span>
        }

    }

    @CoreMethod(names = &quot;sort&quot;, needsBlock = true)
    public abstract static class SortNode extends ArrayCoreMethodNode {

        @Child protected DispatchHeadNode compareDispatchNode;
        @Child protected YieldDispatchHeadNode yieldNode;

        public SortNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L3457">            super(context, sourceSection);</span>
<span class="nc" id="L3458">            compareDispatchNode = new DispatchHeadNode(context);</span>
<span class="nc" id="L3459">            yieldNode = new YieldDispatchHeadNode(context);</span>
<span class="nc" id="L3460">        }</span>

        public SortNode(SortNode prev) {
<span class="nc" id="L3463">            super(prev);</span>
<span class="nc" id="L3464">            compareDispatchNode = prev.compareDispatchNode;</span>
<span class="nc" id="L3465">            yieldNode = prev.yieldNode;</span>
<span class="nc" id="L3466">        }</span>

        @Specialization(guards = &quot;isNull&quot;)
        public RubyArray sortNull(RubyArray array, UndefinedPlaceholder block) {
<span class="nc" id="L3470">            notDesignedForCompilation();</span>

<span class="nc" id="L3472">            return new RubyArray(getContext().getCoreLibrary().getArrayClass());</span>
        }

        @ExplodeLoop
        @Specialization(guards = {&quot;isIntegerFixnum&quot;, &quot;isSmall&quot;})
        public RubyArray sortVeryShortIntegerFixnum(VirtualFrame frame, RubyArray array, UndefinedPlaceholder block) {
<span class="nc" id="L3478">            final int[] store = (int[]) array.getStore();</span>

<span class="nc" id="L3480">            final int size = array.getSize();</span>

            // Selection sort - written very carefully to allow PE

<span class="nc bnc" id="L3484" title="All 2 branches missed.">            for (int i = 0; i &lt; RubyArray.ARRAYS_SMALL; i++) {</span>
<span class="nc bnc" id="L3485" title="All 2 branches missed.">                if (i &lt; size) {</span>
<span class="nc bnc" id="L3486" title="All 2 branches missed.">                    for (int j = i + 1; j &lt; RubyArray.ARRAYS_SMALL; j++) {</span>
<span class="nc bnc" id="L3487" title="All 2 branches missed.">                        if (j &lt; size) {</span>
<span class="nc bnc" id="L3488" title="All 2 branches missed.">                            if ((int) compareDispatchNode.call(frame, store[j], &quot;&lt;=&gt;&quot;, null, store[i]) &lt; 0) {</span>
<span class="nc" id="L3489">                                final int temp = store[j];</span>
<span class="nc" id="L3490">                                store[j] = store[i];</span>
<span class="nc" id="L3491">                                store[i] = temp;</span>
                            }
                        }
                    }
                }
            }

<span class="nc" id="L3498">            return array;</span>
        }

        @Specialization(guards = &quot;isIntegerFixnum&quot;)
        public RubyArray sortIntegerFixnum(VirtualFrame frame, RubyArray array, UndefinedPlaceholder block) {
<span class="nc" id="L3503">            notDesignedForCompilation();</span>

<span class="nc" id="L3505">            final Object[] boxed = ArrayUtils.box((int[]) array.getStore());</span>
<span class="nc" id="L3506">            sort(frame, boxed);</span>
<span class="nc" id="L3507">            final int[] unboxed = ArrayUtils.unboxInteger(boxed, array.getSize());</span>
<span class="nc" id="L3508">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), unboxed, array.getSize());</span>
        }

        @ExplodeLoop
        @Specialization(guards = {&quot;isLongFixnum&quot;, &quot;isSmall&quot;})
        public RubyArray sortVeryShortLongFixnum(VirtualFrame frame, RubyArray array, UndefinedPlaceholder block) {
<span class="nc" id="L3514">            final long[] store = (long[]) array.getStore();</span>

<span class="nc" id="L3516">            final int size = array.getSize();</span>

            // Selection sort - written very carefully to allow PE

<span class="nc bnc" id="L3520" title="All 2 branches missed.">            for (int i = 0; i &lt; RubyArray.ARRAYS_SMALL; i++) {</span>
<span class="nc bnc" id="L3521" title="All 2 branches missed.">                if (i &lt; size) {</span>
<span class="nc bnc" id="L3522" title="All 2 branches missed.">                    for (int j = i + 1; j &lt; RubyArray.ARRAYS_SMALL; j++) {</span>
<span class="nc bnc" id="L3523" title="All 2 branches missed.">                        if (j &lt; size) {</span>
<span class="nc bnc" id="L3524" title="All 2 branches missed.">                            if ((int) compareDispatchNode.call(frame, store[j], &quot;&lt;=&gt;&quot;, null, store[i]) &lt; 0) {</span>
<span class="nc" id="L3525">                                final long temp = store[j];</span>
<span class="nc" id="L3526">                                store[j] = store[i];</span>
<span class="nc" id="L3527">                                store[i] = temp;</span>
                            }
                        }
                    }
                }
            }

<span class="nc" id="L3534">            return array;</span>
        }

        @Specialization(guards = &quot;isLongFixnum&quot;)
        public RubyArray sortLongFixnum(VirtualFrame frame, RubyArray array, UndefinedPlaceholder block) {
<span class="nc" id="L3539">            notDesignedForCompilation();</span>

<span class="nc" id="L3541">            final Object[] boxed = ArrayUtils.box((long[]) array.getStore());</span>
<span class="nc" id="L3542">            sort(frame, boxed);</span>
<span class="nc" id="L3543">            final long[] unboxed = ArrayUtils.unboxLong(boxed, array.getSize());</span>
<span class="nc" id="L3544">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), unboxed, array.getSize());</span>
        }

        @Specialization(guards = &quot;isFloat&quot;)
        public RubyArray sortDouble(VirtualFrame frame, RubyArray array, UndefinedPlaceholder block) {
<span class="nc" id="L3549">            notDesignedForCompilation();</span>

<span class="nc" id="L3551">            final Object[] boxed = ArrayUtils.box((double[]) array.getStore());</span>
<span class="nc" id="L3552">            sort(frame, boxed);</span>
<span class="nc" id="L3553">            final double[] unboxed = ArrayUtils.unboxDouble(boxed, array.getSize());</span>
<span class="nc" id="L3554">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), unboxed, array.getSize());</span>
        }

        @Specialization(guards = {&quot;isObject&quot;, &quot;isSmall&quot;})
        public RubyArray sortVeryShortObject(VirtualFrame frame, RubyArray array, UndefinedPlaceholder block) {
<span class="nc" id="L3559">            final Object[] store = (Object[]) array.getStore();</span>

            // Insertion sort

<span class="nc" id="L3563">            final int size = array.getSize();</span>

<span class="nc bnc" id="L3565" title="All 2 branches missed.">            for (int i = 1; i &lt; size; i++) {</span>
<span class="nc" id="L3566">                final Object x = store[i];</span>
<span class="nc" id="L3567">                int j = i;</span>
                // TODO(CS): node for this cast
<span class="nc bnc" id="L3569" title="All 4 branches missed.">                while (j &gt; 0 &amp;&amp; (int) compareDispatchNode.call(frame, store[j - 1], &quot;&lt;=&gt;&quot;, null, x) &gt; 0) {</span>
<span class="nc" id="L3570">                    store[j] = store[j - 1];</span>
<span class="nc" id="L3571">                    j--;</span>
                }
<span class="nc" id="L3573">                store[j] = x;</span>
            }

<span class="nc" id="L3576">            return array;</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public RubyArray sortObject(VirtualFrame frame, RubyArray array, UndefinedPlaceholder block) {
<span class="nc" id="L3581">            notDesignedForCompilation();</span>

<span class="nc" id="L3583">            final Object[] store = Arrays.copyOf((Object[]) array.getStore(), array.getSize());</span>
<span class="nc" id="L3584">            sort(frame, store);</span>
<span class="nc" id="L3585">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), store, array.getSize());</span>
        }

        @Specialization(guards = &quot;isObject&quot;)
        public RubyArray sortWithCompareBlock(VirtualFrame frame, RubyArray array, RubyProc block) {
<span class="nc" id="L3590">            notDesignedForCompilation();</span>

<span class="nc" id="L3592">            final Object[] store = Arrays.copyOf((Object[]) array.getStore(), array.getSize());</span>
<span class="nc" id="L3593">            sort(frame, store, block);</span>
<span class="nc" id="L3594">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), store, array.getSize());</span>
        }

        private &lt;T&gt; void sort(VirtualFrame frame, T[] objects) {
<span class="nc" id="L3598">            final VirtualFrame finalFrame = frame;</span>

<span class="nc" id="L3600">            Arrays.sort(objects, new Comparator&lt;Object&gt;() {</span>

                @Override
                public int compare(Object a, Object b) {
                    // TODO(CS): node for this cast
<span class="nc" id="L3605">                    return (int) compareDispatchNode.call(finalFrame, a, &quot;&lt;=&gt;&quot;, null, b);</span>
                }

            });
<span class="nc" id="L3609">        }</span>

        private &lt;T&gt; void sort(VirtualFrame frame, T[] objects, RubyProc compare) {
<span class="nc" id="L3612">            final VirtualFrame finalFrame = frame;</span>
<span class="nc" id="L3613">            final RubyProc finalCompare = compare;</span>

<span class="nc" id="L3615">            Arrays.sort(objects, new Comparator&lt;Object&gt;() {</span>

                @Override
                public int compare(Object a, Object b) {
                    // TODO(CS): node for this cast
<span class="nc" id="L3620">                    return (int) yieldNode.dispatch(finalFrame, finalCompare, a, b);</span>
                }

            });
<span class="nc" id="L3624">        }</span>

        protected static boolean isSmall(RubyArray array) {
<span class="nc bnc" id="L3627" title="All 2 branches missed.">            return array.getSize() &lt;= RubyArray.ARRAYS_SMALL;</span>
        }

    }

    @CoreMethod(names = &quot;sort!&quot;)
    public abstract static class SortBangNode extends ArrayCoreMethodNode {

        @Child protected DispatchHeadNode compareDispatchNode;

        public SortBangNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L3638">            super(context, sourceSection);</span>
<span class="nc" id="L3639">            compareDispatchNode = new DispatchHeadNode(context);</span>
<span class="nc" id="L3640">        }</span>

        public SortBangNode(SortBangNode prev) {
<span class="nc" id="L3643">            super(prev);</span>
<span class="nc" id="L3644">            compareDispatchNode = prev.compareDispatchNode;</span>
<span class="nc" id="L3645">        }</span>

        @Specialization
        public RubyArray sort(VirtualFrame frame, RubyArray array) {
<span class="nc" id="L3649">            notDesignedForCompilation();</span>

<span class="nc" id="L3651">            final Object[] store = array.slowToArray();</span>
<span class="nc" id="L3652">            sort(frame, store);</span>
<span class="nc" id="L3653">            array.setStore(store, array.getSize());</span>
<span class="nc" id="L3654">            return array;</span>
        }

        // TODO(CS): copied from #sort

        private &lt;T&gt; void sort(VirtualFrame frame, T[] objects) {
<span class="nc" id="L3660">            final VirtualFrame finalFrame = frame;</span>

<span class="nc" id="L3662">            Arrays.sort(objects, new Comparator&lt;Object&gt;() {</span>

                @Override
                public int compare(Object a, Object b) {
                    // TODO(CS): node for this cast
<span class="nc" id="L3667">                    return (int) compareDispatchNode.call(finalFrame, a, &quot;&lt;=&gt;&quot;, null, b);</span>
                }

            });
<span class="nc" id="L3671">        }</span>

    }

    @CoreMethod(names = &quot;to_a&quot;)
    public abstract static class ToANode extends CoreMethodNode {

        public ToANode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L3679">            super(context, sourceSection);</span>
<span class="nc" id="L3680">        }</span>

        public ToANode(ToANode prev) {
<span class="nc" id="L3683">            super(prev);</span>
<span class="nc" id="L3684">        }</span>

        @Specialization
        public RubyArray toA(RubyArray array) {
<span class="nc" id="L3688">            return array;</span>
        }

    }

    @CoreMethod(names = &quot;uniq&quot;)
    public abstract static class UniqNode extends CoreMethodNode {

        public UniqNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L3697">            super(context, sourceSection);</span>
<span class="nc" id="L3698">        }</span>

        public UniqNode(UniqNode prev) {
<span class="nc" id="L3701">            super(prev);</span>
<span class="nc" id="L3702">        }</span>

        @Specialization
        public RubyArray uniq(RubyArray array) {
<span class="nc" id="L3706">            notDesignedForCompilation();</span>

<span class="nc" id="L3708">            final RubyArray uniq = new RubyArray(getContext().getCoreLibrary().getArrayClass(), null, 0);</span>

<span class="nc bnc" id="L3710" title="All 2 branches missed.">            for (Object value : array.slowToArray()) {</span>
<span class="nc" id="L3711">                boolean duplicate = false;</span>

<span class="nc bnc" id="L3713" title="All 2 branches missed.">                for (Object compare : uniq.slowToArray()) {</span>
<span class="nc bnc" id="L3714" title="All 2 branches missed.">                    if ((boolean) DebugOperations.send(getContext(), value, &quot;==&quot;, null, compare)) {</span>
<span class="nc" id="L3715">                        duplicate = true;</span>
<span class="nc" id="L3716">                        break;</span>
                    }
                }

<span class="nc bnc" id="L3720" title="All 2 branches missed.">                if (!duplicate) {</span>
<span class="nc" id="L3721">                    uniq.slowPush(value);</span>
                }
            }

<span class="nc" id="L3725">            return uniq;</span>
        }

    }

    @CoreMethod(names = &quot;unshift&quot;, argumentsAsArray = true)
    public abstract static class UnshiftNode extends CoreMethodNode {

        public UnshiftNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L3734">            super(context, sourceSection);</span>
<span class="nc" id="L3735">        }</span>

        public UnshiftNode(UnshiftNode prev) {
<span class="nc" id="L3738">            super(prev);</span>
<span class="nc" id="L3739">        }</span>

        @Specialization
        public RubyArray unshift(RubyArray array, Object... args) {
<span class="nc" id="L3743">            notDesignedForCompilation();</span>

<span class="nc" id="L3745">            array.slowUnshift(args);</span>
<span class="nc" id="L3746">            return array;</span>
        }

    }

<span class="nc" id="L3751">    @CoreMethod(names = &quot;zip&quot;, required = 1)</span>
    public abstract static class ZipNode extends ArrayCoreMethodNode {

        public ZipNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L3755">            super(context, sourceSection);</span>
<span class="nc" id="L3756">        }</span>

        public ZipNode(ZipNode prev) {
<span class="nc" id="L3759">            super(prev);</span>
<span class="nc" id="L3760">        }</span>

        @Specialization(guards = {&quot;isObject&quot;, &quot;isOtherIntegerFixnum&quot;})
        public RubyArray zipObjectIntegerFixnum(RubyArray array, RubyArray other) {
<span class="nc" id="L3764">            final Object[] a = (Object[]) array.getStore();</span>
<span class="nc" id="L3765">            final int aLength = array.getSize();</span>

<span class="nc" id="L3767">            final int[] b = (int[]) other.getStore();</span>
<span class="nc" id="L3768">            final int bLength = other.getSize();</span>

<span class="nc" id="L3770">            final int zippedLength = Math.min(aLength, bLength);</span>
<span class="nc" id="L3771">            final Object[] zipped = new Object[zippedLength];</span>

<span class="nc bnc" id="L3773" title="All 2 branches missed.">            for (int n = 0; n &lt; zippedLength; n++) {</span>
<span class="nc" id="L3774">                zipped[n] = new RubyArray(getContext().getCoreLibrary().getArrayClass(), new Object[]{a[n], b[n]}, 2);</span>
            }

<span class="nc" id="L3777">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), zipped, zippedLength);</span>
        }

        @Specialization(guards = {&quot;isObject&quot;, &quot;isOtherObject&quot;})
        public RubyArray zipObjectObject(RubyArray array, RubyArray other) {
<span class="nc" id="L3782">            final Object[] a = (Object[]) array.getStore();</span>
<span class="nc" id="L3783">            final int aLength = array.getSize();</span>

<span class="nc" id="L3785">            final Object[] b = (Object[]) other.getStore();</span>
<span class="nc" id="L3786">            final int bLength = other.getSize();</span>

<span class="nc" id="L3788">            final int zippedLength = Math.min(aLength, bLength);</span>
<span class="nc" id="L3789">            final Object[] zipped = new Object[zippedLength];</span>

<span class="nc bnc" id="L3791" title="All 2 branches missed.">            for (int n = 0; n &lt; zippedLength; n++) {</span>
<span class="nc" id="L3792">                zipped[n] = new RubyArray(getContext().getCoreLibrary().getArrayClass(), new Object[]{a[n], b[n]}, 2);</span>
            }

<span class="nc" id="L3795">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), zipped, zippedLength);</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>