<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MathNodes.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby.truffle.nodes.core</a> &gt; <span class="el_source">MathNodes.java</span></div><h1>MathNodes.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013, 2014 Oracle and/or its affiliates. All rights reserved. This
 * code is released under a tri EPL/GPL/LGPL license. You can use it,
 * redistribute it and/or modify it under the terms of the:
 *
 * Eclipse Public License version 1.0
 * GNU General Public License version 2
 * GNU Lesser General Public License version 2.1
 */
package org.jruby.truffle.nodes.core;

import com.oracle.truffle.api.CompilerDirectives;
import com.oracle.truffle.api.dsl.Fallback;
import com.oracle.truffle.api.dsl.Specialization;
import com.oracle.truffle.api.frame.VirtualFrame;
import com.oracle.truffle.api.source.SourceSection;
import org.jruby.RubyMath;
import org.jruby.truffle.nodes.RubyNode;
import org.jruby.truffle.nodes.dispatch.Dispatch;
import org.jruby.truffle.nodes.dispatch.DispatchHeadNode;
import org.jruby.truffle.nodes.dispatch.UseMethodMissingException;
import org.jruby.truffle.runtime.RubyContext;
import org.jruby.truffle.runtime.UndefinedPlaceholder;
import org.jruby.truffle.runtime.control.RaiseException;
import org.jruby.truffle.runtime.core.RubyArray;
import org.jruby.truffle.runtime.core.RubyBignum;

@CoreClass(name = &quot;Math&quot;)
<span class="nc" id="L29">public abstract class MathNodes {</span>

    @CoreMethod(names = &quot;acos&quot;, isModuleFunction = true, required = 1)
    public abstract static class ACosNode extends SimpleMonadicMathFunction {

        public ACosNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L35">            super(context, sourceSection);</span>
<span class="nc" id="L36">        }</span>

        public ACosNode(ACosNode prev) {
<span class="nc" id="L39">            super(prev);</span>
<span class="nc" id="L40">        }</span>

        @Override
        protected double doFunction(double a) {
<span class="nc bnc" id="L44" title="All 4 branches missed.">            if (a &lt; -1.0 || a &gt; 1.0) {</span>
<span class="nc" id="L45">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L46">                throw new RaiseException(getContext().getCoreLibrary().mathDomainError(&quot;acos&quot;, this));</span>
            }

<span class="nc" id="L49">            return Math.acos(a);</span>
        }

    }

    @CoreMethod(names = &quot;acosh&quot;, isModuleFunction = true, required = 1)
    public abstract static class ACosHNode extends SimpleMonadicMathFunction {

        public ACosHNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L58">            super(context, sourceSection);</span>
<span class="nc" id="L59">        }</span>

        public ACosHNode(ACosHNode prev) {
<span class="nc" id="L62">            super(prev);</span>
<span class="nc" id="L63">        }</span>

        @Override
        protected double doFunction(double a) {
            // Copied from RubyMath - see copyright notices there

<span class="nc bnc" id="L69" title="All 2 branches missed.">            if (Double.isNaN(a)) {</span>
<span class="nc" id="L70">                return Double.NaN;</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">            } else if (a &lt; 1) {</span>
<span class="nc" id="L72">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L73">                throw new RaiseException(getContext().getCoreLibrary().mathDomainError(&quot;acosh&quot;, this));</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">            } else if (a &lt; 94906265.62) {</span>
<span class="nc" id="L75">                return Math.log(a + Math.sqrt(a * a - 1.0));</span>
            } else{
<span class="nc" id="L77">                return 0.69314718055994530941723212145818 + Math.log(a);</span>
            }
        }

    }

    @CoreMethod(names = &quot;asin&quot;, isModuleFunction = true, required = 1)
    public abstract static class ASinNode extends SimpleMonadicMathFunction {

        public ASinNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L87">            super(context, sourceSection);</span>
<span class="nc" id="L88">        }</span>

        public ASinNode(ASinNode prev) {
<span class="nc" id="L91">            super(prev);</span>
<span class="nc" id="L92">        }</span>

        @Override
        protected double doFunction(double a) {
<span class="nc bnc" id="L96" title="All 4 branches missed.">            if (a &lt; -1.0 || a &gt; 1.0) {</span>
<span class="nc" id="L97">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L98">                throw new RaiseException(getContext().getCoreLibrary().mathDomainError(&quot;asin&quot;, this));</span>
            }

<span class="nc" id="L101">            return Math.asin(a);</span>
        }

    }

    @CoreMethod(names = &quot;asinh&quot;, isModuleFunction = true, required = 1)
    public abstract static class ASinHNode extends SimpleMonadicMathFunction {

        public ASinHNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L110">            super(context, sourceSection);</span>
<span class="nc" id="L111">        }</span>

        public ASinHNode(ASinHNode prev) {
<span class="nc" id="L114">            super(prev);</span>
<span class="nc" id="L115">        }</span>

        @Override
        protected double doFunction(double a) {
            // Copied from RubyMath - see copyright notices there

<span class="nc" id="L121">            final double y = Math.abs(a);</span>

<span class="nc bnc" id="L123" title="All 2 branches missed.">            if (Double.isNaN(a)) {</span>
<span class="nc" id="L124">                return Double.NaN;</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            } else if (y &lt;= 1.05367e-08) {</span>
<span class="nc" id="L126">                return a;</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">            } else if (y &lt;= 1.0) {</span>
<span class="nc" id="L128">                return a * (1.0 + RubyMath.chebylevSerie(2.0 * a * a - 1.0, RubyMath.ASINH_COEF));</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">            } else if (y &lt; 94906265.62) {</span>
<span class="nc" id="L130">                return Math.log(a + Math.sqrt(a * a + 1.0));</span>
            } else {
<span class="nc" id="L132">                double result = 0.69314718055994530941723212145818 + Math.log(y);</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">                if (a &lt; 0) result *= -1;</span>
<span class="nc" id="L134">                return result;</span>
            }
        }

    }

    @CoreMethod(names = &quot;atan&quot;, isModuleFunction = true, required = 1)
    public abstract static class ATanNode extends SimpleMonadicMathFunction {

        public ATanNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L144">            super(context, sourceSection);</span>
<span class="nc" id="L145">        }</span>

        public ATanNode(ATanNode prev) {
<span class="nc" id="L148">            super(prev);</span>
<span class="nc" id="L149">        }</span>

        @Override
        protected double doFunction(double a) {
<span class="nc" id="L153">            return Math.atan(a);</span>
        }

    }

    @CoreMethod(names = &quot;atan2&quot;, isModuleFunction = true, required = 2)
    public abstract static class ATan2Node extends SimpleDyadicMathFunction {

        public ATan2Node(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L162">            super(context, sourceSection);</span>
<span class="nc" id="L163">        }</span>

        public ATan2Node(ATan2Node prev) {
<span class="nc" id="L166">            super(prev);</span>
<span class="nc" id="L167">        }</span>

        @Override
        protected double doFunction(double a, double b) {
<span class="nc" id="L171">            return Math.atan2(a, b);</span>
        }

    }

    @CoreMethod(names = &quot;atanh&quot;, isModuleFunction = true, required = 1)
    public abstract static class ATanHNode extends SimpleMonadicMathFunction {

        public ATanHNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L180">            super(context, sourceSection);</span>
<span class="nc" id="L181">        }</span>

        public ATanHNode(ATanHNode prev) {
<span class="nc" id="L184">            super(prev);</span>
<span class="nc" id="L185">        }</span>

        @Override
        protected double doFunction(double a) {
            // Copied from RubyMath - see copyright notices there

<span class="nc bnc" id="L191" title="All 4 branches missed.">            if (a &lt; -1.0 || a &gt; 1.0) {</span>
<span class="nc" id="L192">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L193">                throw new RaiseException(getContext().getCoreLibrary().mathDomainError(&quot;atanh&quot;, this));</span>
            }

<span class="nc" id="L196">            final double y = Math.abs(a);</span>

<span class="nc bnc" id="L198" title="All 2 branches missed.">            if (Double.isNaN(a)) {</span>
<span class="nc" id="L199">                return Double.NaN;</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            } else if (y &lt; 1.82501e-08) {</span>
<span class="nc" id="L201">                return a;</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">            } else if (y &lt;= 0.5) {</span>
<span class="nc" id="L203">                return a * (1.0 + RubyMath.chebylevSerie(8.0 * a * a - 1.0, RubyMath.ATANH_COEF));</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">            } else if (y &lt; 1.0) {</span>
<span class="nc" id="L205">                return 0.5 * Math.log((1.0 + a) / (1.0 - a));</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">            } else if (y == 1.0) {</span>
<span class="nc" id="L207">                return a * Double.POSITIVE_INFINITY;</span>
            } else {
<span class="nc" id="L209">                return Double.NaN;</span>
            }
        }

    }

    @CoreMethod(names = &quot;cbrt&quot;, isModuleFunction = true, required = 1)
    public abstract static class CbRtNode extends SimpleMonadicMathFunction {

        public CbRtNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L219">            super(context, sourceSection);</span>
<span class="nc" id="L220">        }</span>

        public CbRtNode(CbRtNode prev) {
<span class="nc" id="L223">            super(prev);</span>
<span class="nc" id="L224">        }</span>

        @Override
        protected double doFunction(double a) {
<span class="nc" id="L228">            return Math.cbrt(a);</span>
        }

    }

    @CoreMethod(names = &quot;cos&quot;, isModuleFunction = true, required = 1)
    public abstract static class CosNode extends SimpleMonadicMathFunction {

        public CosNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L237">            super(context, sourceSection);</span>
<span class="nc" id="L238">        }</span>

        public CosNode(CosNode prev) {
<span class="nc" id="L241">            super(prev);</span>
<span class="nc" id="L242">        }</span>

        @Override
        protected double doFunction(double a) {
<span class="nc" id="L246">            return Math.cos(a);</span>
        }

    }

    @CoreMethod(names = &quot;cosh&quot;, isModuleFunction = true, required = 1)
    public abstract static class CosHNode extends SimpleMonadicMathFunction {

        public CosHNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L255">            super(context, sourceSection);</span>
<span class="nc" id="L256">        }</span>

        public CosHNode(CosHNode prev) {
<span class="nc" id="L259">            super(prev);</span>
<span class="nc" id="L260">        }</span>

        @Override
        protected double doFunction(double a) {
<span class="nc" id="L264">            return Math.cosh(a);</span>
        }

    }

    @CoreMethod(names = &quot;erf&quot;, isModuleFunction = true, required = 1)
    public abstract static class ErfNode extends SimpleMonadicMathFunction {

        public ErfNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L273">            super(context, sourceSection);</span>
<span class="nc" id="L274">        }</span>

        public ErfNode(ErfNode prev) {
<span class="nc" id="L277">            super(prev);</span>
<span class="nc" id="L278">        }</span>

        @Override
        protected double doFunction(double a) {
            // Copied from RubyMath - see copyright notices there

<span class="nc" id="L284">            final double y = Math.abs(a);</span>

<span class="nc bnc" id="L286" title="All 2 branches missed.">            if (y &lt;= 1.49012e-08) {</span>
<span class="nc" id="L287">                return 2 * a / 1.77245385090551602729816748334;</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">            } else if (y &lt;= 1) {</span>
<span class="nc" id="L289">                return a * (1 + RubyMath.chebylevSerie(2 * a * a - 1, RubyMath.ERFC_COEF));</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">            } else if (y &lt; 6.013687357) {</span>
<span class="nc" id="L291">                return RubyMath.sign(1 - ErfcNode.erfc(y), a);</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">            } else if (Double.isNaN(y)) {</span>
<span class="nc" id="L293">                return Double.NaN;</span>
            } else {
<span class="nc" id="L295">                return RubyMath.sign(1, a);</span>
            }
        }

    }

    @CoreMethod(names = &quot;erfc&quot;, isModuleFunction = true, required = 1)
    public abstract static class ErfcNode extends SimpleMonadicMathFunction {

        public ErfcNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L305">            super(context, sourceSection);</span>
<span class="nc" id="L306">        }</span>

        public ErfcNode(ErfcNode prev) {
<span class="nc" id="L309">            super(prev);</span>
<span class="nc" id="L310">        }</span>

        @Override
        public double doFunction(double a) {
<span class="nc" id="L314">            return erfc(a);</span>
        }

        public static double erfc(double a) {
            // Copied from RubyMath - see copyright notices there

<span class="nc" id="L320">            final double y = Math.abs(a);</span>

<span class="nc bnc" id="L322" title="All 2 branches missed.">            if (a &lt;= -6.013687357) {</span>
<span class="nc" id="L323">                return 2;</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">            } else if (y &lt; 1.49012e-08) {</span>
<span class="nc" id="L325">                return 1 - 2 * a / 1.77245385090551602729816748334;</span>
            } else {
<span class="nc" id="L327">                double ysq = y*y;</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">                if (y &lt; 1) {</span>
<span class="nc" id="L329">                    return 1 - a * (1 + RubyMath.chebylevSerie(2 * ysq - 1, RubyMath.ERFC_COEF));</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">                } else if (y &lt;= 4.0) {</span>
<span class="nc" id="L331">                    double result = Math.exp(-ysq)/y*(0.5+RubyMath.chebylevSerie((8.0 / ysq - 5.0) / 3.0, RubyMath.ERFC2_COEF));</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">                    if (a &lt; 0) result = 2.0 - result;</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">                    if (a &lt; 0) result = 2.0 - result;</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">                    if (a &lt; 0) result = 2.0 - result;</span>
<span class="nc" id="L335">                    return result;</span>
                } else {
<span class="nc" id="L337">                    double result = Math.exp(-ysq) / y * (0.5 + RubyMath.chebylevSerie(8.0 / ysq - 1, RubyMath.ERFCC_COEF));</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">                    if (a &lt; 0) result = 2.0 - result;</span>
<span class="nc" id="L339">                    return result;</span>
                }
            }
        }

    }

    @CoreMethod(names = &quot;exp&quot;, isModuleFunction = true, required = 1)
    public abstract static class ExpNode extends SimpleMonadicMathFunction {

        public ExpNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L350">            super(context, sourceSection);</span>
<span class="nc" id="L351">        }</span>

        public ExpNode(ExpNode prev) {
<span class="nc" id="L354">            super(prev);</span>
<span class="nc" id="L355">        }</span>

        @Override
        protected double doFunction(double a) {
<span class="nc" id="L359">            return Math.exp(a);</span>
        }

    }

    @CoreMethod(names = &quot;frexp&quot;, isModuleFunction = true, required = 1)
    public abstract static class FrExpNode extends CoreMethodNode {

        @Child protected KernelNodes.IsANode isANode;
        @Child protected DispatchHeadNode floatNode;

        public FrExpNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L371">            super(context, sourceSection);</span>
<span class="nc" id="L372">            isANode = KernelNodesFactory.IsANodeFactory.create(context, sourceSection, new RubyNode[]{null, null});</span>
<span class="nc" id="L373">            floatNode = new DispatchHeadNode(context, Dispatch.MissingBehavior.RETURN_MISSING);</span>
<span class="nc" id="L374">        }</span>

        public FrExpNode(FrExpNode prev) {
<span class="nc" id="L377">            super(prev);</span>
<span class="nc" id="L378">            isANode = prev.isANode;</span>
<span class="nc" id="L379">            floatNode = prev.floatNode;</span>
<span class="nc" id="L380">        }</span>

        @Specialization
        public RubyArray frexp(int a) {
<span class="nc" id="L384">            return frexp((double) a);</span>
        }

        @Specialization
        public RubyArray frexp(long a) {
<span class="nc" id="L389">            return frexp((double) a);</span>
        }

        @Specialization
        public RubyArray frexp(RubyBignum a) {
<span class="nc" id="L394">            return frexp(a.doubleValue());</span>
        }

        @Specialization
        public RubyArray frexp(double a) {
            // Copied from RubyMath - see copyright notices there

<span class="nc" id="L401">            double mantissa = a;</span>
<span class="nc" id="L402">            short sign = 1;</span>
<span class="nc" id="L403">            long exponent = 0;</span>

<span class="nc bnc" id="L405" title="All 4 branches missed.">            if (!Double.isInfinite(mantissa) &amp;&amp; mantissa != 0.0) {</span>
                // Make mantissa same sign so we only have one code path.
<span class="nc bnc" id="L407" title="All 2 branches missed.">                if (mantissa &lt; 0) {</span>
<span class="nc" id="L408">                    mantissa = -mantissa;</span>
<span class="nc" id="L409">                    sign = -1;</span>
                }

                // Increase value to hit lower range.
<span class="nc bnc" id="L413" title="All 2 branches missed.">                for (; mantissa &lt; 0.5; mantissa *= 2.0, exponent -=1) { }</span>

                // Decrease value to hit upper range.
<span class="nc bnc" id="L416" title="All 2 branches missed.">                for (; mantissa &gt;= 1.0; mantissa *= 0.5, exponent +=1) { }</span>
            }

<span class="nc" id="L419">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), new Object[]{sign * mantissa, exponent}, 2);</span>
        }

        @Fallback
        public RubyArray frexp(VirtualFrame frame, Object a) {
<span class="nc bnc" id="L424" title="All 2 branches missed.">            if (isANode.executeBoolean(a, getContext().getCoreLibrary().getNumericClass())) {</span>
                try {
<span class="nc" id="L426">                    return frexp(floatNode.callFloat(frame, a, &quot;to_f&quot;, null));</span>
<span class="nc" id="L427">                } catch (UseMethodMissingException e) {</span>
<span class="nc" id="L428">                    throw new RaiseException(getContext().getCoreLibrary().typeErrorCantConvertInto(</span>
<span class="nc" id="L429">                            getContext().getCoreLibrary().getLogicalClass(a).getName(),</span>
<span class="nc" id="L430">                            getContext().getCoreLibrary().getFloatClass().getName(),</span>
                            this));
                }
            } else {
<span class="nc" id="L434">                CompilerDirectives.transferToInterpreter();</span>

<span class="nc" id="L436">                throw new RaiseException(getContext().getCoreLibrary().typeErrorCantConvertInto(</span>
<span class="nc" id="L437">                        getContext().getCoreLibrary().getLogicalClass(a).getName(),</span>
<span class="nc" id="L438">                        getContext().getCoreLibrary().getFloatClass().getName(),</span>
                        this));
            }
        }

    }

    @CoreMethod(names = &quot;gamma&quot;, isModuleFunction = true, required = 1)
    public abstract static class GammaNode extends SimpleMonadicMathFunction {

        public GammaNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L449">            super(context, sourceSection);</span>
<span class="nc" id="L450">        }</span>

        public GammaNode(GammaNode prev) {
<span class="nc" id="L453">            super(prev);</span>
<span class="nc" id="L454">        }</span>

        @Override
        protected double doFunction(double a) {
            // Copied from RubyMath - see copyright notices there

<span class="nc bnc" id="L460" title="All 2 branches missed.">            if (a == -1) {</span>
<span class="nc" id="L461">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L462">                throw new RaiseException(getContext().getCoreLibrary().mathDomainError(&quot;gamma&quot;, this));</span>
            }

<span class="nc bnc" id="L465" title="All 2 branches missed.">            if (Double.isNaN(a)) {</span>
<span class="nc" id="L466">                return Double.NaN;</span>
            }

<span class="nc bnc" id="L469" title="All 2 branches missed.">            if (Double.isInfinite(a)) {</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">                if (a &gt; 0) {</span>
<span class="nc" id="L471">                    return Double.POSITIVE_INFINITY;</span>
                } else {
<span class="nc" id="L473">                    CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L474">                    throw new RaiseException(getContext().getCoreLibrary().mathDomainError(&quot;gamma&quot;, this));</span>
                }
            }

<span class="nc" id="L478">            double result = RubyMath.nemes_gamma(a);</span>

<span class="nc bnc" id="L480" title="All 2 branches missed.">            if (Double.isInfinite(result)) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">                if (a &lt; 0) {</span>
<span class="nc" id="L482">                    result = Double.NaN;</span>
                } else {
<span class="nc bnc" id="L484" title="All 4 branches missed.">                    if (a == 0 &amp;&amp; 1 / a &lt; 0) {</span>
<span class="nc" id="L485">                        result = Double.NEGATIVE_INFINITY;</span>
                    } else {
<span class="nc" id="L487">                        result = Double.POSITIVE_INFINITY;</span>
                    }
                }
            }

<span class="nc bnc" id="L492" title="All 2 branches missed.">            if (Double.isNaN(a)) {</span>
<span class="nc" id="L493">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L494">                throw new RaiseException(getContext().getCoreLibrary().mathDomainError(&quot;gamma&quot;, this));</span>
            }

<span class="nc" id="L497">            return result;</span>
        }

    }

    @CoreMethod(names = &quot;hypot&quot;, isModuleFunction = true, required = 2)
    public abstract static class HypotNode extends SimpleDyadicMathFunction {

        public HypotNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L506">            super(context, sourceSection);</span>
<span class="nc" id="L507">        }</span>

        public HypotNode(HypotNode prev) {
<span class="nc" id="L510">            super(prev);</span>
<span class="nc" id="L511">        }</span>

        @Override
        protected double doFunction(double a, double b) {
<span class="nc" id="L515">            return Math.hypot(a, b);</span>
        }

    }

    @CoreMethod(names = &quot;ldexp&quot;, isModuleFunction = true, required = 2)
    public abstract static class LdexpNode extends CoreMethodNode {

        @Child protected KernelNodes.IsANode isANode;
        @Child protected DispatchHeadNode floatANode;
        @Child protected DispatchHeadNode integerBNode;

        protected LdexpNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L528">            super(context, sourceSection);</span>
<span class="nc" id="L529">            isANode = KernelNodesFactory.IsANodeFactory.create(context, sourceSection, new RubyNode[]{null, null});</span>
<span class="nc" id="L530">            floatANode = new DispatchHeadNode(context, Dispatch.MissingBehavior.RETURN_MISSING);</span>
<span class="nc" id="L531">            integerBNode = new DispatchHeadNode(context, Dispatch.MissingBehavior.RETURN_MISSING);</span>
<span class="nc" id="L532">        }</span>

        protected LdexpNode(LdexpNode prev) {
<span class="nc" id="L535">            super(prev);</span>
<span class="nc" id="L536">            isANode = prev.isANode;</span>
<span class="nc" id="L537">            floatANode = prev.floatANode;</span>
<span class="nc" id="L538">            integerBNode = prev.integerBNode;</span>
<span class="nc" id="L539">        }</span>

        @Specialization
        public double function(int a, int b) {
<span class="nc" id="L543">            return function((double) a, b);</span>
        }

        @Specialization
        public double function(int a, long b) {
<span class="nc" id="L548">            return function((double) a, b);</span>
        }

        @Specialization
        public double function(int a, double b) {
<span class="nc" id="L553">            return function((double) a, b);</span>
        }

        @Specialization
        public double function(long a, int b) {
<span class="nc" id="L558">            return function((double) a, b);</span>
        }

        @Specialization
        public double function(long a, long b) {
<span class="nc" id="L563">            return function((double) a, b);</span>
        }

        @Specialization
        public double function(long a, double b) {
<span class="nc" id="L568">            return function((double) a, b);</span>
        }

        @Specialization
        public double function(RubyBignum a, int b) {
<span class="nc" id="L573">            return function(a.doubleValue(), b);</span>
        }

        @Specialization
        public double function(RubyBignum a, long b) {
<span class="nc" id="L578">            return function(a.doubleValue(), b);</span>
        }

        @Specialization
        public double function(RubyBignum a, double b) {
<span class="nc" id="L583">            return function(a.doubleValue(), b);</span>
        }

        @Specialization
        public double function(double a, int b) {
<span class="nc" id="L588">            return function(a, (double) b);</span>
        }

        @Specialization
        public double function(double a, long b) {
<span class="nc" id="L593">            return function(a, (double) b);</span>
        }

        @Specialization
        public double function(double a, double b) {
<span class="nc bnc" id="L598" title="All 2 branches missed.">            if (Double.isNaN(b)) {</span>
<span class="nc" id="L599">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L600">                throw new RaiseException(getContext().getCoreLibrary().rangeError(&quot;float&quot;, Double.toString(b), &quot;integer&quot;, this));</span>
            }

<span class="nc" id="L603">            return a * Math.pow(2, b);</span>
        }

        @Fallback
        public double function(VirtualFrame frame, Object a, Object b) {
<span class="nc bnc" id="L608" title="All 2 branches missed.">            if (isANode.executeBoolean(a, getContext().getCoreLibrary().getNumericClass())) {</span>
                try {
<span class="nc" id="L610">                    return function(</span>
<span class="nc" id="L611">                            floatANode.callFloat(frame, a, &quot;to_f&quot;, null),</span>
<span class="nc" id="L612">                            integerBNode.callLongFixnum(frame, b, &quot;to_int&quot;, null));</span>
<span class="nc" id="L613">                } catch (UseMethodMissingException e) {</span>
<span class="nc" id="L614">                    throw new RaiseException(getContext().getCoreLibrary().typeErrorCantConvertInto(</span>
<span class="nc" id="L615">                            getContext().getCoreLibrary().getLogicalClass(a).getName(),</span>
<span class="nc" id="L616">                            getContext().getCoreLibrary().getIntegerClass().getName(),</span>
                            this));
                }
            } else {
<span class="nc" id="L620">                CompilerDirectives.transferToInterpreter();</span>

<span class="nc" id="L622">                throw new RaiseException(getContext().getCoreLibrary().typeErrorCantConvertInto(</span>
<span class="nc" id="L623">                        getContext().getCoreLibrary().getLogicalClass(a).getName(),</span>
<span class="nc" id="L624">                        getContext().getCoreLibrary().getFloatClass().getName(),</span>
                        this));
            }
        }

    }



    @CoreMethod(names = &quot;lgamma&quot;, isModuleFunction = true, required = 1)
    public abstract static class LGammaNode extends CoreMethodNode {

        @Child protected KernelNodes.IsANode isANode;
        @Child protected DispatchHeadNode floatNode;

        public LGammaNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L640">            super(context, sourceSection);</span>
<span class="nc" id="L641">            isANode = KernelNodesFactory.IsANodeFactory.create(context, sourceSection, new RubyNode[]{null, null});</span>
<span class="nc" id="L642">            floatNode = new DispatchHeadNode(context, Dispatch.MissingBehavior.RETURN_MISSING);</span>
<span class="nc" id="L643">        }</span>

        public LGammaNode(LGammaNode prev) {
<span class="nc" id="L646">            super(prev);</span>
<span class="nc" id="L647">            isANode = prev.isANode;</span>
<span class="nc" id="L648">            floatNode = prev.floatNode;</span>
<span class="nc" id="L649">        }</span>

        @Specialization
        public RubyArray lgamma(int a) {
<span class="nc" id="L653">            return lgamma((double) a);</span>
        }

        @Specialization
        public RubyArray lgamma(long a) {
<span class="nc" id="L658">            return lgamma((double) a);</span>
        }

        @Specialization
        public RubyArray lgamma(RubyBignum a) {
<span class="nc" id="L663">            return lgamma(a.doubleValue());</span>
        }

        @Specialization
        public RubyArray lgamma(double a) {
            // Copied from RubyMath - see copyright notices there

<span class="nc bnc" id="L670" title="All 4 branches missed.">            if (a &lt; 0 &amp;&amp; Double.isInfinite(a)) {</span>
<span class="nc" id="L671">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L672">                throw new RaiseException(getContext().getCoreLibrary().mathDomainError(&quot;log2&quot;, this));</span>
            }

<span class="nc" id="L675">            final RubyMath.NemesLogGamma l = new RubyMath.NemesLogGamma(a);</span>

<span class="nc" id="L677">            return new RubyArray(getContext().getCoreLibrary().getArrayClass(), new Object[]{l.value, l.sign}, 2);</span>
        }

        @Fallback
        public RubyArray lgamma(VirtualFrame frame, Object a) {
<span class="nc bnc" id="L682" title="All 2 branches missed.">            if (isANode.executeBoolean(a, getContext().getCoreLibrary().getNumericClass())) {</span>
                try {
<span class="nc" id="L684">                    return lgamma(floatNode.callFloat(frame, a, &quot;to_f&quot;, null));</span>
<span class="nc" id="L685">                } catch (UseMethodMissingException e) {</span>
<span class="nc" id="L686">                    throw new RaiseException(getContext().getCoreLibrary().typeErrorCantConvertInto(</span>
<span class="nc" id="L687">                            getContext().getCoreLibrary().getLogicalClass(a).getName(),</span>
<span class="nc" id="L688">                            getContext().getCoreLibrary().getFloatClass().getName(),</span>
                            this));
                }
            } else {
<span class="nc" id="L692">                CompilerDirectives.transferToInterpreter();</span>

<span class="nc" id="L694">                throw new RaiseException(getContext().getCoreLibrary().typeErrorCantConvertInto(</span>
<span class="nc" id="L695">                        getContext().getCoreLibrary().getLogicalClass(a).getName(),</span>
<span class="nc" id="L696">                        getContext().getCoreLibrary().getFloatClass().getName(),</span>
                        this));
            }
        }

    }

    @CoreMethod(names = &quot;log&quot;, isModuleFunction = true, required = 1, optional = 1)
    public abstract static class LogNode extends SimpleDyadicMathFunction {

        public LogNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L707">            super(context, sourceSection);</span>
<span class="nc" id="L708">        }</span>

        public LogNode(LogNode prev) {
<span class="nc" id="L711">            super(prev);</span>
<span class="nc" id="L712">        }</span>

        @Specialization
        public double function(int a, UndefinedPlaceholder b) {
<span class="nc" id="L716">            return doFunction(a);</span>
        }

        @Specialization
        public double function(long a, UndefinedPlaceholder b) {
<span class="nc" id="L721">            return doFunction(a);</span>
        }

        @Specialization
        public double function(RubyBignum a, UndefinedPlaceholder b) {
<span class="nc" id="L726">            return doFunction(a.doubleValue());</span>
        }

        @Specialization
        public double function(double a, UndefinedPlaceholder b) {
<span class="nc" id="L731">            return doFunction(a);</span>
        }

        @Specialization
        public double function(VirtualFrame frame, Object a, UndefinedPlaceholder b) {
<span class="nc bnc" id="L736" title="All 2 branches missed.">            if (isANode.executeBoolean(a, getContext().getCoreLibrary().getNumericClass())) {</span>
                try {
<span class="nc" id="L738">                    return doFunction(</span>
<span class="nc" id="L739">                            floatANode.callFloat(frame, a, &quot;to_f&quot;, null));</span>
<span class="nc" id="L740">                } catch (UseMethodMissingException e) {</span>
<span class="nc" id="L741">                    throw new RaiseException(getContext().getCoreLibrary().typeErrorCantConvertInto(</span>
<span class="nc" id="L742">                            getContext().getCoreLibrary().getLogicalClass(a).getName(),</span>
<span class="nc" id="L743">                            getContext().getCoreLibrary().getFloatClass().getName(),</span>
                            this));
                }
            } else {
<span class="nc" id="L747">                CompilerDirectives.transferToInterpreter();</span>

<span class="nc" id="L749">                throw new RaiseException(getContext().getCoreLibrary().typeErrorCantConvertInto(</span>
<span class="nc" id="L750">                        getContext().getCoreLibrary().getLogicalClass(a).getName(),</span>
<span class="nc" id="L751">                        getContext().getCoreLibrary().getFloatClass().getName(),</span>
                        this));
            }
        }

        private double doFunction(double a) {
<span class="nc bnc" id="L757" title="All 2 branches missed.">            if (a &lt; 0) {</span>
<span class="nc" id="L758">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L759">                throw new RaiseException(getContext().getCoreLibrary().mathDomainError(&quot;log&quot;, this));</span>
            }

<span class="nc" id="L762">            return Math.log(a);</span>
        }

        @Override
        protected double doFunction(double a, double b) {
<span class="nc bnc" id="L767" title="All 2 branches missed.">            if (a &lt; 0) {</span>
<span class="nc" id="L768">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L769">                throw new RaiseException(getContext().getCoreLibrary().mathDomainError(&quot;log&quot;, this));</span>
            }

<span class="nc" id="L772">            return Math.log(a) / Math.log(b);</span>
        }

    }

    @CoreMethod(names = &quot;log10&quot;, isModuleFunction = true, required = 1)
    public abstract static class Log10Node extends SimpleMonadicMathFunction {

        public Log10Node(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L781">            super(context, sourceSection);</span>
<span class="nc" id="L782">        }</span>

        public Log10Node(Log10Node prev) {
<span class="nc" id="L785">            super(prev);</span>
<span class="nc" id="L786">        }</span>

        @Override
        protected double doFunction(double a) {
<span class="nc bnc" id="L790" title="All 2 branches missed.">            if (a &lt; 0) {</span>
<span class="nc" id="L791">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L792">                throw new RaiseException(getContext().getCoreLibrary().mathDomainError(&quot;log10&quot;, this));</span>
            }

<span class="nc" id="L795">            return Math.log10(a);</span>
        }

    }

    @CoreMethod(names = &quot;log2&quot;, isModuleFunction = true, required = 1)
    public abstract static class Log2Node extends SimpleMonadicMathFunction {

<span class="nc" id="L803">        private final double LOG2 = Math.log(2);</span>

        public Log2Node(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L806">            super(context, sourceSection);</span>
<span class="nc" id="L807">        }</span>

        public Log2Node(Log2Node prev) {
<span class="nc" id="L810">            super(prev);</span>
<span class="nc" id="L811">        }</span>

        @Override
        protected double doFunction(double a) {
<span class="nc bnc" id="L815" title="All 2 branches missed.">            if (a &lt; 0) {</span>
<span class="nc" id="L816">                CompilerDirectives.transferToInterpreter();</span>
<span class="nc" id="L817">                throw new RaiseException(getContext().getCoreLibrary().mathDomainError(&quot;log2&quot;, this));</span>
            }

<span class="nc" id="L820">            return Math.log(a) / LOG2;</span>
        }

    }

    @CoreMethod(names = &quot;sin&quot;, isModuleFunction = true, required = 1)
    public abstract static class SinNode extends SimpleMonadicMathFunction {

        public SinNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L829">            super(context, sourceSection);</span>
<span class="nc" id="L830">        }</span>

        public SinNode(SinNode prev) {
<span class="nc" id="L833">            super(prev);</span>
<span class="nc" id="L834">        }</span>

        @Override
        protected double doFunction(double a) {
<span class="nc" id="L838">            return Math.sin(a);</span>
        }

    }

    @CoreMethod(names = &quot;sinh&quot;, isModuleFunction = true, required = 1)
    public abstract static class SinHNode extends SimpleMonadicMathFunction {

        public SinHNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L847">            super(context, sourceSection);</span>
<span class="nc" id="L848">        }</span>

        public SinHNode(SinHNode prev) {
<span class="nc" id="L851">            super(prev);</span>
<span class="nc" id="L852">        }</span>

        @Override
        protected double doFunction(double a) {
<span class="nc" id="L856">            return Math.sinh(a);</span>
        }

    }

    @CoreMethod(names = &quot;tan&quot;, isModuleFunction = true, required = 1)
    public abstract static class TanNode extends SimpleMonadicMathFunction {

        public TanNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L865">            super(context, sourceSection);</span>
<span class="nc" id="L866">        }</span>

        public TanNode(TanNode prev) {
<span class="nc" id="L869">            super(prev);</span>
<span class="nc" id="L870">        }</span>

        @Override
        protected double doFunction(double a) {
<span class="nc" id="L874">            return Math.tan(a);</span>
        }

    }

    @CoreMethod(names = &quot;tanh&quot;, isModuleFunction = true, required = 1)
    public abstract static class TanHNode extends SimpleMonadicMathFunction {

        public TanHNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L883">            super(context, sourceSection);</span>
<span class="nc" id="L884">        }</span>

        public TanHNode(TanHNode prev) {
<span class="nc" id="L887">            super(prev);</span>
<span class="nc" id="L888">        }</span>

        @Override
        protected double doFunction(double a) {
<span class="nc" id="L892">            return Math.tanh(a);</span>
        }

    }

    @CoreMethod(names = &quot;sqrt&quot;, isModuleFunction = true, required = 1)
    public abstract static class SqrtNode extends SimpleMonadicMathFunction {

        public SqrtNode(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L901">            super(context, sourceSection);</span>
<span class="nc" id="L902">        }</span>

        public SqrtNode(SqrtNode prev) {
<span class="nc" id="L905">            super(prev);</span>
<span class="nc" id="L906">        }</span>

        @Override
        protected double doFunction(double a) {
<span class="nc" id="L910">            return Math.sqrt(a);</span>
        }

    }

    protected abstract static class SimpleMonadicMathFunction extends CoreMethodNode {

        @Child protected KernelNodes.IsANode isANode;
        @Child protected DispatchHeadNode floatNode;

        protected SimpleMonadicMathFunction(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L921">            super(context, sourceSection);</span>
<span class="nc" id="L922">            isANode = KernelNodesFactory.IsANodeFactory.create(context, sourceSection, new RubyNode[]{null, null});</span>
<span class="nc" id="L923">            floatNode = new DispatchHeadNode(context, Dispatch.MissingBehavior.RETURN_MISSING);</span>
<span class="nc" id="L924">        }</span>

        protected SimpleMonadicMathFunction(SimpleMonadicMathFunction prev) {
<span class="nc" id="L927">            super(prev);</span>
<span class="nc" id="L928">            isANode = prev.isANode;</span>
<span class="nc" id="L929">            floatNode = prev.floatNode;</span>
<span class="nc" id="L930">        }</span>

        // TODO: why can't we leave this abstract?

        protected double doFunction(double a) {
<span class="nc" id="L935">            throw new UnsupportedOperationException();</span>
        }

        @Specialization
        public double function(int a) {
<span class="nc" id="L940">            return doFunction(a);</span>
        }

        @Specialization
        public double function(long a) {
<span class="nc" id="L945">            return doFunction(a);</span>
        }

        @Specialization
        public double function(RubyBignum a) {
<span class="nc" id="L950">            return doFunction(a.doubleValue());</span>
        }

        @Specialization
        public double function(double a) {
<span class="nc" id="L955">            return doFunction(a);</span>
        }

        @Fallback
        public double function(VirtualFrame frame, Object a) {
<span class="nc bnc" id="L960" title="All 2 branches missed.">            if (isANode.executeBoolean(a, getContext().getCoreLibrary().getNumericClass())) {</span>
                try {
<span class="nc" id="L962">                    return doFunction(floatNode.callFloat(frame, a, &quot;to_f&quot;, null));</span>
<span class="nc" id="L963">                } catch (UseMethodMissingException e) {</span>
<span class="nc" id="L964">                    throw new RaiseException(getContext().getCoreLibrary().typeErrorCantConvertInto(</span>
<span class="nc" id="L965">                            getContext().getCoreLibrary().getLogicalClass(a).getName(),</span>
<span class="nc" id="L966">                            getContext().getCoreLibrary().getFloatClass().getName(),</span>
                            this));
                }
            } else {
<span class="nc" id="L970">                CompilerDirectives.transferToInterpreter();</span>

<span class="nc" id="L972">                throw new RaiseException(getContext().getCoreLibrary().typeErrorCantConvertInto(</span>
<span class="nc" id="L973">                        getContext().getCoreLibrary().getLogicalClass(a).getName(),</span>
<span class="nc" id="L974">                        getContext().getCoreLibrary().getFloatClass().getName(),</span>
                        this));
            }
        }

    }

<span class="nc" id="L981">    protected abstract static class SimpleDyadicMathFunction extends CoreMethodNode {</span>

        @Child protected KernelNodes.IsANode isANode;
        @Child protected DispatchHeadNode floatANode;
        @Child protected DispatchHeadNode floatBNode;

        protected SimpleDyadicMathFunction(RubyContext context, SourceSection sourceSection) {
<span class="nc" id="L988">            super(context, sourceSection);</span>
<span class="nc" id="L989">            isANode = KernelNodesFactory.IsANodeFactory.create(context, sourceSection, new RubyNode[]{null, null});</span>
<span class="nc" id="L990">            floatANode = new DispatchHeadNode(context, Dispatch.MissingBehavior.RETURN_MISSING);</span>
<span class="nc" id="L991">            floatBNode = new DispatchHeadNode(context, Dispatch.MissingBehavior.RETURN_MISSING);</span>
<span class="nc" id="L992">        }</span>

        protected SimpleDyadicMathFunction(SimpleDyadicMathFunction prev) {
<span class="nc" id="L995">            super(prev);</span>
<span class="nc" id="L996">            isANode = prev.isANode;</span>
<span class="nc" id="L997">            floatANode = prev.floatANode;</span>
<span class="nc" id="L998">            floatBNode = prev.floatBNode;</span>
<span class="nc" id="L999">        }</span>

        // TODO: why can't we leave this abstract?

        protected double doFunction(double a, double b) {
<span class="nc" id="L1004">            throw new UnsupportedOperationException();</span>
        }

        @Specialization
        public double function(int a, int b) {
<span class="nc" id="L1009">            return doFunction(a, b);</span>
        }

        @Specialization
        public double function(int a, long b) {
<span class="nc" id="L1014">            return doFunction(a, b);</span>
        }

        @Specialization
        public double function(int a, RubyBignum b) {
<span class="nc" id="L1019">            return doFunction(a, b.doubleValue());</span>
        }

        @Specialization
        public double function(int a, double b) {
<span class="nc" id="L1024">            return doFunction(a, b);</span>
        }

        @Specialization
        public double function(long a, int b) {
<span class="nc" id="L1029">            return doFunction(a, b);</span>
        }

        @Specialization
        public double function(long a, long b) {
<span class="nc" id="L1034">            return doFunction(a, b);</span>
        }

        @Specialization
        public double function(long a, RubyBignum b) {
<span class="nc" id="L1039">            return doFunction(a, b.doubleValue());</span>
        }

        @Specialization
        public double function(long a, double b) {
<span class="nc" id="L1044">            return doFunction(a, b);</span>
        }

        @Specialization
        public double function(RubyBignum a, int b) {
<span class="nc" id="L1049">            return doFunction(a.doubleValue(), b);</span>
        }

        @Specialization
        public double function(RubyBignum a, long b) {
<span class="nc" id="L1054">            return doFunction(a.doubleValue(), b);</span>
        }

        @Specialization
        public double function(RubyBignum a, RubyBignum b) {
<span class="nc" id="L1059">            return doFunction(a.doubleValue(), b.doubleValue());</span>
        }

        @Specialization
        public double function(RubyBignum a, double b) {
<span class="nc" id="L1064">            return doFunction(a.doubleValue(), b);</span>
        }

        @Specialization
        public double function(double a, int b) {
<span class="nc" id="L1069">            return doFunction(a, b);</span>
        }

        @Specialization
        public double function(double a, long b) {
<span class="nc" id="L1074">            return doFunction(a, b);</span>
        }

        @Specialization
        public double function(double a, RubyBignum b) {
<span class="nc" id="L1079">            return doFunction(a, b.doubleValue());</span>
        }

        @Specialization
        public double function(double a, double b) {
<span class="nc" id="L1084">            return doFunction(a, b);</span>
        }

        @Fallback
        public double function(VirtualFrame frame, Object a, Object b) {
<span class="nc bnc" id="L1089" title="All 4 branches missed.">            if (isANode.executeBoolean(a, getContext().getCoreLibrary().getNumericClass()) &amp;&amp; isANode.executeBoolean(b, getContext().getCoreLibrary().getNumericClass())) {</span>
                try {
<span class="nc" id="L1091">                    return doFunction(</span>
<span class="nc" id="L1092">                            floatANode.callFloat(frame, a, &quot;to_f&quot;, null),</span>
<span class="nc" id="L1093">                            floatBNode.callFloat(frame, b, &quot;to_f&quot;, null));</span>
<span class="nc" id="L1094">                } catch (UseMethodMissingException e) {</span>
<span class="nc" id="L1095">                    throw new RaiseException(getContext().getCoreLibrary().typeErrorCantConvertInto(</span>
<span class="nc" id="L1096">                            getContext().getCoreLibrary().getLogicalClass(a).getName(),</span>
<span class="nc" id="L1097">                            getContext().getCoreLibrary().getFloatClass().getName(),</span>
                            this));
                }
            } else {
<span class="nc" id="L1101">                CompilerDirectives.transferToInterpreter();</span>

<span class="nc" id="L1103">                throw new RaiseException(getContext().getCoreLibrary().typeErrorCantConvertInto(</span>
<span class="nc" id="L1104">                        getContext().getCoreLibrary().getLogicalClass(a).getName(),</span>
<span class="nc" id="L1105">                        getContext().getCoreLibrary().getFloatClass().getName(),</span>
                        this));
            }
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>