<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>IRBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby.ir</a> &gt; <span class="el_source">IRBuilder.java</span></div><h1>IRBuilder.java</h1><pre class="source lang-java linenums">package org.jruby.ir;

import org.jcodings.specific.ASCIIEncoding;
import org.jruby.EvalType;
import org.jruby.Ruby;
import org.jruby.RubyInstanceConfig;
import org.jruby.ast.*;
import org.jruby.ast.types.INameNode;
import org.jruby.compiler.NotCompilableException;
import org.jruby.internal.runtime.methods.IRMethodArgs;
import org.jruby.ir.instructions.*;
import org.jruby.ir.instructions.defined.GetErrorInfoInstr;
import org.jruby.ir.instructions.defined.RestoreErrorInfoInstr;
import org.jruby.ir.listeners.IRScopeListener;
import org.jruby.ir.operands.*;
import org.jruby.ir.operands.Boolean;
import org.jruby.ir.operands.Float;
import org.jruby.ir.transformations.inlining.SimpleCloneInfo;
import org.jruby.parser.StaticScope;
import org.jruby.runtime.Arity;
import org.jruby.runtime.CallType;
import org.jruby.runtime.Helpers;
import org.jruby.runtime.RubyEvent;
import org.jruby.util.ByteList;
import org.jruby.util.KeyValuePair;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;

import static org.jruby.ir.instructions.RuntimeHelperCall.Methods.*;

import static org.jruby.ir.operands.CurrentScope.*;
import static org.jruby.ir.operands.ScopeModule.*;

// This class converts an AST into a bunch of IR instructions

// IR Building Notes
// -----------------
//
// 1. More copy instructions added than necessary
// ----------------------------------------------
// Note that in general, there will be lots of a = b kind of copies
// introduced in the IR because the translation is entirely single-node focused.
// An example will make this clear
//
// RUBY:
//     v = @f
// will translate to
//
// AST:
//     LocalAsgnNode v
//       InstrVarNode f
// will translate to
//
// IR:
//     tmp = self.f [ GET_FIELD(tmp,self,f) ]
//     v = tmp      [ COPY(v, tmp) ]
//
// instead of
//     v = self.f   [ GET_FIELD(v, self, f) ]
//
// We could get smarter and pass in the variable into which this expression is going to get evaluated
// and use that to store the value of the expression (or not build the expression if the variable is null).
//
// But, that makes the code more complicated, and in any case, all this will get fixed in a single pass of
// copy propagation and dead-code elimination.
//
// Something to pay attention to and if this extra pass becomes a concern (not convinced that it is yet),
// this smart can be built in here.  Right now, the goal is to do something simple and straightforward that is going to be correct.
//
// 2. Returning null vs manager.getNil()
// ----------------------------
// - We should be returning null from the build methods where it is a normal &quot;error&quot; condition
// - We should be returning manager.getNil() where the actual return value of a build is the ruby nil operand
//   Look in buildIf for an example of this
//
// 3. Temporary variable reuse
// ---------------------------
// I am reusing variables a lot in places in this code.  Should I instead always get a new variable when I need it
// This introduces artificial data dependencies, but fewer variables.  But, if we are going to implement SSA pass
// this is not a big deal.  Think this through!

<span class="pc bpc" id="L85" title="1 of 2 branches missed.">public class IRBuilder {</span>
<span class="fc" id="L86">    static final Operand[] NO_ARGS = new Operand[]{};</span>
<span class="fc" id="L87">    static final UnexecutableNil U_NIL = UnexecutableNil.U_NIL;</span>

    public static IRBuilder createIRBuilder(Ruby runtime, IRManager manager) {
<span class="fc" id="L90">        return new IRBuilder(manager);</span>
    }

    public static Node buildAST(boolean isCommandLineScript, String arg) {
<span class="nc" id="L94">        Ruby ruby = Ruby.getGlobalRuntime();</span>

        // inline script
<span class="nc bnc" id="L97" title="All 2 branches missed.">        if (isCommandLineScript) return ruby.parse(ByteList.create(arg), &quot;-e&quot;, null, 0, false);</span>

        // from file
<span class="nc" id="L100">        FileInputStream fis = null;</span>
        try {
<span class="nc" id="L102">            File file = new File(arg);</span>
<span class="nc" id="L103">            fis = new FileInputStream(file);</span>
<span class="nc" id="L104">            long size = file.length();</span>
<span class="nc" id="L105">            byte[] bytes = new byte[(int)size];</span>
<span class="nc" id="L106">            fis.read(bytes);</span>
<span class="nc" id="L107">            System.out.println(&quot;-- processing &quot; + arg + &quot; --&quot;);</span>
<span class="nc" id="L108">            return ruby.parse(new ByteList(bytes), arg, null, 0, false);</span>
<span class="nc" id="L109">        } catch (IOException ioe) {</span>
<span class="nc" id="L110">            throw new RuntimeException(ioe);</span>
        } finally {
<span class="nc bnc" id="L112" title="All 4 branches missed.">            try { if (fis != null) fis.close(); } catch(Exception ignored) { }</span>
        }
    }

    private static class IRLoop {
        public final IRScope  container;
        public final IRLoop   parentLoop;
        public final Label    loopStartLabel;
        public final Label    loopEndLabel;
        public final Label    iterStartLabel;
        public final Label    iterEndLabel;
        public final Variable loopResult;

<span class="fc" id="L125">        public IRLoop(IRScope s, IRLoop outerLoop) {</span>
<span class="fc" id="L126">            container = s;</span>
<span class="fc" id="L127">            parentLoop = outerLoop;</span>
<span class="fc" id="L128">            loopStartLabel = s.getNewLabel(&quot;_LOOP_BEGIN&quot;);</span>
<span class="fc" id="L129">            loopEndLabel   = s.getNewLabel(&quot;_LOOP_END&quot;);</span>
<span class="fc" id="L130">            iterStartLabel = s.getNewLabel(&quot;_ITER_BEGIN&quot;);</span>
<span class="fc" id="L131">            iterEndLabel   = s.getNewLabel(&quot;_ITER_END&quot;);</span>
<span class="fc" id="L132">            loopResult     = s.createTemporaryVariable();</span>
<span class="fc" id="L133">            s.setHasLoopsFlag();</span>
<span class="fc" id="L134">        }</span>
    }

    private static class RescueBlockInfo {
        RescueNode rescueNode;             // Rescue node for which we are tracking info
        Label      entryLabel;             // Entry of the rescue block
        Variable   savedExceptionVariable; // Variable that contains the saved $! variable
        IRLoop     innermostLoop;          // Innermost loop within which this rescue block is nested, if any

<span class="fc" id="L143">        public RescueBlockInfo(RescueNode n, Label l, Variable v, IRLoop loop) {</span>
<span class="fc" id="L144">            rescueNode = n;</span>
<span class="fc" id="L145">            entryLabel = l;</span>
<span class="fc" id="L146">            savedExceptionVariable = v;</span>
<span class="fc" id="L147">            innermostLoop = loop;</span>
<span class="fc" id="L148">        }</span>

        public void restoreException(IRBuilder b, IRScope s, IRLoop currLoop) {
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">            if (currLoop == innermostLoop) b.addInstr(s, new PutGlobalVarInstr(&quot;$!&quot;, savedExceptionVariable));</span>
<span class="fc" id="L152">        }</span>
    }

    /* -----------------------------------------------------------------------------------
     * Every ensure block has a start label and end label
     *
     * This ruby code will translate to the IR shown below
     * -----------------
     *   begin
     *       ... protected body ...
     *   ensure
     *       ... ensure block to run
     *   end
     * -----------------
     *  L_region_start
     *     IR instructions for the protected body
     *     .. copy of ensure block IR ..
     *  L_dummy_rescue:
     *     e = recv_exc
     *  L_start:
     *     .. ensure block IR ..
     *     throw e
     *  L_end:
     * -----------------
     *
     * If N is a node in the protected body that might exit this scope (exception rethrows
     * and returns), N has to first run the ensure block before exiting.
     *
     * Since we can have a nesting of ensure blocks, we are maintaining a stack of these
     * well-nested ensure blocks.  Every node N that will exit this scope will have to
     * run the stack of ensure blocks in the right order.
     * ----------------------------------------------------------------------------------- */
    private static class EnsureBlockInfo {
        Label    regionStart;
        Label    start;
        Label    end;
        Label    dummyRescueBlockLabel;
        Variable savedGlobalException;

        // Label of block that will rescue exceptions raised by ensure code
        Label    bodyRescuer;

        // Innermost loop within which this ensure block is nested, if any
        IRLoop   innermostLoop;

        // AST node for any associated rescue node in the case of begin-rescue-ensure-end block
        // Will be null in the case of begin-ensure-end block
        RescueNode matchingRescueNode;

        // This ensure block's instructions
        List&lt;Instr&gt; instrs;

<span class="fc" id="L204">        public EnsureBlockInfo(IRScope s, RescueNode n, IRLoop l, Label bodyRescuer) {</span>
<span class="fc" id="L205">            regionStart = s.getNewLabel();</span>
<span class="fc" id="L206">            start       = s.getNewLabel();</span>
<span class="fc" id="L207">            end         = s.getNewLabel();</span>
<span class="fc" id="L208">            dummyRescueBlockLabel = s.getNewLabel();</span>
<span class="fc" id="L209">            instrs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L210">            savedGlobalException = null;</span>
<span class="fc" id="L211">            innermostLoop = l;</span>
<span class="fc" id="L212">            matchingRescueNode = n;</span>
<span class="fc" id="L213">            this.bodyRescuer = bodyRescuer;</span>
<span class="fc" id="L214">        }</span>

        public void addInstr(Instr i) {
<span class="fc" id="L217">            instrs.add(i);</span>
<span class="fc" id="L218">        }</span>

        public void addInstrAtBeginning(Instr i) {
<span class="nc" id="L221">            instrs.add(0, i);</span>
<span class="nc" id="L222">        }</span>

        public void emitBody(IRBuilder b, IRScope s) {
<span class="fc" id="L225">            b.addInstr(s, new LabelInstr(start));</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">            for (Instr i: instrs) {</span>
<span class="fc" id="L227">                b.addInstr(s, i);</span>
<span class="fc" id="L228">            }</span>
<span class="fc" id="L229">        }</span>

        public void cloneIntoHostScope(IRBuilder b, IRScope s) {
<span class="fc" id="L232">            SimpleCloneInfo ii = new SimpleCloneInfo(s, true);</span>

            // Clone required labels.
            // During normal cloning below, labels not found in the rename map
            // are not cloned.
<span class="fc" id="L237">            ii.renameLabel(start);</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">            for (Instr i: instrs) {</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">                if (i instanceof LabelInstr) {</span>
<span class="fc" id="L240">                    ii.renameLabel(((LabelInstr)i).label);</span>
                }
<span class="fc" id="L242">            }</span>

            // Clone instructions now
<span class="fc" id="L245">            b.addInstr(s, new LabelInstr(ii.getRenamedLabel(start)));</span>
<span class="fc" id="L246">            b.addInstr(s, new ExceptionRegionStartMarkerInstr(bodyRescuer));</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">            for (Instr i: instrs) {</span>
<span class="fc" id="L248">                Instr clonedInstr = i.clone(ii);</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">                if (clonedInstr instanceof CallBase) {</span>
<span class="fc" id="L250">                    CallBase call = (CallBase)clonedInstr;</span>
<span class="fc" id="L251">                    Operand block = call.getClosureArg(null);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">                    if (block instanceof WrappedIRClosure) s.addClosure(((WrappedIRClosure)block).getClosure());</span>
                }
<span class="fc" id="L254">                b.addInstr(s, clonedInstr);</span>
<span class="fc" id="L255">            }</span>
<span class="fc" id="L256">            b.addInstr(s, new ExceptionRegionEndMarkerInstr());</span>
<span class="fc" id="L257">        }</span>
    }

    // Stack of nested rescue blocks -- this just tracks the start label of the blocks
<span class="fc" id="L261">    private Stack&lt;RescueBlockInfo&gt; activeRescueBlockStack = new Stack&lt;&gt;();</span>

    // Stack of ensure blocks that are currently active
<span class="fc" id="L264">    private Stack&lt;EnsureBlockInfo&gt; activeEnsureBlockStack = new Stack&lt;&gt;();</span>

    // Stack of ensure blocks whose bodies are being constructed
<span class="fc" id="L267">    private Stack&lt;EnsureBlockInfo&gt; ensureBodyBuildStack   = new Stack&lt;&gt;();</span>

    // Combined stack of active rescue/ensure nestings -- required to properly set up
    // rescuers for ensure block bodies cloned into other regions -- those bodies are
    // rescued by the active rescuers at the point of definition rather than the point
    // of cloning.
<span class="fc" id="L273">    private Stack&lt;Label&gt; activeRescuers = new Stack&lt;&gt;();</span>

<span class="fc" id="L275">    private int _lastProcessedLineNum = -1;</span>

    // Since we are processing ASTs, loop bodies are processed in depth-first manner
    // with outer loops encountered before inner loops, and inner loops finished before outer ones.
    //
    // So, we can keep track of loops in a loop stack which  keeps track of loops as they are encountered.
    // This lets us implement next/redo/break/retry easily for the non-closure cases
<span class="fc" id="L282">    private Stack&lt;IRLoop&gt; loopStack = new Stack&lt;&gt;();</span>

    public IRLoop getCurrentLoop() {
<span class="fc bfc" id="L285" title="All 2 branches covered.">        return loopStack.isEmpty() ? null : loopStack.peek();</span>
    }

    protected IRManager manager;

<span class="fc" id="L290">    public IRBuilder(IRManager manager) {</span>
<span class="fc" id="L291">        this.manager = manager;</span>
<span class="fc" id="L292">        this.activeRescuers.push(Label.UNRESCUED_REGION_LABEL);</span>
<span class="fc" id="L293">    }</span>

    public void addInstr(IRScope s, Instr i) {
        // If we are building an ensure body, stash the instruction
        // in the ensure body's list. If not, add it to the scope directly.
<span class="fc bfc" id="L298" title="All 2 branches covered.">        if (ensureBodyBuildStack.empty()) {</span>
<span class="fc" id="L299">            s.addInstr(i);</span>
        } else {
<span class="fc" id="L301">            ensureBodyBuildStack.peek().addInstr(i);</span>
        }
<span class="fc" id="L303">    }</span>

    public void addInstrAtBeginning(IRScope s, Instr i) {
        // If we are building an ensure body, stash the instruction
        // in the ensure body's list. If not, add it to the scope directly.
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">        if (ensureBodyBuildStack.empty()) {</span>
<span class="fc" id="L309">            s.addInstrAtBeginning(i);</span>
        } else {
<span class="nc" id="L311">            ensureBodyBuildStack.peek().addInstrAtBeginning(i);</span>
        }
<span class="fc" id="L313">    }</span>

    // FIXME: This all seems wrong to me.  IRClosures can receive explicit closures why are we searching only methods
    // and by-passing closures
    private Operand getImplicitBlockArg(IRScope s) {
<span class="fc" id="L318">        int n = 0;</span>
<span class="fc bfc" id="L319" title="All 4 branches covered.">        while (s instanceof IRClosure || s instanceof IRMetaClassBody) {</span>
<span class="fc" id="L320">            n++;</span>
<span class="fc" id="L321">            s = s.getLexicalParent();</span>
        }

<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        if (s != null) {</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">            LocalVariable v = s instanceof IRMethod ? s.getLocalVariable(Variable.BLOCK, 0) : null;</span>

<span class="fc bfc" id="L327" title="All 4 branches covered.">            if (v != null) return n == 0 ? v : v.cloneForDepth(n);</span>
        }

<span class="fc" id="L330">        return manager.getNil();</span>
    }

    // Emit cloned ensure bodies by walking up the ensure block stack.
    // If we have been passed a loop value, only emit bodies that are nested within that loop.
    private void emitEnsureBlocks(IRScope s, IRLoop loop) {
<span class="fc" id="L336">        int n = activeEnsureBlockStack.size();</span>
<span class="fc" id="L337">        EnsureBlockInfo[] ebArray = activeEnsureBlockStack.toArray(new EnsureBlockInfo[n]);</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">        for (int i = n-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L339">            EnsureBlockInfo ebi = ebArray[i];</span>

            // For &quot;break&quot; and &quot;next&quot; instructions, we only want to run
            // ensure blocks from the loops they are present in.
<span class="pc bpc" id="L343" title="1 of 4 branches missed.">            if (loop != null &amp;&amp; ebi.innermostLoop != loop) break;</span>

            // SSS FIXME: Should $! be restored before or after the ensure block is run?
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">            if (ebi.savedGlobalException != null) {</span>
<span class="nc" id="L347">                addInstr(s, new PutGlobalVarInstr(&quot;$!&quot;, ebi.savedGlobalException));</span>
            }

            // Clone into host scope
<span class="fc" id="L351">            ebi.cloneIntoHostScope(this, s);</span>
        }
<span class="fc" id="L353">    }</span>

    private Operand buildOperand(Node node, IRScope s) throws NotCompilableException {
<span class="pc bpc" id="L356" title="8 of 96 branches missed.">        switch (node.getNodeType()) {</span>
<span class="fc" id="L357">            case ALIASNODE: return buildAlias((AliasNode) node, s);</span>
<span class="fc" id="L358">            case ANDNODE: return buildAnd((AndNode) node, s);</span>
<span class="fc" id="L359">            case ARGSCATNODE: return buildArgsCat((ArgsCatNode) node, s);</span>
<span class="fc" id="L360">            case ARGSPUSHNODE: return buildArgsPush((ArgsPushNode) node, s);</span>
<span class="fc" id="L361">            case ARRAYNODE: return buildArray(node, s);</span>
<span class="fc" id="L362">            case ATTRASSIGNNODE: return buildAttrAssign((AttrAssignNode) node, s);</span>
<span class="fc" id="L363">            case BACKREFNODE: return buildBackref((BackRefNode) node, s);</span>
<span class="fc" id="L364">            case BEGINNODE: return buildBegin((BeginNode) node, s);</span>
<span class="fc" id="L365">            case BIGNUMNODE: return buildBignum((BignumNode) node);</span>
<span class="fc" id="L366">            case BLOCKNODE: return buildBlock((BlockNode) node, s);</span>
<span class="fc" id="L367">            case BREAKNODE: return buildBreak((BreakNode) node, s);</span>
<span class="fc" id="L368">            case CALLNODE: return buildCall((CallNode) node, s);</span>
<span class="fc" id="L369">            case CASENODE: return buildCase((CaseNode) node, s);</span>
<span class="fc" id="L370">            case CLASSNODE: return buildClass((ClassNode) node, s);</span>
<span class="fc" id="L371">            case CLASSVARNODE: return buildClassVar((ClassVarNode) node, s);</span>
<span class="fc" id="L372">            case CLASSVARASGNNODE: return buildClassVarAsgn((ClassVarAsgnNode) node, s);</span>
<span class="nc" id="L373">            case CLASSVARDECLNODE: return buildClassVarDecl((ClassVarDeclNode) node, s);</span>
<span class="fc" id="L374">            case COLON2NODE: return buildColon2((Colon2Node) node, s);</span>
<span class="fc" id="L375">            case COLON3NODE: return buildColon3((Colon3Node) node, s);</span>
<span class="fc" id="L376">            case COMPLEXNODE: return buildComplex((ComplexNode) node, s);</span>
<span class="fc" id="L377">            case CONSTDECLNODE: return buildConstDecl((ConstDeclNode) node, s);</span>
<span class="fc" id="L378">            case CONSTNODE: return searchConst(s, ((ConstNode) node).getName());</span>
<span class="fc" id="L379">            case DASGNNODE: return buildDAsgn((DAsgnNode) node, s);</span>
<span class="fc" id="L380">            case DEFINEDNODE: return buildGetDefinition(((DefinedNode) node).getExpressionNode(), s);</span>
<span class="fc" id="L381">            case DEFNNODE: return buildDefn((MethodDefNode) node, s);</span>
<span class="fc" id="L382">            case DEFSNODE: return buildDefs((DefsNode) node, s);</span>
<span class="fc" id="L383">            case DOTNODE: return buildDot((DotNode) node, s);</span>
<span class="fc" id="L384">            case DREGEXPNODE: return buildDRegexp((DRegexpNode) node, s);</span>
<span class="fc" id="L385">            case DSTRNODE: return buildDStr((DStrNode) node, s);</span>
<span class="fc" id="L386">            case DSYMBOLNODE: return buildDSymbol((DSymbolNode) node, s);</span>
<span class="fc" id="L387">            case DVARNODE: return buildDVar((DVarNode) node, s);</span>
<span class="fc" id="L388">            case DXSTRNODE: return buildDXStr((DXStrNode) node, s);</span>
<span class="fc" id="L389">            case ENCODINGNODE: return buildEncoding((EncodingNode)node, s);</span>
<span class="fc" id="L390">            case ENSURENODE: return buildEnsureNode((EnsureNode) node, s);</span>
<span class="fc" id="L391">            case EVSTRNODE: return buildEvStr((EvStrNode) node, s);</span>
<span class="fc" id="L392">            case FALSENODE: return buildFalse();</span>
<span class="fc" id="L393">            case FCALLNODE: return buildFCall((FCallNode) node, s);</span>
<span class="fc" id="L394">            case FIXNUMNODE: return buildFixnum((FixnumNode) node);</span>
<span class="fc" id="L395">            case FLIPNODE: return buildFlip((FlipNode) node, s);</span>
<span class="fc" id="L396">            case FLOATNODE: return buildFloat((FloatNode) node);</span>
<span class="fc" id="L397">            case FORNODE: return buildFor((ForNode) node, s);</span>
<span class="fc" id="L398">            case GLOBALASGNNODE: return buildGlobalAsgn((GlobalAsgnNode) node, s);</span>
<span class="fc" id="L399">            case GLOBALVARNODE: return buildGlobalVar((GlobalVarNode) node, s);</span>
<span class="fc" id="L400">            case HASHNODE: return buildHash((HashNode) node, s);</span>
<span class="fc" id="L401">            case IFNODE: return buildIf((IfNode) node, s);</span>
<span class="fc" id="L402">            case INSTASGNNODE: return buildInstAsgn((InstAsgnNode) node, s);</span>
<span class="fc" id="L403">            case INSTVARNODE: return buildInstVar((InstVarNode) node, s);</span>
<span class="fc" id="L404">            case ITERNODE: return buildIter((IterNode) node, s);</span>
<span class="fc" id="L405">            case LAMBDANODE: return buildLambda((LambdaNode)node, s);</span>
<span class="fc" id="L406">            case LITERALNODE: return buildLiteral((LiteralNode) node, s);</span>
<span class="fc" id="L407">            case LOCALASGNNODE: return buildLocalAsgn((LocalAsgnNode) node, s);</span>
<span class="fc" id="L408">            case LOCALVARNODE: return buildLocalVar((LocalVarNode) node, s);</span>
<span class="fc" id="L409">            case MATCH2NODE: return buildMatch2((Match2Node) node, s);</span>
<span class="fc" id="L410">            case MATCH3NODE: return buildMatch3((Match3Node) node, s);</span>
<span class="fc" id="L411">            case MATCHNODE: return buildMatch((MatchNode) node, s);</span>
<span class="fc" id="L412">            case MODULENODE: return buildModule((ModuleNode) node, s);</span>
<span class="nc" id="L413">            case MULTIPLEASGNNODE: return buildMultipleAsgn((MultipleAsgnNode) node, s); // Only for 1.8</span>
<span class="fc" id="L414">            case MULTIPLEASGN19NODE: return buildMultipleAsgn19((MultipleAsgn19Node) node, s);</span>
<span class="fc" id="L415">            case NEWLINENODE: return buildNewline((NewlineNode) node, s);</span>
<span class="fc" id="L416">            case NEXTNODE: return buildNext((NextNode) node, s);</span>
<span class="fc" id="L417">            case NTHREFNODE: return buildNthRef((NthRefNode) node, s);</span>
<span class="fc" id="L418">            case NILNODE: return buildNil();</span>
<span class="fc" id="L419">            case OPASGNANDNODE: return buildOpAsgnAnd((OpAsgnAndNode) node, s);</span>
<span class="fc" id="L420">            case OPASGNNODE: return buildOpAsgn((OpAsgnNode) node, s);</span>
<span class="fc" id="L421">            case OPASGNORNODE: return buildOpAsgnOr((OpAsgnOrNode) node, s);</span>
<span class="fc" id="L422">            case OPELEMENTASGNNODE: return buildOpElementAsgn((OpElementAsgnNode) node, s);</span>
<span class="fc" id="L423">            case ORNODE: return buildOr((OrNode) node, s);</span>
<span class="fc" id="L424">            case PREEXENODE: return buildPreExe((PreExeNode) node, s);</span>
<span class="nc" id="L425">            case POSTEXENODE: return buildPostExe((PostExeNode) node, s);</span>
<span class="fc" id="L426">            case RATIONALNODE: return buildRational((RationalNode) node);</span>
<span class="fc" id="L427">            case REDONODE: return buildRedo(s);</span>
<span class="fc" id="L428">            case REGEXPNODE: return buildRegexp((RegexpNode) node, s);</span>
            case RESCUEBODYNODE:
<span class="nc" id="L430">                throw new NotCompilableException(&quot;rescue body is handled by rescue compilation at: &quot; + node.getPosition());</span>
<span class="fc" id="L431">            case RESCUENODE: return buildRescue((RescueNode) node, s);</span>
<span class="fc" id="L432">            case RETRYNODE: return buildRetry(s);</span>
<span class="fc" id="L433">            case RETURNNODE: return buildReturn((ReturnNode) node, s);</span>
            case ROOTNODE:
<span class="nc" id="L435">                throw new NotCompilableException(&quot;Use buildRoot(); Root node at: &quot; + node.getPosition());</span>
<span class="fc" id="L436">            case SCLASSNODE: return buildSClass((SClassNode) node, s);</span>
<span class="fc" id="L437">            case SELFNODE: return buildSelf(s);</span>
<span class="fc" id="L438">            case SPLATNODE: return buildSplat((SplatNode) node, s);</span>
<span class="fc" id="L439">            case STRNODE: return buildStr((StrNode) node, s);</span>
<span class="fc" id="L440">            case SUPERNODE: return buildSuper((SuperNode) node, s);</span>
<span class="fc" id="L441">            case SVALUENODE: return buildSValue((SValueNode) node, s);</span>
<span class="fc" id="L442">            case SYMBOLNODE: return buildSymbol((SymbolNode) node);</span>
<span class="fc" id="L443">            case TRUENODE: return buildTrue();</span>
<span class="fc" id="L444">            case UNDEFNODE: return buildUndef(node, s);</span>
<span class="fc" id="L445">            case UNTILNODE: return buildUntil((UntilNode) node, s);</span>
<span class="nc" id="L446">            case VALIASNODE: return buildVAlias((VAliasNode) node, s);</span>
<span class="fc" id="L447">            case VCALLNODE: return buildVCall((VCallNode) node, s);</span>
<span class="fc" id="L448">            case WHILENODE: return buildWhile((WhileNode) node, s);</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">            case WHENNODE: assert false : &quot;When nodes are handled by case node compilation.&quot;; return null;</span>
<span class="fc" id="L450">            case XSTRNODE: return buildXStr((XStrNode) node, s);</span>
<span class="fc" id="L451">            case YIELDNODE: return buildYield((YieldNode) node, s);</span>
<span class="fc" id="L452">            case ZARRAYNODE: return buildZArray(s);</span>
<span class="fc" id="L453">            case ZSUPERNODE: return buildZSuper((ZSuperNode) node, s);</span>
<span class="nc" id="L454">            default: throw new NotCompilableException(&quot;Unknown node encountered in builder: &quot; + node.getClass());</span>
        }
    }

    private boolean hasListener() {
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">        return manager.getIRScopeListener() != null;</span>
    }

    public static IRBuilder newIRBuilder(IRManager manager) {
<span class="fc" id="L463">        return new IRBuilder(manager);</span>
    }

    public Node skipOverNewlines(IRScope s, Node n) {
<span class="fc bfc" id="L467" title="All 2 branches covered.">        if (n.getNodeType() == NodeType.NEWLINENODE) {</span>
            // Do not emit multiple line number instrs for the same line
<span class="fc" id="L469">            int currLineNum = n.getPosition().getLine();</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">            if (currLineNum != _lastProcessedLineNum) {</span>
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">                if (RubyInstanceConfig.FULL_TRACE_ENABLED) {</span>
<span class="nc" id="L472">                    addInstr(s, new TraceInstr(RubyEvent.LINE, methodNameFor(s), s.getFileName(), currLineNum));</span>
                }
<span class="fc" id="L474">               addInstr(s, new LineNumberInstr(currLineNum));</span>
<span class="fc" id="L475">               _lastProcessedLineNum = currLineNum;</span>
            }
        }

<span class="fc bfc" id="L479" title="All 2 branches covered.">        while (n.getNodeType() == NodeType.NEWLINENODE) {</span>
<span class="fc" id="L480">            n = ((NewlineNode) n).getNextNode();</span>
        }

<span class="fc" id="L483">        return n;</span>
    }

    public Operand build(Node node, IRScope s) {
<span class="fc bfc" id="L487" title="All 2 branches covered.">        if (node == null) return null;</span>

<span class="pc bpc" id="L489" title="1 of 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L490">            System.out.println(&quot;Got a null scope!&quot;);</span>
<span class="nc" id="L491">            throw new NotCompilableException(&quot;Unknown node encountered in builder: &quot; + node);</span>
        }
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">        if (hasListener()) {</span>
<span class="nc" id="L494">            IRScopeListener listener = manager.getIRScopeListener();</span>
<span class="nc" id="L495">            listener.startBuildOperand(node, s);</span>
        }
<span class="fc" id="L497">        Operand operand = buildOperand(node, s);</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">        if (hasListener()) {</span>
<span class="nc" id="L499">            IRScopeListener listener = manager.getIRScopeListener();</span>
<span class="nc" id="L500">            listener.endBuildOperand(node, s, operand);</span>
        }
<span class="fc" id="L502">        return operand;</span>
    }

    public Operand buildLambda(LambdaNode node, IRScope s) {
<span class="fc" id="L506">        IRClosure closure = new IRClosure(manager, s, node.getPosition().getLine(), node.getScope(), Arity.procArityOf(node.getArgs()), node.getArgumentType());</span>

        // Create a new nested builder to ensure this gets its own IR builder state
        // like the ensure block stack
<span class="fc" id="L510">        IRBuilder closureBuilder = newIRBuilder(manager);</span>

        // Receive self
<span class="fc" id="L513">        closureBuilder.addInstr(closure, new ReceiveSelfInstr(closure.getSelf()));</span>

        // Set %current_scope = &lt;current-scope&gt;
        // Set %current_module = &lt;current-module&gt;
<span class="fc" id="L517">        closureBuilder.addInstr(closure, new CopyInstr(closure.getCurrentScopeVariable(), CURRENT_SCOPE[0]));</span>
<span class="fc" id="L518">        closureBuilder.addInstr(closure, new CopyInstr(closure.getCurrentModuleVariable(), SCOPE_MODULE[0]));</span>

        // args
<span class="fc" id="L521">        closureBuilder.receiveBlockArgs(node, closure);</span>

<span class="fc bfc" id="L523" title="All 2 branches covered.">        Operand closureRetVal = node.getBody() == null ? manager.getNil() : closureBuilder.build(node.getBody(), closure);</span>

        // can be U_NIL if the node is an if node with returns in both branches.
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">        if (closureRetVal != U_NIL) closureBuilder.addInstr(closure, new ReturnInstr(closureRetVal));</span>

<span class="fc" id="L528">        closureBuilder.handleBreakAndReturnsInLambdas(closure);</span>

<span class="fc" id="L530">        Variable lambda = s.createTemporaryVariable();</span>
<span class="fc" id="L531">        WrappedIRClosure lambdaBody = new WrappedIRClosure(closure.getSelf(), closure);</span>
<span class="fc" id="L532">        addInstr(s, new BuildLambdaInstr(lambda, lambdaBody, node.getPosition()));</span>
<span class="fc" id="L533">        return lambda;</span>
    }

    public Operand buildEncoding(EncodingNode node, IRScope s) {
<span class="fc" id="L537">        Variable ret = s.createTemporaryVariable();</span>
<span class="fc" id="L538">        addInstr(s, new GetEncodingInstr(ret, node.getEncoding()));</span>
<span class="fc" id="L539">        return ret;</span>
    }

    // Non-arg masgn
    public Operand buildMultipleAsgn19(MultipleAsgn19Node multipleAsgnNode, IRScope s) {
<span class="fc" id="L544">        Operand  values = build(multipleAsgnNode.getValueNode(), s);</span>
<span class="fc" id="L545">        Variable ret = getValueInTemporaryVariable(s, values);</span>
<span class="fc" id="L546">        Variable tmp = s.createTemporaryVariable();</span>
<span class="fc" id="L547">        addInstr(s, new ToAryInstr(tmp, ret));</span>
<span class="fc" id="L548">        buildMultipleAsgn19Assignment(multipleAsgnNode, s, null, tmp);</span>
<span class="fc" id="L549">        return ret;</span>
    }

    protected Variable copyAndReturnValue(IRScope s, Operand val) {
<span class="fc" id="L553">        return addResultInstr(s, new CopyInstr(s.createTemporaryVariable(), val));</span>
    }

    protected Variable getValueInTemporaryVariable(IRScope s, Operand val) {
<span class="pc bpc" id="L557" title="1 of 4 branches missed.">        if (val != null &amp;&amp; val instanceof TemporaryVariable) return (Variable) val;</span>

<span class="fc" id="L559">        return copyAndReturnValue(s, val);</span>
    }

    // Return the last argument in the list as this represents rhs of the overall attrassign expression
    // e.g. 'a[1] = 2 #=&gt; 2' or 'a[1] = 1,2,3 #=&gt; [1,2,3]'
    protected Operand buildAttrAssignCallArgs(List&lt;Operand&gt; argsList, Node args, IRScope s) {
<span class="pc bpc" id="L565" title="2 of 4 branches missed.">        switch (args.getNodeType()) {</span>
            case ARRAYNODE: {     // a[1] = 2; a[1,2,3] = 4,5,6
<span class="fc" id="L567">                Operand last = manager.getNil();</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">                for (Node n: args.childNodes()) {</span>
<span class="fc" id="L569">                    last = build(n, s);</span>
<span class="fc" id="L570">                    argsList.add(last);</span>
<span class="fc" id="L571">                }</span>
<span class="fc" id="L572">                return last;</span>
            }
            case ARGSPUSHNODE:  { // a[1, *b] = 2
<span class="fc" id="L575">                ArgsPushNode argsPushNode = (ArgsPushNode)args;</span>
<span class="fc" id="L576">                Operand lhs = build(argsPushNode.getFirstNode(), s);</span>
<span class="fc" id="L577">                Operand rhs = build(argsPushNode.getSecondNode(), s);</span>
<span class="fc" id="L578">                Variable res = s.createTemporaryVariable();</span>
<span class="fc" id="L579">                addInstr(s, new BuildCompoundArrayInstr(res, lhs, rhs, true));</span>
<span class="fc" id="L580">                argsList.add(new Splat(res, true));</span>
<span class="fc" id="L581">                return rhs;</span>
            }
            case SPLATNODE: {     // a[1] = *b
<span class="nc" id="L584">                Splat rhs = new Splat(build(((SplatNode)args).getValue(), s), true);</span>
<span class="nc" id="L585">                argsList.add(rhs);</span>
<span class="nc" id="L586">                return rhs;</span>
            }
        }

<span class="nc" id="L590">        throw new NotCompilableException(&quot;Invalid node for attrassign call args: &quot; + args.getClass().getSimpleName() + &quot;:&quot; + args.getPosition());</span>
    }

    protected Operand[] buildCallArgs(Node args, IRScope s) {
<span class="pc bpc" id="L594" title="1 of 4 branches missed.">        switch (args.getNodeType()) {</span>
            case ARGSCATNODE:
            case ARGSPUSHNODE:
<span class="fc" id="L597">                return new Operand[] { new Splat(build(args, s), true) };</span>
            case ARRAYNODE: {
<span class="fc" id="L599">                List&lt;Node&gt; children = args.childNodes();</span>
<span class="fc" id="L600">                int numberOfArgs = children.size();</span>
<span class="fc" id="L601">                Operand[] builtArgs = new Operand[numberOfArgs];</span>

<span class="fc bfc" id="L603" title="All 2 branches covered.">                for (int i = 0; i &lt; numberOfArgs; i++) {</span>
<span class="fc" id="L604">                    builtArgs[i] = build(children.get(i), s);</span>
                }
<span class="fc" id="L606">                return builtArgs;</span>
            }
            case SPLATNODE:
<span class="fc" id="L609">                return new Operand[] { new Splat(build(((SplatNode) args).getValue(), s), true) };</span>
        }

<span class="nc" id="L612">        throw new NotCompilableException(&quot;Invalid node for call args: &quot; + args.getClass().getSimpleName() + &quot;:&quot; + args.getPosition());</span>
    }

    public Operand[] setupCallArgs(Node args, IRScope s) {
<span class="fc bfc" id="L616" title="All 2 branches covered.">        return args == null ? Operand.EMPTY_ARRAY : buildCallArgs(args, s);</span>
    }

    public static Operand[] addArg(Operand[] args, Operand extraArg) {
<span class="fc" id="L620">        Operand[] newArgs = new Operand[args.length + 1];</span>
<span class="fc" id="L621">        System.arraycopy(args, 0, newArgs, 0, args.length);</span>
<span class="fc" id="L622">        newArgs[args.length] = extraArg;</span>
<span class="fc" id="L623">        return newArgs;</span>
    }

    // Non-arg masgn (actually a nested masgn)
    public void buildVersionSpecificAssignment(Node node, IRScope s, Variable v) {
<span class="pc bpc" id="L628" title="1 of 2 branches missed.">        switch (node.getNodeType()) {</span>
        case MULTIPLEASGN19NODE: {
<span class="fc" id="L630">            Variable tmp = s.createTemporaryVariable();</span>
<span class="fc" id="L631">            addInstr(s, new ToAryInstr(tmp, v));</span>
<span class="fc" id="L632">            buildMultipleAsgn19Assignment((MultipleAsgn19Node)node, s, null, tmp);</span>
<span class="fc" id="L633">            break;</span>
        }
        default:
<span class="nc" id="L636">            throw new NotCompilableException(&quot;Can't build assignment node: &quot; + node);</span>
        }
<span class="fc" id="L638">    }</span>

    // This method is called to build assignments for a multiple-assignment instruction
    public void buildAssignment(Node node, IRScope s, Variable rhsVal) {
<span class="pc bpc" id="L642" title="3 of 10 branches missed.">        switch (node.getNodeType()) {</span>
            case ATTRASSIGNNODE:
<span class="fc" id="L644">                buildAttrAssignAssignment(node, s, rhsVal);</span>
<span class="fc" id="L645">                break;</span>
            case CLASSVARASGNNODE:
<span class="fc" id="L647">                addInstr(s, new PutClassVariableInstr(classVarDefinitionContainer(s), ((ClassVarAsgnNode)node).getName(), rhsVal));</span>
<span class="fc" id="L648">                break;</span>
            case CLASSVARDECLNODE:
<span class="nc" id="L650">                addInstr(s, new PutClassVariableInstr(classVarDeclarationContainer(s), ((ClassVarDeclNode)node).getName(), rhsVal));</span>
<span class="nc" id="L651">                break;</span>
            case CONSTDECLNODE:
<span class="nc" id="L653">                buildConstDeclAssignment((ConstDeclNode) node, s, rhsVal);</span>
<span class="nc" id="L654">                break;</span>
            case DASGNNODE: {
<span class="fc" id="L656">                DAsgnNode variable = (DAsgnNode) node;</span>
<span class="fc" id="L657">                int depth = variable.getDepth();</span>
<span class="fc" id="L658">                addInstr(s, new CopyInstr(s.getLocalVariable(variable.getName(), depth), rhsVal));</span>
<span class="fc" id="L659">                break;</span>
            }
            case GLOBALASGNNODE:
<span class="fc" id="L662">                addInstr(s, new PutGlobalVarInstr(((GlobalAsgnNode)node).getName(), rhsVal));</span>
<span class="fc" id="L663">                break;</span>
            case INSTASGNNODE:
                // NOTE: if 's' happens to the a class, this is effectively an assignment of a class instance variable
<span class="fc" id="L666">                addInstr(s, new PutFieldInstr(s.getSelf(), ((InstAsgnNode)node).getName(), rhsVal));</span>
<span class="fc" id="L667">                break;</span>
            case LOCALASGNNODE: {
<span class="fc" id="L669">                LocalAsgnNode localVariable = (LocalAsgnNode) node;</span>
<span class="fc" id="L670">                int depth = localVariable.getDepth();</span>
<span class="fc" id="L671">                addInstr(s, new CopyInstr(s.getLocalVariable(localVariable.getName(), depth), rhsVal));</span>
<span class="fc" id="L672">                break;</span>
            }
            case ZEROARGNODE:
<span class="nc" id="L675">                throw new NotCompilableException(&quot;Shouldn't get here; zeroarg does not do assignment: &quot; + node);</span>
            default:
<span class="fc" id="L677">                buildVersionSpecificAssignment(node, s, rhsVal);</span>
        }
<span class="fc" id="L679">    }</span>

    protected LocalVariable getBlockArgVariable(IRScope s, String name, int depth) {
<span class="pc bpc" id="L682" title="1 of 2 branches missed.">        if (!(s instanceof IRFor)) throw new NotCompilableException(&quot;Cannot ask for block-arg variable in 1.9 mode&quot;);</span>

<span class="fc" id="L684">        return s.getLocalVariable(name, depth);</span>
    }

    protected void receiveBlockArg(IRScope s, Variable v, Operand argsArray, int argIndex, boolean isSplat) {
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">        if (argsArray != null) {</span>
            // We are in a nested receive situation -- when we are not at the root of a masgn tree
            // Ex: We are trying to receive (b,c) in this example: &quot;|a, (b,c), d| = ...&quot;
<span class="nc bnc" id="L691" title="All 2 branches missed.">            if (isSplat) addInstr(s, new RestArgMultipleAsgnInstr(v, argsArray, argIndex));</span>
<span class="nc" id="L692">            else addInstr(s, new ReqdArgMultipleAsgnInstr(v, argsArray, argIndex));</span>
        } else {
            // argsArray can be null when the first node in the args-node-ast is a multiple-assignment
            // For example, for-nodes
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">            addInstr(s, isSplat ? new ReceiveRestArgInstr(v, argIndex, argIndex) : new ReceivePreReqdArgInstr(v, argIndex));</span>
        }
<span class="fc" id="L698">    }</span>

    public void buildVersionSpecificBlockArgsAssignment(Node node, IRScope s) {
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">        if (!(s instanceof IRFor)) throw new NotCompilableException(&quot;Should not have come here for block args assignment in 1.9 mode: &quot; + node);</span>

        // Argh!  For-loop bodies and regular iterators are different in terms of block-args!
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">        switch (node.getNodeType()) {</span>
            case MULTIPLEASGN19NODE: {
<span class="fc" id="L706">                ListNode sourceArray = ((MultipleAsgn19Node) node).getPre();</span>
<span class="fc" id="L707">                int i = 0;</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">                for (Node an: sourceArray.childNodes()) {</span>
                    // Use 1.8 mode version for this
<span class="fc" id="L710">                    buildBlockArgsAssignment(an, s, null, i, false);</span>
<span class="fc" id="L711">                    i++;</span>
<span class="fc" id="L712">                }</span>
<span class="fc" id="L713">                break;</span>
            }
            default:
<span class="nc" id="L716">                throw new NotCompilableException(&quot;Can't build assignment node: &quot; + node);</span>
        }
<span class="fc" id="L718">    }</span>

    // This method is called to build arguments for a block!
    public void buildBlockArgsAssignment(Node node, IRScope s, Operand argsArray, int argIndex, boolean isSplat) {
        Variable v;
<span class="pc bpc" id="L723" title="5 of 10 branches missed.">        switch (node.getNodeType()) {</span>
            case ATTRASSIGNNODE:
<span class="nc" id="L725">                v = s.createTemporaryVariable();</span>
<span class="nc" id="L726">                receiveBlockArg(s, v, argsArray, argIndex, isSplat);</span>
<span class="nc" id="L727">                buildAttrAssignAssignment(node, s, v);</span>
<span class="nc" id="L728">                break;</span>
            case DASGNNODE: {
<span class="fc" id="L730">                DAsgnNode dynamicAsgn = (DAsgnNode) node;</span>
<span class="fc" id="L731">                v = getBlockArgVariable(s, dynamicAsgn.getName(), dynamicAsgn.getDepth());</span>
<span class="fc" id="L732">                receiveBlockArg(s, v, argsArray, argIndex, isSplat);</span>
<span class="fc" id="L733">                break;</span>
            }
            case CLASSVARASGNNODE:
<span class="fc" id="L736">                v = s.createTemporaryVariable();</span>
<span class="fc" id="L737">                receiveBlockArg(s, v, argsArray, argIndex, isSplat);</span>
<span class="fc" id="L738">                addInstr(s, new PutClassVariableInstr(classVarDefinitionContainer(s), ((ClassVarAsgnNode)node).getName(), v));</span>
<span class="fc" id="L739">                break;</span>
            case CLASSVARDECLNODE:
<span class="nc" id="L741">                v = s.createTemporaryVariable();</span>
<span class="nc" id="L742">                receiveBlockArg(s, v, argsArray, argIndex, isSplat);</span>
<span class="nc" id="L743">                addInstr(s, new PutClassVariableInstr(classVarDeclarationContainer(s), ((ClassVarDeclNode)node).getName(), v));</span>
<span class="nc" id="L744">                break;</span>
            case CONSTDECLNODE:
<span class="fc" id="L746">                v = s.createTemporaryVariable();</span>
<span class="fc" id="L747">                receiveBlockArg(s, v, argsArray, argIndex, isSplat);</span>
<span class="fc" id="L748">                buildConstDeclAssignment((ConstDeclNode) node, s, v);</span>
<span class="fc" id="L749">                break;</span>
            case GLOBALASGNNODE:
<span class="nc" id="L751">                v = s.createTemporaryVariable();</span>
<span class="nc" id="L752">                receiveBlockArg(s, v, argsArray, argIndex, isSplat);</span>
<span class="nc" id="L753">                addInstr(s, new PutGlobalVarInstr(((GlobalAsgnNode)node).getName(), v));</span>
<span class="nc" id="L754">                break;</span>
            case INSTASGNNODE:
<span class="fc" id="L756">                v = s.createTemporaryVariable();</span>
<span class="fc" id="L757">                receiveBlockArg(s, v, argsArray, argIndex, isSplat);</span>
                // NOTE: if 's' happens to the a class, this is effectively an assignment of a class instance variable
<span class="fc" id="L759">                addInstr(s, new PutFieldInstr(s.getSelf(), ((InstAsgnNode)node).getName(), v));</span>
<span class="fc" id="L760">                break;</span>
            case LOCALASGNNODE: {
<span class="nc" id="L762">                LocalAsgnNode localVariable = (LocalAsgnNode) node;</span>
<span class="nc" id="L763">                int depth = localVariable.getDepth();</span>
<span class="nc" id="L764">                v = getBlockArgVariable(s, localVariable.getName(), depth);</span>
<span class="nc" id="L765">                receiveBlockArg(s, v, argsArray, argIndex, isSplat);</span>
<span class="nc" id="L766">                break;</span>
            }
            case ZEROARGNODE:
<span class="nc" id="L769">                throw new NotCompilableException(&quot;Shouldn't get here; zeroarg does not do assignment: &quot; + node);</span>
            default:
<span class="fc" id="L771">                buildVersionSpecificBlockArgsAssignment(node, s);</span>
        }
<span class="fc" id="L773">    }</span>

    public Operand buildAlias(final AliasNode alias, IRScope s) {
<span class="fc" id="L776">        Operand newName = build(alias.getNewName(), s);</span>
<span class="fc" id="L777">        Operand oldName = build(alias.getOldName(), s);</span>
<span class="fc" id="L778">        addInstr(s, new AliasInstr(newName, oldName));</span>

<span class="fc" id="L780">        return manager.getNil();</span>
    }

    // Translate &quot;ret = (a &amp;&amp; b)&quot; --&gt; &quot;ret = (a ? b : false)&quot; --&gt;
    //
    //    v1 = -- build(a) --
    //       OPT: ret can be set to v1, but effectively v1 is false if we take the branch to L.
    //            while this info can be inferred by using attributes, why bother if we can do this?
    //    ret = v1
    //    beq(v1, false, L)
    //    v2 = -- build(b) --
    //    ret = v2
    // L:
    //
    public Operand buildAnd(final AndNode andNode, IRScope s) {
<span class="fc bfc" id="L795" title="All 2 branches covered.">        if (andNode.getFirstNode().getNodeType().alwaysTrue()) {</span>
            // build first node (and ignore its result) and then second node
<span class="fc" id="L797">            build(andNode.getFirstNode(), s);</span>
<span class="fc" id="L798">            return build(andNode.getSecondNode(), s);</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">        } else if (andNode.getFirstNode().getNodeType().alwaysFalse()) {</span>
            // build first node only and return its value
<span class="fc" id="L801">            return build(andNode.getFirstNode(), s);</span>
        } else {
<span class="fc" id="L803">            Label    l   = s.getNewLabel();</span>
<span class="fc" id="L804">            Operand  v1  = build(andNode.getFirstNode(), s);</span>
<span class="fc" id="L805">            Variable ret = getValueInTemporaryVariable(s, v1);</span>
<span class="fc" id="L806">            addInstr(s, BEQInstr.create(v1, manager.getFalse(), l));</span>
<span class="fc" id="L807">            Operand  v2  = build(andNode.getSecondNode(), s);</span>
<span class="fc" id="L808">            addInstr(s, new CopyInstr(ret, v2));</span>
<span class="fc" id="L809">            addInstr(s, new LabelInstr(l));</span>
<span class="fc" id="L810">            return ret;</span>
        }
    }

    public Operand buildArray(Node node, IRScope s) {
<span class="fc" id="L815">        List&lt;Operand&gt; elts = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">        for (Node e: node.childNodes())</span>
<span class="fc" id="L817">            elts.add(build(e, s));</span>

<span class="fc" id="L819">        return copyAndReturnValue(s, new Array(elts));</span>
    }

    public Operand buildArgsCat(final ArgsCatNode argsCatNode, IRScope s) {
<span class="fc" id="L823">        Operand v1 = build(argsCatNode.getFirstNode(), s);</span>
<span class="fc" id="L824">        Operand v2 = build(argsCatNode.getSecondNode(), s);</span>
<span class="fc" id="L825">        Variable res = s.createTemporaryVariable();</span>
<span class="fc" id="L826">        addInstr(s, new BuildCompoundArrayInstr(res, v1, v2, false));</span>
<span class="fc" id="L827">        return res;</span>
    }

    public Operand buildArgsPush(final ArgsPushNode node, IRScope s) {
<span class="fc" id="L831">        Operand lhs = build(node.getFirstNode(), s);</span>
<span class="fc" id="L832">        Operand rhs = build(node.getSecondNode(), s);</span>

<span class="fc" id="L834">        return addResultInstr(s, new BuildCompoundArrayInstr(s.createTemporaryVariable(), lhs, rhs, true));</span>
    }

    private Operand buildAttrAssign(final AttrAssignNode attrAssignNode, IRScope s) {
<span class="fc" id="L838">        Operand obj = build(attrAssignNode.getReceiverNode(), s);</span>
<span class="fc" id="L839">        List&lt;Operand&gt; args = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L840">        Node argsNode = attrAssignNode.getArgsNode();</span>
<span class="pc bpc" id="L841" title="1 of 2 branches missed.">        Operand lastArg = (argsNode == null) ? manager.getNil() : buildAttrAssignCallArgs(args, argsNode, s);</span>
<span class="fc" id="L842">        addInstr(s, new AttrAssignInstr(obj, attrAssignNode.getName(), args.toArray(new Operand[args.size()])));</span>
<span class="fc" id="L843">        return lastArg;</span>
    }

    public Operand buildAttrAssignAssignment(Node node, IRScope s, Operand value) {
<span class="fc" id="L847">        final AttrAssignNode attrAssignNode = (AttrAssignNode) node;</span>
<span class="fc" id="L848">        Operand obj = build(attrAssignNode.getReceiverNode(), s);</span>
<span class="fc" id="L849">        Operand[] args = setupCallArgs(attrAssignNode.getArgsNode(), s);</span>
<span class="fc" id="L850">        args = addArg(args, value);</span>
<span class="fc" id="L851">        addInstr(s, new AttrAssignInstr(obj, attrAssignNode.getName(), args));</span>
<span class="fc" id="L852">        return value;</span>
    }

    public Operand buildBackref(BackRefNode node, IRScope s) {
        // SSS FIXME: Required? Verify with Tom/Charlie
<span class="fc" id="L857">        return copyAndReturnValue(s, new Backref(node.getType()));</span>
    }

    public Operand buildBegin(BeginNode beginNode, IRScope s) {
<span class="fc" id="L861">        return build(beginNode.getBodyNode(), s);</span>
    }

    public Operand buildBignum(BignumNode node) {
        // SSS: Since bignum literals are effectively interned objects, no need to copyAndReturnValue(...)
        // Or is this a premature optimization?
<span class="fc" id="L867">        return new Bignum(node.getValue());</span>
    }

    public Operand buildBlock(BlockNode node, IRScope s) {
<span class="fc" id="L871">        Operand retVal = null;</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">        for (Node child : node.childNodes()) {</span>
<span class="fc" id="L873">            retVal = build(child, s);</span>
<span class="fc" id="L874">        }</span>

        // Value of the last expression in the block
<span class="fc" id="L877">        return retVal;</span>
    }

    public Operand buildBreak(BreakNode breakNode, IRScope s) {
<span class="fc" id="L881">        IRLoop currLoop = getCurrentLoop();</span>

<span class="fc" id="L883">        Operand rv = build(breakNode.getValueNode(), s);</span>
        // If we have ensure blocks, have to run those first!
<span class="fc bfc" id="L885" title="All 2 branches covered.">        if (!activeEnsureBlockStack.empty()) emitEnsureBlocks(s, currLoop);</span>
<span class="fc bfc" id="L886" title="All 2 branches covered.">        else if (!activeRescueBlockStack.empty()) activeRescueBlockStack.peek().restoreException(this, s, currLoop);</span>

<span class="fc bfc" id="L888" title="All 2 branches covered.">        if (currLoop != null) {</span>
<span class="fc" id="L889">            addInstr(s, new CopyInstr(currLoop.loopResult, rv));</span>
<span class="fc" id="L890">            addInstr(s, new JumpInstr(currLoop.loopEndLabel));</span>
        } else {
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">            if (s instanceof IRClosure) {</span>
                // This lexical scope value is only used (and valid) in regular block contexts.
                // If this instruction is executed in a Proc or Lambda context, the lexical scope value is useless.
<span class="fc" id="L895">                IRScope returnScope = s.getLexicalParent();</span>
                // In 1.9 and later modes, no breaks from evals
<span class="pc bpc" id="L897" title="2 of 4 branches missed.">                if (s instanceof IREvalScript || returnScope == null) addInstr(s, new ThrowExceptionInstr(IRException.BREAK_LocalJumpError));</span>
<span class="fc" id="L898">                else addInstr(s, new BreakInstr(rv, returnScope.getName()));</span>
<span class="fc" id="L899">            } else {</span>
                // We are not in a closure or a loop =&gt; bad break instr!
<span class="nc" id="L901">                addInstr(s, new ThrowExceptionInstr(IRException.BREAK_LocalJumpError));</span>
            }
        }

        // Once the break instruction executes, control exits this scope
<span class="fc" id="L906">        return U_NIL;</span>
    }

    private void handleNonlocalReturnInMethod(IRScope s) {
<span class="fc" id="L910">        Label rBeginLabel = s.getNewLabel();</span>
<span class="fc" id="L911">        Label rEndLabel   = s.getNewLabel();</span>
<span class="fc" id="L912">        Label gebLabel    = s.getNewLabel();</span>

        // Protect the entire body as it exists now with the global ensure block
        //
        // Add label and marker instruction in reverse order to the beginning
        // so that the label ends up being the first instr.
<span class="fc" id="L918">        addInstrAtBeginning(s, new ExceptionRegionStartMarkerInstr(gebLabel));</span>
<span class="fc" id="L919">        addInstrAtBeginning(s, new LabelInstr(rBeginLabel));</span>
<span class="fc" id="L920">        addInstr(s, new ExceptionRegionEndMarkerInstr());</span>

        // Receive exceptions (could be anything, but the handler only processes IRReturnJumps)
<span class="fc" id="L923">        addInstr(s, new LabelInstr(gebLabel));</span>
<span class="fc" id="L924">        Variable exc = s.createTemporaryVariable();</span>
<span class="fc" id="L925">        addInstr(s, new ReceiveJRubyExceptionInstr(exc));</span>

<span class="pc bpc" id="L927" title="1 of 2 branches missed.">        if (RubyInstanceConfig.FULL_TRACE_ENABLED) {</span>
<span class="nc" id="L928">            addInstr(s, new TraceInstr(RubyEvent.RETURN, s.getName(), s.getFileName(), -1));</span>
        }

        // Handle break using runtime helper
        // --&gt; IRRuntimeHelpers.handleNonlocalReturn(scope, bj, blockType)
<span class="fc" id="L933">        Variable ret = s.createTemporaryVariable();</span>
<span class="fc" id="L934">        addInstr(s, new RuntimeHelperCall(ret, HANDLE_NONLOCAL_RETURN, new Operand[]{exc} ));</span>
<span class="fc" id="L935">        addInstr(s, new ReturnInstr(ret));</span>

        // End
<span class="fc" id="L938">        addInstr(s, new LabelInstr(rEndLabel));</span>
<span class="fc" id="L939">    }</span>

    private Operand receiveBreakException(IRScope s, Operand block, CodeBlock codeBlock) {
        // Check if we have to handle a break
<span class="fc bfc" id="L943" title="All 4 branches covered.">        if (block == null ||</span>
            !(block instanceof WrappedIRClosure) ||
<span class="fc bfc" id="L945" title="All 2 branches covered.">            !(((WrappedIRClosure)block).getClosure()).flags.contains(IRFlags.HAS_BREAK_INSTRS)) {</span>
            // No protection needed -- add the call and return
<span class="fc" id="L947">            return codeBlock.run();</span>
        }

<span class="fc" id="L950">        Label rBeginLabel = s.getNewLabel();</span>
<span class="fc" id="L951">        Label rEndLabel   = s.getNewLabel();</span>
<span class="fc" id="L952">        Label rescueLabel = s.getNewLabel();</span>

        // Protected region
<span class="fc" id="L955">        addInstr(s, new LabelInstr(rBeginLabel));</span>
<span class="fc" id="L956">        addInstr(s, new ExceptionRegionStartMarkerInstr(rescueLabel));</span>
<span class="fc" id="L957">        Variable callResult = (Variable)codeBlock.run();</span>
<span class="fc" id="L958">        addInstr(s, new JumpInstr(rEndLabel));</span>
<span class="fc" id="L959">        addInstr(s, new ExceptionRegionEndMarkerInstr());</span>

        // Receive exceptions (could be anything, but the handler only processes IRBreakJumps)
<span class="fc" id="L962">        addInstr(s, new LabelInstr(rescueLabel));</span>
<span class="fc" id="L963">        Variable exc = s.createTemporaryVariable();</span>
<span class="fc" id="L964">        addInstr(s, new ReceiveJRubyExceptionInstr(exc));</span>

        // Handle break using runtime helper
        // --&gt; IRRuntimeHelpers.handlePropagatedBreak(context, scope, bj, blockType)
<span class="fc" id="L968">        addInstr(s, new RuntimeHelperCall(callResult, HANDLE_PROPAGATE_BREAK, new Operand[]{exc} ));</span>

        // End
<span class="fc" id="L971">        addInstr(s, new LabelInstr(rEndLabel));</span>

<span class="fc" id="L973">        return callResult;</span>
    }

    // Wrap call in a rescue handler that catches the IRBreakJump
    private void receiveBreakException(final IRScope s, Operand block, final CallInstr callInstr) {
<span class="fc" id="L978">        receiveBreakException(s, block, new CodeBlock() { public Operand run() { addInstr(s, callInstr); return callInstr.getResult(); } });</span>
<span class="fc" id="L979">    }</span>

    public Operand buildCall(CallNode callNode, IRScope s) {
<span class="fc" id="L982">        Node          callArgsNode = callNode.getArgsNode();</span>
<span class="fc" id="L983">        Node          receiverNode = callNode.getReceiverNode();</span>

        // check for &quot;string&quot;.freeze
<span class="fc bfc" id="L986" title="All 4 branches covered.">        if (receiverNode instanceof StrNode &amp;&amp; callNode.getName().equals(&quot;freeze&quot;)) {</span>
            // frozen string optimization
<span class="fc" id="L988">            return new FrozenString(((StrNode)receiverNode).getValue());</span>
        }

        // Though you might be tempted to move this build into the CallInstr as:
        //    new Callinstr( ... , build(receiverNode, s), ...)
        // that is incorrect IR because the receiver has to be built *before* call arguments are built
        // to preserve expected code execution order
<span class="fc" id="L995">        Operand       receiver     = build(receiverNode, s);</span>
<span class="fc" id="L996">        Operand[] args         = setupCallArgs(callArgsNode, s);</span>
<span class="fc" id="L997">        Operand       block        = setupCallClosure(callNode.getIterNode(), s);</span>
<span class="fc" id="L998">        Variable      callResult   = s.createTemporaryVariable();</span>
<span class="fc" id="L999">        CallInstr     callInstr    = CallInstr.create(callResult, callNode.getName(), receiver, args, block);</span>

        // This is to support the ugly Proc.new with no block, which must see caller's frame
<span class="fc" id="L1002">        if (</span>
<span class="fc bfc" id="L1003" title="All 4 branches covered.">                callNode.getName().equals(&quot;new&quot;) &amp;&amp;</span>
                receiverNode instanceof ConstNode &amp;&amp;
<span class="fc bfc" id="L1005" title="All 2 branches covered.">                ((ConstNode)receiverNode).getName().equals(&quot;Proc&quot;)) {</span>
<span class="fc" id="L1006">            callInstr.setProcNew(true);</span>
        }

<span class="fc" id="L1009">        receiveBreakException(s, block, callInstr);</span>
<span class="fc" id="L1010">        return callResult;</span>
    }

    public Operand buildCase(CaseNode caseNode, IRScope s) {
        // get the incoming case value
<span class="fc" id="L1015">        Operand value = build(caseNode.getCaseNode(), s);</span>

        // This is for handling case statements without a value (see example below)
        //   case
        //     when true &lt;blah&gt;
        //     when false &lt;blah&gt;
        //   end
<span class="fc bfc" id="L1022" title="All 2 branches covered.">        if (value == null) value = UndefinedValue.UNDEFINED;</span>

<span class="fc" id="L1024">        Label     endLabel  = s.getNewLabel();</span>
<span class="fc bfc" id="L1025" title="All 2 branches covered.">        boolean   hasElse   = (caseNode.getElseNode() != null);</span>
<span class="fc" id="L1026">        Label     elseLabel = s.getNewLabel();</span>
<span class="fc" id="L1027">        Variable  result    = s.createTemporaryVariable();</span>

<span class="fc" id="L1029">        List&lt;Label&gt; labels = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1030">        Map&lt;Label, Node&gt; bodies = new HashMap&lt;&gt;();</span>

        // build each &quot;when&quot;
<span class="fc bfc" id="L1033" title="All 2 branches covered.">        for (Node aCase : caseNode.getCases().childNodes()) {</span>
<span class="fc" id="L1034">            WhenNode whenNode = (WhenNode)aCase;</span>
<span class="fc" id="L1035">            Label bodyLabel = s.getNewLabel();</span>

<span class="fc" id="L1037">            Variable eqqResult = s.createTemporaryVariable();</span>
<span class="fc" id="L1038">            labels.add(bodyLabel);</span>
            Operand v1, v2;
<span class="fc bfc" id="L1040" title="All 2 branches covered.">            if (whenNode.getExpressionNodes() instanceof ListNode</span>
                    // DNode produces a proper result, so we don't want the special ListNode handling below
                    // FIXME: This is obviously gross, and we need a better way to filter out non-expression ListNode here
                    // See GH #2423
<span class="pc bpc" id="L1044" title="1 of 2 branches missed.">                    &amp;&amp; !(whenNode.getExpressionNodes() instanceof DNode)) {</span>
                // Note about refactoring:
                // - BEQInstr has a quick implementation when the second operand is a boolean literal
                //   If it can be fixed to do this even on the first operand, we can switch around
                //   v1 and v2 in the UndefinedValue scenario and DRY out this code.
                // - Even with this asymmetric implementation of BEQInstr, you might be tempted to
                //   switch around v1 and v2 in the else case.  But, that is equivalent to this Ruby code change:
                //      (v1 == value) instead of (value == v1)
                //   It seems that they should be identical, but the first one is v1.==(value) and the second one is
                //   value.==(v1).  This is just fine *if* the Ruby programmer has implemented an algebraically
                //   symmetric &quot;==&quot; method on those objects.  If not, then, the results might be unexpected where the
                //   code (intentionally or otherwise) relies on this asymmetry of &quot;==&quot;.  While it could be argued
                //   that this a Ruby code bug, we will just try to preserve the order of the == check as it appears
                //   in the Ruby code.
<span class="pc bpc" id="L1058" title="1 of 2 branches missed.">                if (value == UndefinedValue.UNDEFINED)  {</span>
<span class="nc" id="L1059">                    v1 = build(whenNode.getExpressionNodes(), s);</span>
<span class="nc" id="L1060">                    v2 = manager.getTrue();</span>
                } else {
<span class="fc" id="L1062">                    v1 = value;</span>
<span class="fc" id="L1063">                    v2 = build(whenNode.getExpressionNodes(), s);</span>
                }
            } else {
<span class="fc" id="L1066">                addInstr(s, new EQQInstr(eqqResult, build(whenNode.getExpressionNodes(), s), value));</span>
<span class="fc" id="L1067">                v1 = eqqResult;</span>
<span class="fc" id="L1068">                v2 = manager.getTrue();</span>
            }
<span class="fc" id="L1070">            addInstr(s, BEQInstr.create(v1, v2, bodyLabel));</span>

            // SSS FIXME: This doesn't preserve original order of when clauses.  We could consider
            // preserving the order (or maybe not, since we would have to sort the constants first
            // in any case) for outputting jump tables in certain situations.
            //
            // add body to map for emitting later
<span class="fc" id="L1077">            bodies.put(bodyLabel, whenNode.getBodyNode());</span>
<span class="fc" id="L1078">        }</span>

        // Jump to else in case nothing matches!
<span class="fc" id="L1081">        addInstr(s, new JumpInstr(elseLabel));</span>

        // Build &quot;else&quot; if it exists
<span class="fc bfc" id="L1084" title="All 2 branches covered.">        if (hasElse) {</span>
<span class="fc" id="L1085">            labels.add(elseLabel);</span>
<span class="fc" id="L1086">            bodies.put(elseLabel, caseNode.getElseNode());</span>
        }

        // Now, emit bodies while preserving when clauses order
<span class="fc bfc" id="L1090" title="All 2 branches covered.">        for (Label whenLabel: labels) {</span>
<span class="fc" id="L1091">            addInstr(s, new LabelInstr(whenLabel));</span>
<span class="fc" id="L1092">            Operand bodyValue = build(bodies.get(whenLabel), s);</span>
            // bodyValue can be null if the body ends with a return!
<span class="pc bpc" id="L1094" title="1 of 2 branches missed.">            if (bodyValue != null) {</span>
                // SSS FIXME: Do local optimization of break results (followed by a copy &amp; jump) to short-circuit the jump right away
                // rather than wait to do it during an optimization pass when a dead jump needs to be removed.  For this, you have
                // to look at what the last generated instruction was.
<span class="fc" id="L1098">                addInstr(s, new CopyInstr(result, bodyValue));</span>
<span class="fc" id="L1099">                addInstr(s, new JumpInstr(endLabel));</span>
            }
<span class="fc" id="L1101">        }</span>

<span class="fc bfc" id="L1103" title="All 2 branches covered.">        if (!hasElse) {</span>
<span class="fc" id="L1104">            addInstr(s, new LabelInstr(elseLabel));</span>
<span class="fc" id="L1105">            addInstr(s, new CopyInstr(result, manager.getNil()));</span>
<span class="fc" id="L1106">            addInstr(s, new JumpInstr(endLabel));</span>
        }

        // Close it out
<span class="fc" id="L1110">        addInstr(s, new LabelInstr(endLabel));</span>

<span class="fc" id="L1112">        return result;</span>
    }

    /**
     * Build a new class and add it to the current scope (s).
     */
    public Operand buildClass(ClassNode classNode, IRScope s) {
<span class="fc" id="L1119">        Node superNode = classNode.getSuperNode();</span>
<span class="fc" id="L1120">        Colon3Node cpath = classNode.getCPath();</span>
<span class="fc bfc" id="L1121" title="All 2 branches covered.">        Operand superClass = (superNode == null) ? null : build(superNode, s);</span>
<span class="fc" id="L1122">        String className = cpath.getName();</span>
<span class="fc" id="L1123">        Operand container = getContainerFromCPath(cpath, s);</span>
<span class="fc" id="L1124">        IRClassBody body = new IRClassBody(manager, s, className, classNode.getPosition().getLine(), classNode.getScope());</span>
<span class="fc" id="L1125">        Variable classVar = addResultInstr(s, new DefineClassInstr(s.createTemporaryVariable(), body, container, superClass));</span>

<span class="fc" id="L1127">        return buildModuleOrClassBody(s, classVar, body, classNode.getBodyNode(), classNode.getPosition().getLine());</span>
    }

    // class Foo; class &lt;&lt; self; end; end
    // Here, the class &lt;&lt; self declaration is in Foo's body.
    // Foo is the class in whose context this is being defined.
    public Operand buildSClass(SClassNode sclassNode, IRScope s) {
<span class="fc" id="L1134">        Operand receiver = build(sclassNode.getReceiverNode(), s);</span>
<span class="fc" id="L1135">        IRModuleBody body = new IRMetaClassBody(manager, s, manager.getMetaClassName(), sclassNode.getPosition().getLine(), sclassNode.getScope());</span>
<span class="fc" id="L1136">        Variable sClassVar = addResultInstr(s, new DefineMetaClassInstr(s.createTemporaryVariable(), receiver, body));</span>

<span class="fc" id="L1138">        return buildModuleOrClassBody(s, sClassVar, body, sclassNode.getBodyNode(), sclassNode.getPosition().getLine());</span>
    }

    // @@c
    public Operand buildClassVar(ClassVarNode node, IRScope s) {
<span class="fc" id="L1143">        Variable ret = s.createTemporaryVariable();</span>
<span class="fc" id="L1144">        addInstr(s, new GetClassVariableInstr(ret, classVarDefinitionContainer(s), node.getName()));</span>
<span class="fc" id="L1145">        return ret;</span>
    }

    // Add the specified result instruction to the scope and return its result variable.
    private Variable addResultInstr(IRScope s, ResultInstr instr) {
<span class="fc" id="L1150">        addInstr(s, (Instr) instr);</span>

<span class="fc" id="L1152">        return instr.getResult();</span>
    }

    // ClassVarAsgn node is assignment within a method/closure scope
    //
    // def foo
    //   @@c = 1
    // end
    public Operand buildClassVarAsgn(final ClassVarAsgnNode classVarAsgnNode, IRScope s) {
<span class="fc" id="L1161">        Operand val = build(classVarAsgnNode.getValueNode(), s);</span>
<span class="fc" id="L1162">        addInstr(s, new PutClassVariableInstr(classVarDefinitionContainer(s), classVarAsgnNode.getName(), val));</span>
<span class="fc" id="L1163">        return val;</span>
    }

    // ClassVarDecl node is assignment outside method/closure scope (top-level, class, module)
    //
    // class C
    //   @@c = 1
    // end
    public Operand buildClassVarDecl(final ClassVarDeclNode classVarDeclNode, IRScope s) {
<span class="nc" id="L1172">        Operand val = build(classVarDeclNode.getValueNode(), s);</span>
<span class="nc" id="L1173">        addInstr(s, new PutClassVariableInstr(classVarDeclarationContainer(s), classVarDeclNode.getName(), val));</span>
<span class="nc" id="L1174">        return val;</span>
    }

    public Operand classVarDeclarationContainer(IRScope s) {
<span class="nc" id="L1178">        return classVarContainer(s, true);</span>
    }

    public Operand classVarDefinitionContainer(IRScope s) {
<span class="fc" id="L1182">        return classVarContainer(s, false);</span>
    }

    // SSS FIXME: This feels a little ugly.  Is there a better way of representing this?
    public Operand classVarContainer(IRScope s, boolean declContext) {
        /* -------------------------------------------------------------------------------
         * We are looking for the nearest enclosing scope that is a non-singleton class body
         * without running into an eval-scope in between.
         *
         * Stop lexical scope walking at an eval script boundary.  Evals are essentially
         * a way for a programmer to splice an entire tree of lexical scopes at the point
         * where the eval happens.  So, when we hit an eval-script boundary at compile-time,
         * defer scope traversal to when we know where this scope has been spliced in.
         * ------------------------------------------------------------------------------- */
<span class="fc" id="L1196">        int n = 0;</span>
<span class="fc" id="L1197">        IRScope cvarScope = s;</span>
<span class="fc bfc" id="L1198" title="All 6 branches covered.">        while (cvarScope != null &amp;&amp; !(cvarScope instanceof IREvalScript) &amp;&amp; !cvarScope.isNonSingletonClassBody()) {</span>
<span class="fc" id="L1199">            cvarScope = cvarScope.getLexicalParent();</span>
<span class="fc" id="L1200">            n++;</span>
        }

<span class="fc bfc" id="L1203" title="All 4 branches covered.">        if ((cvarScope != null) &amp;&amp; cvarScope.isNonSingletonClassBody()) {</span>
<span class="fc" id="L1204">            return ScopeModule.ModuleFor(n);</span>
        } else {
<span class="fc" id="L1206">            return addResultInstr(s, new GetClassVarContainerModuleInstr(s.createTemporaryVariable(),</span>
<span class="pc bpc" id="L1207" title="1 of 2 branches missed.">                    s.getCurrentScopeVariable(), declContext ? null : s.getSelf()));</span>
        }
    }

    public Operand buildConstDecl(ConstDeclNode node, IRScope s) {
<span class="fc" id="L1212">        return buildConstDeclAssignment(node, s, build(node.getValueNode(), s));</span>
    }

    private Operand findContainerModule(IRScope s) {
<span class="fc" id="L1216">        int nearestModuleBodyDepth = s.getNearestModuleReferencingScopeDepth();</span>
<span class="fc bfc" id="L1217" title="All 2 branches covered.">        return (nearestModuleBodyDepth == -1) ? s.getCurrentModuleVariable() : ScopeModule.ModuleFor(nearestModuleBodyDepth);</span>
    }

    private Operand startingSearchScope(IRScope s) {
<span class="fc" id="L1221">        int nearestModuleBodyDepth = s.getNearestModuleReferencingScopeDepth();</span>
<span class="fc bfc" id="L1222" title="All 2 branches covered.">        return nearestModuleBodyDepth == -1 ? s.getCurrentScopeVariable() : CurrentScope.ScopeFor(nearestModuleBodyDepth);</span>
    }

    public Operand buildConstDeclAssignment(ConstDeclNode constDeclNode, IRScope s, Operand val) {
<span class="fc" id="L1226">        Node constNode = constDeclNode.getConstNode();</span>

<span class="fc bfc" id="L1228" title="All 2 branches covered.">        if (constNode == null) {</span>
<span class="fc" id="L1229">            addInstr(s, new PutConstInstr(findContainerModule(s), constDeclNode.getName(), val));</span>
<span class="fc bfc" id="L1230" title="All 2 branches covered.">        } else if (constNode.getNodeType() == NodeType.COLON2NODE) {</span>
<span class="fc" id="L1231">            Operand module = build(((Colon2Node) constNode).getLeftNode(), s);</span>
<span class="fc" id="L1232">            addInstr(s, new PutConstInstr(module, constDeclNode.getName(), val));</span>
<span class="fc" id="L1233">        } else { // colon3, assign in Object</span>
<span class="fc" id="L1234">            addInstr(s, new PutConstInstr(new ObjectClass(), constDeclNode.getName(), val));</span>
        }

<span class="fc" id="L1237">        return val;</span>
    }

    private void genInheritanceSearchInstrs(IRScope s, Operand startingModule, Variable constVal, Label foundLabel, boolean noPrivateConstants, String name) {
<span class="fc" id="L1241">        addInstr(s, new InheritanceSearchConstInstr(constVal, startingModule, name, noPrivateConstants));</span>
<span class="fc" id="L1242">        addInstr(s, BNEInstr.create(constVal, UndefinedValue.UNDEFINED, foundLabel));</span>
<span class="fc" id="L1243">        addInstr(s, new ConstMissingInstr(constVal, startingModule, name));</span>
<span class="fc" id="L1244">        addInstr(s, new LabelInstr(foundLabel));</span>
<span class="fc" id="L1245">    }</span>

    private Operand searchConstInInheritanceHierarchy(IRScope s, Operand startingModule, String name) {
<span class="fc" id="L1248">        Variable constVal = s.createTemporaryVariable();</span>
<span class="fc" id="L1249">        genInheritanceSearchInstrs(s, startingModule, constVal, s.getNewLabel(), true, name);</span>
<span class="fc" id="L1250">        return constVal;</span>
    }

    private Operand searchConst(IRScope s, String name) {
<span class="fc" id="L1254">        final boolean noPrivateConstants = false;</span>
<span class="fc" id="L1255">        Variable v = s.createTemporaryVariable();</span>
/**
 * SSS FIXME: Went back to a single instruction for now.
 *
 * Do not split search into lexical-search, inheritance-search, and const-missing instrs.
 *
        Label foundLabel = s.getNewLabel();
        addInstr(s, new LexicalSearchConstInstr(v, startingSearchScope(s), name));
        addInstr(s, BNEInstr.create(v, UndefinedValue.UNDEFINED, foundLabel));
        genInheritanceSearchInstrs(s, findContainerModule(startingScope), v, foundLabel, noPrivateConstants, name);
**/
<span class="fc" id="L1266">        addInstr(s, new SearchConstInstr(v, name, startingSearchScope(s), noPrivateConstants));</span>
<span class="fc" id="L1267">        return v;</span>
    }

    public Operand buildColon2(final Colon2Node iVisited, IRScope s) {
<span class="fc" id="L1271">        Node leftNode = iVisited.getLeftNode();</span>
<span class="fc" id="L1272">        final String name = iVisited.getName();</span>

        // Colon2ImplicitNode
<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">        if (leftNode == null) return searchConst(s, name);</span>

        // Colon2ConstNode
        // 1. Load the module first (lhs of node)
        // 2. Then load the constant from the module
<span class="fc" id="L1280">        Operand module = build(leftNode, s);</span>
<span class="fc" id="L1281">        return searchConstInInheritanceHierarchy(s, module, name);</span>
    }

    public Operand buildColon3(Colon3Node node, IRScope s) {
<span class="fc" id="L1285">        return searchConstInInheritanceHierarchy(s, new ObjectClass(), node.getName());</span>
    }

    public Operand buildComplex(ComplexNode node, IRScope s) {
<span class="fc" id="L1289">        return new Complex((ImmutableLiteral) build(node.getNumber(), s));</span>
    }

    interface CodeBlock {
        public Operand run();
    }

    private Operand protectCodeWithRescue(IRScope s, CodeBlock protectedCode, CodeBlock rescueBlock) {
        // This effectively mimics a begin-rescue-end code block
        // Except this catches all exceptions raised by the protected code

<span class="fc" id="L1300">        Variable rv = s.createTemporaryVariable();</span>
<span class="fc" id="L1301">        Label rBeginLabel = s.getNewLabel();</span>
<span class="fc" id="L1302">        Label rEndLabel   = s.getNewLabel();</span>
<span class="fc" id="L1303">        Label rescueLabel = s.getNewLabel();</span>

        // Protected region code
<span class="fc" id="L1306">        addInstr(s, new LabelInstr(rBeginLabel));</span>
<span class="fc" id="L1307">        addInstr(s, new ExceptionRegionStartMarkerInstr(rescueLabel));</span>
<span class="fc" id="L1308">        Object v1 = protectedCode.run(); // YIELD: Run the protected code block</span>
<span class="fc" id="L1309">        addInstr(s, new CopyInstr(rv, (Operand)v1));</span>
<span class="fc" id="L1310">        addInstr(s, new JumpInstr(rEndLabel));</span>
<span class="fc" id="L1311">        addInstr(s, new ExceptionRegionEndMarkerInstr());</span>

        // SSS FIXME: Create an 'Exception' operand type to eliminate the constant lookup below
        // We could preload a set of constant objects that are preloaded at boot time and use them
        // directly in IR when we know there is no lookup involved.
        //
        // new Operand type: CachedClass(String name)?
        //
        // Some candidates: Exception, StandardError, Fixnum, Object, Boolean, etc.
        // So, when they are referenced, they are fetched directly from the runtime object
        // which probably already has cached references to these constants.
        //
        // But, unsure if this caching is safe ... so, just an idea here for now.

        // Rescue code
<span class="fc" id="L1326">        Label caughtLabel = s.getNewLabel();</span>
<span class="fc" id="L1327">        Variable exc = s.createTemporaryVariable();</span>
<span class="fc" id="L1328">        Variable excType = s.createTemporaryVariable();</span>

        // Receive 'exc' and verify that 'exc' is of ruby-type 'Exception'
<span class="fc" id="L1331">        addInstr(s, new LabelInstr(rescueLabel));</span>
<span class="fc" id="L1332">        addInstr(s, new ReceiveRubyExceptionInstr(exc));</span>
<span class="fc" id="L1333">        addInstr(s, new InheritanceSearchConstInstr(excType, new ObjectClass(), &quot;Exception&quot;, false));</span>
<span class="fc" id="L1334">        outputExceptionCheck(s, excType, exc, caughtLabel);</span>

        // Fall-through when the exc !== Exception; rethrow 'exc'
<span class="fc" id="L1337">        addInstr(s, new ThrowExceptionInstr(exc));</span>

        // exc === Exception; Run the rescue block
<span class="fc" id="L1340">        addInstr(s, new LabelInstr(caughtLabel));</span>
<span class="fc" id="L1341">        Object v2 = rescueBlock.run(); // YIELD: Run the protected code block</span>
<span class="pc bpc" id="L1342" title="1 of 2 branches missed.">        if (v2 != null) addInstr(s, new CopyInstr(rv, manager.getNil()));</span>

        // End
<span class="fc" id="L1345">        addInstr(s, new LabelInstr(rEndLabel));</span>

<span class="fc" id="L1347">        return rv;</span>
    }

    public Operand buildGetDefinition(Node node, final IRScope scope) {
<span class="fc" id="L1351">        node = skipOverNewlines(scope, node);</span>

        // FIXME: Do we still have MASGN and MASGN19?
<span class="pc bpc" id="L1354" title="2 of 25 branches missed.">        switch (node.getNodeType()) {</span>
        case CLASSVARASGNNODE: case CLASSVARDECLNODE: case CONSTDECLNODE:
        case DASGNNODE: case GLOBALASGNNODE: case LOCALASGNNODE: case MULTIPLEASGNNODE:
        case MULTIPLEASGN19NODE: case OPASGNNODE: case OPASGNANDNODE: case OPASGNORNODE:
        case OPELEMENTASGNNODE: case INSTASGNNODE:
<span class="fc" id="L1359">            return new ConstantStringLiteral(&quot;assignment&quot;);</span>
        case ORNODE: case ANDNODE:
<span class="fc" id="L1361">            return new ConstantStringLiteral(&quot;expression&quot;);</span>
        case FALSENODE:
<span class="fc" id="L1363">            return new ConstantStringLiteral(&quot;false&quot;);</span>
        case LOCALVARNODE: case DVARNODE:
<span class="fc" id="L1365">            return new ConstantStringLiteral(&quot;local-variable&quot;);</span>
        case MATCH2NODE: case MATCH3NODE:
<span class="nc" id="L1367">            return new ConstantStringLiteral(&quot;method&quot;);</span>
        case NILNODE:
<span class="fc" id="L1369">            return new ConstantStringLiteral(&quot;nil&quot;);</span>
        case SELFNODE:
<span class="fc" id="L1371">            return new ConstantStringLiteral(&quot;self&quot;);</span>
        case TRUENODE:
<span class="fc" id="L1373">            return new ConstantStringLiteral(&quot;true&quot;);</span>
        case DREGEXPNODE: case DSTRNODE: {
<span class="fc" id="L1375">            final Node dNode = node;</span>

            // protected code
<span class="fc" id="L1378">            CodeBlock protectedCode = new CodeBlock() {</span>
                public Operand run() {
<span class="fc" id="L1380">                    build(dNode, scope);</span>
                    // always an expression as long as we get through here without an exception!
<span class="fc" id="L1382">                    return new ConstantStringLiteral(&quot;expression&quot;);</span>
                }
            };
            // rescue block
<span class="fc" id="L1386">            CodeBlock rescueBlock = new CodeBlock() {</span>
<span class="fc" id="L1387">                public Operand run() { return manager.getNil(); } // Nothing to do if we got an exception</span>
            };

            // Try verifying definition, and if we get an JumpException exception, process it with the rescue block above
<span class="fc" id="L1391">            Operand v = protectCodeWithRescue(scope, protectedCode, rescueBlock);</span>
<span class="fc" id="L1392">            Label doneLabel = scope.getNewLabel();</span>
<span class="fc" id="L1393">            Variable tmpVar = getValueInTemporaryVariable(scope, v);</span>
<span class="fc" id="L1394">            addInstr(scope, BNEInstr.create(tmpVar, manager.getNil(), doneLabel));</span>
<span class="fc" id="L1395">            addInstr(scope, new CopyInstr(tmpVar, new ConstantStringLiteral(&quot;expression&quot;)));</span>
<span class="fc" id="L1396">            addInstr(scope, new LabelInstr(doneLabel));</span>

<span class="fc" id="L1398">            return tmpVar;</span>
        }
        case ARRAYNODE: { // If all elts of array are defined the array is as well
<span class="fc" id="L1401">            ArrayNode array = (ArrayNode) node;</span>
<span class="fc" id="L1402">            Label undefLabel = scope.getNewLabel();</span>
<span class="fc" id="L1403">            Label doneLabel = scope.getNewLabel();</span>

<span class="fc" id="L1405">            Variable tmpVar = scope.createTemporaryVariable();</span>
<span class="fc bfc" id="L1406" title="All 2 branches covered.">            for (Node elt: array.childNodes()) {</span>
<span class="fc" id="L1407">                Operand result = buildGetDefinition(elt, scope);</span>

<span class="fc" id="L1409">                addInstr(scope, BEQInstr.create(result, manager.getNil(), undefLabel));</span>
<span class="fc" id="L1410">            }</span>

<span class="fc" id="L1412">            addInstr(scope, new CopyInstr(tmpVar, new ConstantStringLiteral(&quot;expression&quot;)));</span>
<span class="fc" id="L1413">            addInstr(scope, new JumpInstr(doneLabel));</span>
<span class="fc" id="L1414">            addInstr(scope, new LabelInstr(undefLabel));</span>
<span class="fc" id="L1415">            addInstr(scope, new CopyInstr(tmpVar, manager.getNil()));</span>
<span class="fc" id="L1416">            addInstr(scope, new LabelInstr(doneLabel));</span>

<span class="fc" id="L1418">            return tmpVar;</span>
        }
        case BACKREFNODE:
<span class="fc" id="L1421">            return addResultInstr(scope, new RuntimeHelperCall(scope.createTemporaryVariable(), IS_DEFINED_BACKREF,</span>
                    Operand.EMPTY_ARRAY));
        case GLOBALVARNODE:
<span class="fc" id="L1424">            return addResultInstr(scope, new RuntimeHelperCall(scope.createTemporaryVariable(), IS_DEFINED_GLOBAL,</span>
<span class="fc" id="L1425">                    new Operand[] { new StringLiteral(((GlobalVarNode) node).getName()) }));</span>
        case NTHREFNODE: {
<span class="fc" id="L1427">            return addResultInstr(scope, new RuntimeHelperCall(scope.createTemporaryVariable(), IS_DEFINED_NTH_REF,</span>
<span class="fc" id="L1428">                    new Operand[] { new Fixnum(((NthRefNode) node).getMatchNumber()) }));</span>
        }
        case INSTVARNODE:
<span class="fc" id="L1431">            return addResultInstr(scope, new RuntimeHelperCall(scope.createTemporaryVariable(), IS_DEFINED_INSTANCE_VAR,</span>
<span class="fc" id="L1432">                    new Operand[] { scope.getSelf(), new StringLiteral(((InstVarNode) node).getName()) }));</span>
        case CLASSVARNODE:
<span class="fc" id="L1434">            return addResultInstr(scope, new RuntimeHelperCall(scope.createTemporaryVariable(), IS_DEFINED_CLASS_VAR,</span>
<span class="fc" id="L1435">                    new Operand[]{classVarDefinitionContainer(scope), new StringLiteral(((ClassVarNode) node).getName())}));</span>
        case SUPERNODE: {
<span class="fc" id="L1437">            Label undefLabel = scope.getNewLabel();</span>
<span class="fc" id="L1438">            Variable tmpVar  = addResultInstr(scope, new RuntimeHelperCall(scope.createTemporaryVariable(), IS_DEFINED_SUPER,</span>
<span class="fc" id="L1439">                    new Operand[] { scope.getSelf() }));</span>
<span class="fc" id="L1440">            addInstr(scope, BEQInstr.create(tmpVar, manager.getNil(), undefLabel));</span>
<span class="fc" id="L1441">            Operand superDefnVal = buildGetArgumentDefinition(((SuperNode) node).getArgsNode(), scope, &quot;super&quot;);</span>
<span class="fc" id="L1442">            return buildDefnCheckIfThenPaths(scope, undefLabel, superDefnVal);</span>
        }
        case VCALLNODE:
<span class="fc" id="L1445">            return addResultInstr(scope, new RuntimeHelperCall(scope.createTemporaryVariable(), IS_DEFINED_METHOD,</span>
<span class="fc" id="L1446">                    new Operand[] { scope.getSelf(), new StringLiteral(((VCallNode) node).getName()), Boolean.FALSE}));</span>
        case YIELDNODE:
<span class="fc" id="L1448">            return buildDefinitionCheck(scope, new BlockGivenInstr(scope.createTemporaryVariable(), getImplicitBlockArg(scope)), &quot;yield&quot;);</span>
        case ZSUPERNODE:
<span class="fc" id="L1450">            return addResultInstr(scope, new RuntimeHelperCall(scope.createTemporaryVariable(), IS_DEFINED_SUPER,</span>
<span class="fc" id="L1451">                    new Operand[] { scope.getSelf() } ));</span>
        case CONSTNODE: {
<span class="fc" id="L1453">            Label defLabel = scope.getNewLabel();</span>
<span class="fc" id="L1454">            Label doneLabel = scope.getNewLabel();</span>
<span class="fc" id="L1455">            Variable tmpVar  = scope.createTemporaryVariable();</span>
<span class="fc" id="L1456">            String constName = ((ConstNode) node).getName();</span>
<span class="fc" id="L1457">            addInstr(scope, new LexicalSearchConstInstr(tmpVar, startingSearchScope(scope), constName));</span>
<span class="fc" id="L1458">            addInstr(scope, BNEInstr.create(tmpVar, UndefinedValue.UNDEFINED, defLabel));</span>
<span class="fc" id="L1459">            addInstr(scope, new InheritanceSearchConstInstr(tmpVar, findContainerModule(scope), constName, false)); // SSS FIXME: should this be the current-module var or something else?</span>
<span class="fc" id="L1460">            addInstr(scope, BNEInstr.create(tmpVar, UndefinedValue.UNDEFINED, defLabel));</span>
<span class="fc" id="L1461">            addInstr(scope, new CopyInstr(tmpVar, manager.getNil()));</span>
<span class="fc" id="L1462">            addInstr(scope, new JumpInstr(doneLabel));</span>
<span class="fc" id="L1463">            addInstr(scope, new LabelInstr(defLabel));</span>
<span class="fc" id="L1464">            addInstr(scope, new CopyInstr(tmpVar, new ConstantStringLiteral(&quot;constant&quot;)));</span>
<span class="fc" id="L1465">            addInstr(scope, new LabelInstr(doneLabel));</span>
<span class="fc" id="L1466">            return tmpVar;</span>
        }
        case COLON3NODE: case COLON2NODE: {
            // SSS FIXME: Is there a reason to do this all with low-level IR?
            // Can't this all be folded into a Java method that would be part
            // of the runtime library, which then can be used by buildDefinitionCheck method above?
            // This runtime library would be used both by the interpreter &amp; the compiled code!

<span class="fc" id="L1474">            final Colon3Node colon = (Colon3Node) node;</span>
<span class="fc" id="L1475">            final String name = colon.getName();</span>
<span class="fc" id="L1476">            final Variable errInfo = scope.createTemporaryVariable();</span>

            // store previous exception for restoration if we rescue something
<span class="fc" id="L1479">            addInstr(scope, new GetErrorInfoInstr(errInfo));</span>

<span class="fc" id="L1481">            CodeBlock protectedCode = new CodeBlock() {</span>
                public Operand run() {
<span class="fc bfc" id="L1483" title="All 2 branches covered.">                    Operand v = colon instanceof Colon2Node ?</span>
<span class="fc" id="L1484">                            build(((Colon2Node)colon).getLeftNode(), scope) : new ObjectClass();</span>

<span class="fc" id="L1486">                    Variable tmpVar = scope.createTemporaryVariable();</span>
<span class="fc" id="L1487">                    addInstr(scope, new RuntimeHelperCall(tmpVar, IS_DEFINED_CONSTANT_OR_METHOD, new Operand[] {v, new ConstantStringLiteral(name)}));</span>
<span class="fc" id="L1488">                    return tmpVar;</span>
                }
            };

            // rescue block
<span class="fc" id="L1493">            CodeBlock rescueBlock = new CodeBlock() {</span>
                 public Operand run() {
                 // Nothing to do -- ignore the exception, and restore stashed error info!
<span class="fc" id="L1496">                 addInstr(scope, new RestoreErrorInfoInstr(errInfo));</span>
<span class="fc" id="L1497">                 return manager.getNil();</span>
                 }
            };

                // Try verifying definition, and if we get an JumpException exception, process it with the rescue block above
<span class="fc" id="L1502">            return protectCodeWithRescue(scope, protectedCode, rescueBlock);</span>
        }
        case FCALLNODE: {
            /* ------------------------------------------------------------------
             * Generate IR for:
             *    r = self/receiver
             *    mc = r.metaclass
             *    return mc.methodBound(meth) ? buildGetArgumentDefn(..) : false
             * ----------------------------------------------------------------- */
<span class="fc" id="L1511">            Label undefLabel = scope.getNewLabel();</span>
<span class="fc" id="L1512">            Variable tmpVar = addResultInstr(scope, new RuntimeHelperCall(scope.createTemporaryVariable(), IS_DEFINED_METHOD,</span>
<span class="fc" id="L1513">                    new Operand[]{scope.getSelf(), new StringLiteral(((FCallNode) node).getName()), Boolean.FALSE}));</span>
<span class="fc" id="L1514">            addInstr(scope, BEQInstr.create(tmpVar, manager.getNil(), undefLabel));</span>
<span class="fc" id="L1515">            Operand argsCheckDefn = buildGetArgumentDefinition(((FCallNode) node).getArgsNode(), scope, &quot;method&quot;);</span>
<span class="fc" id="L1516">            return buildDefnCheckIfThenPaths(scope, undefLabel, argsCheckDefn);</span>
        }
        case CALLNODE: {
<span class="fc" id="L1519">            final Label undefLabel = scope.getNewLabel();</span>
<span class="fc" id="L1520">            final CallNode callNode = (CallNode) node;</span>
<span class="fc" id="L1521">            Operand  receiverDefn = buildGetDefinition(callNode.getReceiverNode(), scope);</span>
<span class="fc" id="L1522">            addInstr(scope, BEQInstr.create(receiverDefn, manager.getNil(), undefLabel));</span>

            // protected main block
<span class="fc" id="L1525">            CodeBlock protectedCode = new CodeBlock() {</span>
                public Operand run() {
<span class="fc" id="L1527">                    Variable tmpVar = scope.createTemporaryVariable();</span>
<span class="fc" id="L1528">                    addInstr(scope, new RuntimeHelperCall(tmpVar, IS_DEFINED_CALL,</span>
<span class="fc" id="L1529">                            new Operand[]{build(callNode.getReceiverNode(), scope), new StringLiteral(callNode.getName())}));</span>
<span class="fc" id="L1530">                    return buildDefnCheckIfThenPaths(scope, undefLabel, tmpVar);</span>
                }
            };

            // rescue block
<span class="fc" id="L1535">            CodeBlock rescueBlock = new CodeBlock() {</span>
<span class="fc" id="L1536">                public Operand run() { return manager.getNil(); } // Nothing to do if we got an exception</span>
            };

            // Try verifying definition, and if we get an exception, throw it out, and return nil
<span class="fc" id="L1540">            return protectCodeWithRescue(scope, protectedCode, rescueBlock);</span>
        }
        case ATTRASSIGNNODE: {
<span class="nc" id="L1543">            final Label  undefLabel = scope.getNewLabel();</span>
<span class="nc" id="L1544">            final AttrAssignNode attrAssign = (AttrAssignNode) node;</span>
<span class="nc" id="L1545">            Operand receiverDefn = buildGetDefinition(attrAssign.getReceiverNode(), scope);</span>
<span class="nc" id="L1546">            addInstr(scope, BEQInstr.create(receiverDefn, manager.getNil(), undefLabel));</span>

            // protected main block
<span class="nc" id="L1549">            CodeBlock protectedCode = new CodeBlock() {</span>
                public Operand run() {
                    /* --------------------------------------------------------------------------
                     * This basically combines checks from CALLNODE and FCALLNODE
                     *
                     * Generate IR for this sequence
                     *
                     *    1. r  = receiver
                     *    2. mc = r.metaClass
                     *    3. v  = mc.getVisibility(methodName)
                     *    4. f  = !v || v.isPrivate? || (v.isProtected? &amp;&amp; receiver/self?.kindof(mc.getRealClass))
                     *    5. return !f &amp;&amp; mc.methodBound(attrmethod) ? buildGetArgumentDefn(..) : false
                     *
                     * Hide the complexity of instrs 2-4 into a verifyMethodIsPublicAccessible call
                     * which can executely entirely in Java-land.  No reason to expose the guts in IR.
                     * ------------------------------------------------------------------------------ */
<span class="nc" id="L1565">                    Variable tmpVar     = scope.createTemporaryVariable();</span>
<span class="nc" id="L1566">                    Operand  receiver   = build(attrAssign.getReceiverNode(), scope);</span>
<span class="nc" id="L1567">                    addInstr(scope, new RuntimeHelperCall(tmpVar, IS_DEFINED_METHOD,</span>
<span class="nc" id="L1568">                            new Operand[] { receiver, new StringLiteral(attrAssign.getName()), Boolean.TRUE }));</span>
<span class="nc" id="L1569">                    addInstr(scope, BEQInstr.create(tmpVar, manager.getNil(), undefLabel));</span>
<span class="nc" id="L1570">                    Operand argsCheckDefn = buildGetArgumentDefinition(attrAssign.getArgsNode(), scope, &quot;assignment&quot;);</span>
<span class="nc" id="L1571">                    return buildDefnCheckIfThenPaths(scope, undefLabel, argsCheckDefn);</span>
                }
            };

            // rescue block
<span class="nc" id="L1576">            CodeBlock rescueBlock = new CodeBlock() {</span>
<span class="nc" id="L1577">                public Operand run() { return manager.getNil(); } // Nothing to do if we got an exception</span>
            };

            // Try verifying definition, and if we get an JumpException exception, process it with the rescue block above
<span class="nc" id="L1581">            return protectCodeWithRescue(scope, protectedCode, rescueBlock);</span>
        }
        default:
<span class="fc" id="L1584">            return new ConstantStringLiteral(&quot;expression&quot;);</span>
        }
    }

    protected Variable buildDefnCheckIfThenPaths(IRScope s, Label undefLabel, Operand defVal) {
<span class="fc" id="L1589">        Label defLabel = s.getNewLabel();</span>
<span class="fc" id="L1590">        Variable tmpVar = getValueInTemporaryVariable(s, defVal);</span>
<span class="fc" id="L1591">        addInstr(s, new JumpInstr(defLabel));</span>
<span class="fc" id="L1592">        addInstr(s, new LabelInstr(undefLabel));</span>
<span class="fc" id="L1593">        addInstr(s, new CopyInstr(tmpVar, manager.getNil()));</span>
<span class="fc" id="L1594">        addInstr(s, new LabelInstr(defLabel));</span>
<span class="fc" id="L1595">        return tmpVar;</span>
    }

    protected Variable buildDefinitionCheck(IRScope s, ResultInstr definedInstr, String definedReturnValue) {
<span class="fc" id="L1599">        Label undefLabel = s.getNewLabel();</span>
<span class="fc" id="L1600">        addInstr(s, (Instr) definedInstr);</span>
<span class="fc" id="L1601">        addInstr(s, BEQInstr.create(definedInstr.getResult(), manager.getFalse(), undefLabel));</span>
<span class="fc" id="L1602">        return buildDefnCheckIfThenPaths(s, undefLabel, new ConstantStringLiteral(definedReturnValue));</span>
    }

    public Operand buildGetArgumentDefinition(final Node node, IRScope s, String type) {
<span class="pc bpc" id="L1606" title="1 of 2 branches missed.">        if (node == null) return new StringLiteral(type);</span>

<span class="nc" id="L1608">        Operand rv = new ConstantStringLiteral(type);</span>
<span class="nc" id="L1609">        boolean failPathReqd = false;</span>
<span class="nc" id="L1610">        Label failLabel = s.getNewLabel();</span>
<span class="nc bnc" id="L1611" title="All 2 branches missed.">        if (node instanceof ArrayNode) {</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">            for (int i = 0; i &lt; ((ArrayNode) node).size(); i++) {</span>
<span class="nc" id="L1613">                Node iterNode = ((ArrayNode) node).get(i);</span>
<span class="nc" id="L1614">                Operand def = buildGetDefinition(iterNode, s);</span>
<span class="nc bnc" id="L1615" title="All 2 branches missed.">                if (def == manager.getNil()) { // Optimization!</span>
<span class="nc" id="L1616">                    rv = manager.getNil();</span>
<span class="nc" id="L1617">                    break;</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">                } else if (!def.hasKnownValue()) { // Optimization!</span>
<span class="nc" id="L1619">                    failPathReqd = true;</span>
<span class="nc" id="L1620">                    addInstr(s, BEQInstr.create(def, manager.getNil(), failLabel));</span>
                }
            }
        } else {
<span class="nc" id="L1624">            Operand def = buildGetDefinition(node, s);</span>
<span class="nc bnc" id="L1625" title="All 2 branches missed.">            if (def == manager.getNil()) { // Optimization!</span>
<span class="nc" id="L1626">                rv = manager.getNil();</span>
<span class="nc bnc" id="L1627" title="All 2 branches missed.">            } else if (!def.hasKnownValue()) { // Optimization!</span>
<span class="nc" id="L1628">                failPathReqd = true;</span>
<span class="nc" id="L1629">                addInstr(s, BEQInstr.create(def, manager.getNil(), failLabel));</span>
            }
        }

        // Optimization!
<span class="nc bnc" id="L1634" title="All 2 branches missed.">        return failPathReqd ? buildDefnCheckIfThenPaths(s, failLabel, rv) : rv;</span>

    }

    public Operand buildDAsgn(final DAsgnNode dasgnNode, IRScope s) {
        // SSS: Looks like we receive the arg in buildBlockArgsAssignment via the IterNode
        // We won't get here for argument receives!  So, buildDasgn is called for
        // assignments to block variables within a block.  As far as the IR is concerned,
        // this is just a simple copy
<span class="fc" id="L1643">        int depth = dasgnNode.getDepth();</span>
<span class="fc" id="L1644">        Variable arg = s.getLocalVariable(dasgnNode.getName(), depth);</span>
<span class="fc" id="L1645">        Operand  value = build(dasgnNode.getValueNode(), s);</span>
<span class="fc" id="L1646">        addInstr(s, new CopyInstr(arg, value));</span>
<span class="fc" id="L1647">        return value;</span>

        // IMPORTANT: The return value of this method is value, not arg!
        //
        // Consider this Ruby code: foo((a = 1), (a = 2))
        //
        // If we return 'value' this will get translated to:
        //    a = 1
        //    a = 2
        //    call(&quot;foo&quot;, [1,2]) &lt;---- CORRECT
        //
        // If we return 'arg' this will get translated to:
        //    a = 1
        //    a = 2
        //    call(&quot;foo&quot;, [a,a]) &lt;---- BUGGY
        //
        // This technique only works if 'value' is an immutable value (ex: fixnum) or a variable
        // So, for Ruby code like this:
        //     def foo(x); x &lt;&lt; 5; end;
        //     foo(a=[1,2]);
        //     p a
        // we are guaranteed that the value passed into foo and 'a' point to the same object
        // because of the use of copyAndReturnValue method for literal objects.
    }

    // Called by defineMethod but called on a new builder so things like ensure block info recording
    // do not get confused.
    protected IRMethod defineMethodInner(MethodDefNode defNode, IRMethod method, IRScope parent) {
<span class="pc bpc" id="L1675" title="1 of 2 branches missed.">        if (RubyInstanceConfig.FULL_TRACE_ENABLED) {</span>
<span class="nc" id="L1676">            addInstr(method, new TraceInstr(RubyEvent.CALL, method.getName(), method.getFileName(), method.getLineNumber()));</span>
        }

<span class="fc" id="L1679">        addInstr(method, new ReceiveSelfInstr(method.getSelf()));</span>


        // These instructions need to be toward the top of the method because they may both be needed for
        // processing optional arguments as in def foo(a = Object).
        // Set %current_scope = &lt;current-scope&gt;
        // Set %current_module = isInstanceMethod ? %self.metaclass : %self
<span class="fc" id="L1686">        int nearestScopeDepth = parent.getNearestModuleReferencingScopeDepth();</span>
<span class="fc bfc" id="L1687" title="All 2 branches covered.">        addInstr(method, new CopyInstr(method.getCurrentScopeVariable(), CurrentScope.ScopeFor(nearestScopeDepth == -1 ? 1 : nearestScopeDepth)));</span>
<span class="fc bfc" id="L1688" title="All 2 branches covered.">        addInstr(method, new CopyInstr(method.getCurrentModuleVariable(), ScopeModule.ModuleFor(nearestScopeDepth == -1 ? 1 : nearestScopeDepth)));</span>

        // Build IR for arguments (including the block arg)
<span class="fc" id="L1691">        receiveMethodArgs(defNode.getArgsNode(), method);</span>

        // Thread poll on entry to method
<span class="fc" id="L1694">        addInstr(method, new ThreadPollInstr());</span>

        // Build IR for body
<span class="fc" id="L1697">        Operand rv = newIRBuilder(manager).build(defNode.getBodyNode(), method);</span>

<span class="pc bpc" id="L1699" title="1 of 2 branches missed.">        if (RubyInstanceConfig.FULL_TRACE_ENABLED) {</span>
<span class="nc" id="L1700">            addInstr(method, new TraceInstr(RubyEvent.RETURN, method.getName(), method.getFileName(), -1));</span>
        }

<span class="pc bpc" id="L1703" title="1 of 2 branches missed.">        if (rv != null) addInstr(method, new ReturnInstr(rv));</span>

        // If the method can receive non-local returns
<span class="fc bfc" id="L1706" title="All 2 branches covered.">        if (method.canReceiveNonlocalReturns()) handleNonlocalReturnInMethod(method);</span>

<span class="fc" id="L1708">        return method;</span>
    }

    private IRMethod defineNewMethod(MethodDefNode defNode, IRScope parent, boolean isInstanceMethod) {
<span class="fc" id="L1712">        return new IRMethod(manager, parent, defNode, defNode.getName(), isInstanceMethod, defNode.getPosition().getLine(), defNode.getScope());</span>

        //return newIRBuilder(manager).defineMethodInner(defNode, method, parent);
    }

    public Operand buildDefn(MethodDefNode node, IRScope s) { // Instance method
<span class="fc" id="L1718">        IRMethod method = defineNewMethod(node, s, true);</span>
<span class="fc" id="L1719">        addInstr(s, new DefineInstanceMethodInstr(method));</span>
        // FIXME: Method name should save encoding
<span class="fc" id="L1721">        return new Symbol(method.getName(), ASCIIEncoding.INSTANCE);</span>
    }

    public Operand buildDefs(DefsNode node, IRScope s) { // Class method
<span class="fc" id="L1725">        Operand container =  build(node.getReceiverNode(), s);</span>
<span class="fc" id="L1726">        IRMethod method = defineNewMethod(node, s, false);</span>
<span class="fc" id="L1727">        addInstr(s, new DefineClassMethodInstr(container, method));</span>
        // FIXME: Method name should save encoding
<span class="fc" id="L1729">        return new Symbol(method.getName(), ASCIIEncoding.INSTANCE);</span>
    }

    protected LocalVariable getArgVariable(IRScope s, String name, int depth) {
        // For non-loops, this name will override any name that exists in outer scopes
<span class="pc bpc" id="L1734" title="1 of 2 branches missed.">        return s instanceof IRFor ? s.getLocalVariable(name, depth) : s.getNewLocalVariable(name, 0);</span>
    }

    private void addArgReceiveInstr(IRScope s, Variable v, int argIndex, boolean post, int numPreReqd, int numPostRead) {
<span class="fc bfc" id="L1738" title="All 2 branches covered.">        if (post) addInstr(s, new ReceivePostReqdArgInstr(v, argIndex, numPreReqd, numPostRead));</span>
<span class="fc" id="L1739">        else addInstr(s, new ReceivePreReqdArgInstr(v, argIndex));</span>
<span class="fc" id="L1740">    }</span>

    public void receiveRequiredArg(Node node, IRScope s, int argIndex, boolean post, int numPreReqd, int numPostRead) {
<span class="pc bpc" id="L1743" title="1 of 3 branches missed.">        switch (node.getNodeType()) {</span>
            case ARGUMENTNODE: {
<span class="fc" id="L1745">                ArgumentNode a = (ArgumentNode)node;</span>
<span class="fc" id="L1746">                String argName = a.getName();</span>
<span class="fc bfc" id="L1747" title="All 2 branches covered.">                if (s instanceof IRMethod) ((IRMethod)s).addArgDesc(IRMethodArgs.ArgType.req, argName);</span>
                // Ignore duplicate &quot;_&quot; args in blocks
                // (duplicate _ args are named &quot;_$0&quot;)
<span class="fc bfc" id="L1750" title="All 2 branches covered.">                if (!argName.equals(&quot;_$0&quot;)) {</span>
<span class="fc" id="L1751">                    addArgReceiveInstr(s, s.getNewLocalVariable(argName, 0), argIndex, post, numPreReqd, numPostRead);</span>
                }
                break;
            }
            case MULTIPLEASGN19NODE: {
<span class="fc" id="L1756">                MultipleAsgn19Node childNode = (MultipleAsgn19Node) node;</span>
<span class="fc" id="L1757">                Variable v = s.createTemporaryVariable();</span>
<span class="fc" id="L1758">                addArgReceiveInstr(s, v, argIndex, post, numPreReqd, numPostRead);</span>
<span class="fc bfc" id="L1759" title="All 2 branches covered.">                if (s instanceof IRMethod) ((IRMethod)s).addArgDesc(IRMethodArgs.ArgType.req, &quot;&quot;);</span>
<span class="fc" id="L1760">                Variable tmp = s.createTemporaryVariable();</span>
<span class="fc" id="L1761">                addInstr(s, new ToAryInstr(tmp, v));</span>
<span class="fc" id="L1762">                buildMultipleAsgn19Assignment(childNode, s, tmp, null);</span>
<span class="fc" id="L1763">                break;</span>
            }
<span class="nc" id="L1765">            default: throw new NotCompilableException(&quot;Can't build assignment node: &quot; + node);</span>
        }
<span class="fc" id="L1767">    }</span>

    private void receiveClosureArg(BlockArgNode blockVarNode, IRScope s) {
<span class="fc" id="L1770">        Variable blockVar = null;</span>
<span class="fc bfc" id="L1771" title="All 2 branches covered.">        if (blockVarNode != null) {</span>
<span class="fc" id="L1772">            String blockArgName = blockVarNode.getName();</span>
<span class="fc" id="L1773">            blockVar = s.getNewLocalVariable(blockArgName, 0);</span>
<span class="fc bfc" id="L1774" title="All 2 branches covered.">            if (s instanceof IRMethod) ((IRMethod)s).addArgDesc(IRMethodArgs.ArgType.block, blockArgName);</span>
<span class="fc" id="L1775">            addInstr(s, new ReceiveClosureInstr(blockVar));</span>
        }

        // In addition, store the block argument in an implicit block variable
<span class="fc bfc" id="L1779" title="All 2 branches covered.">        if (s instanceof IRMethod) {</span>
<span class="fc" id="L1780">            Variable implicitBlockArg = (Variable)getImplicitBlockArg(s);</span>
<span class="fc bfc" id="L1781" title="All 2 branches covered.">            if (blockVar == null) addInstr(s, new ReceiveClosureInstr(implicitBlockArg));</span>
<span class="fc" id="L1782">            else addInstr(s, new CopyInstr(implicitBlockArg, blockVar));</span>
        }
<span class="fc" id="L1784">    }</span>

    protected void receiveNonBlockArgs(final ArgsNode argsNode, IRScope s) {
<span class="fc" id="L1787">        final int numPreReqd = argsNode.getPreCount();</span>
<span class="fc" id="L1788">        final int numPostReqd = argsNode.getPostCount();</span>
<span class="fc" id="L1789">        final int required = argsNode.getRequiredArgsCount(); // numPreReqd + numPostReqd</span>
<span class="fc" id="L1790">        int opt = argsNode.getOptionalArgsCount();</span>
<span class="fc" id="L1791">        int rest = argsNode.getRestArg();</span>

<span class="fc" id="L1793">        s.getStaticScope().setArities(required, opt, rest);</span>
<span class="fc" id="L1794">        KeywordRestArgNode keyRest = argsNode.getKeyRest();</span>

        // For closures, we don't need the check arity call
<span class="fc bfc" id="L1797" title="All 2 branches covered.">        if (s instanceof IRMethod) {</span>
            // Expensive to do this explicitly?  But, two advantages:
            // (a) on inlining, we'll be able to get rid of these checks in almost every case.
            // (b) compiler to bytecode will anyway generate this and this is explicit.
            // For now, we are going explicit instruction route.
            // But later, perhaps can make this implicit in the method setup preamble?

<span class="fc bfc" id="L1804" title="All 2 branches covered.">            addInstr(s, new CheckArityInstr(required, opt, rest, argsNode.hasKwargs(),</span>
<span class="fc" id="L1805">                    keyRest == null ? -1 : keyRest.getIndex()));</span>
<span class="pc bpc" id="L1806" title="1 of 4 branches missed.">        } else if (s instanceof IRClosure &amp;&amp; argsNode.hasKwargs()) {</span>
            // FIXME: This is added to check for kwargs correctness but bypass regular correctness.
            // Any other arity checking currently happens within Java code somewhere (RubyProc.call?)
<span class="fc bfc" id="L1809" title="All 2 branches covered.">            addInstr(s, new CheckArityInstr(required, opt, rest, argsNode.hasKwargs(),</span>
<span class="fc" id="L1810">                    keyRest == null ? -1 : keyRest.getIndex()));</span>
        }

        // Other args begin at index 0
<span class="fc" id="L1814">        int argIndex = 0;</span>

        // Pre(-opt and rest) required args
<span class="fc" id="L1817">        ListNode preArgs = argsNode.getPre();</span>
<span class="fc bfc" id="L1818" title="All 2 branches covered.">        for (int i = 0; i &lt; numPreReqd; i++, argIndex++) {</span>
<span class="fc" id="L1819">            receiveRequiredArg(preArgs.get(i), s, argIndex, false, -1, -1);</span>
        }

        // Fixup opt/rest
<span class="fc bfc" id="L1823" title="All 2 branches covered.">        opt = opt &gt; 0 ? opt : 0;</span>
<span class="fc bfc" id="L1824" title="All 2 branches covered.">        rest = rest &gt; -1 ? 1 : 0;</span>

        // Now for opt args
<span class="fc bfc" id="L1827" title="All 2 branches covered.">        if (opt &gt; 0) {</span>
<span class="fc" id="L1828">            ListNode optArgs = argsNode.getOptArgs();</span>
<span class="fc bfc" id="L1829" title="All 2 branches covered.">            for (int j = 0; j &lt; opt; j++, argIndex++) {</span>
                // Jump to 'l' if this arg is not null.  If null, fall through and build the default value!
<span class="fc" id="L1831">                Label l = s.getNewLabel();</span>
<span class="fc" id="L1832">                OptArgNode n = (OptArgNode)optArgs.get(j);</span>
<span class="fc" id="L1833">                String argName = n.getName();</span>
<span class="fc" id="L1834">                Variable av = s.getNewLocalVariable(argName, 0);</span>
<span class="fc bfc" id="L1835" title="All 2 branches covered.">                if (s instanceof IRMethod) ((IRMethod)s).addArgDesc(IRMethodArgs.ArgType.opt, argName);</span>
                // You need at least required+j+1 incoming args for this opt arg to get an arg at all
<span class="fc" id="L1837">                addInstr(s, new ReceiveOptArgInstr(av, required, numPreReqd, j));</span>
<span class="fc" id="L1838">                addInstr(s, BNEInstr.create(av, UndefinedValue.UNDEFINED, l)); // if 'av' is not undefined, go to default</span>
<span class="fc" id="L1839">                build(n.getValue(), s);</span>
<span class="fc" id="L1840">                addInstr(s, new LabelInstr(l));</span>
            }
        }

        // Rest arg
<span class="fc bfc" id="L1845" title="All 2 branches covered.">        if (rest &gt; 0) {</span>
            // Consider: def foo(*); .. ; end
            // For this code, there is no argument name available from the ruby code.
            // So, we generate an implicit arg name
<span class="fc" id="L1849">            String argName = argsNode.getRestArgNode().getName();</span>
<span class="pc bpc" id="L1850" title="1 of 4 branches missed.">            if (s instanceof IRMethod) ((IRMethod)s).addArgDesc(IRMethodArgs.ArgType.rest, argName == null ? &quot;&quot; : argName);</span>
<span class="fc bfc" id="L1851" title="All 4 branches covered.">            argName = (argName == null || argName.equals(&quot;&quot;)) ? &quot;*&quot; : argName;</span>

            // You need at least required+opt+1 incoming args for the rest arg to get any args at all
            // If it is going to get something, then it should ignore required+opt args from the beginning
            // because they have been accounted for already.
<span class="fc" id="L1856">            addInstr(s, new ReceiveRestArgInstr(s.getNewLocalVariable(argName, 0), required + opt, argIndex));</span>
        }

        // Post(-opt and rest) required args
<span class="fc" id="L1860">        ListNode postArgs = argsNode.getPost();</span>
<span class="fc bfc" id="L1861" title="All 2 branches covered.">        for (int i = 0; i &lt; numPostReqd; i++) {</span>
<span class="fc" id="L1862">            receiveRequiredArg(postArgs.get(i), s, i, true, numPreReqd, numPostReqd);</span>
        }
<span class="fc" id="L1864">    }</span>

    protected void receiveBlockArg(final ArgsNode argsNode, IRScope s) {
        // For methods, we always receive it (implicitly, if the block arg is not explicit)
        // For closures, only if it is explicitly present
<span class="fc" id="L1869">        BlockArgNode blockArg = argsNode.getBlock();</span>
<span class="fc bfc" id="L1870" title="All 4 branches covered.">        if (s instanceof IRMethod || blockArg != null) receiveClosureArg(blockArg, s);</span>
<span class="fc" id="L1871">    }</span>

    public void receiveArgs(final ArgsNode argsNode, IRScope s) {
        // 1.9 pre, opt, rest, post args
<span class="fc" id="L1875">        receiveNonBlockArgs(argsNode, s);</span>

        // 2.0 keyword args
<span class="fc" id="L1878">        ListNode keywords = argsNode.getKeywords();</span>
<span class="fc" id="L1879">        int required = argsNode.getRequiredArgsCount();</span>
<span class="fc bfc" id="L1880" title="All 2 branches covered.">        if (keywords != null) {</span>
<span class="fc bfc" id="L1881" title="All 2 branches covered.">            for (Node knode : keywords.childNodes()) {</span>
<span class="fc" id="L1882">                KeywordArgNode kwarg = (KeywordArgNode)knode;</span>
<span class="fc" id="L1883">                AssignableNode kasgn = kwarg.getAssignable();</span>
<span class="fc" id="L1884">                String argName = ((INameNode) kasgn).getName();</span>
<span class="fc" id="L1885">                Variable av = s.getNewLocalVariable(argName, 0);</span>
<span class="fc" id="L1886">                Label l = s.getNewLabel();</span>
<span class="fc bfc" id="L1887" title="All 2 branches covered.">                if (s instanceof IRMethod) ((IRMethod)s).addArgDesc(IRMethodArgs.ArgType.key, argName);</span>
<span class="fc" id="L1888">                addInstr(s, new ReceiveKeywordArgInstr(av, argName, required));</span>
<span class="fc" id="L1889">                addInstr(s, BNEInstr.create(av, UndefinedValue.UNDEFINED, l)); // if 'av' is not undefined, we are done</span>

                // Required kwargs have no value and check_arity will throw if they are not provided.
<span class="fc bfc" id="L1892" title="All 2 branches covered.">                if (kasgn.getValueNode().getNodeType() != NodeType.REQUIRED_KEYWORD_ARGUMENT_VALUE) {</span>
<span class="fc" id="L1893">                    build(kasgn, s);</span>
                } else {
<span class="fc" id="L1895">                    addInstr(s, new RaiseRequiredKeywordArgumentError(argName));</span>
                }
<span class="fc" id="L1897">                addInstr(s, new LabelInstr(l));</span>
<span class="fc" id="L1898">            }</span>
        }

        // 2.0 keyword rest arg
<span class="fc" id="L1902">        KeywordRestArgNode keyRest = argsNode.getKeyRest();</span>
<span class="fc bfc" id="L1903" title="All 2 branches covered.">        if (keyRest != null) {</span>
<span class="fc" id="L1904">            String argName = keyRest.getName();</span>
<span class="fc" id="L1905">            Variable av = s.getNewLocalVariable(argName, 0);</span>
<span class="fc bfc" id="L1906" title="All 2 branches covered.">            if (s instanceof IRMethod) ((IRMethod)s).addArgDesc(IRMethodArgs.ArgType.keyrest, argName);</span>
<span class="fc" id="L1907">            addInstr(s, new ReceiveKeywordRestArgInstr(av, required));</span>
        }

        // Block arg
<span class="fc" id="L1911">        receiveBlockArg(argsNode, s);</span>
<span class="fc" id="L1912">    }</span>

    // This method is called to build arguments
    public void buildArgsMasgn(Node node, IRScope s, Operand argsArray, boolean isMasgnRoot, int preArgsCount, int postArgsCount, int index, boolean isSplat) {
        Variable v;
<span class="pc bpc" id="L1917" title="1 of 4 branches missed.">        switch (node.getNodeType()) {</span>
            case DASGNNODE: {
<span class="fc" id="L1919">                DAsgnNode dynamicAsgn = (DAsgnNode) node;</span>
<span class="fc" id="L1920">                v = getArgVariable(s, dynamicAsgn.getName(), dynamicAsgn.getDepth());</span>
<span class="fc bfc" id="L1921" title="All 2 branches covered.">                if (isSplat) addInstr(s, new RestArgMultipleAsgnInstr(v, argsArray, preArgsCount, postArgsCount, index));</span>
<span class="fc" id="L1922">                else addInstr(s, new ReqdArgMultipleAsgnInstr(v, argsArray, preArgsCount, postArgsCount, index));</span>
<span class="fc" id="L1923">                break;</span>
            }
            case LOCALASGNNODE: {
<span class="fc" id="L1926">                LocalAsgnNode localVariable = (LocalAsgnNode) node;</span>
<span class="fc" id="L1927">                v = getArgVariable(s, localVariable.getName(), localVariable.getDepth());</span>
<span class="fc bfc" id="L1928" title="All 2 branches covered.">                if (isSplat) addInstr(s, new RestArgMultipleAsgnInstr(v, argsArray, preArgsCount, postArgsCount, index));</span>
<span class="fc" id="L1929">                else addInstr(s, new ReqdArgMultipleAsgnInstr(v, argsArray, preArgsCount, postArgsCount, index));</span>
<span class="fc" id="L1930">                break;</span>
            }
            case MULTIPLEASGN19NODE: {
<span class="fc" id="L1933">                MultipleAsgn19Node childNode = (MultipleAsgn19Node) node;</span>
<span class="pc bpc" id="L1934" title="1 of 2 branches missed.">                if (!isMasgnRoot) {</span>
<span class="fc" id="L1935">                    v = s.createTemporaryVariable();</span>
<span class="pc bpc" id="L1936" title="1 of 2 branches missed.">                    if (isSplat) addInstr(s, new RestArgMultipleAsgnInstr(v, argsArray, preArgsCount, postArgsCount, index));</span>
<span class="fc" id="L1937">                    else addInstr(s, new ReqdArgMultipleAsgnInstr(v, argsArray, preArgsCount, postArgsCount, index));</span>
<span class="fc" id="L1938">                    Variable tmp = s.createTemporaryVariable();</span>
<span class="fc" id="L1939">                    addInstr(s, new ToAryInstr(tmp, v));</span>
<span class="fc" id="L1940">                    argsArray = tmp;</span>
                }
                // Build
<span class="fc" id="L1943">                buildMultipleAsgn19Assignment(childNode, s, argsArray, null);</span>
<span class="fc" id="L1944">                break;</span>
            }
            default:
<span class="nc" id="L1947">                throw new NotCompilableException(&quot;Shouldn't get here: &quot; + node);</span>
        }
<span class="fc" id="L1949">    }</span>

    // SSS: This method is called both for regular multiple assignment as well as argument passing
    //
    // Ex: a,b,*c=v  is a regular assignment and in this case, the &quot;values&quot; operand will be non-null
    // Ex: { |a,b,*c| ..} is the argument passing case
    public void buildMultipleAsgn19Assignment(final MultipleAsgn19Node multipleAsgnNode, IRScope s, Operand argsArray, Operand values) {
<span class="fc" id="L1956">        final ListNode masgnPre = multipleAsgnNode.getPre();</span>

        // Build assignments for specific named arguments
<span class="fc" id="L1959">        int i = 0;</span>
<span class="fc bfc" id="L1960" title="All 2 branches covered.">        if (masgnPre != null) {</span>
<span class="fc bfc" id="L1961" title="All 2 branches covered.">            for (Node an: masgnPre.childNodes()) {</span>
<span class="fc bfc" id="L1962" title="All 2 branches covered.">                if (values == null) {</span>
<span class="fc" id="L1963">                    buildArgsMasgn(an, s, argsArray, false, -1, -1, i, false);</span>
                } else {
<span class="fc" id="L1965">                    Variable rhsVal = s.createTemporaryVariable();</span>
<span class="fc" id="L1966">                    addInstr(s, new ReqdArgMultipleAsgnInstr(rhsVal, values, i));</span>
<span class="fc" id="L1967">                    buildAssignment(an, s, rhsVal);</span>
                }
<span class="fc" id="L1969">                i++;</span>
<span class="fc" id="L1970">            }</span>
        }

        // Build an assignment for a splat, if any, with the rest of the operands!
<span class="fc" id="L1974">        Node restNode = multipleAsgnNode.getRest();</span>
<span class="fc" id="L1975">        int postArgsCount = multipleAsgnNode.getPostCount();</span>
<span class="fc bfc" id="L1976" title="All 4 branches covered.">        if (restNode != null &amp;&amp; !(restNode instanceof StarNode)) {</span>
<span class="fc bfc" id="L1977" title="All 2 branches covered.">            if (values == null) {</span>
<span class="fc" id="L1978">                buildArgsMasgn(restNode, s, argsArray, false, i, postArgsCount, 0, true); // rest of the argument array!</span>
            } else {
<span class="fc" id="L1980">                Variable rhsVal = s.createTemporaryVariable();</span>
<span class="fc" id="L1981">                addInstr(s, new RestArgMultipleAsgnInstr(rhsVal, values, i, postArgsCount, 0));</span>
<span class="fc" id="L1982">                buildAssignment(restNode, s, rhsVal); // rest of the argument array!</span>
            }
        }

        // Build assignments for rest of the operands
<span class="fc" id="L1987">        final ListNode masgnPost = multipleAsgnNode.getPost();</span>
<span class="fc bfc" id="L1988" title="All 2 branches covered.">        if (masgnPost != null) {</span>
<span class="fc" id="L1989">            int j = 0;</span>
<span class="fc bfc" id="L1990" title="All 2 branches covered.">            for (Node an: masgnPost.childNodes()) {</span>
<span class="fc bfc" id="L1991" title="All 2 branches covered.">                if (values == null) {</span>
<span class="fc" id="L1992">                    buildArgsMasgn(an, s, argsArray, false, i, postArgsCount, j, false);</span>
                } else {
<span class="fc" id="L1994">                    Variable rhsVal = s.createTemporaryVariable();</span>
<span class="fc" id="L1995">                    addInstr(s, new ReqdArgMultipleAsgnInstr(rhsVal, values, i, postArgsCount, j));  // Fetch from the end</span>
<span class="fc" id="L1996">                    buildAssignment(an, s, rhsVal);</span>
                }
<span class="fc" id="L1998">                j++;</span>
<span class="fc" id="L1999">            }</span>
        }
<span class="fc" id="L2001">    }</span>

    private void handleBreakAndReturnsInLambdas(IRClosure s) {
<span class="fc" id="L2004">        Label rEndLabel   = s.getNewLabel();</span>
<span class="fc" id="L2005">        Label rescueLabel = Label.getGlobalEnsureBlockLabel();</span>

        // protect the entire body as it exists now with the global ensure block
<span class="fc" id="L2008">        addInstrAtBeginning(s, new ExceptionRegionStartMarkerInstr(rescueLabel));</span>
<span class="fc" id="L2009">        addInstr(s, new ExceptionRegionEndMarkerInstr());</span>

        // Receive exceptions (could be anything, but the handler only processes IRBreakJumps)
<span class="fc" id="L2012">        addInstr(s, new LabelInstr(rescueLabel));</span>
<span class="fc" id="L2013">        Variable exc = s.createTemporaryVariable();</span>
<span class="fc" id="L2014">        addInstr(s, new ReceiveJRubyExceptionInstr(exc));</span>

        // Handle break using runtime helper
        // --&gt; IRRuntimeHelpers.handleBreakAndReturnsInLambdas(context, scope, bj, blockType)
<span class="fc" id="L2018">        Variable ret = s.createTemporaryVariable();</span>
<span class="fc" id="L2019">        addInstr(s, new RuntimeHelperCall(ret, RuntimeHelperCall.Methods.HANDLE_BREAK_AND_RETURNS_IN_LAMBDA, new Operand[]{exc} ));</span>
<span class="fc" id="L2020">        addInstr(s, new ReturnInstr(ret));</span>

        // End
<span class="fc" id="L2023">        addInstr(s, new LabelInstr(rEndLabel));</span>
<span class="fc" id="L2024">    }</span>

    public void receiveMethodArgs(final ArgsNode argsNode, IRScope s) {
<span class="fc" id="L2027">        receiveArgs(argsNode, s);</span>
<span class="fc" id="L2028">    }</span>

    public void receiveBlockArgs(final IterNode node, IRScope s) {
<span class="fc" id="L2031">        Node args = node.getVarNode();</span>
<span class="fc bfc" id="L2032" title="All 2 branches covered.">        if (args instanceof ArgsNode) { // regular blocks</span>
<span class="fc" id="L2033">            ((IRClosure)s).setParameterList(Helpers.encodeParameterList((ArgsNode) args).split(&quot;;&quot;));</span>
<span class="fc" id="L2034">            receiveArgs((ArgsNode)args, s);</span>
        } else  {
            // for loops -- reuse code in IRBuilder:buildBlockArgsAssignment
<span class="fc" id="L2037">            buildBlockArgsAssignment(args, s, null, 0, false);</span>
        }
<span class="fc" id="L2039">    }</span>

    public Operand buildDot(final DotNode dotNode, IRScope s) {
<span class="fc" id="L2042">        Variable res = s.createTemporaryVariable();</span>
<span class="fc" id="L2043">        addInstr(s, new BuildRangeInstr(res, build(dotNode.getBeginNode(), s), build(dotNode.getEndNode(), s), dotNode.isExclusive()));</span>
<span class="fc" id="L2044">        return res;</span>
    }

    private Operand dynamicPiece(Node pieceNode, IRScope s) {
<span class="fc" id="L2048">        Operand piece = build(pieceNode, s);</span>

<span class="pc bpc" id="L2050" title="1 of 2 branches missed.">        return piece == null ? manager.getNil() : piece;</span>
    }

    public Operand buildDRegexp(DRegexpNode dregexpNode, IRScope s) {
<span class="fc" id="L2054">        List&lt;Operand&gt; strPieces = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2055" title="All 2 branches covered.">        for (Node n : dregexpNode.childNodes()) {</span>
<span class="fc" id="L2056">            strPieces.add(dynamicPiece(n, s));</span>
<span class="fc" id="L2057">        }</span>

<span class="fc" id="L2059">        Variable res = s.createTemporaryVariable();</span>
<span class="fc" id="L2060">        addInstr(s, new BuildDynRegExpInstr(res, strPieces, dregexpNode.getOptions()));</span>
<span class="fc" id="L2061">        return res;</span>
    }

    public Operand buildDStr(DStrNode dstrNode, IRScope s) {
<span class="fc" id="L2065">        List&lt;Operand&gt; strPieces = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2066" title="All 2 branches covered.">        for (Node n : dstrNode.childNodes()) {</span>
<span class="fc" id="L2067">            strPieces.add(dynamicPiece(n, s));</span>
<span class="fc" id="L2068">        }</span>

<span class="fc" id="L2070">        Variable res = s.createTemporaryVariable();</span>
<span class="fc" id="L2071">        addInstr(s, new BuildCompoundStringInstr(res, strPieces, dstrNode.getEncoding()));</span>
<span class="fc" id="L2072">        return copyAndReturnValue(s, res);</span>
    }

    public Operand buildDSymbol(DSymbolNode node, IRScope s) {
<span class="fc" id="L2076">        List&lt;Operand&gt; strPieces = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2077" title="All 2 branches covered.">        for (Node n : node.childNodes()) {</span>
<span class="fc" id="L2078">            strPieces.add(dynamicPiece(n, s));</span>
<span class="fc" id="L2079">        }</span>

<span class="fc" id="L2081">        Variable res = s.createTemporaryVariable();</span>
<span class="fc" id="L2082">        addInstr(s, new BuildCompoundStringInstr(res, strPieces, node.getEncoding()));</span>
<span class="fc" id="L2083">        return copyAndReturnValue(s, new DynamicSymbol(res));</span>
    }

    public Operand buildDVar(DVarNode node, IRScope s) {
<span class="fc" id="L2087">        return s.getLocalVariable(node.getName(), node.getDepth());</span>
    }

    public Operand buildDXStr(final DXStrNode dstrNode, IRScope s) {
<span class="fc" id="L2091">        List&lt;Operand&gt; strPieces = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2092" title="All 2 branches covered.">        for (Node nextNode : dstrNode.childNodes()) {</span>
<span class="fc" id="L2093">            strPieces.add(dynamicPiece(nextNode, s));</span>
<span class="fc" id="L2094">        }</span>

<span class="fc" id="L2096">        Variable res = s.createTemporaryVariable();</span>
<span class="fc" id="L2097">        addInstr(s, new BacktickInstr(res, strPieces));</span>
<span class="fc" id="L2098">        return res;</span>
    }

    /* ****************************************************************
     * Consider the ensure-protected ruby code below:

           begin
             .. protected body ..
           ensure
             .. eb code
           end

       This ruby code is effectively rewritten into the following ruby code

          begin
            .. protected body ..
            .. copy of ensure body code ..
          rescue &lt;any-exception-or-error&gt; =&gt; e
            .. ensure body code ..
            raise e
          end

      which in IR looks like this:

          L1:
            Exception region start marker_1 (protected by L10)
            ... IR for protected body ...
            Exception region end marker_1
          L2:
            Exception region start marker_2 (protected by whichever block handles exceptions for ensure body)
            .. copy of IR for ensure block ..
            Exception region end marker_2
            jump L3
          L10:          &lt;----- dummy rescue block
            e = recv_exception
            .. IR for ensure block ..
            throw e
          L3:

     * ****************************************************************/
    public Operand buildEnsureNode(EnsureNode ensureNode, IRScope s) {
<span class="fc" id="L2139">        Node bodyNode = ensureNode.getBodyNode();</span>

        // ------------ Build the body of the ensure block ------------
        //
        // The ensure code is built first so that when the protected body is being built,
        // the ensure code can be cloned at break/next/return sites in the protected body.

        // Push a new ensure block node onto the stack of ensure bodies being built
        // The body's instructions are stashed and emitted later.
<span class="fc bfc" id="L2148" title="All 2 branches covered.">        EnsureBlockInfo ebi = new EnsureBlockInfo(s,</span>
            (bodyNode instanceof RescueNode) ? (RescueNode)bodyNode : null,
<span class="fc" id="L2150">            getCurrentLoop(),</span>
<span class="fc" id="L2151">            activeRescuers.peek());</span>

<span class="fc" id="L2153">        ensureBodyBuildStack.push(ebi);</span>
<span class="pc bpc" id="L2154" title="1 of 2 branches missed.">        Operand ensureRetVal = (ensureNode.getEnsureNode() == null) ? manager.getNil() : build(ensureNode.getEnsureNode(), s);</span>
<span class="fc" id="L2155">        ensureBodyBuildStack.pop();</span>

        // ------------ Build the protected region ------------
<span class="fc" id="L2158">        activeEnsureBlockStack.push(ebi);</span>

        // Start of protected region
<span class="fc" id="L2161">        addInstr(s, new LabelInstr(ebi.regionStart));</span>
<span class="fc" id="L2162">        addInstr(s, new ExceptionRegionStartMarkerInstr(ebi.dummyRescueBlockLabel));</span>
<span class="fc" id="L2163">        activeRescuers.push(ebi.dummyRescueBlockLabel);</span>

        // Generate IR for code being protected
<span class="fc bfc" id="L2166" title="All 2 branches covered.">        Operand rv = bodyNode instanceof RescueNode ? buildRescueInternal((RescueNode) bodyNode, s, ebi) : build(bodyNode, s);</span>

        // end of protected region
<span class="fc" id="L2169">        addInstr(s, new ExceptionRegionEndMarkerInstr());</span>
<span class="fc" id="L2170">        activeRescuers.pop();</span>

        // Clone the ensure body and jump to the end.
        // Dont bother if the protected body ended in a return.
<span class="fc bfc" id="L2174" title="All 4 branches covered.">        if (rv != U_NIL &amp;&amp; !(bodyNode instanceof RescueNode)) {</span>
<span class="fc" id="L2175">            ebi.cloneIntoHostScope(this, s);</span>
<span class="fc" id="L2176">            addInstr(s, new JumpInstr(ebi.end));</span>
        }

        // Pop the current ensure block info node
<span class="fc" id="L2180">        activeEnsureBlockStack.pop();</span>

        // ------------ Emit the ensure body alongwith dummy rescue block ------------
        // Now build the dummy rescue block that:
        // * catches all exceptions thrown by the body
<span class="fc" id="L2185">        Variable exc = s.createTemporaryVariable();</span>
<span class="fc" id="L2186">        addInstr(s, new LabelInstr(ebi.dummyRescueBlockLabel));</span>
<span class="fc" id="L2187">        addInstr(s, new ReceiveJRubyExceptionInstr(exc));</span>

        // Now emit the ensure body's stashed instructions
<span class="fc" id="L2190">        ebi.emitBody(this, s);</span>

        // 1. Ensure block has no explicit return =&gt; the result of the entire ensure expression is the result of the protected body.
        // 2. Ensure block has an explicit return =&gt; the result of the protected body is ignored.
        // U_NIL =&gt; there was a return from within the ensure block!
<span class="fc bfc" id="L2195" title="All 2 branches covered.">        if (ensureRetVal == U_NIL) rv = U_NIL;</span>

        // Return (rethrow exception/end)
        // rethrows the caught exception from the dummy ensure block
<span class="fc" id="L2199">        addInstr(s, new ThrowExceptionInstr(exc));</span>

        // End label for the exception region
<span class="fc" id="L2202">        addInstr(s, new LabelInstr(ebi.end));</span>

<span class="fc" id="L2204">        return rv;</span>
    }

    public Operand buildEvStr(EvStrNode node, IRScope s) {
<span class="fc" id="L2208">        return new AsString(build(node.getBody(), s));</span>
    }

    public Operand buildFalse() {
<span class="fc" id="L2212">        return manager.getFalse();</span>
    }

    public Operand buildFCall(FCallNode fcallNode, IRScope s) {
<span class="fc" id="L2216">        Node          callArgsNode = fcallNode.getArgsNode();</span>
<span class="fc" id="L2217">        Operand[] args         = setupCallArgs(callArgsNode, s);</span>
<span class="fc" id="L2218">        Operand       block        = setupCallClosure(fcallNode.getIterNode(), s);</span>
<span class="fc" id="L2219">        Variable      callResult   = s.createTemporaryVariable();</span>
<span class="fc" id="L2220">        CallInstr     callInstr    = CallInstr.create(CallType.FUNCTIONAL, callResult, fcallNode.getName(), s.getSelf(), args, block);</span>
<span class="fc" id="L2221">        receiveBreakException(s, block, callInstr);</span>
<span class="fc" id="L2222">        return callResult;</span>
    }

    private Operand setupCallClosure(Node node, IRScope s) {
<span class="fc bfc" id="L2226" title="All 2 branches covered.">        if (node == null) return null;</span>

<span class="pc bpc" id="L2228" title="1 of 3 branches missed.">        switch (node.getNodeType()) {</span>
            case ITERNODE:
<span class="fc" id="L2230">                return build(node, s);</span>
            case BLOCKPASSNODE:
<span class="fc" id="L2232">                return build(((BlockPassNode)node).getBodyNode(), s);</span>
            default:
<span class="nc" id="L2234">                throw new NotCompilableException(&quot;ERROR: Encountered a method with a non-block, non-blockpass iter node at: &quot; + node);</span>
        }
    }

    public Operand buildFixnum(FixnumNode node) {
<span class="fc" id="L2239">        return new Fixnum(node.getValue());</span>
    }

    public Operand buildFlip(FlipNode flipNode, IRScope s) {
        /* ----------------------------------------------------------------------
         * Consider a simple 2-state (s1, s2) FSM with the following transitions:
         *
         *     new_state(s1, F) = s1
         *     new_state(s1, T) = s2
         *     new_state(s2, F) = s2
         *     new_state(s2, T) = s1
         *
         * Here is the pseudo-code for evaluating the flip-node.
         * Let 'v' holds the value of the current state.
         *
         *    1. if (v == 's1') f1 = eval_condition(s1-condition); v = new_state(v, f1); ret = f1
         *    2. if (v == 's2') f2 = eval_condition(s2-condition); v = new_state(v, f2); ret = true
         *    3. return ret
         *
         * For exclusive flip conditions, line 2 changes to:
         *    2. if (!f1 &amp;&amp; (v == 's2')) f2 = eval_condition(s2-condition); v = new_state(v, f2)
         *
         * In IR code below, we are representing the two states as 1 and 2.  Any
         * two values are good enough (even true and false), but 1 and 2 is simple
         * enough and also makes the IR output readable
         * ---------------------------------------------------------------------- */

<span class="fc" id="L2266">        Fixnum s1 = new Fixnum((long)1);</span>
<span class="fc" id="L2267">        Fixnum s2 = new Fixnum((long)2);</span>

        // Create a variable to hold the flip state
<span class="fc" id="L2270">        IRScope nearestNonClosure = s.getNearestFlipVariableScope();</span>
<span class="fc" id="L2271">        Variable flipState = nearestNonClosure.getNewFlipStateVariable();</span>
<span class="fc" id="L2272">        nearestNonClosure.initFlipStateVariable(flipState, s1);</span>
<span class="pc bpc" id="L2273" title="1 of 2 branches missed.">        if (s instanceof IRClosure) {</span>
            // Clone the flip variable to be usable at the proper-depth.
<span class="fc" id="L2275">            int n = 0;</span>
<span class="fc" id="L2276">            IRScope x = s;</span>
<span class="fc bfc" id="L2277" title="All 2 branches covered.">            while (!x.isFlipScope()) {</span>
<span class="fc" id="L2278">                n++;</span>
<span class="fc" id="L2279">                x = x.getLexicalParent();</span>
            }
<span class="pc bpc" id="L2281" title="1 of 2 branches missed.">            if (n &gt; 0) flipState = ((LocalVariable)flipState).cloneForDepth(n);</span>
        }

        // Variables and labels needed for the code
<span class="fc" id="L2285">        Variable returnVal = s.createTemporaryVariable();</span>
<span class="fc" id="L2286">        Label    s2Label   = s.getNewLabel();</span>
<span class="fc" id="L2287">        Label    doneLabel = s.getNewLabel();</span>

        // Init
<span class="fc" id="L2290">        addInstr(s, new CopyInstr(returnVal, manager.getFalse()));</span>

        // Are we in state 1?
<span class="fc" id="L2293">        addInstr(s, BNEInstr.create(flipState, s1, s2Label));</span>

        // ----- Code for when we are in state 1 -----
<span class="fc" id="L2296">        Operand s1Val = build(flipNode.getBeginNode(), s);</span>
<span class="fc" id="L2297">        addInstr(s, BNEInstr.create(s1Val, manager.getTrue(), s2Label));</span>

        // s1 condition is true =&gt; set returnVal to true &amp; move to state 2
<span class="fc" id="L2300">        addInstr(s, new CopyInstr(returnVal, manager.getTrue()));</span>
<span class="fc" id="L2301">        addInstr(s, new CopyInstr(flipState, s2));</span>

        // Check for state 2
<span class="fc" id="L2304">        addInstr(s, new LabelInstr(s2Label));</span>

        // For exclusive ranges/flips, we dont evaluate s2's condition if s1's condition was satisfied
<span class="fc bfc" id="L2307" title="All 2 branches covered.">        if (flipNode.isExclusive()) addInstr(s, BEQInstr.create(returnVal, manager.getTrue(), doneLabel));</span>

        // Are we in state 2?
<span class="fc" id="L2310">        addInstr(s, BNEInstr.create(flipState, s2, doneLabel));</span>

        // ----- Code for when we are in state 2 -----
<span class="fc" id="L2313">        Operand s2Val = build(flipNode.getEndNode(), s);</span>
<span class="fc" id="L2314">        addInstr(s, new CopyInstr(returnVal, manager.getTrue()));</span>
<span class="fc" id="L2315">        addInstr(s, BNEInstr.create(s2Val, manager.getTrue(), doneLabel));</span>

        // s2 condition is true =&gt; move to state 1
<span class="fc" id="L2318">        addInstr(s, new CopyInstr(flipState, s1));</span>

        // Done testing for s1's and s2's conditions.
        // returnVal will have the result of the flip condition
<span class="fc" id="L2322">        addInstr(s, new LabelInstr(doneLabel));</span>

<span class="fc" id="L2324">        return returnVal;</span>
    }

    public Operand buildFloat(FloatNode node) {
        // SSS: Since flaot literals are effectively interned objects, no need to copyAndReturnValue(...)
        // Or is this a premature optimization?
<span class="fc" id="L2330">        return new Float(node.getValue());</span>
    }

    public Operand buildFor(ForNode forNode, IRScope s) {
<span class="fc" id="L2334">        Variable result = s.createTemporaryVariable();</span>
<span class="fc" id="L2335">        Operand  receiver = build(forNode.getIterNode(), s);</span>
<span class="fc" id="L2336">        Operand  forBlock = buildForIter(forNode, s);</span>
<span class="fc" id="L2337">        CallInstr callInstr = new CallInstr(CallType.NORMAL, result, &quot;each&quot;, receiver, NO_ARGS, forBlock);</span>
<span class="fc" id="L2338">        receiveBreakException(s, forBlock, callInstr);</span>

<span class="fc" id="L2340">        return result;</span>
    }

    public Operand buildForIter(final ForNode forNode, IRScope s) {
            // Create a new closure context
<span class="fc" id="L2345">        IRClosure closure = new IRFor(manager, s, forNode.getPosition().getLine(), forNode.getScope(), Arity.procArityOf(forNode.getVarNode()), forNode.getArgumentType());</span>

        // Create a new nested builder to ensure this gets its own IR builder state
        // like the ensure block stack
<span class="fc" id="L2349">        IRBuilder forBuilder = newIRBuilder(manager);</span>

            // Receive self
<span class="fc" id="L2352">        forBuilder.addInstr(closure, new ReceiveSelfInstr(closure.getSelf()));</span>

            // Build args
<span class="fc" id="L2355">        Node varNode = forNode.getVarNode();</span>
<span class="pc bpc" id="L2356" title="2 of 4 branches missed.">        if (varNode != null &amp;&amp; varNode.getNodeType() != null) forBuilder.receiveBlockArgs(forNode, closure);</span>

        // Set %current_scope = &lt;current-scope&gt;
        // Set %current_module = &lt;current-module&gt;
<span class="fc" id="L2360">        forBuilder.addInstr(closure, new CopyInstr(closure.getCurrentScopeVariable(), CURRENT_SCOPE[0]));</span>
<span class="fc" id="L2361">        forBuilder.addInstr(closure, new CopyInstr(closure.getCurrentModuleVariable(), SCOPE_MODULE[0]));</span>

        // Thread poll on entry of closure
<span class="fc" id="L2364">        forBuilder.addInstr(closure, new ThreadPollInstr());</span>

            // Start label -- used by redo!
<span class="fc" id="L2367">        forBuilder.addInstr(closure, new LabelInstr(closure.startLabel));</span>

            // Build closure body and return the result of the closure
<span class="fc bfc" id="L2370" title="All 2 branches covered.">        Operand closureRetVal = forNode.getBodyNode() == null ? manager.getNil() : forBuilder.build(forNode.getBodyNode(), closure);</span>
<span class="pc bpc" id="L2371" title="1 of 2 branches missed.">        if (closureRetVal != U_NIL) { // can be null if the node is an if node with returns in both branches.</span>
<span class="fc" id="L2372">            forBuilder.addInstr(closure, new ReturnInstr(closureRetVal));</span>
        }

<span class="fc" id="L2375">        return new WrappedIRClosure(s.getSelf(), closure);</span>
    }

    public Operand buildGlobalAsgn(GlobalAsgnNode globalAsgnNode, IRScope s) {
<span class="fc" id="L2379">        Operand value = build(globalAsgnNode.getValueNode(), s);</span>
<span class="fc" id="L2380">        addInstr(s, new PutGlobalVarInstr(globalAsgnNode.getName(), value));</span>
<span class="fc" id="L2381">        return value;</span>
    }

    public Operand buildGlobalVar(GlobalVarNode node, IRScope s) {
<span class="fc" id="L2385">        return addResultInstr(s, new GetGlobalVariableInstr(s.createTemporaryVariable(), node.getName()));</span>
    }

    public Operand buildHash(HashNode hashNode, IRScope s) {
<span class="fc" id="L2389">        List&lt;KeyValuePair&lt;Operand, Operand&gt;&gt; args = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2390">        Operand splatKeywordArgument = null;</span>

<span class="fc bfc" id="L2392" title="All 2 branches covered.">        for (KeyValuePair&lt;Node, Node&gt; pair: hashNode.getPairs()) {</span>
<span class="fc" id="L2393">            Node key = pair.getKey();</span>
            Operand keyOperand;

<span class="fc bfc" id="L2396" title="All 2 branches covered.">            if (key == null) { // splat kwargs [e.g. foo(a: 1, **splat)] key is null and will be in last pair of hash</span>
<span class="fc" id="L2397">                splatKeywordArgument = build(pair.getValue(), s);</span>
<span class="fc" id="L2398">                break;</span>
            } else {
<span class="fc" id="L2400">               keyOperand = build(key, s);</span>
            }

<span class="fc" id="L2403">            args.add(new KeyValuePair&lt;&gt;(keyOperand, build(pair.getValue(), s)));</span>
<span class="fc" id="L2404">        }</span>

<span class="fc bfc" id="L2406" title="All 2 branches covered.">        if (splatKeywordArgument != null) { // splat kwargs merge with any explicit kwargs</span>
<span class="fc" id="L2407">            Variable tmp = s.createTemporaryVariable();</span>
<span class="fc" id="L2408">            s.addInstr(new RuntimeHelperCall(tmp, MERGE_KWARGS, new Operand[] { splatKeywordArgument, new Hash(args)}));</span>
<span class="fc" id="L2409">            return tmp;</span>
        } else {
<span class="fc" id="L2411">            return copyAndReturnValue(s, new Hash(args));</span>
        }
    }

    // Translate &quot;r = if (cond); .. thenbody ..; else; .. elsebody ..; end&quot; to
    //
    //     v = -- build(cond) --
    //     BEQ(v, FALSE, L1)
    //     r = -- build(thenbody) --
    //     jump L2
    // L1:
    //     r = -- build(elsebody) --
    // L2:
    //     --- r is the result of the if expression --
    //
    public Operand buildIf(final IfNode ifNode, IRScope s) {
<span class="fc" id="L2427">        Node actualCondition = skipOverNewlines(s, ifNode.getCondition());</span>

        Variable result;
<span class="fc" id="L2430">        Label    falseLabel = s.getNewLabel();</span>
<span class="fc" id="L2431">        Label    doneLabel  = s.getNewLabel();</span>
        Operand  thenResult;
<span class="fc" id="L2433">        addInstr(s, BEQInstr.create(build(actualCondition, s), manager.getFalse(), falseLabel));</span>

<span class="fc" id="L2435">        boolean thenNull = false;</span>
<span class="fc" id="L2436">        boolean elseNull = false;</span>
<span class="fc" id="L2437">        boolean thenUnil = false;</span>
<span class="fc" id="L2438">        boolean elseUnil = false;</span>

        // Build the then part of the if-statement
<span class="fc bfc" id="L2441" title="All 2 branches covered.">        if (ifNode.getThenBody() != null) {</span>
<span class="fc" id="L2442">            thenResult = build(ifNode.getThenBody(), s);</span>
<span class="fc bfc" id="L2443" title="All 2 branches covered.">            if (thenResult != U_NIL) { // thenResult can be U_NIL if then-body ended with a return!</span>
                // SSS FIXME: Can look at the last instr and short-circuit this jump if it is a break rather
                // than wait for dead code elimination to do it
<span class="fc" id="L2446">                result = getValueInTemporaryVariable(s, thenResult);</span>
<span class="fc" id="L2447">                addInstr(s, new JumpInstr(doneLabel));</span>
            } else {
<span class="fc" id="L2449">                result = s.createTemporaryVariable();</span>
<span class="fc" id="L2450">                thenUnil = true;</span>
            }
        } else {
<span class="fc" id="L2453">            thenNull = true;</span>
<span class="fc" id="L2454">            result = addResultInstr(s, new CopyInstr(s.createTemporaryVariable(), manager.getNil()));</span>
<span class="fc" id="L2455">            addInstr(s, new JumpInstr(doneLabel));</span>
        }

        // Build the else part of the if-statement
<span class="fc" id="L2459">        addInstr(s, new LabelInstr(falseLabel));</span>
<span class="fc bfc" id="L2460" title="All 2 branches covered.">        if (ifNode.getElseBody() != null) {</span>
<span class="fc" id="L2461">            Operand elseResult = build(ifNode.getElseBody(), s);</span>
            // elseResult can be U_NIL if then-body ended with a return!
<span class="fc bfc" id="L2463" title="All 2 branches covered.">            if (elseResult != U_NIL) {</span>
<span class="fc" id="L2464">                addInstr(s, new CopyInstr(result, elseResult));</span>
            } else {
<span class="fc" id="L2466">                elseUnil = true;</span>
            }
<span class="fc" id="L2468">        } else {</span>
<span class="fc" id="L2469">            elseNull = true;</span>
<span class="fc" id="L2470">            addInstr(s, new CopyInstr(result, manager.getNil()));</span>
        }

<span class="fc bfc" id="L2473" title="All 4 branches covered.">        if (thenNull &amp;&amp; elseNull) {</span>
<span class="fc" id="L2474">            addInstr(s, new LabelInstr(doneLabel));</span>
<span class="fc" id="L2475">            return manager.getNil();</span>
<span class="fc bfc" id="L2476" title="All 4 branches covered.">        } else if (thenUnil &amp;&amp; elseUnil) {</span>
<span class="fc" id="L2477">            return U_NIL;</span>
        } else {
<span class="fc" id="L2479">            addInstr(s, new LabelInstr(doneLabel));</span>
<span class="fc" id="L2480">            return result;</span>
        }
    }

    public Operand buildInstAsgn(final InstAsgnNode instAsgnNode, IRScope s) {
<span class="fc" id="L2485">        Operand val = build(instAsgnNode.getValueNode(), s);</span>
        // NOTE: if 's' happens to the a class, this is effectively an assignment of a class instance variable
<span class="fc" id="L2487">        addInstr(s, new PutFieldInstr(s.getSelf(), instAsgnNode.getName(), val));</span>
<span class="fc" id="L2488">        return val;</span>
    }

    public Operand buildInstVar(InstVarNode node, IRScope s) {
<span class="fc" id="L2492">        return addResultInstr(s, new GetFieldInstr(s.createTemporaryVariable(), s.getSelf(), node.getName()));</span>
    }

    public Operand buildIter(final IterNode iterNode, IRScope s) {
<span class="fc" id="L2496">        IRClosure closure = new IRClosure(manager, s, iterNode.getPosition().getLine(), iterNode.getScope(), Arity.procArityOf(iterNode.getVarNode()), iterNode.getArgumentType());</span>

        // Create a new nested builder to ensure this gets its own IR builder state
        // like the ensure block stack
<span class="fc" id="L2500">        IRBuilder closureBuilder = newIRBuilder(manager);</span>

        // Receive self
<span class="fc" id="L2503">        closureBuilder.addInstr(closure, new ReceiveSelfInstr(closure.getSelf()));</span>

        // Build args
<span class="pc bpc" id="L2506" title="1 of 2 branches missed.">        if (iterNode.getVarNode().getNodeType() != null) closureBuilder.receiveBlockArgs(iterNode, closure);</span>

        // Set %current_scope = &lt;current-scope&gt;
        // Set %current_module = &lt;current-module&gt;
<span class="fc" id="L2510">        closureBuilder.addInstr(closure, new CopyInstr(closure.getCurrentScopeVariable(), CURRENT_SCOPE[0]));</span>
<span class="fc" id="L2511">        closureBuilder.addInstr(closure, new CopyInstr(closure.getCurrentModuleVariable(), SCOPE_MODULE[0]));</span>

        // Thread poll on entry of closure
<span class="fc" id="L2514">        closureBuilder.addInstr(closure, new ThreadPollInstr());</span>

        // start label -- used by redo!
<span class="fc" id="L2517">        closureBuilder.addInstr(closure, new LabelInstr(closure.startLabel));</span>

        // Build closure body and return the result of the closure
<span class="fc bfc" id="L2520" title="All 2 branches covered.">        Operand closureRetVal = iterNode.getBodyNode() == null ? manager.getNil() : closureBuilder.build(iterNode.getBodyNode(), closure);</span>
<span class="fc bfc" id="L2521" title="All 2 branches covered.">        if (closureRetVal != U_NIL) { // can be U_NIL if the node is an if node with returns in both branches.</span>
<span class="fc" id="L2522">            closureBuilder.addInstr(closure, new ReturnInstr(closureRetVal));</span>
        }

        // Always add break/return handling even though this
        // is only required for lambdas, but we don't know at this time,
        // if this is a lambda or not.
        //
        // SSS FIXME: At a later time, see if we can optimize this and
        // do this on demand.
<span class="fc" id="L2531">        closureBuilder.handleBreakAndReturnsInLambdas(closure);</span>

<span class="fc" id="L2533">        return new WrappedIRClosure(s.getSelf(), closure);</span>
    }

    public Operand buildLiteral(LiteralNode literalNode, IRScope s) {
<span class="fc" id="L2537">        return copyAndReturnValue(s, new StringLiteral(literalNode.getName()));</span>
    }

    public Operand buildLocalAsgn(LocalAsgnNode localAsgnNode, IRScope s) {
<span class="fc" id="L2541">        Variable var  = s.getLocalVariable(localAsgnNode.getName(), localAsgnNode.getDepth());</span>
<span class="fc" id="L2542">        Operand value = build(localAsgnNode.getValueNode(), s);</span>
<span class="fc" id="L2543">        addInstr(s, new CopyInstr(var, value));</span>
<span class="fc" id="L2544">        return value;</span>

        // IMPORTANT: The return value of this method is value, not var!
        //
        // Consider this Ruby code: foo((a = 1), (a = 2))
        //
        // If we return 'value' this will get translated to:
        //    a = 1
        //    a = 2
        //    call(&quot;foo&quot;, [1,2]) &lt;---- CORRECT
        //
        // If we return 'var' this will get translated to:
        //    a = 1
        //    a = 2
        //    call(&quot;foo&quot;, [a,a]) &lt;---- BUGGY
        //
        // This technique only works if 'value' is an immutable value (ex: fixnum) or a variable
        // So, for Ruby code like this:
        //     def foo(x); x &lt;&lt; 5; end;
        //     foo(a=[1,2]);
        //     p a
        // we are guaranteed that the value passed into foo and 'a' point to the same object
        // because of the use of copyAndReturnValue method for literal objects.
    }

    public Operand buildLocalVar(LocalVarNode node, IRScope s) {
<span class="fc" id="L2570">        return s.getLocalVariable(node.getName(), node.getDepth());</span>
    }

    public Operand buildMatch(MatchNode matchNode, IRScope s) {
<span class="fc" id="L2574">        Operand regexp = build(matchNode.getRegexpNode(), s);</span>

<span class="fc" id="L2576">        return addResultInstr(s, new MatchInstr(s.createTemporaryVariable(), regexp));</span>
    }

    public Operand buildMatch2(Match2Node matchNode, IRScope s) {
<span class="fc" id="L2580">        Operand receiver = build(matchNode.getReceiverNode(), s);</span>
<span class="fc" id="L2581">        Operand value    = build(matchNode.getValueNode(), s);</span>
<span class="fc" id="L2582">        Variable result  = s.createTemporaryVariable();</span>
<span class="fc" id="L2583">        addInstr(s, new Match2Instr(result, receiver, value));</span>
<span class="fc bfc" id="L2584" title="All 2 branches covered.">        if (matchNode instanceof Match2CaptureNode) {</span>
<span class="fc" id="L2585">            Match2CaptureNode m2c = (Match2CaptureNode)matchNode;</span>
<span class="fc bfc" id="L2586" title="All 2 branches covered.">            for (int slot:  m2c.getScopeOffsets()) {</span>
                // Static scope scope offsets store both depth and offset
<span class="fc" id="L2588">                int depth = slot &gt;&gt; 16;</span>
<span class="fc" id="L2589">                int offset = slot &amp; 0xffff;</span>

                // For now, we'll continue to implicitly reference &quot;$~&quot;
<span class="fc" id="L2592">                String var = getVarNameFromScopeTree(s, depth, offset);</span>
<span class="fc" id="L2593">                addInstr(s, new SetCapturedVarInstr(s.getLocalVariable(var, depth), result, var));</span>
            }
        }
<span class="fc" id="L2596">        return result;</span>
    }

    private String getVarNameFromScopeTree(IRScope scope, int depth, int offset) {
<span class="pc bpc" id="L2600" title="1 of 2 branches missed.">        if (depth == 0) {</span>
<span class="fc" id="L2601">            return scope.getStaticScope().getVariables()[offset];</span>
        }
<span class="nc" id="L2603">        return getVarNameFromScopeTree(scope.getLexicalParent(), depth - 1, offset);</span>
    }

    public Operand buildMatch3(Match3Node matchNode, IRScope s) {
<span class="fc" id="L2607">        Operand receiver = build(matchNode.getReceiverNode(), s);</span>
<span class="fc" id="L2608">        Operand value    = build(matchNode.getValueNode(), s);</span>

<span class="fc" id="L2610">        return addResultInstr(s, new Match3Instr(s.createTemporaryVariable(), receiver, value));</span>
    }

    private Operand getContainerFromCPath(Colon3Node cpath, IRScope s) {
        Operand container;

<span class="fc bfc" id="L2616" title="All 2 branches covered.">        if (cpath instanceof Colon2Node) {</span>
<span class="fc" id="L2617">            Node leftNode = ((Colon2Node) cpath).getLeftNode();</span>

<span class="fc bfc" id="L2619" title="All 2 branches covered.">            if (leftNode != null) { // Foo::Bar</span>
<span class="fc" id="L2620">                container = build(leftNode, s);</span>
            } else { // Only name with no left-side Bar &lt;- Note no :: on left
<span class="fc" id="L2622">                container = findContainerModule(s);</span>
            }
<span class="fc" id="L2624">        } else { //::Bar</span>
<span class="fc" id="L2625">            container = new ObjectClass();</span>
        }

<span class="fc" id="L2628">        return container;</span>
    }

    public Operand buildModule(ModuleNode moduleNode, IRScope s) {
<span class="fc" id="L2632">        Colon3Node cpath = moduleNode.getCPath();</span>
<span class="fc" id="L2633">        String moduleName = cpath.getName();</span>
<span class="fc" id="L2634">        Operand container = getContainerFromCPath(cpath, s);</span>
<span class="fc" id="L2635">        IRModuleBody body = new IRModuleBody(manager, s, moduleName, moduleNode.getPosition().getLine(), moduleNode.getScope());</span>
<span class="fc" id="L2636">        Variable moduleVar = addResultInstr(s, new DefineModuleInstr(s.createTemporaryVariable(), body, container));</span>

<span class="fc" id="L2638">        return buildModuleOrClassBody(s, moduleVar, body, moduleNode.getBodyNode(), moduleNode.getPosition().getLine());</span>
    }

    public Operand buildMultipleAsgn(MultipleAsgnNode multipleAsgnNode, IRScope s) {
<span class="nc" id="L2642">        Operand  values = build(multipleAsgnNode.getValueNode(), s);</span>
<span class="nc" id="L2643">        Variable ret = getValueInTemporaryVariable(s, values);</span>
<span class="nc" id="L2644">        buildMultipleAsgnAssignment(multipleAsgnNode, s, null, ret);</span>
<span class="nc" id="L2645">        return ret;</span>
    }

    // SSS: This method is called both for regular multiple assignment as well as argument passing
    //
    // Ex: a,b,*c=v  is a regular assignment and in this case, the &quot;values&quot; operand will be non-null
    // Ex: { |a,b,*c| ..} is the argument passing case
    public void buildMultipleAsgnAssignment(final MultipleAsgnNode multipleAsgnNode, IRScope s, Operand argsArray, Operand values) {
<span class="nc" id="L2653">        final ListNode sourceArray = multipleAsgnNode.getHeadNode();</span>

        // First, build assignments for specific named arguments
<span class="nc" id="L2656">        int i = 0;</span>
<span class="nc bnc" id="L2657" title="All 2 branches missed.">        if (sourceArray != null) {</span>
<span class="nc bnc" id="L2658" title="All 2 branches missed.">            for (Node an: sourceArray.childNodes()) {</span>
<span class="nc bnc" id="L2659" title="All 2 branches missed.">                if (values == null) {</span>
<span class="nc" id="L2660">                    buildBlockArgsAssignment(an, s, argsArray, i, false);</span>
                } else {
<span class="nc" id="L2662">                    Variable rhsVal = addResultInstr(s, new ReqdArgMultipleAsgnInstr(s.createTemporaryVariable(), values, i));</span>
<span class="nc" id="L2663">                    buildAssignment(an, s, rhsVal);</span>
                }
<span class="nc" id="L2665">                i++;</span>
<span class="nc" id="L2666">            }</span>
        }

        // First, build an assignment for a splat, if any, with the rest of the args!
<span class="nc" id="L2670">        Node argsNode = multipleAsgnNode.getArgsNode();</span>
<span class="nc bnc" id="L2671" title="All 2 branches missed.">        if (argsNode == null) {</span>
<span class="nc bnc" id="L2672" title="All 2 branches missed.">            if (sourceArray == null) {</span>
<span class="nc" id="L2673">                throw new NotCompilableException(&quot;Something's wrong, multiple assignment with no head or args at: &quot; + multipleAsgnNode.getPosition());</span>
            }
<span class="nc bnc" id="L2675" title="All 2 branches missed.">        } else if (!(argsNode instanceof StarNode)) {</span>
<span class="nc bnc" id="L2676" title="All 2 branches missed.">            if (values != null) {</span>
<span class="nc" id="L2677">                buildAssignment(argsNode, s,    // rest of the argument array!</span>
<span class="nc" id="L2678">                        addResultInstr(s, new RestArgMultipleAsgnInstr(s.createTemporaryVariable(), values, i)));</span>
            } else {
<span class="nc" id="L2680">                buildBlockArgsAssignment(argsNode, s, argsArray, i, true); // rest of the argument array!</span>
            }
        }
<span class="nc" id="L2683">    }</span>

    public Operand buildNewline(NewlineNode node, IRScope s) {
<span class="fc" id="L2686">        return build(skipOverNewlines(s, node), s);</span>
    }

    public Operand buildNext(final NextNode nextNode, IRScope s) {
<span class="fc" id="L2690">        IRLoop currLoop = getCurrentLoop();</span>

<span class="pc bpc" id="L2692" title="1 of 2 branches missed.">        Operand rv = (nextNode.getValueNode() == null) ? manager.getNil() : build(nextNode.getValueNode(), s);</span>

        // If we have ensure blocks, have to run those first!
<span class="fc bfc" id="L2695" title="All 2 branches covered.">        if (!activeEnsureBlockStack.empty()) emitEnsureBlocks(s, currLoop);</span>
<span class="pc bpc" id="L2696" title="1 of 2 branches missed.">        else if (!activeRescueBlockStack.empty()) activeRescueBlockStack.peek().restoreException(this, s, currLoop);</span>

<span class="fc bfc" id="L2698" title="All 2 branches covered.">        if (currLoop != null) {</span>
            // If a regular loop, the next is simply a jump to the end of the iteration
<span class="fc" id="L2700">            addInstr(s, new JumpInstr(currLoop.iterEndLabel));</span>
        } else {
<span class="fc" id="L2702">            addInstr(s, new ThreadPollInstr(true));</span>
            // If a closure, the next is simply a return from the closure!
<span class="pc bpc" id="L2704" title="1 of 2 branches missed.">            if (s instanceof IRClosure) addInstr(s, new ReturnInstr(rv));</span>
<span class="nc" id="L2705">            else addInstr(s, new ThrowExceptionInstr(IRException.NEXT_LocalJumpError));</span>
        }

        // Once the &quot;next instruction&quot; (closure-return) executes, control exits this scope
<span class="fc" id="L2709">        return U_NIL;</span>
    }

    public Operand buildNthRef(NthRefNode nthRefNode, IRScope s) {
<span class="fc" id="L2713">        return copyAndReturnValue(s, new NthRef(nthRefNode.getMatchNumber()));</span>
    }

    public Operand buildNil() {
<span class="fc" id="L2717">        return manager.getNil();</span>
    }

    public Operand buildOpAsgn(OpAsgnNode opAsgnNode, IRScope s) {
        Label l;
<span class="fc" id="L2722">        Variable readerValue = s.createTemporaryVariable();</span>
<span class="fc" id="L2723">        Variable writerValue = s.createTemporaryVariable();</span>

        // get attr
<span class="fc" id="L2726">        Operand  v1 = build(opAsgnNode.getReceiverNode(), s);</span>
<span class="fc" id="L2727">        addInstr(s, CallInstr.create(readerValue, opAsgnNode.getVariableName(), v1, NO_ARGS, null));</span>

        // Ex: e.val ||= n
        //     e.val &amp;&amp;= n
<span class="fc" id="L2731">        String opName = opAsgnNode.getOperatorName();</span>
<span class="pc bpc" id="L2732" title="1 of 4 branches missed.">        if (opName.equals(&quot;||&quot;) || opName.equals(&quot;&amp;&amp;&quot;)) {</span>
<span class="fc" id="L2733">            l = s.getNewLabel();</span>
<span class="pc bpc" id="L2734" title="1 of 2 branches missed.">            addInstr(s, BEQInstr.create(readerValue, opName.equals(&quot;||&quot;) ? manager.getTrue() : manager.getFalse(), l));</span>

            // compute value and set it
<span class="fc" id="L2737">            Operand  v2 = build(opAsgnNode.getValueNode(), s);</span>
<span class="fc" id="L2738">            addInstr(s, CallInstr.create(writerValue, opAsgnNode.getVariableNameAsgn(), v1, new Operand[] {v2}, null));</span>
            // It is readerValue = v2.
            // readerValue = writerValue is incorrect because the assignment method
            // might return something else other than the value being set!
<span class="fc" id="L2742">            addInstr(s, new CopyInstr(readerValue, v2));</span>
<span class="fc" id="L2743">            addInstr(s, new LabelInstr(l));</span>

<span class="fc" id="L2745">            return readerValue;</span>
        }
        // Ex: e.val = e.val.f(n)
        else {
            // call operator
<span class="fc" id="L2750">            Operand  v2 = build(opAsgnNode.getValueNode(), s);</span>
<span class="fc" id="L2751">            Variable setValue = s.createTemporaryVariable();</span>
<span class="fc" id="L2752">            addInstr(s, CallInstr.create(setValue, opAsgnNode.getOperatorName(), readerValue, new Operand[]{v2}, null));</span>

            // set attr
<span class="fc" id="L2755">            addInstr(s, CallInstr.create(writerValue, opAsgnNode.getVariableNameAsgn(), v1, new Operand[] {setValue}, null));</span>
            // Returning writerValue is incorrect becuase the assignment method
            // might return something else other than the value being set!
<span class="fc" id="L2758">            return setValue;</span>
        }
    }

    // Translate &quot;x &amp;&amp;= y&quot; --&gt; &quot;x = y if is_true(x)&quot; --&gt;
    //
    //    x = -- build(x) should return a variable! --
    //    f = is_true(x)
    //    beq(f, false, L)
    //    x = -- build(y) --
    // L:
    //
    public Operand buildOpAsgnAnd(OpAsgnAndNode andNode, IRScope s) {
<span class="fc" id="L2771">        Label    l  = s.getNewLabel();</span>
<span class="fc" id="L2772">        Operand  v1 = build(andNode.getFirstNode(), s);</span>
<span class="fc" id="L2773">        Variable result = getValueInTemporaryVariable(s, v1);</span>
<span class="fc" id="L2774">        addInstr(s, BEQInstr.create(v1, manager.getFalse(), l));</span>
<span class="fc" id="L2775">        Operand v2 = build(andNode.getSecondNode(), s);  // This does the assignment!</span>
<span class="fc" id="L2776">        addInstr(s, new CopyInstr(result, v2));</span>
<span class="fc" id="L2777">        addInstr(s, new LabelInstr(l));</span>
<span class="fc" id="L2778">        return result;</span>
    }

    // &quot;x ||= y&quot;
    // --&gt; &quot;x = (is_defined(x) &amp;&amp; is_true(x) ? x : y)&quot;
    // --&gt; v = -- build(x) should return a variable! --
    //     f = is_true(v)
    //     beq(f, true, L)
    //     -- build(x = y) --
    //   L:
    //
    public Operand buildOpAsgnOr(final OpAsgnOrNode orNode, IRScope s) {
<span class="fc" id="L2790">        Label    l1 = s.getNewLabel();</span>
<span class="fc" id="L2791">        Label    l2 = null;</span>
<span class="fc" id="L2792">        Variable flag = s.createTemporaryVariable();</span>
        Operand  v1;
<span class="fc" id="L2794">        boolean  needsDefnCheck = orNode.getFirstNode().needsDefinitionCheck();</span>
<span class="fc bfc" id="L2795" title="All 2 branches covered.">        if (needsDefnCheck) {</span>
<span class="fc" id="L2796">            l2 = s.getNewLabel();</span>
<span class="fc" id="L2797">            v1 = buildGetDefinition(orNode.getFirstNode(), s);</span>
<span class="fc" id="L2798">            addInstr(s, new CopyInstr(flag, v1));</span>
<span class="fc" id="L2799">            addInstr(s, BEQInstr.create(flag, manager.getNil(), l2)); // if v1 is undefined, go to v2's computation</span>
        }
<span class="fc" id="L2801">        v1 = build(orNode.getFirstNode(), s); // build of 'x'</span>
<span class="fc" id="L2802">        addInstr(s, new CopyInstr(flag, v1));</span>
<span class="fc" id="L2803">        Variable result = getValueInTemporaryVariable(s, v1);</span>
<span class="fc bfc" id="L2804" title="All 2 branches covered.">        if (needsDefnCheck) {</span>
<span class="fc" id="L2805">            addInstr(s, new LabelInstr(l2));</span>
        }
<span class="fc" id="L2807">        addInstr(s, BEQInstr.create(flag, manager.getTrue(), l1));  // if v1 is defined and true, we are done!</span>
<span class="fc" id="L2808">        Operand v2 = build(orNode.getSecondNode(), s); // This is an AST node that sets x = y, so nothing special to do here.</span>
<span class="fc" id="L2809">        addInstr(s, new CopyInstr(result, v2));</span>
<span class="fc" id="L2810">        addInstr(s, new LabelInstr(l1));</span>

        // Return value of x ||= y is always 'x'
<span class="fc" id="L2813">        return result;</span>
    }

    public Operand buildOpElementAsgn(OpElementAsgnNode node, IRScope s) {
<span class="fc bfc" id="L2817" title="All 2 branches covered.">        if (node.isOr()) return buildOpElementAsgnWithOr(node, s);</span>
<span class="fc bfc" id="L2818" title="All 2 branches covered.">        if (node.isAnd()) return buildOpElementAsgnWithAnd(node, s);</span>

<span class="fc" id="L2820">        return buildOpElementAsgnWithMethod(node, s);</span>
    }

    // Translate &quot;a[x] ||= n&quot; --&gt; &quot;a[x] = n if !is_true(a[x])&quot;
    //
    //    tmp = build(a) &lt;-- receiver
    //    arg = build(x) &lt;-- args
    //    val = buildCall([], tmp, arg)
    //    f = is_true(val)
    //    beq(f, true, L)
    //    val = build(n) &lt;-- val
    //    buildCall([]= tmp, arg, val)
    // L:
    //
    public Operand buildOpElementAsgnWithOr(OpElementAsgnNode opElementAsgnNode, IRScope s) {
<span class="fc" id="L2835">        Operand array = build(opElementAsgnNode.getReceiverNode(), s);</span>
<span class="fc" id="L2836">        Label    l     = s.getNewLabel();</span>
<span class="fc" id="L2837">        Variable elt   = s.createTemporaryVariable();</span>
<span class="fc" id="L2838">        Operand[] argList = setupCallArgs(opElementAsgnNode.getArgsNode(), s);</span>
<span class="fc" id="L2839">        addInstr(s, CallInstr.create(elt, &quot;[]&quot;, array, argList, null));</span>
<span class="fc" id="L2840">        addInstr(s, BEQInstr.create(elt, manager.getTrue(), l));</span>
<span class="fc" id="L2841">        Operand value = build(opElementAsgnNode.getValueNode(), s);</span>
<span class="fc" id="L2842">        argList = addArg(argList, value);</span>
<span class="fc" id="L2843">        addInstr(s, CallInstr.create(elt, &quot;[]=&quot;, array, argList, null));</span>
<span class="fc" id="L2844">        addInstr(s, new CopyInstr(elt, value));</span>
<span class="fc" id="L2845">        addInstr(s, new LabelInstr(l));</span>
<span class="fc" id="L2846">        return elt;</span>
    }

    // Translate &quot;a[x] &amp;&amp;= n&quot; --&gt; &quot;a[x] = n if is_true(a[x])&quot;
    public Operand buildOpElementAsgnWithAnd(OpElementAsgnNode opElementAsgnNode, IRScope s) {
<span class="fc" id="L2851">        Operand array = build(opElementAsgnNode.getReceiverNode(), s);</span>
<span class="fc" id="L2852">        Label    l     = s.getNewLabel();</span>
<span class="fc" id="L2853">        Variable elt   = s.createTemporaryVariable();</span>
<span class="fc" id="L2854">        Operand[] argList = setupCallArgs(opElementAsgnNode.getArgsNode(), s);</span>
<span class="fc" id="L2855">        addInstr(s, CallInstr.create(elt, &quot;[]&quot;, array, argList, null));</span>
<span class="fc" id="L2856">        addInstr(s, BEQInstr.create(elt, manager.getFalse(), l));</span>
<span class="fc" id="L2857">        Operand value = build(opElementAsgnNode.getValueNode(), s);</span>

<span class="fc" id="L2859">        argList = addArg(argList, value);</span>
<span class="fc" id="L2860">        addInstr(s, CallInstr.create(elt, &quot;[]=&quot;, array, argList, null));</span>
<span class="fc" id="L2861">        addInstr(s, new CopyInstr(elt, value));</span>
<span class="fc" id="L2862">        addInstr(s, new LabelInstr(l));</span>
<span class="fc" id="L2863">        return elt;</span>
    }

    // a[i] *= n, etc.  anything that is not &quot;a[i] &amp;&amp;= .. or a[i] ||= ..&quot;
    //    arr = build(a) &lt;-- receiver
    //    arg = build(x) &lt;-- args
    //    elt = buildCall([], arr, arg)
    //    val = build(n) &lt;-- val
    //    val = buildCall(METH, elt, val)
    //    val = buildCall([]=, arr, arg, val)
    public Operand buildOpElementAsgnWithMethod(OpElementAsgnNode opElementAsgnNode, IRScope s) {
<span class="fc" id="L2874">        Operand array = build(opElementAsgnNode.getReceiverNode(), s);</span>
<span class="fc" id="L2875">        Operand[] argList = setupCallArgs(opElementAsgnNode.getArgsNode(), s);</span>
<span class="fc" id="L2876">        Variable elt = s.createTemporaryVariable();</span>
<span class="fc" id="L2877">        addInstr(s, CallInstr.create(elt, &quot;[]&quot;, array, argList, null)); // elt = a[args]</span>
<span class="fc" id="L2878">        Operand value = build(opElementAsgnNode.getValueNode(), s);                                       // Load 'value'</span>
<span class="fc" id="L2879">        String  operation = opElementAsgnNode.getOperatorName();</span>
<span class="fc" id="L2880">        addInstr(s, CallInstr.create(elt, operation, elt, new Operand[] { value }, null)); // elt = elt.OPERATION(value)</span>
        // SSS: do not load the call result into 'elt' to eliminate the RAW dependency on the call
        // We already know what the result is going be .. we are just storing it back into the array
<span class="fc" id="L2883">        Variable tmp = s.createTemporaryVariable();</span>
<span class="fc" id="L2884">        argList = addArg(argList, elt);</span>
<span class="fc" id="L2885">        addInstr(s, CallInstr.create(tmp, &quot;[]=&quot;, array, argList, null));   // a[args] = elt</span>
<span class="fc" id="L2886">        return elt;</span>
    }

    // Translate ret = (a || b) to ret = (a ? true : b) as follows
    //
    //    v1 = -- build(a) --
    //       OPT: ret can be set to v1, but effectively v1 is true if we take the branch to L.
    //            while this info can be inferred by using attributes, why bother if we can do this?
    //    ret = v1
    //    beq(v1, true, L)
    //    v2 = -- build(b) --
    //    ret = v2
    // L:
    //
    public Operand buildOr(final OrNode orNode, IRScope s) {
<span class="fc bfc" id="L2901" title="All 2 branches covered.">        if (orNode.getFirstNode().getNodeType().alwaysTrue()) {</span>
            // build first node only and return true
<span class="fc" id="L2903">            return build(orNode.getFirstNode(), s);</span>
<span class="fc bfc" id="L2904" title="All 2 branches covered.">        } else if (orNode.getFirstNode().getNodeType().alwaysFalse()) {</span>
            // build first node as non-expr and build second node
<span class="fc" id="L2906">            build(orNode.getFirstNode(), s);</span>
<span class="fc" id="L2907">            return build(orNode.getSecondNode(), s);</span>
        } else {
<span class="fc" id="L2909">            Label    l   = s.getNewLabel();</span>
<span class="fc" id="L2910">            Operand  v1  = build(orNode.getFirstNode(), s);</span>
<span class="fc" id="L2911">            Variable ret = getValueInTemporaryVariable(s, v1);</span>
<span class="fc" id="L2912">            addInstr(s, BEQInstr.create(v1, manager.getTrue(), l));</span>
<span class="fc" id="L2913">            Operand  v2  = build(orNode.getSecondNode(), s);</span>
<span class="fc" id="L2914">            addInstr(s, new CopyInstr(ret, v2));</span>
<span class="fc" id="L2915">            addInstr(s, new LabelInstr(l));</span>
<span class="fc" id="L2916">            return ret;</span>
        }
    }

    public Operand buildPostExe(PostExeNode postExeNode, IRScope s) {
<span class="nc" id="L2921">        IRScope topLevel = s.getTopLevelScope();</span>
<span class="nc" id="L2922">        IRScope nearestLVarScope = s.getNearestTopLocalVariableScope();</span>

<span class="nc" id="L2924">        IRClosure endClosure = new IRClosure(manager, s, postExeNode.getPosition().getLine(), nearestLVarScope.getStaticScope(), Arity.procArityOf(postExeNode.getVarNode()), postExeNode.getArgumentType(), &quot;_END_&quot;, true);</span>
        // Create a new nested builder to ensure this gets its own IR builder state
        // like the ensure block stack
<span class="nc" id="L2927">        IRBuilder closureBuilder = newIRBuilder(manager);</span>

        // Set up %current_scope and %current_module
<span class="nc" id="L2930">        closureBuilder.addInstr(endClosure, new CopyInstr(endClosure.getCurrentScopeVariable(), CURRENT_SCOPE[0]));</span>
<span class="nc" id="L2931">        closureBuilder.addInstr(endClosure, new CopyInstr(endClosure.getCurrentModuleVariable(), SCOPE_MODULE[0]));</span>
<span class="nc" id="L2932">        closureBuilder.build(postExeNode.getBodyNode(), endClosure);</span>

        // END does not have either explicit or implicit return, so we add one
<span class="nc" id="L2935">        closureBuilder.addInstr(endClosure, new ReturnInstr(new Nil()));</span>

        // Add an instruction in 's' to record the end block in the 'topLevel' scope.
        // SSS FIXME: IR support for end-blocks that access vars in non-toplevel-scopes
        // might be broken currently. We could either fix it or consider dropping support
        // for END blocks altogether or only support them in the toplevel. Not worth the pain.
<span class="nc" id="L2941">        addInstr(s, new RecordEndBlockInstr(topLevel, new WrappedIRClosure(s.getSelf(), endClosure)));</span>
<span class="nc" id="L2942">        return manager.getNil();</span>
    }

    public Operand buildPreExe(PreExeNode preExeNode, IRScope s) {
<span class="fc" id="L2946">        IRClosure beginClosure = new IRFor(manager, s, preExeNode.getPosition().getLine(), s.getTopLevelScope().getStaticScope(), Arity.procArityOf(preExeNode.getVarNode()), preExeNode.getArgumentType(), &quot;_BEGIN_&quot;);</span>
        // Create a new nested builder to ensure this gets its own IR builder state
        // like the ensure block stack
<span class="fc" id="L2949">        IRBuilder closureBuilder = newIRBuilder(manager);</span>

        // Set up %current_scope and %current_module
<span class="fc" id="L2952">        closureBuilder.addInstr(beginClosure, new CopyInstr(beginClosure.getCurrentScopeVariable(), CURRENT_SCOPE[0]));</span>
<span class="fc" id="L2953">        closureBuilder.addInstr(beginClosure, new CopyInstr(beginClosure.getCurrentModuleVariable(), SCOPE_MODULE[0]));</span>
<span class="fc" id="L2954">        closureBuilder.build(preExeNode.getBodyNode(), beginClosure);</span>

        // BEGIN does not have either explicit or implicit return, so we add one
<span class="fc" id="L2957">        closureBuilder.addInstr(beginClosure, new ReturnInstr(new Nil()));</span>

        // Record the begin block at IR build time
<span class="fc" id="L2960">        s.getTopLevelScope().recordBeginBlock(beginClosure);</span>
<span class="fc" id="L2961">        return manager.getNil();</span>
    }

    public Operand buildRational(RationalNode rationalNode) {
<span class="fc" id="L2965">        return new Rational(rationalNode.getNumerator(), rationalNode.getDenominator());</span>
    }

    public Operand buildRedo(IRScope s) {
        // If in a loop, a redo is a jump to the beginning of the loop.
        // If not, for closures, a redo is a jump to the beginning of the closure.
        // If not in a loop or a closure, it is a local jump error
<span class="fc" id="L2972">        IRLoop currLoop = getCurrentLoop();</span>
<span class="fc bfc" id="L2973" title="All 2 branches covered.">        if (currLoop != null) {</span>
<span class="fc" id="L2974">             addInstr(s, new JumpInstr(currLoop.iterStartLabel));</span>
        } else {
<span class="pc bpc" id="L2976" title="1 of 2 branches missed.">            if (s instanceof IRClosure) {</span>
<span class="fc" id="L2977">                addInstr(s, new ThreadPollInstr(true));</span>
<span class="fc" id="L2978">                addInstr(s, new JumpInstr(((IRClosure)s).startLabel));</span>
            } else {
<span class="nc" id="L2980">                addInstr(s, new ThrowExceptionInstr(IRException.REDO_LocalJumpError));</span>
            }
        }
<span class="fc" id="L2983">        return manager.getNil();</span>
    }

    public Operand buildRegexp(RegexpNode reNode, IRScope s) {
        // SSS FIXME: Rather than throw syntax error at runtime, we should detect
        // regexp syntax errors at build time and add an exception-throwing instruction instead
<span class="fc" id="L2989">        return copyAndReturnValue(s, new Regexp(new StringLiteral(reNode.getValue()), reNode.getOptions()));</span>
    }

    public Operand buildRescue(RescueNode node, IRScope s) {
<span class="fc" id="L2993">        return buildRescueInternal(node, s, null);</span>
    }

    private Operand buildRescueInternal(RescueNode rescueNode, IRScope s, EnsureBlockInfo ensure) {
        // Labels marking start, else, end of the begin-rescue(-ensure)-end block
<span class="fc bfc" id="L2998" title="All 2 branches covered.">        Label rBeginLabel = ensure == null ? s.getNewLabel() : ensure.regionStart;</span>
<span class="fc bfc" id="L2999" title="All 2 branches covered.">        Label rEndLabel   = ensure == null ? s.getNewLabel() : ensure.end;</span>
<span class="fc" id="L3000">        Label rescueLabel = s.getNewLabel(); // Label marking start of the first rescue code.</span>

        // Save $! in a temp var so it can be restored when the exception gets handled.
<span class="fc" id="L3003">        Variable savedGlobalException = s.createTemporaryVariable();</span>
<span class="fc" id="L3004">        addInstr(s, new GetGlobalVariableInstr(savedGlobalException, &quot;$!&quot;));</span>
<span class="fc bfc" id="L3005" title="All 2 branches covered.">        if (ensure != null) ensure.savedGlobalException = savedGlobalException;</span>

<span class="fc" id="L3007">        addInstr(s, new LabelInstr(rBeginLabel));</span>

        // Placeholder rescue instruction that tells rest of the compiler passes the boundaries of the rescue block.
<span class="fc" id="L3010">        addInstr(s, new ExceptionRegionStartMarkerInstr(rescueLabel));</span>
<span class="fc" id="L3011">        activeRescuers.push(rescueLabel);</span>

        // Body
<span class="fc" id="L3014">        Operand tmp = manager.getNil();  // default return value if for some strange reason, we neither have the body node or the else node!</span>
<span class="fc" id="L3015">        Variable rv = s.createTemporaryVariable();</span>
<span class="pc bpc" id="L3016" title="1 of 2 branches missed.">        if (rescueNode.getBodyNode() != null) tmp = build(rescueNode.getBodyNode(), s);</span>

        // Push rescue block *after* body has been built.
        // If not, this messes up generation of retry in these scenarios like this:
        //
        //     begin    -- 1
        //       ...
        //     rescue
        //       begin  -- 2
        //         ...
        //         retry
        //       rescue
        //         ...
        //       end
        //     end
        //
        // The retry should jump to 1, not 2.
        // If we push the rescue block before building the body, we will jump to 2.
<span class="fc" id="L3034">        RescueBlockInfo rbi = new RescueBlockInfo(rescueNode, rBeginLabel, savedGlobalException, getCurrentLoop());</span>
<span class="fc" id="L3035">        activeRescueBlockStack.push(rbi);</span>

        // Since rescued regions are well nested within Ruby, this bare marker is sufficient to
        // let us discover the edge of the region during linear traversal of instructions during cfg construction.
<span class="fc" id="L3039">        addInstr(s, new ExceptionRegionEndMarkerInstr());</span>
<span class="fc" id="L3040">        activeRescuers.pop();</span>

        // Else part of the body -- we simply fall through from the main body if there were no exceptions
<span class="fc bfc" id="L3043" title="All 2 branches covered.">        Label elseLabel = rescueNode.getElseNode() == null ? null : s.getNewLabel();</span>
<span class="fc bfc" id="L3044" title="All 2 branches covered.">        if (elseLabel != null) {</span>
<span class="fc" id="L3045">            addInstr(s, new LabelInstr(elseLabel));</span>
<span class="fc" id="L3046">            tmp = build(rescueNode.getElseNode(), s);</span>
        }

<span class="fc bfc" id="L3049" title="All 2 branches covered.">        if (tmp != U_NIL) {</span>
<span class="fc" id="L3050">            addInstr(s, new CopyInstr(rv, tmp));</span>

            // No explicit return from the protected body
            // - If we dont have any ensure blocks, simply jump to the end of the rescue block
            // - If we do, execute the ensure code.
<span class="fc bfc" id="L3055" title="All 2 branches covered.">            if (ensure != null) {</span>
<span class="fc" id="L3056">                ensure.cloneIntoHostScope(this, s);</span>
            }
<span class="fc" id="L3058">            addInstr(s, new JumpInstr(rEndLabel));</span>
        }   //else {
            // If the body had an explicit return, the return instruction IR build takes care of setting
            // up execution of all necessary ensure blocks.  So, nothing to do here!
            //
            // Additionally, the value in 'rv' will never be used, so need to set it to any specific value.
            // So, we can leave it undefined.  If on the other hand, there was an exception in that block,
            // 'rv' will get set in the rescue handler -- see the 'rv' being passed into
            // buildRescueBodyInternal below.  So, in either case, we are good!
            //}

        // Start of rescue logic
<span class="fc" id="L3070">        addInstr(s, new LabelInstr(rescueLabel));</span>

        // Save off exception &amp; exception comparison type
<span class="fc" id="L3073">        Variable exc = addResultInstr(s, new ReceiveRubyExceptionInstr(s.createTemporaryVariable()));</span>

        // Build the actual rescue block(s)
<span class="fc" id="L3076">        buildRescueBodyInternal(s, rescueNode.getRescueNode(), rv, exc, rEndLabel);</span>

        // End label -- only if there is no ensure block!  With an ensure block, you end at ensureEndLabel.
<span class="fc bfc" id="L3079" title="All 2 branches covered.">        if (ensure == null) addInstr(s, new LabelInstr(rEndLabel));</span>

<span class="fc" id="L3081">        activeRescueBlockStack.pop();</span>
<span class="fc" id="L3082">        return rv;</span>
    }

    private void outputExceptionCheck(IRScope s, Operand excType, Operand excObj, Label caughtLabel) {
<span class="fc" id="L3086">        Variable eqqResult = addResultInstr(s, new RescueEQQInstr(s.createTemporaryVariable(), excType, excObj));</span>
<span class="fc" id="L3087">        addInstr(s, BEQInstr.create(eqqResult, manager.getTrue(), caughtLabel));</span>
<span class="fc" id="L3088">    }</span>

    private void buildRescueBodyInternal(IRScope s, RescueBodyNode rescueBodyNode, Variable rv, Variable exc, Label endLabel) {
<span class="fc" id="L3091">        final Node exceptionList = rescueBodyNode.getExceptionNodes();</span>

        // Compare and branch as necessary!
<span class="fc" id="L3094">        Label uncaughtLabel = s.getNewLabel();</span>
<span class="fc" id="L3095">        Label caughtLabel = s.getNewLabel();</span>
<span class="fc bfc" id="L3096" title="All 2 branches covered.">        if (exceptionList != null) {</span>
<span class="fc bfc" id="L3097" title="All 2 branches covered.">            if (exceptionList instanceof ListNode) {</span>
<span class="fc" id="L3098">                List&lt;Operand&gt; excTypes = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L3099" title="All 2 branches covered.">                for (Node excType : exceptionList.childNodes()) {</span>
<span class="fc" id="L3100">                    excTypes.add(build(excType, s));</span>
<span class="fc" id="L3101">                }</span>
<span class="fc" id="L3102">                outputExceptionCheck(s, new Array(excTypes), exc, caughtLabel);</span>
<span class="pc bpc" id="L3103" title="1 of 2 branches missed.">            } else if (exceptionList instanceof SplatNode) { // splatnode, catch</span>
<span class="fc" id="L3104">                outputExceptionCheck(s, build(((SplatNode)exceptionList).getValue(), s), exc, caughtLabel);</span>
            } else { // argscat/argspush
<span class="nc" id="L3106">                outputExceptionCheck(s, build(exceptionList, s), exc, caughtLabel);</span>
            }
        } else {
            // SSS FIXME:
            // rescue =&gt; e AND rescue implicitly EQQ the exception object with StandardError
            // We generate explicit IR for this test here.  But, this can lead to inconsistent
            // behavior (when compared to MRI) in certain scenarios.  See example:
            //
            //   self.class.const_set(:StandardError, 1)
            //   begin; raise TypeError.new; rescue; puts &quot;AHA&quot;; end
            //
            // MRI rescues the error, but we will raise an exception because of reassignment
            // of StandardError.  I am ignoring this for now and treating this as undefined behavior.
            //
            // Solution: Create a 'StandardError' operand type to eliminate this.
<span class="fc" id="L3121">            Variable v = addResultInstr(s, new InheritanceSearchConstInstr(s.createTemporaryVariable(), s.getCurrentModuleVariable(), &quot;StandardError&quot;, false));</span>
<span class="fc" id="L3122">            outputExceptionCheck(s, v, exc, caughtLabel);</span>
        }

        // Uncaught exception -- build other rescue nodes or rethrow!
<span class="fc" id="L3126">        addInstr(s, new LabelInstr(uncaughtLabel));</span>
<span class="fc bfc" id="L3127" title="All 2 branches covered.">        if (rescueBodyNode.getOptRescueNode() != null) {</span>
<span class="fc" id="L3128">            buildRescueBodyInternal(s, rescueBodyNode.getOptRescueNode(), rv, exc, endLabel);</span>
        } else {
<span class="fc" id="L3130">            addInstr(s, new ThrowExceptionInstr(exc));</span>
        }

        // Caught exception case -- build rescue body
<span class="fc" id="L3134">        addInstr(s, new LabelInstr(caughtLabel));</span>
<span class="fc" id="L3135">        Node realBody = skipOverNewlines(s, rescueBodyNode.getBodyNode());</span>
<span class="fc" id="L3136">        Operand x = build(realBody, s);</span>
<span class="fc bfc" id="L3137" title="All 2 branches covered.">        if (x != U_NIL) { // can be U_NIL if the rescue block has an explicit return</span>
            // Restore &quot;$!&quot;
<span class="fc" id="L3139">            RescueBlockInfo rbi = activeRescueBlockStack.peek();</span>
<span class="fc" id="L3140">            addInstr(s, new PutGlobalVarInstr(&quot;$!&quot;, rbi.savedExceptionVariable));</span>

            // Set up node return value 'rv'
<span class="fc" id="L3143">            addInstr(s, new CopyInstr(rv, x));</span>

            // If we have a matching ensure block, clone it so ensure block runs here
<span class="pc bpc" id="L3146" title="1 of 4 branches missed.">            if (!activeEnsureBlockStack.empty() &amp;&amp; rbi.rescueNode == activeEnsureBlockStack.peek().matchingRescueNode) {</span>
<span class="fc" id="L3147">                activeEnsureBlockStack.peek().cloneIntoHostScope(this, s);</span>
            }
<span class="fc" id="L3149">            addInstr(s, new JumpInstr(endLabel));</span>
        }
<span class="fc" id="L3151">    }</span>

    public Operand buildRetry(IRScope s) {
        // JRuby only supports retry when present in rescue blocks!
        // 1.9 doesn't support retry anywhere else.

        // Jump back to the innermost rescue block
        // We either find it, or we add code to throw a runtime exception
<span class="pc bpc" id="L3159" title="1 of 2 branches missed.">        if (activeRescueBlockStack.empty()) {</span>
<span class="nc" id="L3160">            addInstr(s, new ThrowExceptionInstr(IRException.RETRY_LocalJumpError));</span>
        } else {
<span class="fc" id="L3162">            addInstr(s, new ThreadPollInstr(true));</span>
            // Restore $! and jump back to the entry of the rescue block
<span class="fc" id="L3164">            RescueBlockInfo rbi = activeRescueBlockStack.peek();</span>
<span class="fc" id="L3165">            addInstr(s, new PutGlobalVarInstr(&quot;$!&quot;, rbi.savedExceptionVariable));</span>
<span class="fc" id="L3166">            addInstr(s, new JumpInstr(rbi.entryLabel));</span>
            // Retries effectively create a loop
<span class="fc" id="L3168">            s.setHasLoopsFlag();</span>
        }
<span class="fc" id="L3170">        return manager.getNil();</span>
    }

    private Operand processEnsureRescueBlocks(IRScope s, Operand retVal) { 
        // Before we return,
        // - have to go execute all the ensure blocks if there are any.
        //   this code also takes care of resetting &quot;$!&quot;
        // - if we have a rescue block, reset &quot;$!&quot;.
<span class="fc bfc" id="L3178" title="All 2 branches covered.">        if (!activeEnsureBlockStack.empty()) {</span>
<span class="fc" id="L3179">            retVal = addResultInstr(s, new CopyInstr(s.createTemporaryVariable(), retVal));</span>
<span class="fc" id="L3180">            emitEnsureBlocks(s, null);</span>
<span class="fc bfc" id="L3181" title="All 2 branches covered.">        } else if (!activeRescueBlockStack.empty()) {</span>
            // Restore $!
<span class="fc" id="L3183">            RescueBlockInfo rbi = activeRescueBlockStack.peek();</span>
<span class="fc" id="L3184">            addInstr(s, new PutGlobalVarInstr(&quot;$!&quot;, rbi.savedExceptionVariable));</span>
        }
<span class="fc" id="L3186">       return retVal;</span>
    }

    public Operand buildReturn(ReturnNode returnNode, IRScope s) {
<span class="pc bpc" id="L3190" title="1 of 2 branches missed.">        Operand retVal = (returnNode.getValueNode() == null) ? manager.getNil() : build(returnNode.getValueNode(), s);</span>

<span class="fc bfc" id="L3192" title="All 2 branches covered.">        if (s instanceof IRClosure) {</span>
            // If 'm' is a block scope, a return returns from the closest enclosing method.
            // If this happens to be a module body, the runtime throws a local jump error if the
            // closure is a proc. If the closure is a lambda, then this becomes a normal return.
<span class="fc" id="L3196">            IRMethod m = s.getNearestMethod();</span>
<span class="fc bfc" id="L3197" title="All 2 branches covered.">            addInstr(s, new RuntimeHelperCall(null, CHECK_FOR_LJE, new Operand[] { new Boolean(m == null) }));</span>
<span class="fc" id="L3198">            retVal = processEnsureRescueBlocks(s, retVal);</span>
<span class="fc bfc" id="L3199" title="All 2 branches covered.">            addInstr(s, new NonlocalReturnInstr(retVal, m == null ? &quot;--none--&quot; : m.getName()));</span>
<span class="fc bfc" id="L3200" title="All 2 branches covered.">        } else if (s.isModuleBody()) {</span>
<span class="fc" id="L3201">            IRMethod sm = s.getNearestMethod();</span>

            // Cannot return from top-level module bodies!
<span class="pc bpc" id="L3204" title="1 of 2 branches missed.">            if (sm == null) addInstr(s, new ThrowExceptionInstr(IRException.RETURN_LocalJumpError));</span>
<span class="fc" id="L3205">            retVal = processEnsureRescueBlocks(s, retVal);</span>
<span class="pc bpc" id="L3206" title="1 of 2 branches missed.">            if (sm != null) addInstr(s, new NonlocalReturnInstr(retVal, sm.getName()));</span>
<span class="fc" id="L3207">        } else {</span>
<span class="fc" id="L3208">            retVal = processEnsureRescueBlocks(s, retVal);</span>
<span class="fc" id="L3209">            addInstr(s, new ReturnInstr(retVal));</span>
        }

        // The value of the return itself in the containing expression can never be used because of control-flow reasons.
        // The expression that uses this result can never be executed beyond the return and hence the value itself is just
        // a placeholder operand.
<span class="fc" id="L3215">        return U_NIL;</span>
    }

    public IREvalScript buildEvalRoot(StaticScope staticScope, IRScope containingScope, String file, int lineNumber, RootNode rootNode, EvalType evalType) {
        // Top-level script!
        IREvalScript script;

<span class="fc bfc" id="L3222" title="All 2 branches covered.">        if (evalType == EvalType.BINDING_EVAL) {</span>
<span class="fc" id="L3223">            script = new IRBindingEvalScript(manager, containingScope, file, lineNumber, staticScope, evalType);</span>
        } else {
<span class="fc" id="L3225">            script = new IREvalScript(manager, containingScope, file, lineNumber, staticScope, evalType);</span>
        }

        // We link IRScope to StaticScope because we may add additional variables (like %block).  During execution
        // we end up growing dynamicscope potentially based on any changes made.
<span class="fc" id="L3230">        staticScope.setIRScope(script);</span>

        // Debug info: record line number
<span class="fc" id="L3233">        addInstr(script, new LineNumberInstr(lineNumber));</span>

        // Set %current_scope = &lt;current-scope&gt;
        // Set %current_module = &lt;current-module&gt;
<span class="fc" id="L3237">        addInstr(script, new CopyInstr(script.getCurrentScopeVariable(), CURRENT_SCOPE[0]));</span>
<span class="fc" id="L3238">        addInstr(script, new CopyInstr(script.getCurrentModuleVariable(), SCOPE_MODULE[0]));</span>
        // Build IR for the tree and return the result of the expression tree
<span class="pc bpc" id="L3240" title="1 of 2 branches missed.">        Operand rval = rootNode.getBodyNode() == null ? manager.getNil() : build(rootNode.getBodyNode(), script);</span>
<span class="fc" id="L3241">        addInstr(script, new ReturnInstr(rval));</span>

<span class="fc" id="L3243">        return script;</span>
    }

    public IRScriptBody buildRoot(RootNode rootNode) {
<span class="fc" id="L3247">        String file = rootNode.getPosition().getFile();</span>
<span class="fc" id="L3248">        StaticScope staticScope = rootNode.getStaticScope();</span>

        // Top-level script!
<span class="fc" id="L3251">        IRScriptBody script = new IRScriptBody(manager, file, staticScope);</span>
<span class="fc" id="L3252">        addInstr(script, new ReceiveSelfInstr(script.getSelf()));</span>
        // Set %current_scope = &lt;current-scope&gt;
        // Set %current_module = &lt;current-module&gt;
<span class="fc" id="L3255">        addInstr(script, new CopyInstr(script.getCurrentScopeVariable(), CURRENT_SCOPE[0]));</span>
<span class="fc" id="L3256">        addInstr(script, new CopyInstr(script.getCurrentModuleVariable(), SCOPE_MODULE[0]));</span>

        // Build IR for the tree and return the result of the expression tree
<span class="fc" id="L3259">        addInstr(script, new ReturnInstr(build(rootNode.getBodyNode(), script)));</span>

<span class="fc" id="L3261">        return script;</span>
    }

    public Operand buildSelf(IRScope s) {
<span class="fc" id="L3265">        return s.getSelf();</span>
    }

    public Operand buildSplat(SplatNode splatNode, IRScope s) {
        // SSS: Since splats can only occur in call argument lists, no need to copyAndReturnValue(...)
        // Verify with Tom / Charlie
<span class="fc" id="L3271">        return new Splat(build(splatNode.getValue(), s));</span>
    }

    public Operand buildStr(StrNode strNode, IRScope s) {
<span class="fc" id="L3275">        return copyAndReturnValue(s, new StringLiteral(strNode.getValue(), strNode.getCodeRange()));</span>
    }

    private Operand buildSuperInstr(IRScope s, Operand block, Operand[] args) {
        CallInstr superInstr;
<span class="fc" id="L3280">        Variable ret = s.createTemporaryVariable();</span>
<span class="fc bfc" id="L3281" title="All 4 branches covered.">        if ((s instanceof IRMethod) &amp;&amp; (s.getLexicalParent() instanceof IRClassBody)) {</span>
<span class="fc" id="L3282">            IRMethod m = (IRMethod)s;</span>
<span class="fc bfc" id="L3283" title="All 2 branches covered.">            if (m.isInstanceMethod) {</span>
<span class="fc" id="L3284">                superInstr = new InstanceSuperInstr(ret, s.getCurrentModuleVariable(), s.getName(), args, block);</span>
            } else {
<span class="fc" id="L3286">                superInstr = new ClassSuperInstr(ret, s.getCurrentModuleVariable(), s.getName(), args, block);</span>
            }
<span class="fc" id="L3288">        } else {</span>
            // We dont always know the method name we are going to be invoking if the super occurs in a closure.
            // This is because the super can be part of a block that will be used by 'define_method' to define
            // a new method.  In that case, the method called by super will be determined by the 'name' argument
            // to 'define_method'.
<span class="fc" id="L3293">            superInstr = new UnresolvedSuperInstr(ret, s.getSelf(), args, block);</span>
        }
<span class="fc" id="L3295">        receiveBreakException(s, block, superInstr);</span>
<span class="fc" id="L3296">        return ret;</span>
    }

    public Operand buildSuper(SuperNode superNode, IRScope s) {
<span class="pc bpc" id="L3300" title="1 of 2 branches missed.">        if (s.isModuleBody()) return buildSuperInScriptBody(s);</span>

<span class="fc" id="L3302">        Operand[] args = setupCallArgs(superNode.getArgsNode(), s);</span>
<span class="fc" id="L3303">        Operand block = setupCallClosure(superNode.getIterNode(), s);</span>
<span class="fc bfc" id="L3304" title="All 2 branches covered.">        if (block == null) block = getImplicitBlockArg(s);</span>
<span class="fc" id="L3305">        return buildSuperInstr(s, block, args);</span>
    }

    private Operand buildSuperInScriptBody(IRScope s) {
<span class="nc" id="L3309">        return addResultInstr(s, new UnresolvedSuperInstr(s.createTemporaryVariable(), s.getSelf(), NO_ARGS, null));</span>
    }

    public Operand buildSValue(SValueNode node, IRScope s) {
        // SSS FIXME: Required? Verify with Tom/Charlie
<span class="fc" id="L3314">        return copyAndReturnValue(s, new SValue(build(node.getValue(), s)));</span>
    }

    public Operand buildSymbol(SymbolNode node) {
        // SSS: Since symbols are interned objects, no need to copyAndReturnValue(...)
<span class="fc" id="L3319">        return new Symbol(node.getName(), node.getEncoding());</span>
    }

    public Operand buildTrue() {
<span class="fc" id="L3323">        return manager.getTrue();</span>
    }

    public Operand buildUndef(Node node, IRScope s) {
<span class="fc" id="L3327">        Operand methName = build(((UndefNode) node).getName(), s);</span>
<span class="fc" id="L3328">        return addResultInstr(s, new UndefMethodInstr(s.createTemporaryVariable(), methName));</span>
    }

    private Operand buildConditionalLoop(IRScope s, Node conditionNode,
            Node bodyNode, boolean isWhile, boolean isLoopHeadCondition) {
<span class="fc bfc" id="L3333" title="All 4 branches covered.">        if (isLoopHeadCondition &amp;&amp;</span>
<span class="fc bfc" id="L3334" title="All 4 branches covered.">                ((isWhile &amp;&amp; conditionNode.getNodeType().alwaysFalse()) ||</span>
<span class="fc bfc" id="L3335" title="All 2 branches covered.">                (!isWhile &amp;&amp; conditionNode.getNodeType().alwaysTrue()))) {</span>
            // we won't enter the loop -- just build the condition node
<span class="fc" id="L3337">            build(conditionNode, s);</span>
<span class="fc" id="L3338">            return manager.getNil();</span>
        } else {
<span class="fc" id="L3340">            IRLoop loop = new IRLoop(s, getCurrentLoop());</span>
<span class="fc" id="L3341">            Variable loopResult = loop.loopResult;</span>
<span class="fc" id="L3342">            Label setupResultLabel = s.getNewLabel();</span>

            // Push new loop
<span class="fc" id="L3345">            loopStack.push(loop);</span>

            // End of iteration jumps here
<span class="fc" id="L3348">            addInstr(s, new LabelInstr(loop.loopStartLabel));</span>
<span class="fc bfc" id="L3349" title="All 2 branches covered.">            if (isLoopHeadCondition) {</span>
<span class="fc" id="L3350">                Operand cv = build(conditionNode, s);</span>
<span class="fc bfc" id="L3351" title="All 2 branches covered.">                addInstr(s, BEQInstr.create(cv, isWhile ? manager.getFalse() : manager.getTrue(), setupResultLabel));</span>
            }

            // Redo jumps here
<span class="fc" id="L3355">            addInstr(s, new LabelInstr(loop.iterStartLabel));</span>

            // Thread poll at start of iteration -- ensures that redos and nexts run one thread-poll per iteration
<span class="fc" id="L3358">            addInstr(s, new ThreadPollInstr(true));</span>

            // Build body
<span class="pc bpc" id="L3361" title="1 of 2 branches missed.">            if (bodyNode != null) build(bodyNode, s);</span>

            // Next jumps here
<span class="fc" id="L3364">            addInstr(s, new LabelInstr(loop.iterEndLabel));</span>
<span class="fc bfc" id="L3365" title="All 2 branches covered.">            if (isLoopHeadCondition) {</span>
<span class="fc" id="L3366">                addInstr(s, new JumpInstr(loop.loopStartLabel));</span>
            } else {
<span class="fc" id="L3368">                Operand cv = build(conditionNode, s);</span>
<span class="fc bfc" id="L3369" title="All 2 branches covered.">                addInstr(s, BEQInstr.create(cv, isWhile ? manager.getTrue() : manager.getFalse(), loop.iterStartLabel));</span>
            }

            // Loop result -- nil always
<span class="fc" id="L3373">            addInstr(s, new LabelInstr(setupResultLabel));</span>
<span class="fc" id="L3374">            addInstr(s, new CopyInstr(loopResult, manager.getNil()));</span>

            // Loop end -- breaks jump here bypassing the result set up above
<span class="fc" id="L3377">            addInstr(s, new LabelInstr(loop.loopEndLabel));</span>

            // Done with loop
<span class="fc" id="L3380">            loopStack.pop();</span>

<span class="fc" id="L3382">            return loopResult;</span>
        }
    }

    public Operand buildUntil(final UntilNode untilNode, IRScope s) {
<span class="fc" id="L3387">        return buildConditionalLoop(s, untilNode.getConditionNode(), untilNode.getBodyNode(), false, untilNode.evaluateAtStart());</span>
    }

    public Operand buildVAlias(VAliasNode valiasNode, IRScope s) {
<span class="nc" id="L3391">        addInstr(s, new GVarAliasInstr(new StringLiteral(valiasNode.getNewName()), new StringLiteral(valiasNode.getOldName())));</span>

<span class="nc" id="L3393">        return manager.getNil();</span>
    }

    public Operand buildVCall(VCallNode node, IRScope s) {
<span class="fc" id="L3397">        return addResultInstr(s, CallInstr.create(CallType.VARIABLE, s.createTemporaryVariable(),</span>
<span class="fc" id="L3398">                node.getName(), s.getSelf(), NO_ARGS, null));</span>
    }

    public Operand buildWhile(final WhileNode whileNode, IRScope s) {
<span class="fc" id="L3402">        return buildConditionalLoop(s, whileNode.getConditionNode(), whileNode.getBodyNode(), true, whileNode.evaluateAtStart());</span>
    }

    public Operand buildXStr(XStrNode node, IRScope s) {
<span class="fc" id="L3406">        Variable res = s.createTemporaryVariable();</span>
<span class="fc" id="L3407">        addInstr(s, new BacktickInstr(res, new StringLiteral(node.getValue())));</span>
<span class="fc" id="L3408">        return res;</span>
    }

    public Operand buildYield(YieldNode node, IRScope s) {
<span class="fc" id="L3412">        boolean unwrap = true;</span>
<span class="fc" id="L3413">        Node argNode = node.getArgsNode();</span>
        // Get rid of one level of array wrapping
<span class="fc bfc" id="L3415" title="All 6 branches covered.">        if (argNode != null &amp;&amp; (argNode instanceof ArrayNode) &amp;&amp; ((ArrayNode)argNode).size() == 1) {</span>
<span class="fc" id="L3416">            argNode = ((ArrayNode)argNode).getLast();</span>
<span class="fc" id="L3417">            unwrap = false;</span>
        }

<span class="fc" id="L3420">        Variable ret = s.createTemporaryVariable();</span>
<span class="fc" id="L3421">        addInstr(s, new YieldInstr(ret, getImplicitBlockArg(s), build(argNode, s), unwrap));</span>
<span class="fc" id="L3422">        return ret;</span>
    }

    public Operand buildZArray(IRScope s) {
<span class="fc" id="L3426">       return copyAndReturnValue(s, new Array());</span>
    }

    private Operand buildZSuperIfNest(final IRScope s, final Operand block) {
        // If we are in a block, we cannot make any assumptions about what args
        // the super instr is going to get -- if there were no 'define_method'
        // for defining methods, we could guarantee that the super is going to
        // receive args from the nearest method the block is embedded in.  But,
        // in the presence of 'define_method' (and eval and aliasing), all bets
        // are off because, any of the intervening block scopes could be a method
        // via a define_method call.
        //
        // Instead, we can actually collect all arguments of all scopes from here
        // till the nearest method scope and select the right set at runtime based
        // on which one happened to be a method scope. This has the additional
        // advantage of making explicit all used arguments.
<span class="fc" id="L3442">        CodeBlock zsuperBuilder = new CodeBlock() {</span>
            public Operand run() {
<span class="fc" id="L3444">                Variable scopeDepth = s.createTemporaryVariable();</span>
<span class="fc" id="L3445">                addInstr(s, new ArgScopeDepthInstr(scopeDepth));</span>

<span class="fc" id="L3447">                Label allDoneLabel = s.getNewLabel();</span>

<span class="fc" id="L3449">                IRScope superScope = s;</span>
<span class="fc" id="L3450">                int depthFromSuper = 0;</span>
<span class="fc" id="L3451">                Label next = null;</span>

                // Loop and generate a block for each possible value of depthFromSuper
<span class="fc" id="L3454">                Variable zsuperResult = s.createTemporaryVariable();</span>
<span class="fc bfc" id="L3455" title="All 2 branches covered.">                while (superScope instanceof IRClosure) {</span>
                    // Generate the next set of instructions
<span class="fc bfc" id="L3457" title="All 2 branches covered.">                    if (next != null) addInstr(s, new LabelInstr(next));</span>
<span class="fc" id="L3458">                    next = s.getNewLabel();</span>
<span class="fc" id="L3459">                    addInstr(s, BNEInstr.create(new Fixnum(depthFromSuper), scopeDepth, next));</span>
<span class="fc" id="L3460">                    Operand[] args = adjustVariableDepth(((IRClosure)superScope).getBlockArgs(), depthFromSuper);</span>
<span class="fc" id="L3461">                    addInstr(s, new ZSuperInstr(zsuperResult, s.getSelf(), args,  block));</span>
<span class="fc" id="L3462">                    addInstr(s, new JumpInstr(allDoneLabel));</span>

                    // Move on
<span class="fc" id="L3465">                    superScope = superScope.getLexicalParent();</span>
<span class="fc" id="L3466">                    depthFromSuper++;</span>
<span class="fc" id="L3467">                }</span>

<span class="fc" id="L3469">                addInstr(s, new LabelInstr(next));</span>

                // If we hit a method, this is known to always succeed
<span class="fc bfc" id="L3472" title="All 2 branches covered.">                if (superScope instanceof IRMethod) {</span>
<span class="fc" id="L3473">                    Operand[] args = adjustVariableDepth(((IRMethod)superScope).getCallArgs(), depthFromSuper);</span>
<span class="fc" id="L3474">                    addInstr(s, new ZSuperInstr(zsuperResult, s.getSelf(), args, block));</span>
                } //else {
                // FIXME: Do or don't ... there is no try
                    /* Control should never get here in the runtime */
                    /* Should we add an exception throw here just in case? */
                //}

<span class="fc" id="L3481">                addInstr(s, new LabelInstr(allDoneLabel));</span>
<span class="fc" id="L3482">                return zsuperResult;</span>
            }
        };

<span class="fc" id="L3486">        return receiveBreakException(s, block, zsuperBuilder);</span>
    }

    public Operand buildZSuper(ZSuperNode zsuperNode, IRScope s) {
<span class="pc bpc" id="L3490" title="1 of 2 branches missed.">        if (s.isModuleBody()) return buildSuperInScriptBody(s);</span>

<span class="fc" id="L3492">        Operand block = setupCallClosure(zsuperNode.getIterNode(), s);</span>
<span class="fc bfc" id="L3493" title="All 2 branches covered.">        if (block == null) block = getImplicitBlockArg(s);</span>

        // Enebo:ZSuper in for (or nested for) can be statically resolved like method but it needs to fixup depth.
<span class="fc bfc" id="L3496" title="All 2 branches covered.">        if (s instanceof IRMethod) {</span>
<span class="fc" id="L3497">            return buildSuperInstr(s, block, ((IRMethod)s).getCallArgs());</span>
        } else {
<span class="fc" id="L3499">            return buildZSuperIfNest(s, block);</span>
        }
    }

    /*
     * Adjust all argument operands by changing their depths to reflect how far they are from
     * super.  This fixup is only currently happening in supers nested in closures.
     */
    private Operand[] adjustVariableDepth(Operand[] args, int depthFromSuper) {
<span class="fc" id="L3508">        Operand[] newArgs = new Operand[args.length];</span>

<span class="fc bfc" id="L3510" title="All 2 branches covered.">        for (int i = 0; i &lt; args.length; i++) {</span>
            // Because of keyword args, we can have a keyword-arg hash in the call args.
<span class="pc bpc" id="L3512" title="1 of 2 branches missed.">            if (args[i] instanceof Hash) {</span>
<span class="nc" id="L3513">                newArgs[i] = ((Hash) args[i]).cloneForLVarDepth(depthFromSuper);</span>
            } else {
<span class="fc" id="L3515">                newArgs[i] = ((DepthCloneable) args[i]).cloneForDepth(depthFromSuper);</span>
            }
        }

<span class="fc" id="L3519">        return newArgs;</span>
    }

    private Operand buildModuleOrClassBody(IRScope parent, Variable moduleVar, IRModuleBody body, Node bodyNode, int linenumber) {
<span class="fc" id="L3523">        Variable processBodyResult = addResultInstr(parent, new ProcessModuleBodyInstr(parent.createTemporaryVariable(), moduleVar));</span>
<span class="fc" id="L3524">        IRBuilder bodyBuilder = newIRBuilder(manager);</span>

<span class="pc bpc" id="L3526" title="1 of 2 branches missed.">        if (RubyInstanceConfig.FULL_TRACE_ENABLED) {</span>
<span class="nc" id="L3527">            bodyBuilder.addInstr(body, new TraceInstr(RubyEvent.CLASS, null, body.getFileName(), linenumber));</span>
        }

<span class="fc" id="L3530">        bodyBuilder.addInstr(body, new ReceiveSelfInstr(body.getSelf()));                            // %self</span>
<span class="fc" id="L3531">        bodyBuilder.addInstr(body, new CopyInstr(body.getCurrentScopeVariable(), CURRENT_SCOPE[0])); // %scope</span>
<span class="fc" id="L3532">        bodyBuilder.addInstr(body, new CopyInstr(body.getCurrentModuleVariable(), SCOPE_MODULE[0])); // %module</span>
        // Create a new nested builder to ensure this gets its own IR builder state
<span class="fc" id="L3534">        Operand bodyReturnValue = bodyBuilder.build(bodyNode, body);</span>

<span class="pc bpc" id="L3536" title="1 of 2 branches missed.">        if (RubyInstanceConfig.FULL_TRACE_ENABLED) {</span>
<span class="nc" id="L3537">            bodyBuilder.addInstr(body, new TraceInstr(RubyEvent.END, null, body.getFileName(), -1));</span>
        }

<span class="fc" id="L3540">        bodyBuilder.addInstr(body, new ReturnInstr(bodyReturnValue));</span>

<span class="fc" id="L3542">        return processBodyResult;</span>
    }

    private String methodNameFor(IRScope s) {
<span class="nc" id="L3546">        IRScope method = s.getNearestMethod();</span>

<span class="nc bnc" id="L3548" title="All 2 branches missed.">        return method == null ? null : method.getName();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>