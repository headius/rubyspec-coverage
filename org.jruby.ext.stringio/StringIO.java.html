<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StringIO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby.ext.stringio</a> &gt; <span class="el_source">StringIO.java</span></div><h1>StringIO.java</h1><pre class="source lang-java linenums">/***** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2006 Ola Bini &lt;ola@ologix.com&gt;
 * Copyright (C) 2006 Ryan Bell &lt;ryan.l.bell@gmail.com&gt;
 * Copyright (C) 2007 Thomas E Enebo &lt;enebo@acm.org&gt;
 * Copyright (C) 2008 Vladimir Sizikov &lt;vsizikov@gmail.com&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby.ext.stringio;

import org.jcodings.Encoding;
import org.jcodings.specific.ASCIIEncoding;
import org.jruby.Ruby;
import org.jruby.RubyArray;
import org.jruby.RubyClass;
import org.jruby.RubyFixnum;
import org.jruby.RubyIO;
import org.jruby.RubyKernel;
import org.jruby.RubyNumeric;
import org.jruby.RubyObject;
import org.jruby.RubyString;
import org.jruby.anno.FrameField;
import org.jruby.anno.JRubyClass;
import org.jruby.anno.JRubyMethod;
import org.jruby.java.addons.IOJavaAddons;
import org.jruby.runtime.Block;
import org.jruby.runtime.ObjectAllocator;
import org.jruby.runtime.ThreadContext;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.runtime.encoding.EncodingCapable;
import org.jruby.util.ByteList;
import org.jruby.util.StringSupport;
import org.jruby.util.TypeConverter;
import org.jruby.util.io.EncodingUtils;
import org.jruby.util.io.ModeFlags;
import org.jruby.util.io.OpenFile;

import java.util.Arrays;

import static org.jruby.RubyEnumerator.enumeratorize;
import static org.jruby.runtime.Visibility.PRIVATE;

@JRubyClass(name=&quot;StringIO&quot;)
@SuppressWarnings(&quot;deprecation&quot;)
public class StringIO extends RubyObject implements EncodingCapable {
<span class="fc" id="L68">    static class StringIOData {</span>
        /**
         * ATTN: the value of internal might be reset to null
         * (during StringIO.open with block), so watch out for that.
         */
        RubyString string;
        int pos;
        int lineno;
        int flags;
    }
    StringIOData ptr;

    private static final int STRIO_READABLE = USER4_F;
    private static final int STRIO_WRITABLE = USER5_F;
    private static final int STRIO_READWRITE = (STRIO_READABLE | STRIO_WRITABLE);

<span class="fc" id="L84">    private static ObjectAllocator STRINGIO_ALLOCATOR = new ObjectAllocator() {</span>
            public IRubyObject allocate(Ruby runtime, RubyClass klass) {
<span class="fc" id="L86">            return new StringIO(runtime, klass);</span>
        }
    };

    public static RubyClass createStringIOClass(final Ruby runtime) {
<span class="fc" id="L91">        RubyClass stringIOClass = runtime.defineClass(</span>
<span class="fc" id="L92">                &quot;StringIO&quot;, runtime.getClass(&quot;Data&quot;), STRINGIO_ALLOCATOR);</span>

<span class="fc" id="L94">        stringIOClass.defineAnnotatedMethods(StringIO.class);</span>
<span class="fc" id="L95">        stringIOClass.includeModule(runtime.getEnumerable());</span>

<span class="pc bpc" id="L97" title="1 of 2 branches missed.">        if (runtime.getObject().isConstantDefined(&quot;Java&quot;)) {</span>
<span class="fc" id="L98">            stringIOClass.defineAnnotatedMethods(IOJavaAddons.AnyIO.class);</span>
        }

<span class="fc" id="L101">        return stringIOClass;</span>
    }

    public Encoding getEncoding() {
<span class="nc" id="L105">        return ptr.string.getEncoding();</span>
    }

    public void setEncoding(Encoding e) {
<span class="nc" id="L109">        ptr.string.setEncoding(e);</span>
<span class="nc" id="L110">    }</span>

    @JRubyMethod(meta = true, rest = true)
    public static IRubyObject open(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="nc" id="L114">        StringIO strio = (StringIO)((RubyClass)recv).newInstance(context, args, Block.NULL_BLOCK);</span>
<span class="nc" id="L115">        IRubyObject val = strio;</span>

<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (block.isGiven()) {</span>
            try {
<span class="nc" id="L119">                val = block.yield(context, strio);</span>
            } finally {
<span class="nc" id="L121">                strio.ptr.string = null;</span>
<span class="nc" id="L122">                strio.flags &amp;= ~STRIO_READWRITE;</span>
<span class="nc" id="L123">            }</span>
        }
<span class="nc" id="L125">        return val;</span>
    }

    protected StringIO(Ruby runtime, RubyClass klass) {
<span class="fc" id="L129">        super(runtime, klass);</span>
<span class="fc" id="L130">    }</span>

    @JRubyMethod(optional = 2, visibility = PRIVATE)
    public IRubyObject initialize(ThreadContext context, IRubyObject[] args) {
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (ptr == null) {</span>
<span class="fc" id="L135">            ptr = new StringIOData();</span>
        }

        // does not dispatch quite right and is not really necessary for us
        //Helpers.invokeSuper(context, this, metaClass, &quot;initialize&quot;, IRubyObject.NULL_ARRAY, Block.NULL_BLOCK);
<span class="fc" id="L140">        strioInit(context, args);</span>
<span class="fc" id="L141">        return this;</span>
    }

    // MRI: strio_init
    private void strioInit(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L146">        Ruby runtime = context.runtime;</span>
        RubyString string;
        IRubyObject mode;
<span class="fc" id="L149">        boolean trunc = false;</span>
        
<span class="pc bpc" id="L151" title="2 of 4 branches missed.">        switch (args.length) {</span>
            case 2:
<span class="fc" id="L153">                mode = args[1];</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">                if (mode instanceof RubyFixnum) {</span>
<span class="nc" id="L155">                    int flags = RubyFixnum.fix2int(mode);</span>
<span class="nc" id="L156">                    ptr.flags = ModeFlags.getOpenFileFlagsFor(flags);</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">                    trunc = (flags &amp; ModeFlags.TRUNC) != 0;</span>
<span class="nc" id="L158">                } else {</span>
<span class="fc" id="L159">                    String m = args[1].convertToString().toString();</span>
<span class="fc" id="L160">                    ptr.flags = OpenFile.ioModestrFmode(runtime, m);</span>
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">                    trunc = m.charAt(0) == 'w';</span>
                }
<span class="fc" id="L163">                string = args[0].convertToString();</span>
<span class="pc bpc" id="L164" title="3 of 4 branches missed.">                if ((ptr.flags &amp; OpenFile.WRITABLE) != 0 &amp;&amp; string.isFrozen()) {</span>
<span class="nc" id="L165">                    throw runtime.newErrnoEACCESError(&quot;Permission denied&quot;);</span>
                }
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">                if (trunc) {</span>
<span class="nc" id="L168">                    string.resize(0);</span>
                }
                break;
            case 1:
<span class="fc" id="L172">                string = args[0].convertToString();</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">                ptr.flags = string.isFrozen() ? OpenFile.READABLE : OpenFile.READWRITE;</span>
<span class="fc" id="L174">                break;</span>
            case 0:
<span class="nc" id="L176">                string = RubyString.newEmptyString(runtime, runtime.getDefaultExternalEncoding());</span>
<span class="nc" id="L177">                ptr.flags = OpenFile.READWRITE;</span>
<span class="nc" id="L178">                break;</span>
            default:
<span class="nc" id="L180">                throw runtime.newArgumentError(args.length, 2);</span>
        }

<span class="fc" id="L183">        ptr.string = string;</span>
<span class="fc" id="L184">        ptr.pos = 0;</span>
<span class="fc" id="L185">        ptr.lineno = 0;</span>
        // funky way of shifting readwrite flags into object flags
<span class="fc" id="L187">        flags |= (ptr.flags &amp; OpenFile.READWRITE) * (STRIO_READABLE / OpenFile.READABLE);</span>
<span class="fc" id="L188">    }</span>

    // MRI: strio_copy
    @JRubyMethod(visibility = PRIVATE)
    public IRubyObject initialize_copy(ThreadContext context, IRubyObject other) {
<span class="nc" id="L193">        StringIO otherIO = (StringIO) TypeConverter.convertToType(other,</span>
<span class="nc" id="L194">                context.runtime.getClass(&quot;StringIO&quot;), &quot;to_strio&quot;);</span>

<span class="nc bnc" id="L196" title="All 2 branches missed.">        if (this == otherIO) return this;</span>

<span class="nc" id="L198">        ptr = otherIO.ptr;</span>
<span class="nc" id="L199">        infectBy(otherIO);</span>
<span class="nc" id="L200">        flags &amp;= ~STRIO_READWRITE;</span>
<span class="nc" id="L201">        flags |= otherIO.flags &amp; STRIO_READWRITE;</span>

<span class="nc" id="L203">        return this;</span>
    }

    @JRubyMethod(name = {&quot;binmode&quot;, &quot;flush&quot;})
    public IRubyObject strio_self() {
<span class="fc" id="L208">        return this;</span>
    }

    @JRubyMethod(name = {&quot;fcntl&quot;}, rest = true)
    public IRubyObject strio_unimpl(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L213">        throw context.runtime.newNotImplementedError(&quot;&quot;);</span>
    }

    @JRubyMethod(name = {&quot;fsync&quot;})
    public IRubyObject strioZero(ThreadContext context) {
<span class="nc" id="L218">        return RubyFixnum.zero(context.runtime);</span>
    }

    @JRubyMethod(name = {&quot;sync=&quot;})
    public IRubyObject strioFirst(IRubyObject arg) {
<span class="nc" id="L223">        checkInitialized();</span>
<span class="nc" id="L224">        return arg;</span>
    }

    @JRubyMethod(name = {&quot;isatty&quot;, &quot;tty?&quot;})
    public IRubyObject strioFalse(ThreadContext context) {
<span class="nc" id="L229">        return context.runtime.getFalse();</span>
    }

    @JRubyMethod(name = {&quot;pid&quot;, &quot;fileno&quot;})
    public IRubyObject strioNil(ThreadContext context) {
<span class="nc" id="L234">        return context.nil;</span>
    }

    @JRubyMethod(name = &quot;&lt;&lt;&quot;, required = 1)
    public IRubyObject append(ThreadContext context, IRubyObject arg) {
        // Claims conversion is done via 'to_s' in docs.
<span class="nc" id="L240">        callMethod(context, &quot;write&quot;, arg);</span>
        
<span class="nc" id="L242">        return this; </span>
    }

    @JRubyMethod
    public IRubyObject close(ThreadContext context) {
<span class="nc" id="L247">        checkInitialized();</span>
<span class="nc" id="L248">        checkOpen();</span>

        // NOTE: This is 2.0 behavior to allow dup'ed StringIO to remain open when original is closed
<span class="nc" id="L251">        flags &amp;= ~STRIO_READWRITE;</span>

<span class="nc" id="L253">        return context.nil;</span>
    }

    @JRubyMethod(name = &quot;closed?&quot;)
    public IRubyObject closed_p() {
<span class="nc" id="L258">        checkInitialized();</span>
<span class="nc" id="L259">        return getRuntime().newBoolean(closed());</span>
    }

    @JRubyMethod
    public IRubyObject close_read(ThreadContext context) {
<span class="nc" id="L264">        checkReadable();</span>
<span class="nc" id="L265">        flags &amp;= ~STRIO_READABLE;</span>
<span class="nc" id="L266">        return context.nil;</span>
    }

    @JRubyMethod(name = &quot;closed_read?&quot;)
    public IRubyObject closed_read_p() {
<span class="nc" id="L271">        checkInitialized();</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">        return getRuntime().newBoolean(!readable());</span>
    }

    @JRubyMethod
    public IRubyObject close_write(ThreadContext context) {
<span class="nc" id="L277">        checkWritable();</span>
<span class="nc" id="L278">        flags &amp;= ~STRIO_WRITABLE;</span>
<span class="nc" id="L279">        return context.nil;</span>
    }

    @JRubyMethod(name = &quot;closed_write?&quot;)
    public IRubyObject closed_write_p() {
<span class="nc" id="L284">        checkInitialized();</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">        return getRuntime().newBoolean(!writable());</span>
    }

    // MRI: strio_each
    @JRubyMethod(name = &quot;each&quot;, optional = 2, writes = FrameField.LASTLINE)
    public IRubyObject each(ThreadContext context, IRubyObject[] args, Block block) {
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (!block.isGiven()) return enumeratorize(context.runtime, this, &quot;each&quot;, args);</span>

        IRubyObject line;
        
<span class="nc bnc" id="L295" title="All 6 branches missed.">        if (args.length &gt; 0 &amp;&amp; !args[args.length - 1].isNil() &amp;&amp; args[args.length - 1].checkStringType19().isNil() &amp;&amp;</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">                RubyNumeric.num2long(args[args.length - 1]) == 0) {</span>
<span class="nc" id="L297">            throw context.runtime.newArgumentError(&quot;invalid limit: 0 for each_line&quot;);</span>
        }

<span class="nc" id="L300">        checkReadable();</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">        while (!(line = getline(context, args)).isNil()) {</span>
<span class="nc" id="L302">            block.yieldSpecific(context, line);</span>
        }
<span class="nc" id="L304">        return this;</span>
    }

    @JRubyMethod(name = &quot;each_line&quot;, optional = 2, writes = FrameField.LASTLINE)
    public IRubyObject each_line(ThreadContext context, IRubyObject[] args, Block block) {
<span class="nc bnc" id="L309" title="All 2 branches missed.">        if (!block.isGiven()) return enumeratorize(context.runtime, this, &quot;each_line&quot;, args);</span>
        
<span class="nc" id="L311">        return each(context, args, block);</span>
    }

    @JRubyMethod(name = &quot;lines&quot;, optional = 2)
    public IRubyObject lines(ThreadContext context, IRubyObject[] args, Block block) {
<span class="nc" id="L316">        context.runtime.getWarnings().warn(&quot;StringIO#lines is deprecated; use #each_line instead&quot;);</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">        return block.isGiven() ? each(context, args, block) : enumeratorize(context.runtime, this, &quot;each_line&quot;, args);</span>
    }

    @JRubyMethod(name = {&quot;each_byte&quot;, &quot;bytes&quot;})
    public IRubyObject each_byte(ThreadContext context, Block block) {
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (!block.isGiven()) return enumeratorize(context.runtime, this, &quot;each_byte&quot;);</span>

<span class="nc" id="L324">        checkReadable();</span>
<span class="nc" id="L325">        Ruby runtime = context.runtime;</span>
<span class="nc" id="L326">        ByteList bytes = ptr.string.getByteList();</span>

        // Check the length every iteration, since
        // the block can modify this string.
<span class="nc bnc" id="L330" title="All 2 branches missed.">        while (ptr.pos &lt; bytes.length()) {</span>
<span class="nc" id="L331">            block.yield(context, runtime.newFixnum(bytes.get((int) ptr.pos++) &amp; 0xFF));</span>
        }
<span class="nc" id="L333">        return this;</span>
    }

    @JRubyMethod
    public IRubyObject each_char(final ThreadContext context, final Block block) {
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (!block.isGiven()) return enumeratorize(context.runtime, this, &quot;each_char&quot;);</span>

        IRubyObject c;
<span class="nc bnc" id="L341" title="All 2 branches missed.">        while (!(c = getc(context)).isNil()) {</span>
<span class="nc" id="L342">            block.yieldSpecific(context, c);</span>
        }
<span class="nc" id="L344">        return this;</span>
    }

    @JRubyMethod
    public IRubyObject chars(final ThreadContext context, final Block block) {
<span class="nc" id="L349">        context.runtime.getWarnings().warn(&quot;StringIO#chars is deprecated; use #each_char instead&quot;);</span>

<span class="nc" id="L351">        return each_char(context, block);</span>
    }

    @JRubyMethod(name = {&quot;eof&quot;, &quot;eof?&quot;})
    public IRubyObject eof(ThreadContext context) {
<span class="nc" id="L356">        checkReadable();</span>
<span class="nc" id="L357">        Ruby runtime = context.runtime;</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">        if (ptr.pos &lt; ptr.string.size()) return runtime.getFalse();</span>
<span class="nc" id="L359">        return runtime.getTrue();</span>
    }
    
    private boolean isEndOfString() {
<span class="fc bfc" id="L363" title="All 2 branches covered.">        return ptr.pos &gt;= ptr.string.size();</span>
    }

    @JRubyMethod(name = &quot;getc&quot;)
    public IRubyObject getc(ThreadContext context) {
<span class="nc" id="L368">        checkReadable();</span>

<span class="nc bnc" id="L370" title="All 2 branches missed.">        if (isEndOfString()) return context.runtime.getNil();</span>

<span class="nc" id="L372">        int start = ptr.pos;</span>
<span class="nc" id="L373">        int total = 1 + StringSupport.bytesToFixBrokenTrailingCharacter(ptr.string.getByteList(), start + 1);</span>
        
<span class="nc" id="L375">        ptr.pos += total;</span>
        
<span class="nc" id="L377">        return context.runtime.newString(ptr.string.getByteList().makeShared(start, total));</span>
    }

    @JRubyMethod(name = &quot;getbyte&quot;)
    public IRubyObject getbyte(ThreadContext context) {
<span class="nc" id="L382">        checkReadable();</span>

<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (isEndOfString()) return context.runtime.getNil();</span>

<span class="nc" id="L386">        int c = ptr.string.getByteList().get(ptr.pos++) &amp; 0xFF;</span>

<span class="nc" id="L388">        return context.runtime.newFixnum(c);</span>
    }
    
    private RubyString strioSubstr(Ruby runtime, int pos, int len) {
<span class="fc" id="L392">        RubyString str = ptr.string;</span>
<span class="fc" id="L393">        ByteList strByteList = str.getByteList();</span>
<span class="fc" id="L394">        byte[] strBytes = strByteList.getUnsafeBytes();</span>
<span class="fc" id="L395">        Encoding enc = str.getEncoding();</span>
<span class="fc" id="L396">        int rlen = str.size() - pos;</span>
        
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        if (len &gt; rlen) len = rlen;</span>
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">        if (len &lt; 0) len = 0;</span>
        
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">        if (len == 0) return RubyString.newEmptyString(runtime);</span>
<span class="fc" id="L402">        return RubyString.newStringShared(runtime, strBytes, strByteList.getBegin() + pos, len, enc);</span>
    }

    private static final int CHAR_BIT = 8;
    
    private static void bm_init_skip(int[] skip, byte[] pat, int patPtr, int m) {
        int c;
        
<span class="nc bnc" id="L410" title="All 2 branches missed.">        for (c = 0; c &lt; (1 &lt;&lt; CHAR_BIT); c++) {</span>
<span class="nc" id="L411">            skip[c] = m;</span>
        }
<span class="nc bnc" id="L413" title="All 2 branches missed.">        while ((--m) &gt; 0) {</span>
<span class="nc" id="L414">            skip[pat[patPtr++]] = m;</span>
        }
<span class="nc" id="L416">    }</span>
    
    // Note that this is substantially more complex in 2.0 (Onigmo)
    private static int bm_search(byte[] little, int lstart, int llen, byte[] big, int bstart, int blen, int[] skip) {
        int i, j, k;
        
<span class="nc" id="L422">        i = llen - 1;</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">        while (i &lt; blen) {</span>
<span class="nc" id="L424">            k = i;</span>
<span class="nc" id="L425">            j = llen - 1;</span>
<span class="nc bnc" id="L426" title="All 4 branches missed.">            while (j &gt;= 0 &amp;&amp; big[k + bstart] == little[j + lstart]) {</span>
<span class="nc" id="L427">                k--;</span>
<span class="nc" id="L428">                j--;</span>
            }
<span class="nc bnc" id="L430" title="All 2 branches missed.">            if (j &lt; 0) return k + 1;</span>
<span class="nc" id="L431">            i += skip[big[i + bstart] &amp; 0xFF];</span>
        }
<span class="nc" id="L433">        return -1;</span>
    }

//        if (sepArg != null) {
//            if (sepArg.isNil()) {
//                int bytesAvailable = data.internal.getByteList().getRealSize() - (int)data.pos;
//                int bytesToUse = (limit &lt; 0 || limit &gt;= bytesAvailable ? bytesAvailable : limit);
//
//                // add additional bytes to fix trailing broken character
//                bytesToUse += StringSupport.bytesToFixBrokenTrailingCharacter(data.internal.getByteList(), bytesToUse);
//
//                ByteList buf = data.internal.getByteList().makeShared(
//                    (int)data.pos, bytesToUse);
//                data.pos += buf.getRealSize();
//                return makeString(runtime, buf);
//            }
//
//            sep = sepArg.convertToString().getByteList();
//            if (sep.getRealSize() == 0) {
//                isParagraph = true;
//                sep = Stream.PARAGRAPH_SEPARATOR;
//            }
//        }
//
//        if (isEndOfString() || data.eof) return context.nil;
//
//        ByteList ss = data.internal.getByteList();
//
//        if (isParagraph) {
//            swallowLF(ss);
//            if (data.pos == ss.getRealSize()) {
//                return runtime.getNil();
//            }
//        }
//
//        int sepIndex = ss.indexOf(sep, (int)data.pos);
//
//        ByteList add;
//        if (-1 == sepIndex) {
//            sepIndex = data.internal.getByteList().getRealSize();
//            add = ByteList.EMPTY_BYTELIST;
//        } else {
//            add = sep;
//        }
//
//        int bytes = sepIndex - (int)data.pos;
//        int bytesToUse = (limit &lt; 0 || limit &gt;= bytes ? bytes : limit);
//
//        int bytesWithSep = sepIndex - (int)data.pos + add.getRealSize();
//        int bytesToUseWithSep = (limit &lt; 0 || limit &gt;= bytesWithSep ? bytesWithSep : limit);
//
//        ByteList line = new ByteList(bytesToUseWithSep);
//        if (is19) line.setEncoding(data.internal.getByteList().getEncoding());
//        line.append(data.internal.getByteList(), (int)data.pos, bytesToUse);
//        data.pos += bytesToUse;
//
//        if (is19) {
//            // add additional bytes to fix trailing broken character
//            int extraBytes = StringSupport.bytesToFixBrokenTrailingCharacter(line, line.length());
//            if (extraBytes != 0) {
//                line.append(data.internal.getByteList(), (int)data.pos, extraBytes);
//                data.pos += extraBytes;
//            }
//        }
//
//        int sepBytesToUse = bytesToUseWithSep - bytesToUse;
//        line.append(add, 0, sepBytesToUse);
//        data.pos += sepBytesToUse;
//
//        if (sepBytesToUse &gt;= add.getRealSize()) {
//            data.lineno++;
//        }
//
//        return makeString(runtime, line);
//    }
//
//    private void swallowLF(ByteList list) {
//        while (ptr.pos &lt; list.getRealSize()) {
//            if (list.get((int)ptr.pos) == '\n') {
//                ptr.pos++;
//            } else {
//                break;
//            }
//        }
//    }

    @JRubyMethod(name = &quot;gets&quot;, optional = 2, writes = FrameField.LASTLINE)
    public IRubyObject gets(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L521">        checkReadable();</span>

<span class="fc" id="L523">        IRubyObject str = getline(context, args);</span>

<span class="fc" id="L525">        context.setLastLine(str);</span>
<span class="fc" id="L526">        return str;</span>
    }

    // strio_getline
    private IRubyObject getline(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L531">        Ruby runtime = context.runtime;</span>

<span class="fc" id="L533">        IRubyObject str = context.nil;;</span>
<span class="fc" id="L534">        int n, limit = -1;</span>

<span class="pc bpc" id="L536" title="3 of 4 branches missed.">        switch (args.length) {</span>
            case 0:
<span class="fc" id="L538">                str = runtime.getGlobalVariables().get(&quot;$/&quot;);</span>
<span class="fc" id="L539">                break;</span>

            case 1:
            {
<span class="nc" id="L543">                str = args[0];</span>
<span class="nc bnc" id="L544" title="All 4 branches missed.">                if (!str.isNil() &amp;&amp; !(str instanceof RubyString)) {</span>
<span class="nc" id="L545">                    IRubyObject tmp = str.checkStringType19();</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">                    if (tmp.isNil()) {</span>
<span class="nc" id="L547">                        limit = RubyNumeric.num2int(str);</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">                        if (limit == 0) return runtime.newString();</span>
<span class="nc" id="L549">                        str = runtime.getGlobalVariables().get(&quot;$/&quot;);</span>
                    } else {
<span class="nc" id="L551">                        str = tmp;</span>
                    }
<span class="nc" id="L553">                }</span>
                break;
            }

            case 2:
<span class="nc bnc" id="L558" title="All 2 branches missed.">                if (!args[0].isNil()) str = args[0].convertToString();</span>
                // 2.0 ignores double nil, 1.9 raises
<span class="nc bnc" id="L560" title="All 2 branches missed.">                if (runtime.is2_0()) {</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">                    if (!args[1].isNil()) {</span>
<span class="nc" id="L562">                        limit = RubyNumeric.num2int(args[1]);</span>
                    }
                } else {
<span class="nc" id="L565">                    limit = RubyNumeric.num2int(args[1]);</span>
                }
                break;
        }

<span class="fc bfc" id="L570" title="All 2 branches covered.">        if (isEndOfString()) {</span>
<span class="fc" id="L571">            return context.nil;</span>
        }

<span class="fc" id="L574">        ByteList sByteList = ptr.string.getByteList();</span>
<span class="fc" id="L575">        byte[] sBytes = sByteList.getUnsafeBytes();</span>
<span class="fc" id="L576">        int begin = sByteList.getBegin();</span>
<span class="fc" id="L577">        int s = begin + ptr.pos;</span>
<span class="fc" id="L578">        int e = begin + sByteList.getRealSize();</span>
        int p;

<span class="pc bpc" id="L581" title="3 of 4 branches missed.">        if (limit &gt; 0 &amp;&amp; s + limit &lt; e) {</span>
<span class="nc" id="L582">            e = sByteList.getEncoding().rightAdjustCharHead(sBytes, s, s + limit, e);</span>
        }
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">        if (str.isNil()) {</span>
<span class="nc" id="L585">            str = strioSubstr(runtime, ptr.pos, e - s);</span>
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">        } else if ((n = ((RubyString)str).size()) == 0) {</span>
            // this is not an exact port; the original confused me
<span class="nc" id="L588">            p = s;</span>
            // remove leading \n
<span class="nc bnc" id="L590" title="All 2 branches missed.">            while (sBytes[p] == '\n') {</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">                if (++p == e) {</span>
<span class="nc" id="L592">                    return context.nil;</span>
                }
            }
<span class="nc" id="L595">            s = p;</span>
            // find next \n or end; if followed by \n, include it too
<span class="nc" id="L597">            p = StringSupport.memchr(sBytes, p, '\n', e - p);</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">            if (p != -1) {</span>
<span class="nc bnc" id="L599" title="All 4 branches missed.">                if (++p &lt; e &amp;&amp; sBytes[p] == '\n') {</span>
<span class="nc" id="L600">                    e = p + 1;</span>
                } else {
<span class="nc" id="L602">                    e = p;</span>
                }
            }
<span class="nc" id="L605">            str = strioSubstr(runtime, s - begin, e - s);</span>
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">        } else if (n == 1) {</span>
<span class="fc" id="L607">            RubyString strStr = (RubyString)str;</span>
<span class="fc" id="L608">            ByteList strByteList = strStr.getByteList();</span>
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">            if ((p = StringSupport.memchr(sBytes, s, strByteList.get(0), e - s)) != -1) {</span>
<span class="fc" id="L610">                e = p + 1;</span>
            }
<span class="fc" id="L612">            str = strioSubstr(runtime, ptr.pos, e - s);</span>
<span class="fc" id="L613">        } else {</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">            if (n &lt; e - s) {</span>
<span class="nc" id="L615">                RubyString strStr = (RubyString)str;</span>
<span class="nc" id="L616">                ByteList strByteList = strStr.getByteList();</span>
<span class="nc" id="L617">                byte[] strBytes = strByteList.getUnsafeBytes();</span>

<span class="nc" id="L619">                int[] skip = new int[1 &lt;&lt; CHAR_BIT];</span>
                int pos;
<span class="nc" id="L621">                p = strByteList.getBegin();</span>
<span class="nc" id="L622">                bm_init_skip(skip, strBytes, p, n);</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">                if ((pos = bm_search(strBytes, p, n, sBytes, s, e - s, skip)) &gt;= 0) {</span>
<span class="nc" id="L624">                    e = s + pos + n;</span>
                }
            }
<span class="nc" id="L627">            str = strioSubstr(runtime, ptr.pos, e - s);</span>
        }
<span class="fc" id="L629">        ptr.pos = e - begin;</span>
<span class="fc" id="L630">        ptr.lineno++;</span>
<span class="fc" id="L631">        return str;</span>
    }

    @JRubyMethod(name = {&quot;length&quot;, &quot;size&quot;})
    public IRubyObject length() {
<span class="nc" id="L636">        checkInitialized();</span>
<span class="nc" id="L637">        checkFinalized();</span>
<span class="nc" id="L638">        return getRuntime().newFixnum(ptr.string.size());</span>
    }

    @JRubyMethod(name = &quot;lineno&quot;)
    public IRubyObject lineno(ThreadContext context) {
<span class="nc" id="L643">        return context.runtime.newFixnum(ptr.lineno);</span>
    }

    @JRubyMethod(name = &quot;lineno=&quot;, required = 1)
    public IRubyObject set_lineno(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L648">        ptr.lineno = RubyNumeric.fix2int(arg);</span>

<span class="nc" id="L650">        return context.nil;</span>
    }

    @JRubyMethod(name = {&quot;pos&quot;, &quot;tell&quot;})
    public IRubyObject pos(ThreadContext context) {
<span class="nc" id="L655">        checkInitialized();</span>

<span class="nc" id="L657">        return context.runtime.newFixnum(ptr.pos);</span>
    }

    @JRubyMethod(name = &quot;pos=&quot;, required = 1)
    public IRubyObject set_pos(IRubyObject arg) {
<span class="nc" id="L662">        checkInitialized();</span>

<span class="nc" id="L664">        int p = RubyNumeric.fix2int(arg);</span>
        
<span class="nc bnc" id="L666" title="All 2 branches missed.">        if (p &lt; 0) throw getRuntime().newErrnoEINVALError(arg.toString());</span>

<span class="nc" id="L668">        ptr.pos = p;</span>

<span class="nc" id="L670">        return arg;</span>
    }

    @JRubyMethod(name = &quot;print&quot;, rest = true)
    public IRubyObject print(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L675">        return RubyIO.print(context, this, args);</span>
    }

    @JRubyMethod(name = &quot;printf&quot;, required = 1, rest = true)
    public IRubyObject printf(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L680">        callMethod(context, &quot;write&quot;, RubyKernel.sprintf(context, this, args));</span>
<span class="nc" id="L681">        return getRuntime().getNil();</span>
    }

    private void strioExtend(int pos, int len) {
        int olen;

<span class="nc" id="L687">        checkModifiable();</span>
<span class="nc" id="L688">        olen = ptr.string.size();</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">        if (pos + len &gt; olen) {</span>
<span class="nc" id="L690">            ptr.string.resize(pos + len);</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">            if (pos &gt; olen) {</span>
<span class="nc" id="L692">                ByteList ptrByteList = ptr.string.getByteList();</span>
                // zero the gap
<span class="nc" id="L694">                Arrays.fill(ptrByteList.getUnsafeBytes(),</span>
<span class="nc" id="L695">                        ptrByteList.getBegin() + olen,</span>
<span class="nc" id="L696">                        ptrByteList.getBegin() + pos,</span>
                        (byte)0);
<span class="nc" id="L698">            }</span>
        } else {
<span class="nc" id="L700">            ptr.string.modify19();</span>
        }
<span class="nc" id="L702">    }</span>

    // MRI: strio_putc
    @JRubyMethod(name = &quot;putc&quot;)
    public IRubyObject putc(ThreadContext context, IRubyObject ch) {
<span class="nc" id="L707">        Ruby runtime = context.runtime;</span>
<span class="nc" id="L708">        checkWritable();</span>
        IRubyObject str;

<span class="nc" id="L711">        checkModifiable();</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">        if (ch instanceof RubyString) {</span>
<span class="nc" id="L713">            str = ((RubyString)ch).substr19(runtime, 0, 1);</span>
        }
        else {
<span class="nc" id="L716">            byte c = RubyNumeric.num2chr(ch);</span>
<span class="nc" id="L717">            str = RubyString.newString(runtime, new byte[]{c});</span>
        }
<span class="nc" id="L719">        write(context, str);</span>
<span class="nc" id="L720">        return ch;</span>
    }

<span class="fc" id="L723">    public static final ByteList NEWLINE = ByteList.create(&quot;\n&quot;);</span>

    @JRubyMethod(name = &quot;puts&quot;, rest = true)
    public IRubyObject puts(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L727">        checkModifiable();</span>
<span class="nc" id="L728">        return puts(context, this, args);</span>
    }

    private static IRubyObject puts(ThreadContext context, IRubyObject maybeIO, IRubyObject[] args) {
        // TODO: This should defer to RubyIO logic, but we don't have puts right there for 1.9
<span class="nc" id="L733">        Ruby runtime = context.runtime;</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">        if (args.length == 0) {</span>
<span class="nc" id="L735">            RubyIO.write(context, maybeIO, RubyString.newStringShared(runtime, NEWLINE));</span>
<span class="nc" id="L736">            return runtime.getNil();</span>
        }

<span class="nc bnc" id="L739" title="All 2 branches missed.">        for (int i = 0; i &lt; args.length; i++) {</span>
<span class="nc" id="L740">            RubyString line = null;</span>

<span class="nc bnc" id="L742" title="All 2 branches missed.">            if (!args[i].isNil()) {</span>
<span class="nc" id="L743">                IRubyObject tmp = args[i].checkArrayType();</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">                if (!tmp.isNil()) {</span>
<span class="nc" id="L745">                    RubyArray arr = (RubyArray) tmp;</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">                    if (runtime.isInspecting(arr)) {</span>
<span class="nc" id="L747">                        line = runtime.newString(&quot;[...]&quot;);</span>
                    } else {
<span class="nc" id="L749">                        inspectPuts(context, maybeIO, arr);</span>
<span class="nc" id="L750">                        continue;</span>
                    }
<span class="nc" id="L752">                } else {</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">                    if (args[i] instanceof RubyString) {</span>
<span class="nc" id="L754">                        line = (RubyString) args[i];</span>
                    } else {
<span class="nc" id="L756">                        line = args[i].asString();</span>
                    }
                }
            }

<span class="nc bnc" id="L761" title="All 2 branches missed.">            if (line != null) RubyIO.write(context, maybeIO, line);</span>

<span class="nc bnc" id="L763" title="All 4 branches missed.">            if (line == null || !line.getByteList().endsWith(NEWLINE)) {</span>
<span class="nc" id="L764">                RubyIO.write(context, maybeIO, RubyString.newStringShared(runtime, NEWLINE));</span>
            }
        }

<span class="nc" id="L768">        return runtime.getNil();</span>
    }

    private static IRubyObject inspectPuts(ThreadContext context, IRubyObject maybeIO, RubyArray array) {
<span class="nc" id="L772">        Ruby runtime = context.runtime;</span>
        try {
<span class="nc" id="L774">            runtime.registerInspecting(array);</span>
<span class="nc" id="L775">            return puts(context, maybeIO, array.toJavaArray());</span>
        } finally {
<span class="nc" id="L777">            runtime.unregisterInspecting(array);</span>
        }
    }
    
    // Make string based on internal data encoding (which ironically is its
    // external encoding.  This seems messy and we should consider a more
    // uniform method for makeing strings (we have a slightly different variant
    // of this in RubyIO.
    private RubyString makeString(Ruby runtime, ByteList buf, boolean setEncoding) {
<span class="nc bnc" id="L786" title="All 4 branches missed.">        if (runtime.is1_9() &amp;&amp; setEncoding) buf.setEncoding(ptr.string.getEncoding());</span>

<span class="nc" id="L788">        RubyString str = RubyString.newString(runtime, buf);</span>
<span class="nc" id="L789">        str.setTaint(true);</span>

<span class="nc" id="L791">        return str;        </span>
    }
    
    private RubyString makeString(Ruby runtime, ByteList buf) {
<span class="nc" id="L795">        return makeString(runtime, buf, true);</span>
    }

    @JRubyMethod(name = &quot;read&quot;, optional = 2)
    public IRubyObject read(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L800">        checkReadable();</span>

<span class="fc" id="L802">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L803">        IRubyObject str = runtime.getNil();</span>
        int len;
<span class="fc" id="L805">        boolean binary = false;</span>

<span class="pc bpc" id="L807" title="3 of 4 branches missed.">        switch (args.length) {</span>
        case 2:
<span class="nc" id="L809">            str = args[1];</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">            if (!str.isNil()) {</span>
<span class="nc" id="L811">                str = str.convertToString();</span>
<span class="nc" id="L812">                ((RubyString)str).modify();</span>
            }
        case 1:
<span class="pc bpc" id="L815" title="1 of 2 branches missed.">            if (!args[0].isNil()) {</span>
<span class="fc" id="L816">                len = RubyNumeric.fix2int(args[0]);</span>

<span class="pc bpc" id="L818" title="1 of 2 branches missed.">                if (len &lt; 0) {</span>
<span class="nc" id="L819">                    throw getRuntime().newArgumentError(&quot;negative length &quot; + len + &quot; given&quot;);</span>
                }
<span class="pc bpc" id="L821" title="2 of 4 branches missed.">                if (len &gt; 0 &amp;&amp; isEndOfString()) {</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">                    if (!str.isNil()) ((RubyString)str).resize(0);</span>
<span class="nc" id="L823">                    return getRuntime().getNil();</span>
                }
<span class="fc" id="L825">                binary = true;</span>
<span class="fc" id="L826">                break;</span>
            }
        case 0:
<span class="nc" id="L829">            len = ptr.string.size();</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">            if (len &lt;= ptr.pos) {</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">                if (str.isNil()) {</span>
<span class="nc" id="L832">                    str = runtime.newString();</span>
                } else {
<span class="nc" id="L834">                    ((RubyString)str).resize(0);</span>
                }

<span class="nc" id="L837">                return str;</span>
            } else {
<span class="nc" id="L839">                len -= ptr.pos;</span>
            }
<span class="nc" id="L841">            break;</span>
        default:
<span class="nc" id="L843">            throw getRuntime().newArgumentError(args.length, 0);</span>
        }

<span class="pc bpc" id="L846" title="1 of 2 branches missed.">        if (str.isNil()) {</span>
<span class="fc" id="L847">            str = strioSubstr(runtime, ptr.pos, len);</span>
<span class="pc bpc" id="L848" title="1 of 2 branches missed.">            if (binary) ((RubyString)str).setEncoding(ASCIIEncoding.INSTANCE);</span>
        } else {
<span class="nc" id="L850">            int rest = ptr.string.size() - ptr.pos;</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">            if (len &gt; rest) len = rest;</span>
<span class="nc" id="L852">            ((RubyString)str).resize(len);</span>
<span class="nc" id="L853">            ByteList strByteList = ((RubyString)str).getByteList();</span>
<span class="nc" id="L854">            byte[] strBytes = strByteList.getUnsafeBytes();</span>
<span class="nc" id="L855">            ByteList dataByteList = ptr.string.getByteList();</span>
<span class="nc" id="L856">            byte[] dataBytes = dataByteList.getUnsafeBytes();</span>
<span class="nc" id="L857">            System.arraycopy(dataBytes, dataByteList.getBegin() + ptr.pos, strBytes, strByteList.getBegin(), len);</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">            if (binary) {</span>
<span class="nc" id="L859">                ((RubyString)str).setEncoding(ASCIIEncoding.INSTANCE);</span>
            } else {
<span class="nc" id="L861">                ((RubyString)str).setEncoding(ptr.string.getEncoding());</span>
            }
        }
<span class="fc" id="L864">        ptr.pos += ((RubyString)str).size();</span>
<span class="fc" id="L865">        return str;</span>
    }

    @JRubyMethod(name=&quot;read_nonblock&quot;, optional = 2)
    public IRubyObject read_nonblock(ThreadContext context, IRubyObject[] args) {
        // TODO: nonblock exception option

<span class="nc" id="L872">        IRubyObject val = read(context, args);</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">        if (val.isNil()) {</span>
<span class="nc" id="L874">            throw context.runtime.newEOFError();</span>
        }

<span class="nc" id="L877">        return val;</span>
    }

    @JRubyMethod(name = &quot;readchar&quot;)
    public IRubyObject readchar(ThreadContext context) {
<span class="nc" id="L882">        IRubyObject c = callMethod(context, &quot;getc&quot;);</span>

<span class="nc bnc" id="L884" title="All 2 branches missed.">        if (c.isNil()) throw getRuntime().newEOFError();</span>

<span class="nc" id="L886">        return c;</span>
    }

    @JRubyMethod(name = &quot;readbyte&quot;)
    public IRubyObject readbyte(ThreadContext context) {
<span class="nc" id="L891">        IRubyObject c = callMethod(context, &quot;getbyte&quot;);</span>

<span class="nc bnc" id="L893" title="All 2 branches missed.">        if (c.isNil()) throw getRuntime().newEOFError();</span>

<span class="nc" id="L895">        return c;</span>
    }

    @JRubyMethod(name = &quot;readline&quot;, optional = 1, writes = FrameField.LASTLINE)
    public IRubyObject readline(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L900">        IRubyObject line = callMethod(context, &quot;gets&quot;, args);</span>

<span class="nc bnc" id="L902" title="All 2 branches missed.">        if (line.isNil()) throw getRuntime().newEOFError();</span>

<span class="nc" id="L904">        return line;</span>
    }

    @JRubyMethod(name = &quot;readlines&quot;, optional = 2)
    public IRubyObject readlines(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L909">        Ruby runtime = context.runtime;</span>
        
<span class="nc bnc" id="L911" title="All 6 branches missed.">        if (args.length &gt; 0 &amp;&amp; !args[args.length - 1].isNil() &amp;&amp; args[args.length - 1].checkStringType19().isNil() &amp;&amp;</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">                RubyNumeric.num2long(args[args.length - 1]) == 0) {</span>
<span class="nc" id="L913">            throw runtime.newArgumentError(&quot;invalid limit: 0 for each_line&quot;);</span>
        }

<span class="nc" id="L916">        RubyArray ary = runtime.newArray();</span>
        IRubyObject line;

<span class="nc" id="L919">        checkReadable();</span>

<span class="nc bnc" id="L921" title="All 2 branches missed.">        while (!(line = getline(context, args)).isNil()) {</span>
<span class="nc" id="L922">            ary.append(line);</span>
        }
<span class="nc" id="L924">        return ary;</span>
    }

    // MRI: strio_reopen
    @JRubyMethod(name = &quot;reopen&quot;, required = 0, optional = 2)
    public IRubyObject reopen(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L930">        checkFrozen();</span>
        
<span class="nc bnc" id="L932" title="All 4 branches missed.">        if (args.length == 1 &amp;&amp; !(args[0] instanceof RubyString)) {</span>
<span class="nc" id="L933">            return initialize_copy(context, args[0]);</span>
        }

        // reset the state
<span class="nc" id="L937">        strioInit(context, args);</span>
<span class="nc" id="L938">        return this;</span>
    }

    @JRubyMethod(name = &quot;rewind&quot;)
    public IRubyObject rewind(ThreadContext context) {
<span class="nc" id="L943">        checkInitialized();</span>

<span class="nc" id="L945">        this.ptr.pos = 0;</span>
<span class="nc" id="L946">        this.ptr.lineno = 0;</span>
<span class="nc" id="L947">        return RubyFixnum.zero(context.runtime);</span>
    }

    @JRubyMethod(required = 1, optional = 1)
    public IRubyObject seek(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L952">        Ruby runtime = context.runtime;</span>

<span class="nc" id="L954">        checkFrozen();</span>
<span class="nc" id="L955">        checkFinalized();</span>
        
<span class="nc" id="L957">        int offset = RubyNumeric.num2int(args[0]);</span>
<span class="nc" id="L958">        IRubyObject whence = context.nil;</span>

<span class="nc bnc" id="L960" title="All 4 branches missed.">        if (args.length &gt; 1 &amp;&amp; !args[0].isNil()) whence = args[1];</span>
        
<span class="nc" id="L962">        checkOpen();</span>

<span class="nc bnc" id="L964" title="All 6 branches missed.">        switch (whence.isNil() ? 0 : RubyNumeric.num2int(whence)) {</span>
            case 0:
<span class="nc" id="L966">                break;</span>
            case 1:
<span class="nc" id="L968">                offset += ptr.pos;</span>
<span class="nc" id="L969">                break;</span>
            case 2:
<span class="nc" id="L971">                offset += ptr.string.size();</span>
<span class="nc" id="L972">                break;</span>
            default:
<span class="nc" id="L974">                throw runtime.newErrnoEINVALError(&quot;invalid whence&quot;);</span>
        }
        
<span class="nc bnc" id="L977" title="All 2 branches missed.">        if (offset &lt; 0) throw runtime.newErrnoEINVALError(&quot;invalid seek value&quot;);</span>

<span class="nc" id="L979">        ptr.pos = offset;</span>

<span class="nc" id="L981">        return RubyFixnum.zero(runtime);</span>
    }

    @JRubyMethod(name = &quot;string=&quot;, required = 1)
    public IRubyObject set_string(IRubyObject arg) {
<span class="nc" id="L986">        checkFrozen();</span>
<span class="nc" id="L987">        ptr.flags &amp;= ~OpenFile.READWRITE;</span>
<span class="nc" id="L988">        RubyString str = arg.convertToString();</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">        ptr.flags = str.isFrozen() ? OpenFile.READABLE : OpenFile.READWRITE;</span>
<span class="nc" id="L990">        ptr.pos = 0;</span>
<span class="nc" id="L991">        ptr.lineno = 0;</span>
<span class="nc" id="L992">        return ptr.string = str;</span>
    }

    @JRubyMethod(name = &quot;string&quot;)
    public IRubyObject string(ThreadContext context) {
<span class="nc bnc" id="L997" title="All 2 branches missed.">        if (ptr.string == null) return context.nil;</span>

<span class="nc" id="L999">        return ptr.string;</span>
    }

    @JRubyMethod(name = &quot;sync&quot;)
    public IRubyObject sync(ThreadContext context) {
<span class="nc" id="L1004">        checkInitialized();</span>
<span class="nc" id="L1005">        return context.runtime.getTrue();</span>
    }
    
    @JRubyMethod(name = {&quot;sysread&quot;, &quot;readpartial&quot;}, optional = 2)
    public IRubyObject sysread(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L1010">        IRubyObject val = callMethod(context, &quot;read&quot;, args);</span>
        
<span class="nc bnc" id="L1012" title="All 2 branches missed.">        if (val.isNil()) throw getRuntime().newEOFError();</span>
        
<span class="nc" id="L1014">        return val;</span>
    }
    
    // only here for the fake-out class in org.jruby
    public IRubyObject sysread(IRubyObject[] args) {
<span class="nc" id="L1019">        return sysread(getRuntime().getCurrentContext(), args);</span>
    }

    @JRubyMethod(name = &quot;truncate&quot;, required = 1)
    public IRubyObject truncate(IRubyObject len) {
<span class="nc" id="L1024">        checkWritable();</span>

<span class="nc" id="L1026">        int l = RubyFixnum.fix2int(len);</span>
<span class="nc" id="L1027">        int plen = ptr.string.size();</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">        if (l &lt; 0) {</span>
<span class="nc" id="L1029">            throw getRuntime().newErrnoEINVALError(&quot;negative legnth&quot;);</span>
        }
<span class="nc" id="L1031">        ptr.string.resize(l);</span>
<span class="nc" id="L1032">        ByteList buf = ptr.string.getByteList();</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">        if (plen &lt; l) {</span>
            // zero the gap
<span class="nc" id="L1035">            Arrays.fill(buf.getUnsafeBytes(), buf.getBegin() + plen, buf.getBegin() + l, (byte) 0);</span>
        }
<span class="nc" id="L1037">        return len;</span>
    }

    @JRubyMethod(name = &quot;ungetc&quot;)
    public IRubyObject ungetc(ThreadContext context, IRubyObject arg) {
        // TODO: Not a line-by-line port.
<span class="nc" id="L1043">        checkReadable();</span>
<span class="nc" id="L1044">        return ungetbyte(context, arg);</span>
    }

    private void ungetbyteCommon(int c) {
<span class="nc" id="L1048">        ptr.string.modify();</span>
<span class="nc" id="L1049">        ptr.pos--;</span>
        
<span class="nc" id="L1051">        ByteList bytes = ptr.string.getByteList();</span>

<span class="nc bnc" id="L1053" title="All 2 branches missed.">        if (isEndOfString()) bytes.length((int)ptr.pos + 1);</span>

<span class="nc bnc" id="L1055" title="All 2 branches missed.">        if (ptr.pos == -1) {</span>
<span class="nc" id="L1056">            bytes.prepend((byte)c);</span>
<span class="nc" id="L1057">            ptr.pos = 0;</span>
        } else {
<span class="nc" id="L1059">            bytes.set((int) ptr.pos, c);</span>
        }
<span class="nc" id="L1061">    }</span>

    private void ungetbyteCommon(RubyString ungetBytes) {
<span class="nc" id="L1064">        ByteList ungetByteList = ungetBytes.getByteList();</span>
<span class="nc" id="L1065">        int len = ungetByteList.getRealSize();</span>
<span class="nc" id="L1066">        int start = ptr.pos;</span>
        
<span class="nc bnc" id="L1068" title="All 2 branches missed.">        if (len == 0) return;</span>
        
<span class="nc" id="L1070">        ptr.string.modify();</span>
        
<span class="nc bnc" id="L1072" title="All 2 branches missed.">        if (len &gt; ptr.pos) {</span>
<span class="nc" id="L1073">            start = 0;</span>
        } else {
<span class="nc" id="L1075">            start = ptr.pos - len;</span>
        }
        
<span class="nc" id="L1078">        ByteList bytes = ptr.string.getByteList();</span>
        
<span class="nc bnc" id="L1080" title="All 2 branches missed.">        if (isEndOfString()) bytes.length(Math.max(ptr.pos, len));</span>

<span class="nc" id="L1082">        bytes.replace(start, ptr.pos - start, ungetBytes.getByteList());</span>
        
<span class="nc" id="L1084">        ptr.pos = start;</span>
<span class="nc" id="L1085">    }</span>
    
    @JRubyMethod
    public IRubyObject ungetbyte(ThreadContext context, IRubyObject arg) {
        // TODO: Not a line-by-line port.
<span class="nc" id="L1090">        checkReadable();</span>
        
<span class="nc bnc" id="L1092" title="All 2 branches missed.">        if (arg.isNil()) return arg;</span>

<span class="nc" id="L1094">        checkModifiable();</span>

<span class="nc bnc" id="L1096" title="All 2 branches missed.">        if (arg instanceof RubyFixnum) {</span>
<span class="nc" id="L1097">            ungetbyteCommon(RubyNumeric.fix2int(arg));</span>
        } else {
<span class="nc" id="L1099">            ungetbyteCommon(arg.convertToString());</span>
        }

<span class="nc" id="L1102">        return context.nil;</span>
    }

    @JRubyMethod(name = &quot;syswrite&quot;, required = 1)
    public IRubyObject syswrite(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L1107">        return RubyIO.write(context, this, arg);</span>
    }

    @JRubyMethod(name = &quot;write_nonblock&quot;, required = 1, optional = 1)
    public IRubyObject syswrite_nonblock(ThreadContext context, IRubyObject[] args) {
        // TODO: handle opts?
<span class="nc" id="L1113">        return syswrite(context, args[0]);</span>
    }

    // MRI: strio_write
    @JRubyMethod(name = {&quot;write&quot;}, required = 1)
    public IRubyObject write(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L1119">        checkWritable();</span>

<span class="nc" id="L1121">        Ruby runtime = context.runtime;</span>

<span class="nc" id="L1123">        RubyString str = arg.asString();</span>
        int len, olen;
        Encoding enc, enc2;

<span class="nc" id="L1127">        enc = ptr.string.getEncoding();</span>
<span class="nc" id="L1128">        enc2 = str.getEncoding();</span>
<span class="nc bnc" id="L1129" title="All 6 branches missed.">        if (enc != enc2 &amp;&amp; enc != EncodingUtils.ascii8bitEncoding(runtime)</span>
                // this is a hack because we don't seem to handle incoming ASCII-8BIT properly in transcoder
                &amp;&amp; enc2 != ASCIIEncoding.INSTANCE) {
<span class="nc" id="L1132">            str = runtime.newString(EncodingUtils.strConvEnc(context, str.getByteList(), enc2, enc));</span>
        }
<span class="nc" id="L1134">        len = str.size();</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">        if (len == 0) return RubyFixnum.zero(runtime);</span>
<span class="nc" id="L1136">        checkModifiable();</span>
<span class="nc" id="L1137">        olen = ptr.string.size();</span>
<span class="nc bnc" id="L1138" title="All 2 branches missed.">        if ((ptr.flags &amp; OpenFile.APPEND) != 0) {</span>
<span class="nc" id="L1139">            ptr.pos = olen;</span>
        }
<span class="nc bnc" id="L1141" title="All 2 branches missed.">        if (ptr.pos == olen) {</span>
<span class="nc" id="L1142">            EncodingUtils.encStrBufCat(runtime, ptr.string, str.getByteList(), enc);</span>
        } else {
<span class="nc" id="L1144">            strioExtend(ptr.pos, len);</span>
<span class="nc" id="L1145">            ByteList ptrByteList = ptr.string.getByteList();</span>
<span class="nc" id="L1146">            System.arraycopy(str.getByteList().getUnsafeBytes(), str.getByteList().getBegin(), ptrByteList.getUnsafeBytes(), ptrByteList.begin + ptr.pos, len);</span>
        }
<span class="nc" id="L1148">        ptr.string.infectBy(str);</span>
<span class="nc" id="L1149">        ptr.string.infectBy(this);</span>
<span class="nc" id="L1150">        ptr.pos += len;</span>
<span class="nc" id="L1151">        return RubyFixnum.newFixnum(runtime, len);</span>
    }
    
    @JRubyMethod
    public IRubyObject set_encoding(ThreadContext context, IRubyObject ext_enc) {
        Encoding enc;

<span class="nc bnc" id="L1158" title="All 2 branches missed.">        if (ext_enc.isNil()) {</span>
<span class="nc" id="L1159">            enc = EncodingUtils.defaultExternalEncoding(context.runtime);</span>
        } else {
<span class="nc" id="L1161">            enc = EncodingUtils.rbToEncoding(context, ext_enc);</span>
        }
<span class="nc bnc" id="L1163" title="All 2 branches missed.">        if(ptr.string.getEncoding() != enc) {</span>
<span class="nc" id="L1164">            ptr.string.modify();</span>
<span class="nc" id="L1165">            ptr.string.setEncoding(enc);</span>
        }
<span class="nc" id="L1167">        return this;</span>
    }
    
    @JRubyMethod
    public IRubyObject set_encoding(ThreadContext context, IRubyObject enc, IRubyObject ignored) {
<span class="nc" id="L1172">        return set_encoding(context, enc);</span>
    }
    
    @JRubyMethod
    public IRubyObject set_encoding(ThreadContext context, IRubyObject enc, IRubyObject ignored1, IRubyObject ignored2) {
<span class="nc" id="L1177">        return set_encoding(context, enc);</span>
    }
    
    @JRubyMethod
    public IRubyObject external_encoding(ThreadContext context) {
<span class="nc" id="L1182">        return context.runtime.getEncodingService().convertEncodingToRubyEncoding(ptr.string.getEncoding());</span>
    }
    
    @JRubyMethod
    public IRubyObject internal_encoding(ThreadContext context) {
<span class="nc" id="L1187">        return context.nil;</span>
    }
    
    @JRubyMethod(name = &quot;each_codepoint&quot;)
    public IRubyObject each_codepoint(ThreadContext context, Block block) {
<span class="nc" id="L1192">        Ruby runtime = context.runtime;</span>

<span class="nc bnc" id="L1194" title="All 2 branches missed.">        if (!block.isGiven()) return enumeratorize(runtime, this, &quot;each_codepoint&quot;);</span>

<span class="nc" id="L1196">        checkReadable();</span>
        
<span class="nc" id="L1198">        Encoding enc = ptr.string.getEncoding();</span>
<span class="nc" id="L1199">        byte[] unsafeBytes = ptr.string.getByteList().getUnsafeBytes();</span>
<span class="nc" id="L1200">        int begin = ptr.string.getByteList().getBegin();</span>
        for (;;) {
<span class="nc bnc" id="L1202" title="All 2 branches missed.">            if (ptr.pos &gt;= ptr.string.size()) {</span>
<span class="nc" id="L1203">                return this;</span>
            }
            
<span class="nc" id="L1206">            int c = StringSupport.codePoint(runtime, enc, unsafeBytes, begin + ptr.pos, unsafeBytes.length);</span>
<span class="nc" id="L1207">            int n = StringSupport.codeLength(runtime, enc, c);</span>
<span class="nc" id="L1208">            block.yield(context, runtime.newFixnum(c));</span>
<span class="nc" id="L1209">            ptr.pos += n;</span>
<span class="nc" id="L1210">        }</span>
    }

    @JRubyMethod(name = &quot;codepoints&quot;)
    public IRubyObject codepoints(ThreadContext context, Block block) {
<span class="nc" id="L1215">        Ruby runtime = context.runtime;</span>
<span class="nc" id="L1216">        runtime.getWarnings().warn(&quot;StringIO#codepoints is deprecated; use #each_codepoint&quot;);</span>

<span class="nc bnc" id="L1218" title="All 2 branches missed.">        if (!block.isGiven()) return enumeratorize(runtime, this, &quot;each_codepoint&quot;);</span>

<span class="nc" id="L1220">        return each_codepoint(context, block);</span>
    }

    /* rb: check_modifiable */
    public void checkFrozen() {
<span class="nc" id="L1225">        super.checkFrozen();</span>
<span class="nc" id="L1226">        checkInitialized();</span>
<span class="nc" id="L1227">    }</span>

    private boolean readable() {
<span class="pc bpc" id="L1230" title="2 of 4 branches missed.">        return (flags &amp; STRIO_READABLE) != 0</span>
                &amp;&amp; (ptr.flags &amp; OpenFile.READABLE) != 0;
    }

    private boolean writable() {
<span class="nc bnc" id="L1235" title="All 4 branches missed.">        return (flags &amp; STRIO_WRITABLE) != 0</span>
                &amp;&amp; (ptr.flags &amp; OpenFile.WRITABLE) != 0;
    }

    private boolean closed() {
<span class="nc bnc" id="L1240" title="All 4 branches missed.">        return !((flags &amp; STRIO_READWRITE) != 0</span>
                &amp;&amp; (ptr.flags &amp; OpenFile.READWRITE) != 0);
    }

    /* rb: readable */
    private void checkReadable() {
<span class="fc" id="L1246">        checkInitialized();</span>
<span class="pc bpc" id="L1247" title="1 of 2 branches missed.">        if (!readable()) {</span>
<span class="nc" id="L1248">            throw getRuntime().newIOError(&quot;not opened for reading&quot;);</span>
        }
<span class="fc" id="L1250">    }</span>

    /* rb: writable */
    private void checkWritable() {
<span class="nc" id="L1254">        checkInitialized();</span>
<span class="nc bnc" id="L1255" title="All 2 branches missed.">        if (!writable()) {</span>
<span class="nc" id="L1256">            throw getRuntime().newIOError(&quot;not opened for writing&quot;);</span>
        }

        // Tainting here if we ever want it. (secure 4)
<span class="nc" id="L1260">    }</span>

    private void checkModifiable() {
<span class="nc" id="L1263">        checkFrozen();</span>
<span class="nc bnc" id="L1264" title="All 2 branches missed.">        if (ptr.string.isFrozen()) throw getRuntime().newIOError(&quot;not modifiable string&quot;);</span>
<span class="nc" id="L1265">    }</span>

    private void checkInitialized() {
<span class="pc bpc" id="L1268" title="1 of 2 branches missed.">        if (ptr == null) {</span>
<span class="nc" id="L1269">            throw getRuntime().newIOError(&quot;uninitialized stream&quot;);</span>
        }
<span class="fc" id="L1271">    }</span>

    private void checkFinalized() {
<span class="nc bnc" id="L1274" title="All 2 branches missed.">        if (ptr.string == null) {</span>
<span class="nc" id="L1275">            throw getRuntime().newIOError(&quot;not opened&quot;);</span>
        }
<span class="nc" id="L1277">    }</span>

    private void checkOpen() {
<span class="nc bnc" id="L1280" title="All 2 branches missed.">        if (closed()) {</span>
<span class="nc" id="L1281">            throw getRuntime().newIOError(RubyIO.CLOSED_STREAM_MSG);</span>
        }
<span class="nc" id="L1283">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>