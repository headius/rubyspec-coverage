<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Options.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby.util.cli</a> &gt; <span class="el_source">Options.java</span></div><h1>Options.java</h1><pre class="source lang-java linenums">/*
 **** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2001-2011 The JRuby Community (and contribs)
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby.util.cli;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.HashSet;

import com.headius.options.Option;
import org.jruby.TruffleBridge;
import org.jruby.runtime.Constants;
import org.jruby.util.KCode;
import org.jruby.util.SafePropertyAccessor;
import static org.jruby.util.cli.Category.*;
import static org.jruby.RubyInstanceConfig.Verbosity;
import static org.jruby.RubyInstanceConfig.ProfilingMode;
import static org.jruby.RubyInstanceConfig.CompileMode;

/**
 * Options defines all configuration settings for JRuby in a consistent form.
 * Loading of individual settings, printing documentation for settings and their
 * options and defaults, and categorizing properties by function are all part
 * of the built-in structure.
 */
<span class="nc" id="L54">public class Options {</span>
<span class="fc" id="L55">    private static final List&lt;Option&gt; _loadedOptions = new ArrayList&lt;Option&gt;();</span>
<span class="fc" id="L56">    private static final boolean INVOKEDYNAMIC_DEFAULT = calculateInvokedynamicDefault();</span>
    
    // This section holds all Options for JRuby. They will be listed in the
    // --properties output.

<span class="fc" id="L61">    public static final Option&lt;Boolean&gt; PARSER_DETAILED_SOURCE_POSITIONS = bool(PARSER, &quot;parser.detailed_source_positions&quot;, false, &quot;Produce detailed source positions&quot;);</span>
<span class="fc" id="L62">    public static final Option&lt;Boolean&gt; PARSER_WARN_USELESSS_USE_OF = bool(PARSER, &quot;parser.warn.useless_use_of&quot;, true, &quot;Warn about potentially useless expressions in void contents.&quot;);</span>
<span class="fc" id="L63">    public static final Option&lt;Boolean&gt; PARSER_WARN_NOT_REACHED = bool(PARSER, &quot;parser.warn.not_reached&quot;, true, &quot;Warn about statements that can never be reached.&quot;);</span>
<span class="fc" id="L64">    public static final Option&lt;Boolean&gt; PARSER_WARN_GROUPED_EXPRESSIONS = bool(PARSER, &quot;parser.warn.grouped_expressions&quot;, true, &quot;Warn about interpreting (...) as a grouped expression.&quot;);</span>
<span class="fc" id="L65">    public static final Option&lt;Boolean&gt; PARSER_WARN_LOCAL_SHADOWING = bool(PARSER, &quot;parser.warn.shadowing_local&quot;, true, &quot;Warn about shadowing local variables.&quot;);</span>
<span class="fc" id="L66">    public static final Option&lt;Boolean&gt; PARSER_WARN_REGEX_CONDITION = bool(PARSER, &quot;parser.warn.regex_condition&quot;, true, &quot;Warn about regex literals in conditions.&quot;);</span>
<span class="fc" id="L67">    public static final Option&lt;Boolean&gt; PARSER_WARN_ARGUMENT_PREFIX = bool(PARSER, &quot;parser.warn.argument_prefix&quot;, true, &quot;Warn about splat operators being interpreted as argument prefixes.&quot;);</span>

<span class="fc" id="L69">    public static final Option&lt;CompileMode&gt; COMPILE_MODE = enumeration(COMPILER, &quot;compile.mode&quot;, CompileMode.class, CompileMode.JIT, &quot;Set compilation mode. JIT = at runtime; FORCE = before execution.&quot;);</span>
<span class="fc" id="L70">    public static final Option&lt;Boolean&gt; COMPILE_DUMP = bool(COMPILER, &quot;compile.dump&quot;, false, &quot;Dump to console all bytecode generated at runtime.&quot;);</span>
<span class="fc" id="L71">    public static final Option&lt;Boolean&gt; COMPILE_THREADLESS = bool(COMPILER, &quot;compile.threadless&quot;, false, &quot;(EXPERIMENTAL) Turn on compilation without polling for \&quot;unsafe\&quot; thread events.&quot;);</span>
<span class="fc" id="L72">    public static final Option&lt;Boolean&gt; COMPILE_FASTOPS = bool(COMPILER, &quot;compile.fastops&quot;, true, &quot;Turn on fast operators for Fixnum and Float.&quot;);</span>
<span class="fc" id="L73">    public static final Option&lt;Integer&gt; COMPILE_CHAINSIZE = integer(COMPILER, &quot;compile.chainsize&quot;, Constants.CHAINED_COMPILE_LINE_COUNT_DEFAULT, &quot;Set the number of lines at which compiled bodies are \&quot;chained\&quot;.&quot;);</span>
<span class="fc" id="L74">    public static final Option&lt;Boolean&gt; COMPILE_LAZYHANDLES = bool(COMPILER, &quot;compile.lazyHandles&quot;, false, &quot;Generate method bindings (handles) for compiled methods lazily.&quot;);</span>
<span class="fc" id="L75">    public static final Option&lt;Boolean&gt; COMPILE_PEEPHOLE = bool(COMPILER, &quot;compile.peephole&quot;, true, &quot;Enable or disable peephole optimizations.&quot;);</span>
<span class="fc" id="L76">    public static final Option&lt;Boolean&gt; COMPILE_NOGUARDS = bool(COMPILER, &quot;compile.noguards&quot;, false, &quot;Compile calls without guards, for experimentation.&quot;);</span>
<span class="fc" id="L77">    public static final Option&lt;Boolean&gt; COMPILE_FASTEST = bool(COMPILER, &quot;compile.fastest&quot;, false, &quot;Compile with all \&quot;mostly harmless\&quot; compiler optimizations.&quot;);</span>
<span class="fc" id="L78">    public static final Option&lt;Boolean&gt; COMPILE_FASTSEND = bool(COMPILER, &quot;compile.fastsend&quot;, false, &quot;Compile obj.__send__(&lt;literal&gt;, ...) as obj.&lt;literal&gt;(...).&quot;);</span>
<span class="fc" id="L79">    public static final Option&lt;Boolean&gt; COMPILE_FASTMASGN = bool(COMPILER, &quot;compile.fastMasgn&quot;, false, &quot;Return true from multiple assignment instead of a new array.&quot;);</span>
<span class="fc" id="L80">    public static final Option&lt;Boolean&gt; COMPILE_INVOKEDYNAMIC = bool(COMPILER, &quot;compile.invokedynamic&quot;, INVOKEDYNAMIC_DEFAULT, &quot;Use invokedynamic for optimizing Ruby code.&quot;);</span>
<span class="fc" id="L81">    public static final Option&lt;Integer&gt; COMPILE_OUTLINE_CASECOUNT = integer(COMPILER, &quot;compile.outline.casecount&quot;, 50, &quot;Outline when bodies when number of cases exceeds this value.&quot;);</span>

<span class="fc" id="L83">    public static final Option&lt;Integer&gt; INVOKEDYNAMIC_MAXFAIL = integer(INVOKEDYNAMIC, &quot;invokedynamic.maxfail&quot;, 1000, &quot;Maximum call site failures after which to inline cache.&quot;);</span>
<span class="fc" id="L84">    public static final Option&lt;Integer&gt; INVOKEDYNAMIC_MAXPOLY = integer(INVOKEDYNAMIC, &quot;invokedynamic.maxpoly&quot;, 6, &quot;Maximum polymorphism of PIC binding.&quot;);</span>
<span class="fc" id="L85">    public static final Option&lt;Boolean&gt; INVOKEDYNAMIC_LOG_BINDING = bool(INVOKEDYNAMIC, &quot;invokedynamic.log.binding&quot;, false, &quot;Log binding of invokedynamic call sites.&quot;);</span>
<span class="fc" id="L86">    public static final Option&lt;Boolean&gt; INVOKEDYNAMIC_LOG_CONSTANTS = bool(INVOKEDYNAMIC, &quot;invokedynamic.log.constants&quot;, false, &quot;Log invokedynamic-based constant lookups.&quot;);</span>
<span class="fc" id="L87">    public static final Option&lt;Boolean&gt; INVOKEDYNAMIC_LOG_GLOBALS = bool(INVOKEDYNAMIC, &quot;invokedynamic.log.globals&quot;, false, &quot;Log invokedynamic-based global lookups.&quot;);</span>
<span class="fc" id="L88">    public static final Option&lt;Boolean&gt; INVOKEDYNAMIC_ALL = bool(INVOKEDYNAMIC, &quot;invokedynamic.all&quot;, false, &quot;Enable all possible uses of invokedynamic.&quot;);</span>
<span class="fc" id="L89">    public static final Option&lt;Boolean&gt; INVOKEDYNAMIC_SAFE = bool(INVOKEDYNAMIC, &quot;invokedynamic.safe&quot;, false, &quot;Enable all safe (but maybe not fast) uses of invokedynamic.&quot;);</span>
<span class="fc" id="L90">    public static final Option&lt;Boolean&gt; INVOKEDYNAMIC_INVOCATION = bool(INVOKEDYNAMIC, &quot;invokedynamic.invocation&quot;, true, &quot;Enable invokedynamic for method invocations.&quot;);</span>
<span class="fc" id="L91">    public static final Option&lt;Boolean&gt; INVOKEDYNAMIC_INVOCATION_INDIRECT = bool(INVOKEDYNAMIC, &quot;invokedynamic.invocation.indirect&quot;, true, &quot;Also bind indirect method invokers to invokedynamic.&quot;);</span>
<span class="fc" id="L92">    public static final Option&lt;Boolean&gt; INVOKEDYNAMIC_INVOCATION_JAVA = bool(INVOKEDYNAMIC, &quot;invokedynamic.invocation.java&quot;, true, &quot;Bind Ruby to Java invocations with invokedynamic.&quot;);</span>
<span class="fc" id="L93">    public static final Option&lt;Boolean&gt; INVOKEDYNAMIC_INVOCATION_ATTR = bool(INVOKEDYNAMIC, &quot;invokedynamic.invocation.attr&quot;, true, &quot;Bind Ruby attribute invocations directly to invokedynamic.&quot;);</span>
<span class="fc" id="L94">    public static final Option&lt;Boolean&gt; INVOKEDYNAMIC_INVOCATION_FFI = bool(INVOKEDYNAMIC, &quot;invokedynamic.invocation.ffi&quot;, true, &quot;Bind Ruby FFI invocations directly to invokedynamic.&quot;);</span>
<span class="fc" id="L95">    public static final Option&lt;Boolean&gt; INVOKEDYNAMIC_INVOCATION_FASTOPS = bool(INVOKEDYNAMIC, &quot;invokedynamic.invocation.fastops&quot;, true, &quot;Bind Fixnum and Float math using optimized logic.&quot;);</span>
<span class="fc" id="L96">    public static final Option&lt;Boolean&gt; INVOKEDYNAMIC_CACHE = bool(INVOKEDYNAMIC, &quot;invokedynamic.cache&quot;, true, &quot;Use invokedynamic to load cached values like literals and constants.&quot;);</span>
<span class="fc" id="L97">    public static final Option&lt;Boolean&gt; INVOKEDYNAMIC_CACHE_CONSTANTS = bool(INVOKEDYNAMIC, &quot;invokedynamic.cache.constants&quot;, true, &quot;Use invokedynamic to load constants.&quot;);</span>
<span class="fc" id="L98">    public static final Option&lt;Boolean&gt; INVOKEDYNAMIC_CACHE_LITERALS = bool(INVOKEDYNAMIC, &quot;invokedynamic.cache.literals&quot;, true, &quot;Use invokedynamic to load literals.&quot;);</span>
<span class="fc" id="L99">    public static final Option&lt;Boolean&gt; INVOKEDYNAMIC_CACHE_IVARS = bool(INVOKEDYNAMIC, &quot;invokedynamic.cache.ivars&quot;, true, &quot;Use invokedynamic to get/set instance variables.&quot;);</span>
<span class="fc" id="L100">    public static final Option&lt;Boolean&gt; INVOKEDYNAMIC_CLASS_VALUES = bool(INVOKEDYNAMIC, &quot;invokedynamic.class.values&quot;, false, &quot;Use ClassValue to store class-specific data.&quot;);</span>
<span class="fc" id="L101">    public static final Option&lt;Integer&gt; INVOKEDYNAMIC_GLOBAL_MAXFAIL = integer(INVOKEDYNAMIC, &quot;invokedynamic.global.maxfail&quot;, 100, &quot;Maximum global cache failures after which to use slow path.&quot;);</span>
<span class="fc" id="L102">    public static final Option&lt;Boolean&gt; INVOKEDYNAMIC_HANDLES = bool(INVOKEDYNAMIC, &quot;invokedynamic.handles&quot;, false, &quot;Use MethodHandles rather than generated code to bind Ruby methods.&quot;);</span>
    
<span class="fc" id="L104">    public static final Option&lt;Integer&gt; JIT_THRESHOLD = integer(JIT, &quot;jit.threshold&quot;, Constants.JIT_THRESHOLD, &quot;Set the JIT threshold to the specified method invocation count.&quot;);</span>
<span class="fc" id="L105">    public static final Option&lt;Integer&gt; JIT_MAX = integer(JIT, &quot;jit.max&quot;, Constants.JIT_MAX_METHODS_LIMIT, &quot;Set the max count of active methods eligible for JIT-compilation.&quot;);</span>
<span class="fc" id="L106">    public static final Option&lt;Integer&gt; JIT_MAXSIZE = integer(JIT, &quot;jit.maxsize&quot;, Constants.JIT_MAX_SIZE_LIMIT, &quot;Set the maximum full-class byte size allowed for jitted methods.&quot;);</span>
<span class="fc" id="L107">    public static final Option&lt;Boolean&gt; JIT_LOGGING = bool(JIT, &quot;jit.logging&quot;, false, &quot;Enable JIT logging (reports successful compilation).&quot;);</span>
<span class="fc" id="L108">    public static final Option&lt;Boolean&gt; JIT_LOGGING_VERBOSE = bool(JIT, &quot;jit.logging.verbose&quot;, false, &quot;Enable verbose JIT logging (reports failed compilation).&quot;);</span>
<span class="fc" id="L109">    public static final Option&lt;Boolean&gt; JIT_DUMPING = bool(JIT, &quot;jit.dumping&quot;, false, &quot;Enable stdout dumping of JITed bytecode.&quot;);</span>
<span class="fc" id="L110">    public static final Option&lt;Integer&gt; JIT_LOGEVERY = integer(JIT, &quot;jit.logEvery&quot;, 0, &quot;Log a message every n methods JIT compiled.&quot;);</span>
<span class="fc" id="L111">    public static final Option&lt;String&gt; JIT_EXCLUDE = string(JIT, &quot;jit.exclude&quot;, new String[]{&quot;ClsOrMod&quot;,&quot;ClsOrMod::method_name&quot;,&quot;-::method_name&quot;}, &quot;&quot;, &quot;Exclude methods from JIT. Comma delimited.&quot;);</span>
<span class="fc" id="L112">    public static final Option&lt;String&gt; JIT_CODECACHE = string(JIT, &quot;jit.codeCache&quot;, new String[]{&quot;dir&quot;}, &quot;Save jitted methods to &lt;dir&gt; as they're compiled, for future runs.&quot;);</span>
<span class="fc" id="L113">    public static final Option&lt;Boolean&gt; JIT_DEBUG = bool(JIT, &quot;jit.debug&quot;, false, &quot;Log loading of JITed bytecode.&quot;);</span>
<span class="fc" id="L114">    public static final Option&lt;Boolean&gt; JIT_BACKGROUND = bool(JIT, &quot;jit.background&quot;, true, &quot;Run the JIT compiler in a background thread.&quot;);</span>
    
<span class="fc" id="L116">    public static final Option&lt;Boolean&gt; IR_DEBUG             = bool(IR, &quot;ir.debug&quot;, false, &quot;Debug generation of JRuby IR.&quot;);</span>
<span class="fc" id="L117">    public static final Option&lt;Boolean&gt; IR_PROFILE           = bool(IR, &quot;ir.profile&quot;, false, &quot;[EXPT]: Profile IR code during interpretation.&quot;);</span>
<span class="fc" id="L118">    public static final Option&lt;Boolean&gt; IR_COMPILER_DEBUG    = bool(IR, &quot;ir.compiler.debug&quot;, false, &quot;Debug compilation of JRuby IR.&quot;);</span>
<span class="fc" id="L119">    public static final Option&lt;Boolean&gt; IR_VISUALIZER        = bool(IR, &quot;ir.visualizer&quot;, false, &quot;Visualization of JRuby IR.&quot;);</span>
<span class="fc" id="L120">    public static final Option&lt;Boolean&gt; IR_UNBOXING          = bool(IR, &quot;ir.unboxing&quot;, false, &quot;Implement unboxing opts.&quot;);</span>
<span class="fc" id="L121">    public static final Option&lt;String&gt;  IR_COMPILER_PASSES   = string(IR, &quot;ir.passes&quot;, &quot;Specify comma delimeted list of passes to run.&quot;);</span>
<span class="fc" id="L122">    public static final Option&lt;String&gt;  IR_JIT_PASSES        = string(IR, &quot;ir.jit.passes&quot;, &quot;Specify comma delimeted list of passes to run before JIT.&quot;);</span>
<span class="fc" id="L123">    public static final Option&lt;Boolean&gt; IR_READING           = bool(IR, &quot;ir.reading&quot;, false, &quot;Read JRuby IR file.&quot;);</span>
<span class="fc" id="L124">    public static final Option&lt;Boolean&gt; IR_READING_DEBUG     = bool(IR, &quot;ir.reading.debug&quot;, false, &quot;Debug reading JRuby IR file.&quot;);</span>
<span class="fc" id="L125">    public static final Option&lt;Boolean&gt; IR_WRITING           = bool(IR, &quot;ir.writing&quot;, false, &quot;Write JRuby IR file.&quot;);</span>
<span class="fc" id="L126">    public static final Option&lt;Boolean&gt; IR_WRITING_DEBUG     = bool(IR, &quot;ir.writing.debug&quot;, false, &quot;Debug writing JRuby IR file.&quot;);</span>
<span class="fc" id="L127">    public static final Option&lt;String&gt;  IR_INLINE_COMPILER_PASSES = string(IR, &quot;ir.inline_passes&quot;, &quot;Specify comma delimeted list of passes to run after inlining a method.&quot;);</span>

<span class="fc" id="L129">    public static final Option&lt;Boolean&gt; TRUFFLE_LOAD_CORE = bool(TRUFFLE, &quot;truffle.load_core&quot;, true, &quot;Load the Truffle core library.&quot;);</span>
<span class="fc" id="L130">    public static final Option&lt;Boolean&gt; TRUFFLE_PRINT_RUNTIME = bool(TRUFFLE, &quot;truffle.printRuntime&quot;, false, &quot;Print the name of the Truffle runtime on startup.&quot;);</span>
<span class="fc" id="L131">    public static final Option&lt;Boolean&gt; TRUFFLE_RUNTIME_VERSION_CHECK = bool(TRUFFLE, &quot;truffle.runtime.version_check&quot;, true, &quot;Check the version of Truffle supplied by the JVM before starting.&quot;);</span>
<span class="fc" id="L132">    public static final Option&lt;Boolean&gt; TRUFFLE_PROC_BINDING = bool(TRUFFLE, &quot;truffle.proc.binding&quot;, true, &quot;Enable Proc#binding.&quot;);</span>
<span class="fc" id="L133">    public static final Option&lt;Boolean&gt; TRUFFLE_EXCEPTIONS_PRINT_JAVA = bool(TRUFFLE, &quot;truffle.exceptions.print_java&quot;, false, &quot;Print Java exceptions at the point of translating them to Ruby exceptions.&quot;);</span>
<span class="fc" id="L134">    public static final Option&lt;Integer&gt; TRUFFLE_ARRAYS_UNINITIALIZED_SIZE = integer(TRUFFLE, &quot;truffle.arrays.uninitialized_size&quot;, 32, &quot;How large an array to allocate when we have no other information to go on.&quot;);</span>
<span class="fc" id="L135">    public static final Option&lt;Boolean&gt; TRUFFLE_ARRAYS_OPTIMISTIC_LONG = bool(TRUFFLE, &quot;truffle.arrays.optimistic.long&quot;, true, &quot;If we allocate an int[] for an Array and it has been converted to a long[], directly allocate a long[] next time.&quot;);</span>
<span class="fc" id="L136">    public static final Option&lt;Integer&gt; TRUFFLE_ARRAYS_SMALL = integer(TRUFFLE, &quot;truffle.arrays.small&quot;, 3, &quot;Maximum size of an Array to consider small for optimisations.&quot;);</span>
<span class="fc" id="L137">    public static final Option&lt;Integer&gt; TRUFFLE_HASHES_SMALL = integer(TRUFFLE, &quot;truffle.hashes.small&quot;, 3, &quot;Maximum size of a Hash to consider small for optimisations.&quot;);</span>
<span class="fc" id="L138">    public static final Option&lt;Boolean&gt; TRUFFLE_ALLOW_SIMPLE_SOURCE_SECTIONS = bool(TRUFFLE, &quot;truffle.allow_simple_source_sections&quot;, false, &quot;Allow simple source sections.&quot;);</span>
<span class="fc" id="L139">    public static final Option&lt;TruffleBridge.BacktraceFormatter&gt; TRUFFLE_BACKTRACE_DISPLAY_FORMAT = enumeration(TRUFFLE, &quot;truffle.backtrace.display_format&quot;, TruffleBridge.BacktraceFormatter.class, TruffleBridge.BacktraceFormatter.MRI, &quot;How to format backtraces displayed to the user.&quot;);</span>
<span class="fc" id="L140">    public static final Option&lt;TruffleBridge.BacktraceFormatter&gt; TRUFFLE_BACKTRACE_DEBUG_FORMAT = enumeration(TRUFFLE, &quot;truffle.backtrace.debug_format&quot;, TruffleBridge.BacktraceFormatter.class, TruffleBridge.BacktraceFormatter.DEBUG, &quot;How to format backtraces displayed using TruffleDebug.dump_call_stack.&quot;);</span>
<span class="fc" id="L141">    public static final Option&lt;TruffleBridge.BacktraceFormatter&gt; TRUFFLE_BACKTRACE_EXCEPTION_FORMAT = enumeration(TRUFFLE, &quot;truffle.backtrace.exception_format&quot;, TruffleBridge.BacktraceFormatter.class, TruffleBridge.BacktraceFormatter.MRI, &quot;How to format backtraces in Exception objects.&quot;);</span>
<span class="fc" id="L142">    public static final Option&lt;TruffleBridge.BacktraceFormatter&gt; TRUFFLE_BACKTRACE_PANIC_FORMAT = enumeration(TRUFFLE, &quot;truffle.backtrace.panic_format&quot;, TruffleBridge.BacktraceFormatter.class, TruffleBridge.BacktraceFormatter.IMPL_DEBUG, &quot;How to format backtraces in panics.&quot;);</span>
<span class="fc" id="L143">    public static final Option&lt;Integer&gt; TRUFFLE_BACKTRACE_MAX_VALUE_LENGTH = integer(TRUFFLE, &quot;truffle.backtrace.max_value_length&quot;, 20, &quot;Max length for values when displayed in a backtrace.&quot;);</span>
<span class="fc" id="L144">    public static final Option&lt;Boolean&gt; TRUFFLE_BACKTRACE_GENERATE = bool(TRUFFLE, &quot;truffle.backtrace.generate&quot;, true, &quot;Generate backtraces on exceptions.&quot;);</span>
<span class="fc" id="L145">    public static final Option&lt;Integer&gt; TRUFFLE_DISPATCH_POLYMORPHIC_MAX = integer(TRUFFLE, &quot;truffle.dispatch.polymorphic.max&quot;, 8, &quot;Maximum size of a polymorphic call site cache.&quot;);</span>
<span class="fc" id="L146">    public static final Option&lt;Boolean&gt; TRUFFLE_DEBUG_ENABLE_ASSERT_CONSTANT = bool(TRUFFLE, &quot;truffle.debug.enable_assert_constant&quot;, false, &quot;Enable special 'truffle_assert_constant' form.&quot;);</span>
<span class="fc" id="L147">    public static final Option&lt;Boolean&gt; TRUFFLE_PANIC_ON_JAVA_ASSERT = bool(TRUFFLE, &quot;truffle.debug.panic_on_java_assert&quot;, false, &quot;Panic as soon as a Java assertion failure is found.&quot;);</span>
<span class="fc" id="L148">    public static final Option&lt;Boolean&gt; TRUFFLE_INLINER_ALWAYS_CLONE_YIELD = bool(TRUFFLE, &quot;truffle.inliner.always_clone_yield&quot;, true, &quot;Always clone yield call targets.&quot;);</span>
<span class="fc" id="L149">    public static final Option&lt;Boolean&gt; TRUFFLE_INLINER_ALWAYS_INLINE_YIELD = bool(TRUFFLE, &quot;truffle.inliner.always_inline_yield&quot;, true, &quot;Always inline yield call targets.&quot;);</span>
<span class="fc" id="L150">    public static final Option&lt;Boolean&gt; TRUFFLE_DISPATCH_METAPROGRAMMING_ALWAYS_UNCACHED = bool(TRUFFLE, &quot;truffle.dispatch.metaprogramming_always_uncached&quot;, false, &quot;Always use uncached dispatch for the metaprogramming methods #__send__, #send and #respond_to?, and for any call site that has to use #method_missing or #const_missing.&quot;);</span>
<span class="fc" id="L151">    public static final Option&lt;Boolean&gt; TRUFFLE_DISPATCH_METAPROGRAMMING_ALWAYS_INDIRECT = bool(TRUFFLE, &quot;truffle.dispatch.metaprogramming_always_indirect&quot;, false, &quot;Always use indirect calls for the metaprogramming methods #__send__ and #send, and for any call site that has to use #method_missing or #const_missing.&quot;);</span>
<span class="fc" id="L152">    public static final Option&lt;Boolean&gt; TRUFFLE_DISPATCH_METHODMISSING_ALWAYS_CLONED = bool(TRUFFLE, &quot;truffle.call.method_missing_always_cloned&quot;, true, &quot;Always clone #method_missing call targets.&quot;);</span>
<span class="fc" id="L153">    public static final Option&lt;Boolean&gt; TRUFFLE_DISPATCH_METHODMISSING_ALWAYS_INLINED = bool(TRUFFLE, &quot;truffle.call.method_missing_always_inlined&quot;, true, &quot;Always inline #method_missing call targets.&quot;);</span>
<span class="fc" id="L154">    public static final Option&lt;String&gt; TRUFFLE_TRANSLATOR_PRINT_AST = string(TRUFFLE, &quot;truffle.translator.print_asts&quot;, &quot;&quot;, &quot;Comma delimited list of method names to print the AST of after translation.&quot;);</span>
<span class="fc" id="L155">    public static final Option&lt;String&gt; TRUFFLE_TRANSLATOR_PRINT_FULL_AST = string(TRUFFLE, &quot;truffle.translator.print_full_asts&quot;, &quot;&quot;, &quot;Comma delimited list of method names to print the full AST of after translation.&quot;);</span>
<span class="fc" id="L156">    public static final Option&lt;String&gt; TRUFFLE_TRANSLATOR_PRINT_PARSE_TREE = string(TRUFFLE, &quot;truffle.translator.print_parse_trees&quot;, &quot;&quot;, &quot;Comma delimited list of method names to print the JRuby parse tree of before translation.&quot;);</span>

<span class="fc" id="L158">    public static final Option&lt;Boolean&gt; NATIVE_ENABLED = bool(NATIVE, &quot;native.enabled&quot;, true, &quot;Enable/disable native code, including POSIX features and C exts.&quot;);</span>
<span class="fc" id="L159">    public static final Option&lt;Boolean&gt; NATIVE_VERBOSE = bool(NATIVE, &quot;native.verbose&quot;, false, &quot;Enable verbose logging of native extension loading.&quot;);</span>
<span class="fc" id="L160">    public static final Option&lt;Boolean&gt; FFI_COMPILE_DUMP = bool(NATIVE, &quot;ffi.compile.dump&quot;, false, &quot;Dump bytecode-generated FFI stubs to console.&quot;);</span>
<span class="fc" id="L161">    public static final Option&lt;Integer&gt; FFI_COMPILE_THRESHOLD = integer(NATIVE, &quot;ffi.compile.threshold&quot;, 100, &quot;Number of FFI invocations before generating a bytecode stub.&quot;);</span>
<span class="fc" id="L162">    public static final Option&lt;Boolean&gt; FFI_COMPILE_INVOKEDYNAMIC = bool(NATIVE, &quot;ffi.compile.invokedynamic&quot;, false, &quot;Use invokedynamic to bind FFI invocations.&quot;);</span>
<span class="fc" id="L163">    public static final Option&lt;Boolean&gt; FFI_COMPILE_REIFY = bool(NATIVE, &quot;ffi.compile.reify&quot;, false, &quot;Reify FFI compiled classes.&quot;);</span>
    
<span class="fc" id="L165">    public static final Option&lt;Integer&gt; THREADPOOL_MIN = integer(THREADPOOL, &quot;thread.pool.min&quot;, 0, &quot;The minimum number of threads to keep alive in the pool.&quot;);</span>
<span class="fc" id="L166">    public static final Option&lt;Integer&gt; THREADPOOL_MAX = integer(THREADPOOL, &quot;thread.pool.max&quot;, Integer.MAX_VALUE, &quot;The maximum number of threads to allow in the pool.&quot;);</span>
<span class="fc" id="L167">    public static final Option&lt;Integer&gt; THREADPOOL_TTL = integer(THREADPOOL, &quot;thread.pool.ttl&quot;, 60, &quot;The maximum number of seconds to keep alive an idle thread.&quot;);</span>
<span class="fc" id="L168">    public static final Option&lt;Integer&gt; FIBER_THREADPOOL_TTL = integer(THREADPOOL, &quot;fiber.thread.pool.ttl&quot;, 60, &quot;The maximum number of seconds to keep alive a pooled fiber thread.&quot;);</span>

<span class="fc" id="L170">    public static final Option&lt;Boolean&gt; OBJECTSPACE_ENABLED = bool(MISCELLANEOUS, &quot;objectspace.enabled&quot;, false, &quot;Enable or disable ObjectSpace.each_object.&quot;);</span>
<span class="fc" id="L171">    public static final Option&lt;Boolean&gt; SIPHASH_ENABLED = bool(MISCELLANEOUS, &quot;siphash.enabled&quot;, false, &quot;Enable or disable SipHash for String hash function.&quot;);</span>
<span class="fc" id="L172">    public static final Option&lt;Boolean&gt; LAUNCH_INPROC = bool(MISCELLANEOUS, &quot;launch.inproc&quot;, false, &quot;Set in-process launching of e.g. system('ruby ...').&quot;);</span>
<span class="fc" id="L173">    public static final Option&lt;String&gt; BYTECODE_VERSION = string(MISCELLANEOUS, &quot;bytecode.version&quot;, new String[]{&quot;1.5&quot;,&quot;1.6&quot;,&quot;1.7&quot;}, SafePropertyAccessor.getProperty(&quot;java.specification.version&quot;, &quot;1.5&quot;), &quot;Specify the major Java bytecode version.&quot;);</span>
<span class="fc" id="L174">    public static final Option&lt;Boolean&gt; MANAGEMENT_ENABLED = bool(MISCELLANEOUS, &quot;management.enabled&quot;, false, &quot;Set whether JMX management is enabled.&quot;);</span>
<span class="fc" id="L175">    public static final Option&lt;Boolean&gt; JUMP_BACKTRACE = bool(MISCELLANEOUS, &quot;jump.backtrace&quot;, false, &quot;Make non-local flow jumps generate backtraces.&quot;);</span>
<span class="fc" id="L176">    public static final Option&lt;Boolean&gt; PROCESS_NOUNWRAP = bool(MISCELLANEOUS, &quot;process.noUnwrap&quot;, false, &quot;Do not unwrap process streams (issue on some recent JVMs).&quot;);</span>
<span class="fc" id="L177">    public static final Option&lt;Boolean&gt; REIFY_CLASSES = bool(MISCELLANEOUS, &quot;reify.classes&quot;, false, &quot;Before instantiation, stand up a real Java class for every Ruby class.&quot;);</span>
<span class="fc" id="L178">    public static final Option&lt;Boolean&gt; REIFY_LOGERRORS = bool(MISCELLANEOUS, &quot;reify.logErrors&quot;, false, &quot;Log errors during reification (reify.classes=true).&quot;);</span>
<span class="fc" id="L179">    public static final Option&lt;Boolean&gt; REFLECTED_HANDLES = bool(MISCELLANEOUS, &quot;reflected.handles&quot;, false, &quot;Use reflection for binding methods, not generated bytecode.&quot;);</span>
<span class="fc" id="L180">    public static final Option&lt;Boolean&gt; BACKTRACE_COLOR = bool(MISCELLANEOUS, &quot;backtrace.color&quot;, false, &quot;Enable colorized backtraces.&quot;);</span>
<span class="fc" id="L181">    public static final Option&lt;String&gt; BACKTRACE_STYLE = string(MISCELLANEOUS, &quot;backtrace.style&quot;, new String[]{&quot;normal&quot;,&quot;raw&quot;,&quot;full&quot;,&quot;mri&quot;}, &quot;normal&quot;, &quot;Set the style of exception backtraces.&quot;);</span>
<span class="fc" id="L182">    public static final Option&lt;Boolean&gt; BACKTRACE_MASK = bool(MISCELLANEOUS, &quot;backtrace.mask&quot;, false, &quot;Mask .java lines in Ruby backtraces.&quot;);</span>
<span class="fc" id="L183">    public static final Option&lt;String&gt; THREAD_DUMP_SIGNAL = string(MISCELLANEOUS, &quot;thread.dump.signal&quot;, new String[]{&quot;USR1&quot;, &quot;USR2&quot;, &quot;etc&quot;}, &quot;USR2&quot;, &quot;Set the signal used for dumping thread stacks.&quot;);</span>
<span class="fc" id="L184">    public static final Option&lt;Boolean&gt; NATIVE_NET_PROTOCOL = bool(MISCELLANEOUS, &quot;native.net.protocol&quot;, false, &quot;Use native impls for parts of net/protocol.&quot;);</span>
<span class="fc" id="L185">    public static final Option&lt;Boolean&gt; FIBER_COROUTINES = bool(MISCELLANEOUS, &quot;fiber.coroutines&quot;, false, &quot;Use JVM coroutines for Fiber.&quot;);</span>
<span class="fc" id="L186">    public static final Option&lt;Boolean&gt; GLOBAL_REQUIRE_LOCK = bool(MISCELLANEOUS, &quot;global.require.lock&quot;, false, &quot;Use a single global lock for requires.&quot;);</span>
<span class="fc" id="L187">    public static final Option&lt;Boolean&gt; NATIVE_EXEC = bool(MISCELLANEOUS, &quot;native.exec&quot;, true, &quot;Do a true process-obliterating native exec for Kernel#exec.&quot;);</span>
<span class="fc" id="L188">    public static final Option&lt;Boolean&gt; ENUMERATOR_LIGHTWEIGHT = bool(MISCELLANEOUS, &quot;enumerator.lightweight&quot;, true, &quot;Use lightweight Enumerator#next logic when possible.&quot;);</span>
<span class="fc" id="L189">    public static final Option&lt;Boolean&gt; CONSISTENT_HASHING = bool(MISCELLANEOUS, &quot;consistent.hashing&quot;, false, &quot;Generate consistent object hashes across JVMs&quot;);</span>
<span class="fc" id="L190">    public static final Option&lt;Boolean&gt; REIFY_VARIABLES = bool(MISCELLANEOUS, &quot;reify.variables&quot;, false, &quot;Attempt to expand instance vars into Java fields&quot;);</span>
<span class="fc" id="L191">    public static final Option&lt;Boolean&gt; PREFER_IPV4 = bool(MISCELLANEOUS, &quot;net.preferIPv4&quot;, true, &quot;Prefer IPv4 network stack&quot;);</span>
<span class="fc" id="L192">    public static final Option&lt;Boolean&gt; FCNTL_LOCKING = bool(MISCELLANEOUS, &quot;file.flock.fcntl&quot;, true, &quot;Use fcntl rather than flock for File#flock&quot;);</span>

<span class="fc" id="L194">    public static final Option&lt;Boolean&gt; DEBUG_LOADSERVICE = bool(DEBUG, &quot;debug.loadService&quot;, false, &quot;Log require/load file searches.&quot;);</span>
<span class="fc" id="L195">    public static final Option&lt;Boolean&gt; DEBUG_LOADSERVICE_TIMING = bool(DEBUG, &quot;debug.loadService.timing&quot;, false, &quot;Log require/load parse+evaluate times.&quot;);</span>
<span class="fc" id="L196">    public static final Option&lt;Boolean&gt; DEBUG_LAUNCH = bool(DEBUG, &quot;debug.launch&quot;, false, &quot;Log externally-launched processes.&quot;);</span>
<span class="fc" id="L197">    public static final Option&lt;Boolean&gt; DEBUG_FULLTRACE = bool(DEBUG, &quot;debug.fullTrace&quot;, false, &quot;Set whether full traces are enabled (c-call/c-return).&quot;);</span>
<span class="fc" id="L198">    public static final Option&lt;Boolean&gt; DEBUG_SCRIPTRESOLUTION = bool(DEBUG, &quot;debug.scriptResolution&quot;, false, &quot;Print which script is executed by '-S' flag.&quot;);</span>
<span class="fc" id="L199">    public static final Option&lt;Boolean&gt; DEBUG_PARSER = bool(DEBUG, &quot;debug.parser&quot;, false, &quot;disables JRuby impl script loads and prints parse exceptions&quot;);</span>
<span class="fc" id="L200">    public static final Option&lt;Boolean&gt; ERRNO_BACKTRACE = bool(DEBUG, &quot;errno.backtrace&quot;, false, &quot;Generate backtraces for heavily-used Errno exceptions (EAGAIN).&quot;);</span>
<span class="fc" id="L201">    public static final Option&lt;Boolean&gt; STOPITERATION_BACKTRACE = bool(DEBUG, &quot;stop_iteration.backtrace&quot;, false, &quot;Generate backtraces for heavily-used Errno exceptions (EAGAIN).&quot;);</span>
<span class="fc" id="L202">    public static final Option&lt;Boolean&gt; LOG_EXCEPTIONS = bool(DEBUG, &quot;log.exceptions&quot;, false, &quot;Log every time an exception is constructed.&quot;);</span>
<span class="fc" id="L203">    public static final Option&lt;Boolean&gt; LOG_BACKTRACES = bool(DEBUG, &quot;log.backtraces&quot;, false, &quot;Log every time an exception backtrace is generated.&quot;);</span>
<span class="fc" id="L204">    public static final Option&lt;Boolean&gt; LOG_CALLERS = bool(DEBUG, &quot;log.callers&quot;, false, &quot;Log every time a Kernel#caller backtrace is generated.&quot;);</span>
<span class="fc" id="L205">    public static final Option&lt;Boolean&gt; LOG_WARNINGS = bool(DEBUG, &quot;log.warnings&quot;, false, &quot;Log every time a built-in warning backtrace is generated.&quot;);</span>
<span class="fc" id="L206">    public static final Option&lt;String&gt; LOGGER_CLASS = string(DEBUG, &quot;logger.class&quot;, new String[] {&quot;class name&quot;}, &quot;org.jruby.util.log.StandardErrorLogger&quot;, &quot;Use specified class for logging.&quot;);</span>
<span class="fc" id="L207">    public static final Option&lt;Boolean&gt; DUMP_INSTANCE_VARS = bool(DEBUG, &quot;dump.variables&quot;, false, &quot;Dump class + instance var names on first new of Object subclasses.&quot;);</span>
<span class="fc" id="L208">    public static final Option&lt;Boolean&gt; REWRITE_JAVA_TRACE = bool(DEBUG, &quot;rewrite.java.trace&quot;, true, &quot;Rewrite stack traces from exceptions raised in Java calls.&quot;);</span>

<span class="fc" id="L210">    public static final Option&lt;Boolean&gt; JI_SETACCESSIBLE = bool(JAVA_INTEGRATION, &quot;ji.setAccessible&quot;, true, &quot;Try to set inaccessible Java methods to be accessible.&quot;);</span>
<span class="fc" id="L211">    public static final Option&lt;Boolean&gt; JI_LOGCANSETACCESSIBLE = bool(JAVA_INTEGRATION, &quot;ji.logCanSetAccessible&quot;, false, &quot;Log whether setAccessible is working.&quot;);</span>
<span class="fc" id="L212">    public static final Option&lt;Boolean&gt; JI_UPPER_CASE_PACKAGE_NAME_ALLOWED = bool(JAVA_INTEGRATION, &quot;ji.upper.case.package.name.allowed&quot;, false, &quot;Allow Capitalized Java pacakge names.&quot;);</span>
<span class="fc" id="L213">    public static final Option&lt;Boolean&gt; INTERFACES_USEPROXY = bool(JAVA_INTEGRATION, &quot;interfaces.useProxy&quot;, false, &quot;Use java.lang.reflect.Proxy for interface impl.&quot;);</span>
<span class="fc" id="L214">    public static final Option&lt;Boolean&gt; JAVA_HANDLES = bool(JAVA_INTEGRATION, &quot;java.handles&quot;, false, &quot;Use generated handles instead of reflection for calling Java.&quot;);</span>
<span class="fc" id="L215">    public static final Option&lt;Boolean&gt; JI_NEWSTYLEEXTENSION = bool(JAVA_INTEGRATION, &quot;ji.newStyleExtension&quot;, false, &quot;Extend Java classes without using a proxy object.&quot;);</span>
<span class="fc" id="L216">    public static final Option&lt;Boolean&gt; JI_OBJECTPROXYCACHE = bool(JAVA_INTEGRATION, &quot;ji.objectProxyCache&quot;, false, &quot;Cache Java object wrappers between calls.&quot;);</span>
<span class="fc" id="L217">    public static final Option&lt;String&gt; JI_PROXYCLASSFACTORY = string(JAVA_INTEGRATION, &quot;ji.proxyClassFactory&quot;, &quot;Allow external envs to replace JI proxy class factory&quot;);</span>
<span class="fc" id="L218">    public static final Option&lt;Boolean&gt; AOT_LOADCLASSES = bool(JAVA_INTEGRATION, &quot;aot.loadClasses&quot;, false, &quot;Look for .class before .rb to load AOT-compiled code&quot;);</span>

<span class="fc" id="L220">    public static final Option&lt;Integer&gt; PROFILE_MAX_METHODS = integer(PROFILING, &quot;profile.max.methods&quot;, 100000, &quot;Maximum number of methods to consider for profiling.&quot;);</span>
    
<span class="fc" id="L222">    public static final Option&lt;Boolean&gt; CLI_AUTOSPLIT = bool(CLI, &quot;cli.autosplit&quot;, false, &quot;Split $_ into $F for -p or -n. Same as -a.&quot;);</span>
<span class="fc" id="L223">    public static final Option&lt;Boolean&gt; CLI_DEBUG = bool(CLI, &quot;cli.debug&quot;, false, &quot;Enable debug mode logging. Same as -d.&quot;);</span>
<span class="fc" id="L224">    public static final Option&lt;Boolean&gt; CLI_PROCESS_LINE_ENDS = bool(CLI, &quot;cli.process.line.ends&quot;, false, &quot;Enable line ending processing. Same as -l.&quot;);</span>
<span class="fc" id="L225">    public static final Option&lt;Boolean&gt; CLI_ASSUME_LOOP = bool(CLI, &quot;cli.assume.loop&quot;, false, &quot;Wrap execution with a gets() loop. Same as -n.&quot;);</span>
<span class="fc" id="L226">    public static final Option&lt;Boolean&gt; CLI_ASSUME_PRINT = bool(CLI, &quot;cli.assume.print&quot;, false, &quot;Print $_ after each execution of script. Same as -p.&quot;);</span>
<span class="fc" id="L227">    public static final Option&lt;Boolean&gt; CLI_VERBOSE = bool(CLI, &quot;cli.verbose&quot;, false, &quot;Verbose mode, as -w or -W2. Sets default for cli.warning.level.&quot;);</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">    public static final Option&lt;Verbosity&gt; CLI_WARNING_LEVEL = enumeration(CLI, &quot;cli.warning.level&quot;, Verbosity.class, CLI_VERBOSE.load() ? Verbosity.TRUE : Verbosity.FALSE, &quot;Warning level (off=0,normal=1,on=2). Same as -W.&quot;);</span>
<span class="fc" id="L229">    public static final Option&lt;Boolean&gt; CLI_PARSER_DEBUG = bool(CLI, &quot;cli.parser.debug&quot;, false, &quot;Enable parser debug logging. Same as -y.&quot;);</span>
<span class="fc" id="L230">    public static final Option&lt;Boolean&gt; CLI_VERSION = bool(CLI, &quot;cli.version&quot;, false, &quot;Print version to stderr. Same as --version.&quot;);</span>
<span class="fc" id="L231">    public static final Option&lt;Boolean&gt; CLI_BYTECODE = bool(CLI, &quot;cli.bytecode&quot;, false, &quot;Print target script bytecode to stderr. Same as --bytecode.&quot;);</span>
<span class="fc" id="L232">    public static final Option&lt;Boolean&gt; CLI_COPYRIGHT = bool(CLI, &quot;cli.copyright&quot;, false, &quot;Print copyright to stderr. Same as --copyright but runs script.&quot;);</span>
<span class="fc" id="L233">    public static final Option&lt;Boolean&gt; CLI_CHECK_SYNTAX = bool(CLI, &quot;cli.check.syntax&quot;, false, &quot;Check syntax of target script. Same as -c but runs script.&quot;);</span>
<span class="fc" id="L234">    public static final Option&lt;String&gt; CLI_AUTOSPLIT_SEPARATOR = string(CLI, &quot;cli.autosplit.separator&quot;, &quot;Set autosplit separator. Same as -F.&quot;);</span>
<span class="fc" id="L235">    public static final Option&lt;KCode&gt; CLI_KCODE = enumeration(CLI, &quot;cli.kcode&quot;, KCode.class, KCode.NONE, &quot;Set kcode character set. Same as -K (1.8).&quot;);</span>
<span class="fc" id="L236">    public static final Option&lt;Boolean&gt; CLI_HELP = bool(CLI, &quot;cli.help&quot;, false, &quot;Print command-line usage. Same as --help but runs script.&quot;);</span>
<span class="fc" id="L237">    public static final Option&lt;Boolean&gt; CLI_PROPERTIES = bool(CLI, &quot;cli.properties&quot;, false, &quot;Print config properties. Same as --properties but runs script.&quot;);</span>
<span class="fc" id="L238">    public static final Option&lt;String&gt; CLI_ENCODING_INTERNAL = string(CLI, &quot;cli.encoding.internal&quot;, &quot;Encoding name to use internally.&quot;);</span>
<span class="fc" id="L239">    public static final Option&lt;String&gt; CLI_ENCODING_EXTERNAL = string(CLI, &quot;cli.encoding.external&quot;, &quot;Encoding name to treat external data.&quot;);</span>
<span class="fc" id="L240">    public static final Option&lt;String&gt; CLI_ENCODING_SOURCE = string(CLI, &quot;cli.encoding.source&quot;, &quot;Encoding name to treat source code.&quot;);</span>
<span class="fc" id="L241">    public static final Option&lt;String&gt; CLI_RECORD_SEPARATOR = string(CLI, &quot;cli.record.separator&quot;, &quot;\n&quot;, &quot;Default record separator.&quot;);</span>
<span class="fc" id="L242">    public static final Option&lt;String&gt; CLI_BACKUP_EXTENSION = string(CLI, &quot;cli.backup.extension&quot;, &quot;Backup extension for in-place ARGV files. Same as -i.&quot;);</span>
<span class="fc" id="L243">    public static final Option&lt;ProfilingMode&gt; CLI_PROFILING_MODE = enumeration(CLI, &quot;cli.profiling.mode&quot;, ProfilingMode.class, ProfilingMode.OFF, &quot;Enable instrumented profiling modes.&quot;);</span>
<span class="fc" id="L244">    public static final Option&lt;Boolean&gt; CLI_RUBYGEMS_ENABLE = bool(CLI, &quot;cli.rubygems.enable&quot;, true, &quot;Enable/disable RubyGems.&quot;);</span>
<span class="fc" id="L245">    public static final Option&lt;Boolean&gt; CLI_RUBYOPT_ENABLE = bool(CLI, &quot;cli.rubyopt.enable&quot;, true, &quot;Enable/disable RUBYOPT processing at start.&quot;);</span>
<span class="fc" id="L246">    public static final Option&lt;Boolean&gt; CLI_STRIP_HEADER = bool(CLI, &quot;cli.strip.header&quot;, false, &quot;Strip text before shebang in script. Same as -x.&quot;);</span>
<span class="fc" id="L247">    public static final Option&lt;Boolean&gt; CLI_LOAD_GEMFILE = bool(CLI, &quot;cli.load.gemfile&quot;, false, &quot;Load a bundler Gemfile in cwd before running. Same as -G.&quot;);</span>

    public static String dump() {
<span class="nc" id="L250">        return &quot;# JRuby configuration options with current values\n&quot; +</span>
<span class="nc" id="L251">                Option.formatValues(_loadedOptions);</span>
    }

<span class="fc" id="L254">    public static final Collection&lt;Option&gt; PROPERTIES = Collections.unmodifiableCollection(_loadedOptions);</span>

    // After PROPERTIES so it doesn't show up in --properties
    @Deprecated
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">    public static final Option&lt;Boolean&gt; JIT_CACHE = bool(JIT, &quot;jit.cache&quot;, !COMPILE_INVOKEDYNAMIC.load(), &quot;(DEPRECATED) Cache jitted method in-memory bodies across runtimes and loads.&quot;);</span>
    
    private static Option&lt;String&gt; string(Category category, String name, String[] options, String defval, String description) {
<span class="fc" id="L261">        Option&lt;String&gt; option = Option.string(&quot;jruby&quot;, name, category, options, defval, description);</span>
<span class="fc" id="L262">        _loadedOptions.add(option);</span>
<span class="fc" id="L263">        return option;</span>
    }
    
    private static Option&lt;String&gt; string(Category category, String name, String defval, String description) {
<span class="fc" id="L267">        Option&lt;String&gt; option = Option.string(&quot;jruby&quot;, name, category, defval, description);</span>
<span class="fc" id="L268">        _loadedOptions.add(option);</span>
<span class="fc" id="L269">        return option;</span>
    }
    
    private static Option&lt;String&gt; string(Category category, String name, String[] options, String description) {
<span class="fc" id="L273">        Option&lt;String&gt; option = Option.string(&quot;jruby&quot;, name, category, options, description);</span>
<span class="fc" id="L274">        _loadedOptions.add(option);</span>
<span class="fc" id="L275">        return option;</span>
    }
    
    private static Option&lt;String&gt; string(Category category, String name, String description) {
<span class="fc" id="L279">        Option&lt;String&gt; option = Option.string(&quot;jruby&quot;, name, category, description);</span>
<span class="fc" id="L280">        _loadedOptions.add(option);</span>
<span class="fc" id="L281">        return option;</span>
    }
    
    private static Option&lt;Boolean&gt; bool(Category category, String name, Boolean defval, String description) {
<span class="fc" id="L285">        Option&lt;Boolean&gt; option = Option.bool(&quot;jruby&quot;, name, category, defval, description);</span>
<span class="fc" id="L286">        _loadedOptions.add(option);</span>
<span class="fc" id="L287">        return option;</span>
    }
    
    private static Option&lt;Integer&gt; integer(Category category, String name, Integer defval, String description) {
<span class="fc" id="L291">        Option&lt;Integer&gt; option = Option.integer(&quot;jruby&quot;, name, category, defval, description);</span>
<span class="fc" id="L292">        _loadedOptions.add(option);</span>
<span class="fc" id="L293">        return option;</span>
    }
    
    private static &lt;T extends Enum&lt;T&gt;&gt; Option&lt;T&gt; enumeration(Category category, String name, Class&lt;T&gt; enumClass, T defval, String description) {
<span class="fc" id="L297">        Option&lt;T&gt; option = Option.enumeration(&quot;jruby&quot;, name, category, defval, description);</span>
<span class="fc" id="L298">        _loadedOptions.add(option);</span>
<span class="fc" id="L299">        return option;</span>
    }

    private static boolean calculateInvokedynamicDefault() {
        // We were defaulting on for Java 8 and might again later if JEP 210 helps reduce warmup time.
<span class="fc" id="L304">        return false;</span>
    }

<span class="nc" id="L307">    private static enum SearchMode {</span>
<span class="nc" id="L308">        PREFIX,</span>
<span class="nc" id="L309">        CONTAINS</span>
    }

    public static void listPrefix(String prefix) {
<span class="nc" id="L313">        list(SearchMode.PREFIX, prefix);</span>
<span class="nc" id="L314">    }</span>

    public static void listContains(String substring) {
<span class="nc" id="L317">        list(SearchMode.CONTAINS, substring);</span>
<span class="nc" id="L318">    }</span>

    private static void list(SearchMode mode, String string) {
<span class="nc bnc" id="L321" title="All 2 branches missed.">        for (Option option : PROPERTIES) {</span>
<span class="nc" id="L322">            boolean include = false;</span>

<span class="nc bnc" id="L324" title="All 3 branches missed.">            switch (mode) {</span>
                case PREFIX:
<span class="nc" id="L326">                    include = option.shortName().startsWith(string);</span>
<span class="nc" id="L327">                    break;</span>
                case CONTAINS:
<span class="nc" id="L329">                    include = option.shortName().contains(string);</span>
                    break;
            }

<span class="nc bnc" id="L333" title="All 2 branches missed.">            if (include) {</span>
<span class="nc" id="L334">                System.out.printf(&quot;%s=%s\n&quot;, option.shortName(), option.load());</span>
            }
<span class="nc" id="L336">        }</span>
<span class="nc" id="L337">    }</span>

    public static Set&lt;String&gt; getPropertyNames() {
<span class="fc" id="L340">        final Set&lt;String&gt; propertyNames = new HashSet&lt;String&gt;();</span>

<span class="fc bfc" id="L342" title="All 2 branches covered.">        for (Option option : PROPERTIES) {</span>
<span class="fc" id="L343">            propertyNames.add(option.propertyName());</span>
<span class="fc" id="L344">        }</span>

<span class="fc" id="L346">        return Collections.unmodifiableSet(propertyNames);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>