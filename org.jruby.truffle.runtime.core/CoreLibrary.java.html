<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CoreLibrary.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby.truffle.runtime.core</a> &gt; <span class="el_source">CoreLibrary.java</span></div><h1>CoreLibrary.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013, 2014 Oracle and/or its affiliates. All rights reserved. This
 * code is released under a tri EPL/GPL/LGPL license. You can use it,
 * redistribute it and/or modify it under the terms of the:
 *
 * Eclipse Public License version 1.0
 * GNU General Public License version 2
 * GNU Lesser General Public License version 2.1
 */
package org.jruby.truffle.runtime.core;

import com.oracle.truffle.api.CompilerAsserts;
import com.oracle.truffle.api.CompilerDirectives;
import com.oracle.truffle.api.nodes.Node;
import com.oracle.truffle.api.source.Source;
import org.jcodings.Encoding;
import org.jcodings.EncodingDB;
import org.jcodings.specific.UTF8Encoding;
import org.jruby.runtime.Constants;
import org.jruby.runtime.encoding.EncodingService;
import org.jruby.truffle.nodes.RubyNode;
import org.jruby.truffle.nodes.core.ArrayNodes;
import org.jruby.truffle.runtime.RubyCallStack;
import org.jruby.truffle.runtime.RubyContext;
import org.jruby.truffle.runtime.hash.HashOperations;
import org.jruby.truffle.runtime.hash.KeyValue;
import org.jruby.truffle.translator.TranslatorDriver;
import org.jruby.util.cli.Options;
import org.jruby.util.cli.OutputStrings;

import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

<span class="nc bnc" id="L38" title="All 2 branches missed.">public class CoreLibrary {</span>

    private final RubyContext context;

    @CompilerDirectives.CompilationFinal private RubyClass argumentErrorClass;
    @CompilerDirectives.CompilationFinal private RubyClass arrayClass;
    @CompilerDirectives.CompilationFinal private RubyClass basicObjectClass;
    @CompilerDirectives.CompilationFinal private RubyClass bignumClass;
    @CompilerDirectives.CompilationFinal private RubyClass bindingClass;
    @CompilerDirectives.CompilationFinal private RubyClass classClass;
    @CompilerDirectives.CompilationFinal private RubyClass continuationClass;
    @CompilerDirectives.CompilationFinal private RubyClass dirClass;
    @CompilerDirectives.CompilationFinal private RubyClass encodingClass;
    @CompilerDirectives.CompilationFinal private RubyClass exceptionClass;
    @CompilerDirectives.CompilationFinal private RubyClass falseClass;
    @CompilerDirectives.CompilationFinal private RubyClass fiberClass;
    @CompilerDirectives.CompilationFinal private RubyClass fileClass;
    @CompilerDirectives.CompilationFinal private RubyClass fixnumClass;
    @CompilerDirectives.CompilationFinal private RubyClass floatClass;
    @CompilerDirectives.CompilationFinal private RubyClass floatDomainErrorClass;
    @CompilerDirectives.CompilationFinal private RubyClass hashClass;
    @CompilerDirectives.CompilationFinal private RubyClass integerClass;
    @CompilerDirectives.CompilationFinal private RubyClass indexErrorClass;
    @CompilerDirectives.CompilationFinal private RubyClass ioClass;
    @CompilerDirectives.CompilationFinal private RubyClass keyErrorClass;
    @CompilerDirectives.CompilationFinal private RubyClass loadErrorClass;
    @CompilerDirectives.CompilationFinal private RubyClass localJumpErrorClass;
    @CompilerDirectives.CompilationFinal private RubyClass matchDataClass;
    @CompilerDirectives.CompilationFinal private RubyClass moduleClass;
    @CompilerDirectives.CompilationFinal private RubyClass nameErrorClass;
    @CompilerDirectives.CompilationFinal private RubyClass nilClass;
    @CompilerDirectives.CompilationFinal private RubyClass noMethodErrorClass;
    @CompilerDirectives.CompilationFinal private RubyClass numericClass;
    @CompilerDirectives.CompilationFinal private RubyClass objectClass;
    @CompilerDirectives.CompilationFinal private RubyClass procClass;
    @CompilerDirectives.CompilationFinal private RubyClass processClass;
    @CompilerDirectives.CompilationFinal private RubyClass rangeClass;
    @CompilerDirectives.CompilationFinal private RubyClass rangeErrorClass;
    @CompilerDirectives.CompilationFinal private RubyClass regexpClass;
    @CompilerDirectives.CompilationFinal private RubyClass regexpErrorClass;
    @CompilerDirectives.CompilationFinal private RubyClass rubyTruffleErrorClass;
    @CompilerDirectives.CompilationFinal private RubyClass runtimeErrorClass;
    @CompilerDirectives.CompilationFinal private RubyClass standardErrorClass;
    @CompilerDirectives.CompilationFinal private RubyClass stringClass;
    @CompilerDirectives.CompilationFinal private RubyClass symbolClass;
    @CompilerDirectives.CompilationFinal private RubyClass syntaxErrorClass;
    @CompilerDirectives.CompilationFinal private RubyClass systemCallErrorClass;
    @CompilerDirectives.CompilationFinal private RubyClass systemExitClass;
    @CompilerDirectives.CompilationFinal private RubyClass threadClass;
    @CompilerDirectives.CompilationFinal private RubyClass timeClass;
    @CompilerDirectives.CompilationFinal private RubyClass trueClass;
    @CompilerDirectives.CompilationFinal private RubyClass typeErrorClass;
    @CompilerDirectives.CompilationFinal private RubyClass zeroDivisionErrorClass;
    @CompilerDirectives.CompilationFinal private RubyModule comparableModule;
    @CompilerDirectives.CompilationFinal private RubyModule configModule;
    @CompilerDirectives.CompilationFinal private RubyModule enumerableModule;
    @CompilerDirectives.CompilationFinal private RubyModule errnoModule;
    @CompilerDirectives.CompilationFinal private RubyModule gcModule;
    @CompilerDirectives.CompilationFinal private RubyModule kernelModule;
    @CompilerDirectives.CompilationFinal private RubyModule mathModule;
    @CompilerDirectives.CompilationFinal private RubyModule objectSpaceModule;
    @CompilerDirectives.CompilationFinal private RubyModule signalModule;
    @CompilerDirectives.CompilationFinal private RubyModule truffleModule;
    @CompilerDirectives.CompilationFinal private RubyModule truffleDebugModule;
    @CompilerDirectives.CompilationFinal private RubyClass edomClass;
    @CompilerDirectives.CompilationFinal private RubyClass encodingConverterClass;
    @CompilerDirectives.CompilationFinal private RubyClass encodingCompatibilityErrorClass;

    @CompilerDirectives.CompilationFinal private RubyArray argv;
    @CompilerDirectives.CompilationFinal private RubyBasicObject globalVariablesObject;
    @CompilerDirectives.CompilationFinal private RubyBasicObject mainObject;
    @CompilerDirectives.CompilationFinal private RubyNilClass nilObject;
    @CompilerDirectives.CompilationFinal private RubyHash envHash;

    private ArrayNodes.MinBlock arrayMinBlock;
    private ArrayNodes.MaxBlock arrayMaxBlock;

<span class="nc" id="L115">    public CoreLibrary(RubyContext context) {</span>
<span class="nc" id="L116">        this.context = context;</span>
<span class="nc" id="L117">    }</span>

    /**
     * Convert a value to a {@code Float}, without doing any lookup.
     */
    public static double toDouble(Object value) {
<span class="nc" id="L123">        RubyNode.notDesignedForCompilation();</span>

<span class="nc bnc" id="L125" title="All 4 branches missed.">        assert value != null;</span>

<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (value instanceof RubyNilClass) {</span>
<span class="nc" id="L128">            return 0;</span>
        }

<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (value instanceof Integer) {</span>
<span class="nc" id="L132">            return (int) value;</span>
        }

<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (value instanceof RubyBignum) {</span>
<span class="nc" id="L136">            return ((RubyBignum) value).doubleValue();</span>
        }

<span class="nc bnc" id="L139" title="All 2 branches missed.">        if (value instanceof Double) {</span>
<span class="nc" id="L140">            return (double) value;</span>
        }

<span class="nc" id="L143">        CompilerDirectives.transferToInterpreter();</span>

<span class="nc" id="L145">        throw new UnsupportedOperationException();</span>
    }

    public static boolean fitsIntoInteger(long value) {
<span class="nc bnc" id="L149" title="All 4 branches missed.">        return value &gt;= Integer.MIN_VALUE &amp;&amp; value &lt;= Integer.MAX_VALUE;</span>
    }

    public void initialize() {
        // Create the cyclic classes and modules

<span class="nc" id="L155">        classClass = new RubyClass(context, null, null, &quot;Class&quot;, false);</span>
<span class="nc" id="L156">        classClass.setAllocator(new RubyClass.ClassAllocator());</span>

<span class="nc" id="L158">        basicObjectClass = RubyClass.createBootClass(context, &quot;BasicObject&quot;);</span>
<span class="nc" id="L159">        objectClass = RubyClass.createBootClass(context, &quot;Object&quot;);</span>

<span class="nc" id="L161">        moduleClass = new RubyClass(context, null, null, &quot;Module&quot;, false);</span>
<span class="nc" id="L162">        moduleClass.setAllocator(new RubyModule.ModuleAllocator());</span>

        // Close the cycles
<span class="nc" id="L165">        classClass.unsafeSetLogicalClass(classClass);</span>

<span class="nc" id="L167">        objectClass.unsafeSetSuperclass(basicObjectClass);</span>
<span class="nc" id="L168">        moduleClass.unsafeSetSuperclass(objectClass);</span>
<span class="nc" id="L169">        classClass.unsafeSetSuperclass(moduleClass);</span>

<span class="nc" id="L171">        classClass.getAdoptedByLexicalParent(objectClass, null);</span>
<span class="nc" id="L172">        basicObjectClass.getAdoptedByLexicalParent(objectClass, null);</span>
<span class="nc" id="L173">        objectClass.getAdoptedByLexicalParent(objectClass, null);</span>
<span class="nc" id="L174">        moduleClass.getAdoptedByLexicalParent(objectClass, null);</span>

        // BasicObject knows itself

<span class="nc" id="L178">        basicObjectClass.setConstant(null, &quot;BasicObject&quot;, basicObjectClass);</span>

        // Create all other classes and modules

<span class="nc" id="L182">        numericClass = new RubyClass(context, objectClass, objectClass, &quot;Numeric&quot;);</span>
<span class="nc" id="L183">        integerClass = new RubyClass(context, objectClass, numericClass, &quot;Integer&quot;);</span>

<span class="nc" id="L185">        exceptionClass = new RubyClass(context, objectClass, objectClass, &quot;Exception&quot;);</span>
<span class="nc" id="L186">        exceptionClass.setAllocator(new RubyException.ExceptionAllocator());</span>

<span class="nc" id="L188">        standardErrorClass = new RubyClass(context, objectClass, exceptionClass, &quot;StandardError&quot;);</span>
<span class="nc" id="L189">        standardErrorClass.setAllocator(new RubyException.ExceptionAllocator());</span>

<span class="nc" id="L191">        ioClass = new RubyClass(context, objectClass, objectClass, &quot;IO&quot;);</span>

<span class="nc" id="L193">        argumentErrorClass = new RubyClass(context, objectClass, standardErrorClass, &quot;ArgumentError&quot;);</span>
<span class="nc" id="L194">        argumentErrorClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L195">        arrayClass = new RubyClass(context, objectClass, objectClass, &quot;Array&quot;);</span>
<span class="nc" id="L196">        arrayClass.setAllocator(new RubyArray.ArrayAllocator());</span>
<span class="nc" id="L197">        bignumClass = new RubyClass(context, objectClass, integerClass, &quot;Bignum&quot;);</span>
<span class="nc" id="L198">        bignumClass.setAllocator(new RubyBignum.BignumAllocator());</span>
<span class="nc" id="L199">        bindingClass = new RubyClass(context, objectClass, objectClass, &quot;Binding&quot;);</span>
<span class="nc" id="L200">        comparableModule = new RubyModule(context, objectClass, &quot;Comparable&quot;);</span>
<span class="nc" id="L201">        configModule = new RubyModule(context, objectClass, &quot;Config&quot;);</span>
<span class="nc" id="L202">        continuationClass = new RubyClass(context, objectClass, objectClass, &quot;Continuation&quot;);</span>
<span class="nc" id="L203">        dirClass = new RubyClass(context, objectClass, objectClass, &quot;Dir&quot;);</span>
<span class="nc" id="L204">        encodingClass = new RubyClass(context, objectClass, objectClass, &quot;Encoding&quot;);</span>
<span class="nc" id="L205">        encodingClass.setAllocator(new RubyEncoding.EncodingAllocator());</span>
<span class="nc" id="L206">        errnoModule = new RubyModule(context, objectClass, &quot;Errno&quot;);</span>
<span class="nc" id="L207">        enumerableModule = new RubyModule(context, objectClass, &quot;Enumerable&quot;);</span>
<span class="nc" id="L208">        falseClass = new RubyClass(context, objectClass, objectClass, &quot;FalseClass&quot;);</span>
<span class="nc" id="L209">        fiberClass = new RubyClass(context, objectClass, objectClass, &quot;Fiber&quot;);</span>
<span class="nc" id="L210">        fileClass = new RubyClass(context, objectClass, ioClass, &quot;File&quot;);</span>
<span class="nc" id="L211">        fixnumClass = new RubyClass(context, objectClass, integerClass, &quot;Fixnum&quot;);</span>
<span class="nc" id="L212">        floatClass = new RubyClass(context, objectClass, numericClass, &quot;Float&quot;);</span>
<span class="nc" id="L213">        floatDomainErrorClass = new RubyClass(context, objectClass, rangeErrorClass, &quot;FloatDomainError&quot;);</span>
<span class="nc" id="L214">        floatDomainErrorClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L215">        gcModule = new RubyModule(context, objectClass, &quot;GC&quot;);</span>
<span class="nc" id="L216">        hashClass = new RubyClass(context, objectClass, objectClass, &quot;Hash&quot;);</span>
<span class="nc" id="L217">        hashClass.setAllocator(new RubyHash.HashAllocator());</span>
<span class="nc" id="L218">        indexErrorClass = new RubyClass(context, objectClass, standardErrorClass, &quot;IndexError&quot;);</span>
<span class="nc" id="L219">        indexErrorClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L220">        kernelModule = new RubyModule(context, objectClass, &quot;Kernel&quot;);</span>
<span class="nc" id="L221">        keyErrorClass = new RubyClass(context, objectClass, indexErrorClass, &quot;KeyError&quot;);</span>
<span class="nc" id="L222">        keyErrorClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L223">        loadErrorClass = new RubyClass(context, objectClass, standardErrorClass, &quot;LoadError&quot;);</span>
<span class="nc" id="L224">        loadErrorClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L225">        localJumpErrorClass = new RubyClass(context, objectClass, standardErrorClass, &quot;LocalJumpError&quot;);</span>
<span class="nc" id="L226">        localJumpErrorClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L227">        matchDataClass = new RubyClass(context, objectClass, objectClass, &quot;MatchData&quot;);</span>
<span class="nc" id="L228">        mathModule = new RubyModule(context, objectClass, &quot;Math&quot;);</span>
<span class="nc" id="L229">        nameErrorClass = new RubyClass(context, objectClass, standardErrorClass, &quot;NameError&quot;);</span>
<span class="nc" id="L230">        nameErrorClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L231">        nilClass = new RubyClass(context, objectClass, objectClass, &quot;NilClass&quot;);</span>
<span class="nc" id="L232">        noMethodErrorClass = new RubyClass(context, objectClass, nameErrorClass, &quot;NoMethodError&quot;);</span>
<span class="nc" id="L233">        noMethodErrorClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L234">        objectSpaceModule = new RubyModule(context, objectClass, &quot;ObjectSpace&quot;);</span>
<span class="nc" id="L235">        procClass = new RubyClass(context, objectClass, objectClass, &quot;Proc&quot;);</span>
<span class="nc" id="L236">        procClass.setAllocator(new RubyProc.ProcAllocator());</span>
<span class="nc" id="L237">        processClass = new RubyClass(context, objectClass, objectClass, &quot;Process&quot;);</span>
<span class="nc" id="L238">        rangeClass = new RubyClass(context, objectClass, objectClass, &quot;Range&quot;);</span>
<span class="nc" id="L239">        rangeErrorClass = new RubyClass(context, objectClass, standardErrorClass, &quot;RangeError&quot;);</span>
<span class="nc" id="L240">        rangeErrorClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L241">        regexpClass = new RubyClass(context, objectClass, objectClass, &quot;Regexp&quot;);</span>
<span class="nc" id="L242">        regexpClass.setAllocator(new RubyRegexp.RegexpAllocator());</span>
<span class="nc" id="L243">        regexpErrorClass = new RubyClass(context, objectClass, standardErrorClass, &quot;RegexpError&quot;);</span>
<span class="nc" id="L244">        regexpErrorClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L245">        rubyTruffleErrorClass = new RubyClass(context, objectClass, standardErrorClass, &quot;RubyTruffleError&quot;);</span>
<span class="nc" id="L246">        rubyTruffleErrorClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L247">        runtimeErrorClass = new RubyClass(context, objectClass, standardErrorClass, &quot;RuntimeError&quot;);</span>
<span class="nc" id="L248">        runtimeErrorClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L249">        signalModule = new RubyModule(context, objectClass, &quot;Signal&quot;);</span>
<span class="nc" id="L250">        stringClass = new RubyClass(context, objectClass, objectClass, &quot;String&quot;);</span>
<span class="nc" id="L251">        stringClass.setAllocator(new RubyString.StringAllocator());</span>
<span class="nc" id="L252">        symbolClass = new RubyClass(context, objectClass, objectClass, &quot;Symbol&quot;);</span>
<span class="nc" id="L253">        syntaxErrorClass = new RubyClass(context, objectClass, standardErrorClass, &quot;SyntaxError&quot;);</span>
<span class="nc" id="L254">        syntaxErrorClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L255">        systemCallErrorClass = new RubyClass(context, objectClass, standardErrorClass, &quot;SystemCallError&quot;);</span>
<span class="nc" id="L256">        systemCallErrorClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L257">        systemExitClass = new RubyClass(context, objectClass, exceptionClass, &quot;SystemExit&quot;);</span>
<span class="nc" id="L258">        systemExitClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L259">        threadClass = new RubyClass(context, objectClass, objectClass, &quot;Thread&quot;);</span>
<span class="nc" id="L260">        threadClass.setAllocator(new RubyThread.ThreadAllocator());</span>
<span class="nc" id="L261">        timeClass = new RubyClass(context, objectClass, objectClass, &quot;Time&quot;);</span>
<span class="nc" id="L262">        timeClass.setAllocator(new RubyTime.TimeAllocator());</span>
<span class="nc" id="L263">        trueClass = new RubyClass(context, objectClass, objectClass, &quot;TrueClass&quot;);</span>
<span class="nc" id="L264">        truffleModule = new RubyModule(context, objectClass, &quot;Truffle&quot;);</span>
<span class="nc" id="L265">        truffleDebugModule = new RubyModule(context, truffleModule, &quot;Debug&quot;);</span>
<span class="nc" id="L266">        new RubyModule(context, truffleModule, &quot;Primitive&quot;);</span>
<span class="nc" id="L267">        typeErrorClass = new RubyClass(context, objectClass, standardErrorClass, &quot;TypeError&quot;);</span>
<span class="nc" id="L268">        typeErrorClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L269">        zeroDivisionErrorClass = new RubyClass(context, objectClass, standardErrorClass, &quot;ZeroDivisionError&quot;);</span>
<span class="nc" id="L270">        zeroDivisionErrorClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L271">        encodingConverterClass = new RubyClass(context, encodingClass, objectClass, &quot;Converter&quot;);</span>
<span class="nc" id="L272">        encodingConverterClass.setAllocator(new RubyEncodingConverter.EncodingConverterAllocator());</span>

<span class="nc" id="L274">        encodingCompatibilityErrorClass = new RubyClass(context, encodingClass, standardErrorClass, &quot;CompatibilityError&quot;);</span>
<span class="nc" id="L275">        encodingCompatibilityErrorClass.setAllocator(new RubyException.ExceptionAllocator());</span>

        // Includes

<span class="nc" id="L279">        objectClass.include(null, kernelModule);</span>
<span class="nc" id="L280">        numericClass.include(null, comparableModule);</span>
<span class="nc" id="L281">        arrayClass.include(null, enumerableModule);</span>

        // Set constants

<span class="nc" id="L285">        objectClass.setConstant(null, &quot;RUBY_VERSION&quot;, RubyString.fromJavaString(stringClass, Constants.RUBY_VERSION));</span>
<span class="nc" id="L286">        objectClass.setConstant(null, &quot;RUBY_PATCHLEVEL&quot;, Constants.RUBY_PATCHLEVEL);</span>
<span class="nc" id="L287">        objectClass.setConstant(null, &quot;RUBY_ENGINE&quot;, RubyString.fromJavaString(stringClass, Constants.ENGINE + &quot;+truffle&quot;));</span>
<span class="nc" id="L288">        objectClass.setConstant(null, &quot;RUBY_PLATFORM&quot;, RubyString.fromJavaString(stringClass, Constants.PLATFORM));</span>

<span class="nc" id="L290">        edomClass = new RubyClass(context, errnoModule, systemCallErrorClass, &quot;EDOM&quot;);</span>
<span class="nc" id="L291">        edomClass.setAllocator(new RubyException.ExceptionAllocator());</span>

        RubyClass tempClass;

<span class="nc" id="L295">        tempClass = new RubyClass(context, errnoModule, systemCallErrorClass, &quot;ENOENT&quot;);</span>
<span class="nc" id="L296">        tempClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L297">        tempClass = new RubyClass(context, errnoModule, systemCallErrorClass, &quot;EPERM&quot;);</span>
<span class="nc" id="L298">        tempClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L299">        tempClass = new RubyClass(context, errnoModule, systemCallErrorClass, &quot;ENOTEMPTY&quot;);</span>
<span class="nc" id="L300">        tempClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L301">        tempClass = new RubyClass(context, errnoModule, systemCallErrorClass, &quot;EEXIST&quot;);</span>
<span class="nc" id="L302">        tempClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L303">        tempClass = new RubyClass(context, errnoModule, systemCallErrorClass, &quot;EXDEV&quot;);</span>
<span class="nc" id="L304">        tempClass.setAllocator(new RubyException.ExceptionAllocator());</span>
<span class="nc" id="L305">        tempClass = new RubyClass(context, errnoModule, systemCallErrorClass, &quot;EACCES&quot;);</span>
<span class="nc" id="L306">        tempClass.setAllocator(new RubyException.ExceptionAllocator());</span>

        // TODO(cs): this should be a separate exception
<span class="nc" id="L309">        mathModule.setConstant(null, &quot;DomainError&quot;, edomClass);</span>

        // Create some key objects

<span class="nc" id="L313">        mainObject = new RubyBasicObject(objectClass);</span>
<span class="nc" id="L314">        nilObject = new RubyNilClass(nilClass);</span>

        // Create the globals object

<span class="nc" id="L318">        globalVariablesObject = new RubyBasicObject(objectClass);</span>
<span class="nc" id="L319">        globalVariablesObject.getOperations().setInstanceVariable(globalVariablesObject, &quot;$LOAD_PATH&quot;, new RubyArray(arrayClass));</span>
<span class="nc" id="L320">        globalVariablesObject.getOperations().setInstanceVariable(globalVariablesObject, &quot;$LOADED_FEATURES&quot;, new RubyArray(arrayClass));</span>
<span class="nc" id="L321">        globalVariablesObject.getOperations().setInstanceVariable(globalVariablesObject, &quot;$:&quot;, globalVariablesObject.getInstanceVariable(&quot;$LOAD_PATH&quot;));</span>
<span class="nc" id="L322">        globalVariablesObject.getOperations().setInstanceVariable(globalVariablesObject, &quot;$\&quot;&quot;, globalVariablesObject.getInstanceVariable(&quot;$LOADED_FEATURES&quot;));</span>
<span class="nc" id="L323">        globalVariablesObject.getOperations().setInstanceVariable(globalVariablesObject, &quot;$,&quot;, nilObject);</span>

<span class="nc" id="L325">        initializeEncodingConstants();</span>

<span class="nc" id="L327">        arrayMinBlock = new ArrayNodes.MinBlock(context);</span>
<span class="nc" id="L328">        arrayMaxBlock = new ArrayNodes.MaxBlock(context);</span>

<span class="nc" id="L330">        argv = new RubyArray(arrayClass);</span>
<span class="nc" id="L331">        objectClass.setConstant(null, &quot;ARGV&quot;, argv);</span>

<span class="nc" id="L333">        fileClass.setConstant(null, &quot;SEPARATOR&quot;, RubyString.fromJavaString(stringClass, File.separator));</span>
<span class="nc" id="L334">        fileClass.setConstant(null, &quot;Separator&quot;, RubyString.fromJavaString(stringClass, File.separator));</span>
<span class="nc" id="L335">        fileClass.setConstant(null, &quot;ALT_SEPARATOR&quot;, nilObject);</span>
<span class="nc" id="L336">        fileClass.setConstant(null, &quot;PATH_SEPARATOR&quot;, RubyString.fromJavaString(stringClass, File.pathSeparator));</span>
<span class="nc" id="L337">        fileClass.setConstant(null, &quot;FNM_SYSCASE&quot;, 0);</span>

<span class="nc" id="L339">        RubyNode.notDesignedForCompilation();</span>
<span class="nc" id="L340">        globalVariablesObject.getOperations().setInstanceVariable(globalVariablesObject, &quot;$DEBUG&quot;, context.getRuntime().isDebug());</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">        Object value = context.getRuntime().warningsEnabled() ? context.getRuntime().isVerbose() : nilObject;</span>
<span class="nc" id="L342">        RubyNode.notDesignedForCompilation();</span>
<span class="nc" id="L343">        globalVariablesObject.getOperations().setInstanceVariable(globalVariablesObject, &quot;$VERBOSE&quot;, value);</span>
<span class="nc" id="L344">    }</span>

    public void initializeAfterMethodsAdded() {
<span class="nc" id="L347">        objectClass.setConstant(null, &quot;RUBY_RELEASE_DATE&quot;, context.makeString(Constants.COMPILE_DATE));</span>
<span class="nc" id="L348">        objectClass.setConstant(null, &quot;RUBY_DESCRIPTION&quot;, context.makeString(OutputStrings.getVersionString()));</span>

<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (Options.TRUFFLE_LOAD_CORE.load()) {</span>
<span class="nc" id="L351">            loadRubyCore(&quot;jruby/truffle/core.rb&quot;);</span>
        }

        // ENV is supposed to be an object that actually updates the environment, and sees any updates

<span class="nc" id="L356">        envHash = getSystemEnv();</span>
<span class="nc" id="L357">        objectClass.setConstant(null, &quot;ENV&quot;, envHash);</span>
<span class="nc" id="L358">    }</span>

    public void loadRubyCore(String fileName) {
        final Source source;

        try {
<span class="nc" id="L364">            source = Source.fromReader(new InputStreamReader(context.getRuntime().getLoadService().getClassPathResource(context.getRuntime().getJRubyClassLoader(), fileName).getInputStream()), &quot;core:/&quot; + fileName);</span>
<span class="nc" id="L365">        } catch (IOException e) {</span>
<span class="nc" id="L366">            throw new RuntimeException(e);</span>
<span class="nc" id="L367">        }</span>

<span class="nc" id="L369">        context.execute(context, source, UTF8Encoding.INSTANCE, TranslatorDriver.ParserContext.TOP_LEVEL, mainObject, null, null);</span>
<span class="nc" id="L370">    }</span>

    public void initializeEncodingConstants() {
<span class="nc" id="L373">        getContext().getRuntime().getEncodingService().defineEncodings(new EncodingService.EncodingDefinitionVisitor() {</span>
            @Override
            public void defineEncoding(EncodingDB.Entry encodingEntry, byte[] name, int p, int end) {
<span class="nc" id="L376">                Encoding e = encodingEntry.getEncoding();</span>

<span class="nc" id="L378">                RubyEncoding re = RubyEncoding.newEncoding(getContext(), e, name, p, end, encodingEntry.isDummy());</span>
<span class="nc" id="L379">                RubyEncoding.storeEncoding(encodingEntry.getIndex(), re);</span>
<span class="nc" id="L380">            }</span>

            @Override
            public void defineConstant(int encodingListIndex, String constName) {
<span class="nc" id="L384">                encodingClass.setConstant(null, constName, RubyEncoding.getEncoding(encodingListIndex));</span>
<span class="nc" id="L385">            }</span>
        });

<span class="nc" id="L388">        getContext().getRuntime().getEncodingService().defineAliases(new EncodingService.EncodingAliasVisitor() {</span>
            @Override
            public void defineAlias(int encodingListIndex, String constName) {
<span class="nc" id="L391">                RubyEncoding re = RubyEncoding.getEncoding(encodingListIndex);</span>
<span class="nc" id="L392">                RubyEncoding.storeAlias(constName, re);</span>
<span class="nc" id="L393">            }</span>

            @Override
            public void defineConstant(int encodingListIndex, String constName) {
<span class="nc" id="L397">                encodingClass.setConstant(null, constName, RubyEncoding.getEncoding(encodingListIndex));</span>
<span class="nc" id="L398">            }</span>
        });
<span class="nc" id="L400">    }</span>

    public RubyClass getMetaClass(Object object) {
<span class="nc" id="L403">        RubyNode.notDesignedForCompilation();</span>

<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (object instanceof RubyBasicObject) {</span>
<span class="nc" id="L406">            return ((RubyBasicObject) object).getMetaClass();</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">        } else if (object instanceof Boolean) {</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">            if ((boolean) object) {</span>
<span class="nc" id="L409">                return trueClass;</span>
            } else {
<span class="nc" id="L411">                return falseClass;</span>
            }
<span class="nc bnc" id="L413" title="All 2 branches missed.">        } else if (object instanceof Integer) {</span>
<span class="nc" id="L414">            return fixnumClass;</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">        } else if (object instanceof Long) {</span>
<span class="nc" id="L416">            return fixnumClass;</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">        } else if (object instanceof Double) {</span>
<span class="nc" id="L418">            return floatClass;</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">        } else if (object == null) {</span>
<span class="nc" id="L420">            throw new RuntimeException();</span>
        } else {
<span class="nc" id="L422">            throw new UnsupportedOperationException(String.format(&quot;Don't know how to get the metaclass for %s&quot;, object.getClass()));</span>
        }
    }

    public RubyClass getLogicalClass(Object object) {
<span class="nc" id="L427">        RubyNode.notDesignedForCompilation();</span>

<span class="nc bnc" id="L429" title="All 2 branches missed.">        if (object instanceof RubyBasicObject) {</span>
<span class="nc" id="L430">            return ((RubyBasicObject) object).getLogicalClass();</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">        } else if (object instanceof Boolean) {</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">            if ((boolean) object) {</span>
<span class="nc" id="L433">                return trueClass;</span>
            } else {
<span class="nc" id="L435">                return falseClass;</span>
            }
<span class="nc bnc" id="L437" title="All 2 branches missed.">        } else if (object instanceof Integer) {</span>
<span class="nc" id="L438">            return fixnumClass;</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">        } else if (object instanceof Long) {</span>
<span class="nc" id="L440">            return fixnumClass;</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">        } else if (object instanceof Double) {</span>
<span class="nc" id="L442">            return floatClass;</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">        } else if (object == null) {</span>
<span class="nc" id="L444">            throw new RuntimeException();</span>
        } else {
<span class="nc" id="L446">            throw new UnsupportedOperationException(String.format(&quot;Don't know how to get the logical class for %s&quot;, object.getClass()));</span>
        }
    }

    public RubyException runtimeError(String message, Node currentNode) {
<span class="nc" id="L451">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L452">        return new RubyException(runtimeErrorClass, context.makeString(message), RubyCallStack.getBacktrace(currentNode));</span>
    }

    public RubyException frozenError(String className, Node currentNode) {
<span class="nc" id="L456">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L457">        return runtimeError(String.format(&quot;FrozenError: can't modify frozen %s&quot;, className), currentNode);</span>
    }

    public RubyException argumentError(String message, Node currentNode) {
<span class="nc" id="L461">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L462">        return new RubyException(argumentErrorClass, context.makeString(message), RubyCallStack.getBacktrace(currentNode));</span>
    }

    public RubyException argumentErrorMissingKeyword(String name, Node currentNode) {
<span class="nc" id="L466">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L467">        return argumentError(String.format(&quot;missing keyword: %s&quot;, name), currentNode);</span>
    }

    public RubyException argumentError(int passed, int required, Node currentNode) {
<span class="nc" id="L471">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L472">        return argumentError(String.format(&quot;wrong number of arguments (%d for %d)&quot;, passed, required), currentNode);</span>
    }

    public RubyException argumentError(int passed, int required, int optional, Node currentNode) {
<span class="nc" id="L476">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L477">        return argumentError(String.format(&quot;wrong number of arguments (%d for %d..%d)&quot;, passed, required, required + optional), currentNode);</span>
    }

    public RubyException argumentErrorEmptyVarargs(Node currentNode) {
<span class="nc" id="L481">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L482">        return argumentError(&quot;wrong number of arguments (0 for 1+)&quot;, currentNode);</span>
    }

    public RubyException indexError(String message, Node currentNode) {
<span class="nc" id="L486">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L487">        return new RubyException(indexErrorClass, context.makeString(message), RubyCallStack.getBacktrace(currentNode));</span>
    }

    public RubyException indexTooSmallError(String type, int index, int length, Node currentNode) {
<span class="nc" id="L491">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L492">        return indexError(String.format(&quot;index %d too small for %s; minimum: -%d&quot;, index, type, length), currentNode);</span>
    }

    public RubyException indexNegativeLength(int length, Node currentNode) {
<span class="nc" id="L496">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L497">        return indexError(String.format(&quot;negative length (%d)&quot;, length), currentNode);</span>
    }

    public RubyException localJumpError(String message, Node currentNode) {
<span class="nc" id="L501">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L502">        return new RubyException(localJumpErrorClass, context.makeString(message), RubyCallStack.getBacktrace(currentNode));</span>
    }

    public RubyException unexpectedReturn(Node currentNode) {
<span class="nc" id="L506">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L507">        return localJumpError(&quot;unexpected return&quot;, currentNode);</span>
    }

    public RubyException noBlockToYieldTo(Node currentNode) {
<span class="nc" id="L511">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L512">        return localJumpError(&quot;no block given (yield)&quot;, currentNode);</span>
    }

    public RubyException typeError(String message, Node currentNode) {
<span class="nc" id="L516">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L517">        return new RubyException(typeErrorClass, context.makeString(message), RubyCallStack.getBacktrace(currentNode));</span>
    }

    public RubyException typeErrorCantDefineSingleton(Node currentNode) {
<span class="nc" id="L521">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L522">        return typeError(&quot;can't define singleton&quot;, currentNode);</span>
    }

    public RubyException typeErrorNoClassToMakeAlias(Node currentNode) {
<span class="nc" id="L526">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L527">        return typeError(&quot;no class to make alias&quot;, currentNode);</span>
    }

    public RubyException typeErrorShouldReturn(String object, String method, String expectedType, Node currentNode) {
<span class="nc" id="L531">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L532">        return typeError(String.format(&quot;%s#%s should return %s&quot;, object, method, expectedType), currentNode);</span>
    }

    public RubyException typeErrorCantConvertTo(String from, String to, Node currentNode) {
<span class="nc" id="L536">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L537">        return typeError(String.format(&quot;can't convert %s to %s&quot;, from, to), currentNode);</span>
    }

    public RubyException typeErrorCantConvertTo(String from, String to, String methodUsed, String given, Node currentNode) {
<span class="nc" id="L541">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L542">        return typeError(String.format(&quot;can't convert %s to %s (%s#%s gives %s)&quot;, from, to, from, methodUsed, given), currentNode);</span>
    }

    public RubyException typeErrorCantConvertInto(String from, String to, Node currentNode) {
<span class="nc" id="L546">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L547">        return typeError(String.format(&quot;can't convert %s into %s&quot;, from, to), currentNode);</span>
    }

    public RubyException typeErrorCantConvertInto(Object from, RubyClass to, Node currentNode) {
<span class="nc" id="L551">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L552">        return typeErrorCantConvertInto(getLogicalClass(from).getName(), to.getName(), currentNode);</span>
    }

    public RubyException typeErrorIsNotA(String value, String expectedType, Node currentNode) {
<span class="nc" id="L556">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L557">        return typeError(String.format(&quot;%s is not a %s&quot;, value, expectedType), currentNode);</span>
    }

    public RubyException typeErrorNoImplicitConversion(Object from, String to, Node currentNode) {
<span class="nc" id="L561">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L562">        return typeError(String.format(&quot;no implicit conversion of %s into %s&quot;, getLogicalClass(from).getName(), to), currentNode);</span>
    }

    public RubyException typeErrorMustBe(String variable, String type, Node currentNode) {
<span class="nc" id="L566">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L567">        return typeError(String.format(&quot;value of %s must be %s&quot;, variable, type), currentNode);</span>
    }

    public RubyException typeErrorBadCoercion(Object from, String to, String coercionMethod, Object coercedTo, Node currentNode) {
<span class="nc" id="L571">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L572">        String badClassName = getLogicalClass(from).getName();</span>
<span class="nc" id="L573">        return typeError(String.format(&quot;can't convert %s to %s (%s#%s gives %s)&quot;,</span>
                badClassName,
                to,
                badClassName,
                coercionMethod,
<span class="nc" id="L578">                getLogicalClass(coercedTo).getName()), currentNode);</span>
    }

    public RubyException nameError(String message, Node currentNode) {
<span class="nc" id="L582">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L583">        return new RubyException(nameErrorClass, context.makeString(message), RubyCallStack.getBacktrace(currentNode));</span>
    }

    public RubyException nameErrorUninitializedConstant(RubyModule module, String name, Node currentNode) {
<span class="nc" id="L587">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L588">        return nameError(String.format(&quot;uninitialized constant %s::%s&quot;, module.getName(), name), currentNode);</span>
    }

    public RubyException nameErrorPrivateConstant(RubyModule module, String name, Node currentNode) {
<span class="nc" id="L592">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L593">        return nameError(String.format(&quot;private constant %s::%s referenced&quot;, module.getName(), name), currentNode);</span>
    }

    public RubyException nameErrorInstanceNameNotAllowable(String name, Node currentNode) {
<span class="nc" id="L597">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L598">        return nameError(String.format(&quot;`%s' is not allowable as an instance variable name&quot;, name), currentNode);</span>
    }

    public RubyException nameErrorReadOnly(String name, Node currentNode) {
<span class="nc" id="L602">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L603">        return nameError(String.format(&quot;%s is a read-only variable&quot;, name), currentNode);</span>
    }

    public RubyException nameErrorUndefinedLocalVariableOrMethod(String name, String object, Node currentNode) {
<span class="nc" id="L607">        return nameError(String.format(&quot;undefined local variable or method `%s' for %s&quot;, name, object), currentNode);</span>
    }

    public RubyException noMethodError(String message, Node currentNode) {
<span class="nc" id="L611">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L612">        return new RubyException(context.getCoreLibrary().getNoMethodErrorClass(), context.makeString(message), RubyCallStack.getBacktrace(currentNode));</span>
    }

    public RubyException noMethodError(String name, String object, Node currentNode) {
<span class="nc" id="L616">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L617">        return noMethodError(String.format(&quot;undefined method `%s' for %s&quot;, name, object), currentNode);</span>
    }

    public RubyException privateMethodError(String name, String object, Node currentNode) {
<span class="nc" id="L621">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L622">        return noMethodError(String.format(&quot;private method `%s' called for %s&quot;, name, object), currentNode);</span>
    }

    public RubyException loadError(String message, Node currentNode) {
<span class="nc" id="L626">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L627">        return new RubyException(context.getCoreLibrary().getLoadErrorClass(), context.makeString(message), RubyCallStack.getBacktrace(currentNode));</span>
    }

    public RubyException loadErrorCannotLoad(String name, Node currentNode) {
<span class="nc" id="L631">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L632">        return loadError(String.format(&quot;cannot load such file -- %s&quot;, name), currentNode);</span>
    }

    public RubyException zeroDivisionError(Node currentNode) {
<span class="nc" id="L636">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L637">        return new RubyException(context.getCoreLibrary().getZeroDivisionErrorClass(), context.makeString(&quot;divided by 0&quot;), RubyCallStack.getBacktrace(currentNode));</span>
    }

    public RubyException syntaxError(String message, Node currentNode) {
<span class="nc" id="L641">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L642">        return new RubyException(syntaxErrorClass, context.makeString(message), RubyCallStack.getBacktrace(currentNode));</span>
    }

    public RubyException floatDomainError(String value, Node currentNode) {
<span class="nc" id="L646">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L647">        return new RubyException(floatDomainErrorClass, context.makeString(value), RubyCallStack.getBacktrace(currentNode));</span>
    }

    public RubyException mathDomainError(String method, Node currentNode) {
<span class="nc" id="L651">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L652">        return new RubyException(edomClass, context.makeString(String.format(&quot;Numerical argument is out of domain - \&quot;%s\&quot;&quot;, method)), RubyCallStack.getBacktrace(currentNode));</span>
    }

    public RubyException rangeError(String type, String value, String range, Node currentNode) {
<span class="nc" id="L656">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L657">        return new RubyException(rangeErrorClass, context.makeString(String.format(&quot;%s %s out of range of %s&quot;, type, value, range)), RubyCallStack.getBacktrace(currentNode));</span>
    }

    public RubyException internalError(String message, Node currentNode) {
<span class="nc" id="L661">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L662">        return new RubyException(context.getCoreLibrary().getRubyTruffleErrorClass(), context.makeString(&quot;internal implementation error - &quot; + message), RubyCallStack.getBacktrace(currentNode));</span>
    }

    public RubyException regexpError(String message, Node currentNode) {
<span class="nc" id="L666">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L667">        return new RubyException(regexpErrorClass, context.makeString(message), RubyCallStack.getBacktrace(currentNode));</span>
    }

    public RubyException encodingCompatibilityErrorIncompatible(String a, String b, Node currentNode) {
<span class="nc" id="L671">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L672">        return encodingCompatibilityError(String.format(&quot;incompatible character encodings: %s and %s&quot;, a, b), currentNode);</span>
    }

    public RubyException encodingCompatibilityError(String message, Node currentNode) {
<span class="nc" id="L676">        CompilerAsserts.neverPartOfCompilation();</span>
<span class="nc" id="L677">        return new RubyException(encodingCompatibilityErrorClass, context.makeString(message), RubyCallStack.getBacktrace(currentNode));</span>
    }

    public RubyContext getContext() {
<span class="nc" id="L681">        return context;</span>
    }

    public RubyClass getArrayClass() {
<span class="nc" id="L685">        return arrayClass;</span>
    }

    public RubyClass getBasicObjectClass() {
<span class="nc" id="L689">        return basicObjectClass;</span>
    }

    public RubyClass getBignumClass() {
<span class="nc" id="L693">        return bignumClass;</span>
    }

    public RubyClass getBindingClass() {
<span class="nc" id="L697">        return bindingClass;</span>
    }

    public RubyClass getClassClass() {
<span class="nc" id="L701">        return classClass;</span>
    }

    public RubyClass getContinuationClass() {
<span class="nc" id="L705">        return continuationClass;</span>
    }

<span class="nc" id="L708">    public RubyClass getExceptionClass() { return exceptionClass; }</span>

    public RubyClass getFalseClass() {
<span class="nc" id="L711">        return falseClass;</span>
    }

    public RubyClass getFiberClass() {
<span class="nc" id="L715">        return fiberClass;</span>
    }

    public RubyClass getFileClass() {
<span class="nc" id="L719">        return fileClass;</span>
    }

    public RubyClass getFixnumClass() {
<span class="nc" id="L723">        return fixnumClass;</span>
    }

    public RubyClass getFloatClass() {
<span class="nc" id="L727">        return floatClass;</span>
    }

    public RubyClass getHashClass() {
<span class="nc" id="L731">        return hashClass;</span>
    }

    public RubyClass getLoadErrorClass() {
<span class="nc" id="L735">        return loadErrorClass;</span>
    }

    public RubyClass getMatchDataClass() {
<span class="nc" id="L739">        return matchDataClass;</span>
    }

    public RubyClass getModuleClass() {
<span class="nc" id="L743">        return moduleClass;</span>
    }

    public RubyClass getNameErrorClass() {
<span class="nc" id="L747">        return nameErrorClass;</span>
    }

    public RubyClass getNilClass() {
<span class="nc" id="L751">        return nilClass;</span>
    }

    public RubyClass getNoMethodErrorClass() {
<span class="nc" id="L755">        return noMethodErrorClass;</span>
    }

    public RubyClass getObjectClass() {
<span class="nc" id="L759">        return objectClass;</span>
    }

    public RubyClass getProcClass() {
<span class="nc" id="L763">        return procClass;</span>
    }

    public RubyClass getRangeClass() {
<span class="nc" id="L767">        return rangeClass;</span>
    }

    public RubyClass getRegexpClass() {
<span class="nc" id="L771">        return regexpClass;</span>
    }

    public RubyClass getRubyTruffleErrorClass() {
<span class="nc" id="L775">        return rubyTruffleErrorClass;</span>
    }

    public RubyClass getRuntimeErrorClass() {
<span class="nc" id="L779">        return runtimeErrorClass;</span>
    }

    public RubyClass getStringClass() {
<span class="nc" id="L783">        return stringClass;</span>
    }

<span class="nc" id="L786">    public RubyClass getEncodingClass(){ return encodingClass; }</span>

    public RubyClass getSymbolClass() {
<span class="nc" id="L789">        return symbolClass;</span>
    }

    public RubyClass getSyntaxErrorClass() {
<span class="nc" id="L793">        return syntaxErrorClass;</span>
    }

    public RubyClass getThreadClass() {
<span class="nc" id="L797">        return threadClass;</span>
    }

    public RubyClass getTimeClass() {
<span class="nc" id="L801">        return timeClass;</span>
    }

    public RubyClass getTrueClass() {
<span class="nc" id="L805">        return trueClass;</span>
    }

    public RubyClass getZeroDivisionErrorClass() {
<span class="nc" id="L809">        return zeroDivisionErrorClass;</span>
    }

    public RubyModule getKernelModule() {
<span class="nc" id="L813">        return kernelModule;</span>
    }

    public RubyArray getArgv() {
<span class="nc" id="L817">        return argv;</span>
    }

    public RubyBasicObject getGlobalVariablesObject() {
<span class="nc" id="L821">        return globalVariablesObject;</span>
    }

    public RubyArray getLoadPath() {
<span class="nc" id="L825">        return (RubyArray) globalVariablesObject.getInstanceVariable(&quot;$LOAD_PATH&quot;);</span>
    }

    public RubyArray getLoadedFeatures() {
<span class="nc" id="L829">        return (RubyArray) globalVariablesObject.getInstanceVariable(&quot;$LOADED_FEATURES&quot;);</span>
    }

    public RubyBasicObject getMainObject() {
<span class="nc" id="L833">        return mainObject;</span>
    }

    public RubyNilClass getNilObject() {
<span class="nc" id="L837">        return nilObject;</span>
    }

    public RubyHash getENV() {
<span class="nc" id="L841">        return envHash;</span>
    }

<span class="nc" id="L844">    public RubyEncoding getDefaultEncoding() { return RubyEncoding.getEncoding(context, &quot;US-ASCII&quot;); }</span>

    private RubyHash getSystemEnv() {
<span class="nc" id="L847">        final List&lt;KeyValue&gt; entries = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L849" title="All 2 branches missed.">        for (Map.Entry&lt;String, String&gt; variable : System.getenv().entrySet()) {</span>
<span class="nc" id="L850">            entries.add(new KeyValue(context.makeString(variable.getKey()), context.makeString(variable.getValue())));</span>
<span class="nc" id="L851">        }</span>

<span class="nc" id="L853">        return HashOperations.verySlowFromEntries(context, entries);</span>
    }

    public ArrayNodes.MinBlock getArrayMinBlock() {
<span class="nc" id="L857">        return arrayMinBlock;</span>
    }

    public ArrayNodes.MaxBlock getArrayMaxBlock() {
<span class="nc" id="L861">        return arrayMaxBlock;</span>
    }

    public RubyClass getNumericClass() {
<span class="nc" id="L865">        return numericClass;</span>
    }

    public RubyClass getIntegerClass() {
<span class="nc" id="L869">        return integerClass;</span>
    }

    public RubyClass getArgumentErrorClass() {
<span class="nc" id="L873">        return argumentErrorClass;</span>
    }

    public RubyClass getEncodingConverterClass() {
<span class="nc" id="L877">        return encodingConverterClass;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>