<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ScriptingContainer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby.embed</a> &gt; <span class="el_source">ScriptingContainer.java</span></div><h1>ScriptingContainer.java</h1><pre class="source lang-java linenums">/**
 * **** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2009-2013 Yoko Harada &lt;yokolet@gmail.com&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 * **** END LICENSE BLOCK *****
 */
package org.jruby.embed;

import java.io.UnsupportedEncodingException;
import org.jruby.embed.internal.LocalContextProvider;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.Writer;
import java.net.URISyntaxException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.jruby.CompatVersion;
import org.jruby.Profile;
import org.jruby.Ruby;
import org.jruby.RubyGlobal.InputGlobalVariable;
import org.jruby.RubyGlobal.OutputGlobalVariable;
import org.jruby.RubyIO;
import org.jruby.RubyInstanceConfig.CompileMode;
import org.jruby.RubyInstanceConfig.LoadServiceCreator;
import org.jruby.RubyInstanceConfig.ProfilingMode;
import org.jruby.embed.internal.BiVariableMap;
import org.jruby.embed.internal.ConcurrentLocalContextProvider;
import org.jruby.embed.internal.EmbedRubyInterfaceAdapterImpl;
import org.jruby.embed.internal.EmbedRubyObjectAdapterImpl;
import org.jruby.embed.internal.EmbedRubyRuntimeAdapterImpl;
import org.jruby.embed.internal.SingleThreadLocalContextProvider;
import org.jruby.embed.internal.SingletonLocalContextProvider;
import org.jruby.embed.internal.ThreadSafeLocalContextProvider;
import org.jruby.embed.io.ReaderInputStream;
import org.jruby.embed.io.WriterOutputStream;
import org.jruby.embed.util.SystemPropertyCatcher;
import org.jruby.internal.runtime.GlobalVariable;
import org.jruby.javasupport.JavaEmbedUtils;
import org.jruby.runtime.Block;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.runtime.profile.builtin.ProfileOutput;
import org.jruby.util.KCode;
import org.jruby.util.cli.OutputStrings;
import org.jruby.util.cli.Options;

/**
 * ScriptingContainer provides various methods and resources that are useful
 * for embedding Ruby in Java. Using this class, users can run Ruby scripts from
 * Java programs easily. Also, users can use methods defined or implemented by Ruby.
 *
 * ScriptingContainer allows users to set various configuration parameters. 
 * Some of them are per-container properties, while others are per-evaluation attributes.
 * For example, a local context scope, local variable behavior, load paths are 
 * per-container properties. Please see {@link PropertyName} and {@link AttributeName}
 * for more details. Be aware that the per-container properties should be set prior to
 * get Ruby runtime be instantiated; otherwise, default values are applied to. 
 * ScriptingContainer delays Ruby runtime initialization as much as possible to
 * improve startup time. When values are put into the ScriptingContainer, or runScriptlet
 * method gets run Ruby runtime is created internally. However, the default, singleton
 * local context scope behave slightly different. If Ruby runtime has been already instantiated
 * by another ScriptingContainer, application, etc, the same runtime will be used.
 *
 * Below are examples.
 *
 * The first Example is a very simple Hello World. After initializing a ScriptingContainer,
 * a Ruby script, puts &quot;Hello World!&quot;, runs and produces &quot;Hello World!.&quot;
 * &lt;pre&gt;Example 1:
 *
 *         ScriptingContainer container = new ScriptingContainer();
 *         container.runScriptlet(&quot;puts \&quot;Hello World!\&quot;&quot;);
 *
 * Produces:
 * Hello World!&lt;/pre&gt;
 * 
 * The second example shows how to share variables between Java and Ruby.
 * In this example, a local variable &quot;x&quot; is shared. To make this happen, a local variable
 * behavior should be transient or persistent. As for JSR223 JRuby engine, set these
 * types using System property, org.jruby.embed.localvariable.behavior. If the local
 * variable behavior is one of transient or persistent,
 * Ruby's local, instance, global variables and constants are available to share
 * between Java and Ruby. (A class variable sharing does not work on current version)
 * Thus, &quot;x&quot; in Java is also &quot;x&quot; in Ruby.
 * 
 * &lt;pre&gt;Example 2:
 *
 *         ScriptingContainer container = new ScriptingContainer();
 *         container.put(&quot;x&quot;, 12345);
 *         container.runScriptlet(&quot;puts x.to_s(2)&quot;);
 *
 * Produces:
 * 11000000111001&lt;/pre&gt;
 *
 * The third examples shows how to keep local variables across multiple evaluations.
 * This feature simulates BSF engine for JRuby. In terms of Ruby semantics,
 * local variables should not survive after the evaluation has completed. Thus,
 * this behavior is optional, and users need to specify LocalVariableBehavior.PERSISTENT
 * when the container is instantiated.
 *
 * &lt;pre&gt;Example 3:
 * 
 *         ScriptingContainer container = new ScriptingContainer(LocalVariableBehavior.PERSISTENT);
 *         container.runScriptlet(&quot;p=9.0&quot;);
 *         container.runScriptlet(&quot;q = Math.sqrt p&quot;);
 *         container.runScriptlet(&quot;puts \&quot;square root of #{p} is #{q}\&quot;&quot;);
 *         System.out.println(&quot;Ruby used values: p = &quot; + container.get(&quot;p&quot;) +
 *               &quot;, q = &quot; + container.get(&quot;q&quot;));
 *
 * Produces:
 * square root of 9.0 is 3.0
 * Ruby used values: p = 9.0, q = 3.0&lt;/pre&gt;
 * 
 * Also, ScriptingContainer provides better i18n support. For example,
 * Unicode Escape Sequence can be included in Ruby scripts.
 *
 * &lt;p&gt;In addition, ScriptingContainer supports a parse-once-eval-many-times feature,
 * invoking methods defined by Ruby, and getting an instance of a specified interface
 * that has been implemented by Ruby.
 *
 * &lt;pre&gt;Example 4:
 *         ScriptingContainer container = new ScriptingContainer();
 *         script =
 *          &quot;def message\n&quot; +
 *              &quot;\&quot;message: #{@message}\&quot;\n&quot; +
 *          &quot;end\n&quot; +
 *          &quot;message&quot;;
 *         container.put(&quot;@message&quot;, &quot;What's up?&quot;);
 *         EvalUnit unit = container.parse(script);
 *         IRubyObject ret = unit.run();
 *         System.out.println(JavaEmbedUtils.rubyToJava(ret));
 *         container.put(&quot;@message&quot;, &quot;Fabulous!&quot;);
 *         ret = unit.run();
 *         System.out.println(JavaEmbedUtils.rubyToJava(ret));
 *         container.put(&quot;@message&quot;, &quot;That's the way you are.&quot;);
 *         ret = unit.run();
 *         System.out.println(JavaEmbedUtils.rubyToJava(ret));
 * 
 * Produces:
 *     message: What's up?
 *     message: Fabulous!
 *     message: That's the way you are.&lt;/pre&gt;
 *
 * See more details at project's 
 * {@see &lt;a href=&quot;https://github.com/jruby/jruby/wiki/RedBridge&quot;&gt;Wiki&lt;/a&gt;}
 * 
 * @author Yoko Harada &lt;yokolet@gmail.com&gt;
 */
public class ScriptingContainer implements EmbedRubyInstanceConfigAdapter {
<span class="nc" id="L174">    private Map basicProperties = null;</span>
    private final LocalContextScope scope;
<span class="nc" id="L176">    private LocalContextProvider provider = null;</span>
<span class="nc" id="L177">    private EmbedRubyRuntimeAdapter runtimeAdapter = new EmbedRubyRuntimeAdapterImpl(this);</span>
<span class="nc" id="L178">    private EmbedRubyObjectAdapter objectAdapter = new EmbedRubyObjectAdapterImpl(this);</span>
<span class="nc" id="L179">    private EmbedRubyInterfaceAdapter interfaceAdapter = new EmbedRubyInterfaceAdapterImpl(this);</span>

    /**
     * Constructs a ScriptingContainer with a default values.
     */
    public ScriptingContainer() {
<span class="nc" id="L185">        this(LocalContextScope.SINGLETON, LocalVariableBehavior.TRANSIENT, true);</span>
<span class="nc" id="L186">    }</span>

    /**
     * Constructs a ScriptingContainer with a specified local context type.
     *
     * @param scope a local context type.
     */
    public ScriptingContainer(LocalContextScope scope) {
<span class="nc" id="L194">        this(scope, LocalVariableBehavior.TRANSIENT, true);</span>
<span class="nc" id="L195">    }</span>

    /**
     * Constructs a ScriptingContainer with a specified local variable behavior.
     *
     * @param behavior a local variable behavior
     */
    public ScriptingContainer(LocalVariableBehavior behavior) {
<span class="nc" id="L203">        this(LocalContextScope.SINGLETON, behavior, true);</span>
<span class="nc" id="L204">    }</span>

    /**
     * Constructs a ScriptingContainer with a specified local context type and
     * variable behavior.
     *
     * @param scope a local context type
     * @param behavior a local variable behavior
     */
    public ScriptingContainer(LocalContextScope scope, LocalVariableBehavior behavior) {
<span class="nc" id="L214">        this(scope, behavior, true);</span>
<span class="nc" id="L215">    }</span>

    /**
     * Constructs a ScriptingContainer with a specified local context scope,
     * local variable behavior and laziness.
     *
     * @param scope is one of a local context scope defined by {@link LocalContextScope}
     * @param behavior is one of a local variable behavior defined by {@link LocalVariableBehavior}
     * @param lazy is a switch to do lazy retrieval of variables/constants from
     *        Ruby runtime. Default is true. When this value is true, ScriptingContainer tries to
     *        get as many variables/constants as possible from Ruby runtime.
     */
<span class="nc" id="L227">    public ScriptingContainer(LocalContextScope scope, LocalVariableBehavior behavior, boolean lazy) {</span>
<span class="nc" id="L228">        this.provider = getProviderInstance(scope, behavior, lazy);</span>
<span class="nc" id="L229">        this.scope = scope;</span>
        try {
<span class="nc" id="L231">            initConfig();</span>
<span class="nc" id="L232">        } catch (Exception ex) {</span>
<span class="nc" id="L233">            throw new RuntimeException(ex);</span>
<span class="nc" id="L234">        }</span>
<span class="nc" id="L235">        setBasicProperties();</span>
<span class="nc" id="L236">    }</span>

    private LocalContextProvider getProviderInstance(LocalContextScope scope, LocalVariableBehavior behavior, boolean lazy) {
<span class="nc bnc" id="L239" title="All 4 branches missed.">        switch(scope) {</span>
            case THREADSAFE :
<span class="nc" id="L241">                return new ThreadSafeLocalContextProvider(behavior, lazy);</span>
            case CONCURRENT :
<span class="nc" id="L243">                return new ConcurrentLocalContextProvider(behavior, lazy);</span>
            case SINGLETHREAD :
<span class="nc" id="L245">                return new SingleThreadLocalContextProvider(behavior, lazy);</span>
            case SINGLETON :
            default :
<span class="nc" id="L248">                LocalVariableBehavior b = SingletonLocalContextProvider.getLocalVariableBehaviorOrNull();</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">                if (b == null) return new SingletonLocalContextProvider(behavior, lazy);</span>
<span class="nc" id="L250">                else return new SingletonLocalContextProvider(b, lazy);</span>
        }
    }

    private void initConfig() throws URISyntaxException, UnsupportedEncodingException {
<span class="nc" id="L255">        String home = SystemPropertyCatcher.findJRubyHome(this);</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">        if (home != null) {</span>
<span class="nc" id="L257">        	provider.getRubyInstanceConfig().setJRubyHome(home);</span>
        }
<span class="nc" id="L259">        provider.getRubyInstanceConfig().setScriptFileName(&quot;&lt;script&gt;&quot;);</span>
<span class="nc" id="L260">    }</span>

    // maybe these properties are not used at all?
    private void setBasicProperties() {
<span class="nc" id="L264">        basicProperties = new HashMap();</span>
<span class="nc" id="L265">        basicProperties.put(&quot;container.ids&quot;, new String[]{&quot;ruby&quot;, &quot;jruby&quot;});</span>
<span class="nc" id="L266">        basicProperties.put(&quot;language.extension&quot;, new String[]{&quot;rb&quot;});</span>
<span class="nc" id="L267">        basicProperties.put(&quot;language.name&quot;, new String[]{&quot;ruby&quot;});</span>
<span class="nc" id="L268">        basicProperties.put(&quot;language.mimetypes&quot;, new String[]{&quot;application/x-ruby&quot;});</span>
<span class="nc" id="L269">    }</span>

    /**
     * Returns a list of load paths for Ruby scripts/libraries. If no paths is
     * given, the list is created from java.class.path System property.
     *
     * @since JRuby 1.5.0.
     *
     * @return a list of load paths.
     */
    public List&lt;String&gt; getLoadPaths() {
<span class="nc" id="L280">        return provider.getRubyInstanceConfig().getLoadPaths();</span>
    }

    /**
     * Changes a list of load paths Ruby scripts/libraries. The default value
     * is an empty array. If no paths is given, the list is created from
     * java.class.path System property. This value can be set by
     * org.jruby.embed.class.path System property, also.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * the given paths will be used.
     *
     * @since JRuby 1.5.0.
     *
     * @param paths a new list of load paths.
     */
    public void setLoadPaths(List&lt;String&gt; paths) {
<span class="nc" id="L296">        provider.getRubyInstanceConfig().setLoadPaths(paths);</span>
<span class="nc" id="L297">    }</span>

    /**
     * Returns an input stream assigned to STDIN and $stdin.
     *
     * @since JRuby 1.5.0.
     *
     * @return input stream of STDIN and $stdin
     */
    public InputStream getInput() {
<span class="nc" id="L307">        return provider.getRubyInstanceConfig().getInput();</span>
    }

    /**
     * Changes STDIN and $stdin to a given input stream. The default standard input
     * is java.lang.System.in.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * the given input stream will be used.
     *
     * @since JRuby 1.5.0.
     *
     * @param istream an input stream to be set
     */
    public void setInput(InputStream istream) {
<span class="nc" id="L321">        provider.getRubyInstanceConfig().setInput(istream);</span>
<span class="nc" id="L322">    }</span>

    /**
     * Changes STDIN and $stdin to a given reader. No reader is set by default.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * the given reader will be used.
     *
     * @since JRuby 1.5.0.
     *
     * @param reader a reader to be set
     */
    public void setInput(Reader reader) {
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (reader == null) {</span>
<span class="nc" id="L335">            provider.getRubyInstanceConfig().setInput(null);</span>
        } else {
<span class="nc" id="L337">            ReaderInputStream istream = new ReaderInputStream(reader);</span>
<span class="nc" id="L338">            provider.getRubyInstanceConfig().setInput(istream);</span>
        }
<span class="nc" id="L340">    }</span>

    /**
     * Returns an output stream assigned to STDOUT and $stdout.
     *
     * @since JRuby 1.5.0.
     *
     * @return an output stream of STDOUT and $stdout
     */
    public PrintStream getOutput() {
<span class="nc" id="L350">        return provider.getRubyInstanceConfig().getOutput();</span>
    }

    /**
     * Changes STDOUT and $stdout to a given output stream. The default standard
     * output is java.lang.System.out.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * the given output stream will be used.
     *
     * @since JRuby 1.5.0.
     *
     * @param pstream an output stream to be set
     */
    public void setOutput(PrintStream pstream) {
<span class="nc" id="L364">        provider.getRubyInstanceConfig().setOutput(pstream);</span>
<span class="nc" id="L365">    }</span>

    /**
     * Changes STDOUT and $stdout to a given writer. No writer is set by default.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * the given writer will be used.
     *
     * @since JRuby 1.5.0.
     *
     * @param writer a writer to be set
     */
    public void setOutput(Writer writer) {
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (writer == null) {</span>
<span class="nc" id="L378">            provider.getRubyInstanceConfig().setOutput(null);</span>
        } else {
<span class="nc" id="L380">            WriterOutputStream ostream = new WriterOutputStream(writer);</span>
<span class="nc" id="L381">            PrintStream pstream = new PrintStream(ostream);</span>
<span class="nc" id="L382">            provider.getRubyInstanceConfig().setOutput(pstream);</span>
        }
<span class="nc" id="L384">    }</span>

    /**
     * Returns an error stream assigned to STDERR and $stderr.
     *
     * @since JRuby 1.5.0.
     *
     * @return output stream for error stream
     */
    public PrintStream getError() {
<span class="nc" id="L394">        return provider.getRubyInstanceConfig().getError();</span>
    }

    /**
     * Changes STDERR and $stderr to a given print stream. The default standard error
     * is java.lang.System.err.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * the given print stream will be used.
     *
     * @since JRuby 1.5.0.
     *
     * @param pstream a print stream to be set
     */
    public void setError(PrintStream pstream) {
<span class="nc" id="L408">        provider.getRubyInstanceConfig().setError(pstream);</span>
<span class="nc" id="L409">    }</span>

    /**
     * Changes STDERR and $stderr to a given writer. No writer is set by default.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * the given writer will be used.
     *
     * @since JRuby 1.5.0.
     *
     * @param writer a writer to be set
     */
    public void setError(Writer writer) {
<span class="nc bnc" id="L421" title="All 2 branches missed.">        if (writer == null) {</span>
<span class="nc" id="L422">            provider.getRubyInstanceConfig().setError(null);</span>
        } else {
<span class="nc" id="L424">            WriterOutputStream ostream = new WriterOutputStream(writer);</span>
<span class="nc" id="L425">            PrintStream pstream = new PrintStream(ostream);</span>
<span class="nc" id="L426">            provider.getRubyInstanceConfig().setError(pstream);</span>
        }
<span class="nc" id="L428">    }</span>

    /**
     * Returns a compile mode currently chosen, which is one of CompileMode.JIT,
     * CompileMode.FORCE, CompileMode.OFF. The default mode is CompileMode.OFF
     * if CompatVersion.RUBY1_9 is chosen, otherwise, CompileMode.JIT. Also,
     * CompileMode.OFF is chosen when a security restriction is set.
     *
     * @since JRuby 1.5.0.
     *
     * @return a compile mode.
     */
    public CompileMode getCompileMode() {
<span class="nc" id="L441">        return provider.getRubyInstanceConfig().getCompileMode();</span>
    }

    /**
     * Changes a compile mode to a given mode, which should be one of CompileMode.JIT,
     * CompileMode.FORCE, CompileMode.OFF.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * the given mode will be used.
     *
     * @since JRuby 1.5.0.
     *
     * @param mode compile mode
     */
    public void setCompileMode(CompileMode mode) {
<span class="nc" id="L455">        provider.getRubyInstanceConfig().setCompileMode(mode);</span>
<span class="nc" id="L456">    }</span>

    /**
     * Tests whether Ruby runs in a process or not.
     *
     * @since JRuby 1.5.0.
     *
     * @return true if Ruby is configured to run in a process, otherwise, false.
     */
    public boolean isRunRubyInProcess() {
<span class="nc" id="L466">        return provider.getRubyInstanceConfig().isRunRubyInProcess();</span>
    }

    /**
     * Changes the value to determine whether Ruby runs in a process or not. The
     * default value is true.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * the given condition will be set.
     *
     * @since JRuby 1.5.0.
     *
     * @param inprocess true when Ruby is set to run in the process, or false not to
     * run in the process.
     */
    public void setRunRubyInProcess(boolean inprocess) {
<span class="nc" id="L481">        provider.getRubyInstanceConfig().setRunRubyInProcess(inprocess);</span>
<span class="nc" id="L482">    }</span>

    @Deprecated
    public CompatVersion getCompatVersion() {
<span class="nc" id="L486">        return provider.getRubyInstanceConfig().getCompatVersion();</span>
    }

    @Deprecated
    public void setCompatVersion(CompatVersion version) {
<span class="nc" id="L491">    }</span>

    /**
     * Tests whether the Object Space is enabled or not.
     *
     * @since JRuby 1.5.0.
     *
     * @return true if the Object Space is able to use, otherwise, false.
     */
    public boolean isObjectSpaceEnabled() {
<span class="nc" id="L501">        return provider.getRubyInstanceConfig().isObjectSpaceEnabled();</span>
    }

    /**
     * Changes the value to determine whether the Object Space is enabled or not. The
     * default value is false.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * the given condition will be used.
     *
     * @since JRuby 1.5.0.
     *
     * This value can be set by jruby.objectspace.enabled system property.
     *
     * @param enable true to enable the Object Space, or false to disable.
     */
    public void setObjectSpaceEnabled(boolean enable) {
<span class="nc" id="L517">        provider.getRubyInstanceConfig().setObjectSpaceEnabled(enable);</span>
<span class="nc" id="L518">    }</span>

    /**
     * Returns a map of environment variables.
     *
     * @since JRuby 1.5.0.
     *
     * @return a map that has environment variables' key-value pairs.
     */
    public Map getEnvironment() {
<span class="nc" id="L528">        return provider.getRubyInstanceConfig().getEnvironment();</span>
    }

    /**
     * Changes an environment variables' map.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * initial configurations will work.
     *
     * @since JRuby 1.5.0.
     *
     * @param environment a new map of environment variables.
     */
    public void setEnvironment(Map environment) {
<span class="nc" id="L541">        provider.getRubyInstanceConfig().setEnvironment(environment);</span>
<span class="nc" id="L542">    }</span>

    /**
     * Returns a current directory.
     *
     * The default current directory is identical to a value of &quot;user.dir&quot; system
     * property if no security restriction is set. If the &quot;user.dir&quot; directory is
     * protected by the security restriction, the default value is &quot;/&quot;.
     *
     * @since JRuby 1.5.0.
     *
     * @return a current directory.
     */
    public String getCurrentDirectory() {
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (provider.isRuntimeInitialized()) {</span>
<span class="nc" id="L557">            return provider.getRuntime().getCurrentDirectory();</span>
        }
<span class="nc" id="L559">        return provider.getRubyInstanceConfig().getCurrentDirectory();</span>
    }

    /**
     * Changes a current directory to a given directory.
     * The current directory can be changed anytime.
     *
     * @since JRuby 1.5.0.
     *
     * @param directory a new directory to be set.
     */
    public void setCurrentDirectory(String directory) {
<span class="nc bnc" id="L571" title="All 2 branches missed.">        if (provider.isRuntimeInitialized()) {</span>
<span class="nc" id="L572">            provider.getRuntime().setCurrentDirectory(directory);</span>
        } else {
<span class="nc" id="L574">            provider.getRubyInstanceConfig().setCurrentDirectory(directory);</span>
        }
<span class="nc" id="L576">    }</span>

    /**
     * Returns a JRuby home directory.
     *
     * The default JRuby home is the value of JRUBY_HOME environment variable,
     * or &quot;jruby.home&quot; system property when no security restriction is set to
     * those directories. If none of JRUBY_HOME or jruby.home is set and jruby-complete.jar
     * is used, the default JRuby home is &quot;/META-INF/jruby.home&quot; in the jar archive.
     * Otherwise, &quot;java.io.tmpdir&quot; system property is the default value.
     *
     * @since JRuby 1.5.0.
     *
     * @return a JRuby home directory.
     */
    public String getHomeDirectory() {
<span class="nc" id="L592">        return provider.getRubyInstanceConfig().getJRubyHome();</span>
    }

    /**
     * Changes a JRuby home directory to a directory of a given name.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * the given directory will be used.
     *
     * @since JRuby 1.5.0.
     *
     * @param home a name of new JRuby home directory.
     */
    public void setHomeDirectory(String home) {
<span class="nc" id="L605">        provider.getRubyInstanceConfig().setJRubyHome(home);</span>
<span class="nc" id="L606">    }</span>

    /**
     * Returns a class loader object that is currently used. This loader loads
     * Ruby files and libraries.
     *
     * @since JRuby 1.5.0.
     *
     * @return a class loader object that is currently used.
     */
    public ClassLoader getClassLoader() {
<span class="nc" id="L617">        return provider.getRubyInstanceConfig().getLoader();</span>
    }

    /**
     * Changes a class loader to a given loader.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * the given class loader will be used.
     *
     * @since JRuby 1.5.0.
     *
     * @param loader a new class loader to be set.
     */
    public void setClassLoader(ClassLoader loader) {
<span class="nc" id="L630">        provider.getRubyInstanceConfig().setLoader(loader);</span>
<span class="nc" id="L631">    }</span>

    /**
     * Returns a Profile currently used. The default value is Profile.DEFAULT,
     * which has the same behavior to Profile.ALL.
     * Profile allows you to define a restricted subset of code to be loaded during
     * the runtime initialization. When you use JRuby in restricted environment
     * such as Google App Engine, Profile is a helpful option.
     *
     * @since JRuby 1.5.0.
     *
     * @return a current profiler.
     */
    public Profile getProfile() {
<span class="nc" id="L645">        return provider.getRubyInstanceConfig().getProfile();</span>
    }

    /**
     * Changes a Profile to a given one. The default value is Profile.DEFAULT,
     * which has the same behavior to Profile.ALL.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * initial configurations will work.
     *
     * Profile allows you to define a restricted subset of code to be loaded during
     * the runtime initialization. When you use JRuby in restricted environment
     * such as Google App Engine, Profile is a helpful option. For example,
     * Profile.NO_FILE_CLASS doesn't load File class.
     *
     * @since JRuby 1.5.0.
     *
     * @param profile a new profiler to be set.
     */
    public void setProfile(Profile profile) {
<span class="nc" id="L664">        provider.getRubyInstanceConfig().setProfile(profile);</span>
<span class="nc" id="L665">    }</span>

    /**
     * Returns currently configured ProfileOutput object, which determines where
     * the output of profiling operations will be sent.  (e.g., a file specified
     * by --profile.out).
     *
     * @since JRuby 1.7.15
     *
     * @return current profiling output location.
     */
    public ProfileOutput getProfileOutput() {
<span class="nc" id="L677">        return provider.getRubyInstanceConfig().getProfileOutput();</span>
    }

    /**
     * Changes ProfileOutput to given one. The default value is a ProfileOutput
     * instance that writes to stderr.  Similar to passing `--profile.out` from
     * the command line
     *
     * @since JRuby 1.7.15
     *
     * @param out a new ProfileOutput object, to which profiling data should be written
     */
    public void setProfileOutput(ProfileOutput out) {
<span class="nc" id="L690">        provider.getRubyInstanceConfig().setProfileOutput(out);</span>
<span class="nc" id="L691">    }</span>

    /**
     * Returns a ProfilingMode currently used. The default value is ProfilingMode.OFF.
     *
     * @since JRuby 1.6.6.
     *
     * @return a current profiling mode.
     */
    public ProfilingMode getProfilingMode() {
<span class="nc" id="L701">        return provider.getRubyInstanceConfig().getProfilingMode();</span>
    }

    /**
     * Changes a ProfilingMode to a given one. The default value is Profiling.OFF.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * initial configurations will work.
     *
     * ProfilingMode allows you to change profiling style.
     * 
     * Profiling.OFF - default. profiling off.
     * Profiling.API - activates Ruby profiler API. equivalent to --profile.api command line option
     * Profiling.FLAT - synonym for --profile command line option equivalent to --profile.flat command line option
     * Profiling.GRAPH - runs with instrumented (timed) profiling, graph format. equivalent to --profile.graph command line option.
     *
     * @since JRuby 1.6.6.
     *
     * @deprecated Use setProfilingMode instead
     *
     * @param mode a new profiling mode to be set.
     */
    @Deprecated
    public void setProfile(ProfilingMode mode) {
<span class="nc" id="L724">        provider.getRubyInstanceConfig().setProfilingMode(mode);</span>
<span class="nc" id="L725">    }</span>

    /**
     * Changes a ProfilingMode to a given one. The default value is Profiling.OFF.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * initial configurations will work.
     *
     * ProfilingMode allows you to change profiling style.
     *
     * Profiling.OFF - default. profiling off.
     * Profiling.API - activates Ruby profiler API. equivalent to --profile.api command line option
     * Profiling.FLAT - synonym for --profile command line option equivalent to --profile.flat command line option
     * Profiling.GRAPH - runs with instrumented (timed) profiling, graph format. equivalent to --profile.graph command line option.
     *
     * @since JRuby 1.7.15
     *
     * @param mode a new profiling mode to be set.
     */
    public void setProfilingMode(ProfilingMode mode) {
<span class="nc" id="L744">        provider.getRubyInstanceConfig().setProfilingMode(mode);</span>
<span class="nc" id="L745">    }</span>

    /**
     * Returns a LoadServiceCreator currently used.
     *
     * @since JRuby 1.5.0.
     *
     * @return a current LoadServiceCreator.
     */
    public LoadServiceCreator getLoadServiceCreator() {
<span class="nc" id="L755">        return provider.getRubyInstanceConfig().getLoadServiceCreator();</span>
    }

    /**
     * Changes a LoadServiceCreator to a given one.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * initial configurations will work.
     *
     * @since JRuby 1.5.0.
     *
     * @param creator a new LoadServiceCreator
     */
    public void setLoadServiceCreator(LoadServiceCreator creator) {
<span class="nc" id="L768">        provider.getRubyInstanceConfig().setLoadServiceCreator(creator);</span>
<span class="nc" id="L769">    }</span>

    /**
     * Returns a list of argument.
     *
     * @since JRuby 1.5.0.
     *
     * @return an arguments' list.
     */
    public String[] getArgv() {
<span class="nc" id="L779">        return provider.getRubyInstanceConfig().getArgv();</span>
    }

    /**
     * Changes values of the arguments' list.
     *
     * @since JRuby 1.5.0.
     *
     * @param argv a new arguments' list.
     */
    public void setArgv(String[] argv) {
<span class="nc" id="L790">        provider.getRubyInstanceConfig().setArgv(argv);</span>
<span class="nc" id="L791">    }</span>

    /**
     * Returns a script filename to run. The default value is &quot;&amp;lt;script&amp;gt;&quot;.
     *
     * @since JRuby 1.5.0.
     *
     * @return a script filename.
     */
    public String getScriptFilename() {
<span class="nc" id="L801">        return provider.getRubyInstanceConfig().getScriptFileName();</span>
    }

    /**
     * Changes a script filename to run. The default value is &quot;&amp;lt;script&amp;gt;&quot;.
     * Call this before you use put/get, runScriptlet, and parse methods so that
     * initial configurations will work.
     *
     * @since JRuby 1.5.0.
     *
     * @param filename a new script filename.
     */
    public void setScriptFilename(String filename) {
<span class="nc" id="L814">        provider.getRubyInstanceConfig().setScriptFileName(filename);</span>
<span class="nc" id="L815">    }</span>

    /**
     * Returns a record separator. The default value is &quot;\n&quot;.
     *
     * @since JRuby 1.5.0.
     *
     * @return a record separator.
     */
    public String getRecordSeparator() {
<span class="nc" id="L825">        return provider.getRubyInstanceConfig().getRecordSeparator();</span>
    }

    /**
     * Changes a record separator to a given value. If &quot;0&quot; is given, the record
     * separator goes to &quot;\n\n&quot;, &quot;777&quot; goes to &quot;\uFFFF&quot;, otherwise, an octal value
     * of the given number.
     * Call this before you use put/get, runScriptlet, and parse methods so that
     * initial configurations will work.
     *
     * @since JRuby 1.5.0.
     *
     * @param separator a new record separator value, &quot;0&quot; or &quot;777&quot;
     */
    public void setRecordSeparator(String separator) {
<span class="nc" id="L840">        provider.getRubyInstanceConfig().setRecordSeparator(separator);</span>
<span class="nc" id="L841">    }</span>

    /**
     * Returns a value of KCode currently used. The default value is KCode.NONE.
     *
     * @since JRuby 1.5.0.
     *
     * @return a KCode value.
     */
    public KCode getKCode() {
<span class="nc" id="L851">        return provider.getRubyInstanceConfig().getKCode();</span>
    }

    /**
     * Changes a value of KCode to a given value. The value should be one of
     * KCode.NONE, KCode.UTF8, KCode.SJIS, or KCode.EUC. The default value is KCode.NONE.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * the given value will be used.
     *
     * @since JRuby 1.5.0.
     *
     * @param kcode a new KCode value.
     */
    public void setKCode(KCode kcode) {
<span class="nc" id="L865">        provider.getRubyInstanceConfig().setKCode(kcode);</span>
<span class="nc" id="L866">    }</span>

    /**
     * Set whether native code is enabled for this config. Disabling it also
     * disables C extensions (@see RubyInstanceConfig#setCextEnabled).
     *
     * @see Options#NATIVE_ENABLED
     *
     * @param b new value indicating whether native code is enabled
     */
    public void setNativeEnabled(boolean b) {
<span class="nc" id="L877">        provider.getRubyInstanceConfig().setNativeEnabled(b);</span>
<span class="nc" id="L878">    }</span>

    /**
     * Get whether native code is enabled for this config.
     *
     * @see Options#NATIVE_ENABLED
     *
     * @return true if native code is enabled; false otherwise.
     */
    public boolean isNativeEnabled() {
<span class="nc" id="L888">        return provider.getRubyInstanceConfig().isNativeEnabled();</span>
    }



    /**
     * Returns the value of n, which means that jitted methods are logged in
     * every n methods. The default value is 0.
     *
     * @since JRuby 1.5.0.
     *
     * @return a value that determines how often jitted methods are logged.
     */
    public int getJitLogEvery() {
<span class="nc" id="L902">        return provider.getRubyInstanceConfig().getJitLogEvery();</span>
    }

    /**
     * Changes a value of n, so that jitted methods are logged in every n methods.
     * The default value is 0. This value can be set by the jruby.jit.logEvery System
     * property.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * the configurations will work.
     *
     * @since JRuby 1.5.0.
     *
     * @param logEvery a new number of methods.
     */
    public void setJitLogEvery(int logEvery) {
<span class="nc" id="L917">        provider.getRubyInstanceConfig().setJitLogEvery(logEvery);</span>
<span class="nc" id="L918">    }</span>

    /**
     * Returns a value of the threshold that determines whether jitted methods'
     * call reached to the limit or not. The default value is -1 when security
     * restriction is applied, or 50 when no security restriction exists.
     *
     * @since JRuby 1.5.0.
     *
     * @return a value of the threshold.
     */
    public int getJitThreshold() {
<span class="nc" id="L930">        return provider.getRubyInstanceConfig().getJitThreshold();</span>
    }

    /**
     * Changes a value of the threshold that determines whether jitted methods'
     * call reached to the limit or not. The default value is -1 when security
     * restriction is applied, or 50 when no security restriction exists. This
     * value can be set by jruby.jit.threshold System property.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * the configurations will work.
     *
     * @since JRuby 1.5.0.
     *
     * @param threshold a new value of the threshold.
     */
    public void setJitThreshold(int threshold) {
<span class="nc" id="L946">        provider.getRubyInstanceConfig().setJitThreshold(threshold);</span>
<span class="nc" id="L947">    }</span>

    /**
     * Returns a value of a max class cache size. The default value is 0 when
     * security restriction is applied, or 4096 when no security restriction exists.
     *
     * @since JRuby 1.5.0.
     *
     * @return a value of a max class cache size.
     */
    public int getJitMax() {
<span class="nc" id="L958">        return provider.getRubyInstanceConfig().getJitMax();</span>
    }

    /**
     * Changes a value of a max class cache size. The default value is 0 when
     * security restriction is applied, or 4096 when no security restriction exists.
     * This value can be set by jruby.jit.max System property.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * the configurations will work.
     *
     * @since JRuby 1.5.0.
     *
     * @param max a new value of a max class cache size.
     */
    public void setJitMax(int max) {
<span class="nc" id="L973">        provider.getRubyInstanceConfig().setJitMax(max);</span>
<span class="nc" id="L974">    }</span>

    /**
     * Returns a value of a max size of the bytecode generated by compiler. The
     * default value is -1 when security restriction is applied, or 10000 when
     * no security restriction exists.
     *
     * @since JRuby 1.5.0.
     *
     * @return a value of a max size of the bytecode.
     */
    public int getJitMaxSize() {
<span class="nc" id="L986">        return provider.getRubyInstanceConfig().getJitMaxSize();</span>
    }

    /**
     * Changes a value of a max size of the bytecode generated by compiler. The
     * default value is -1 when security restriction is applied, or 10000 when
     * no security restriction exists. This value can be set by jruby.jit.maxsize
     * System property.
     * Call this method before you use put/get, runScriptlet, and parse methods so that
     * the configurations will work.
     *
     * @since JRuby 1.5.0.
     *
     * @param maxSize a new value of a max size of the bytecode.
     */
    public void setJitMaxSize(int maxSize) {
<span class="nc" id="L1002">        provider.getRubyInstanceConfig().setJitMaxSize(maxSize);</span>
<span class="nc" id="L1003">    }</span>

    /**
     * Returns version information about JRuby and Ruby supported by this platform.
     *
     * @return version information.
     */
    public String getSupportedRubyVersion() {
<span class="nc" id="L1011">        return OutputStrings.getVersionString().trim();</span>
    }

    /**
     * Returns an array of values associated to a key.
     *
     * @param key is a key in a property file
     * @return values associated to the key
     */
    public String[] getProperty(String key) {
<span class="nc bnc" id="L1021" title="All 2 branches missed.">        if (basicProperties.containsKey(key)) {</span>
<span class="nc" id="L1022">            return (String[]) basicProperties.get(key);</span>
        } else {
<span class="nc" id="L1024">            return null;</span>
        }
    }

    /**
     * Returns a provider instance of {@link LocalContextProvider}. When users 
     * want to configure Ruby runtime, they can do by setting class loading paths,
     * {@link org.jruby.RubyInstanceConfig} to the provider before they get Ruby
     * runtime.
     * 
     * @return a provider of {@link LocalContextProvider}
     */
    public LocalContextProvider getProvider() {
<span class="nc" id="L1037">        return provider;</span>
    }

    /**
     * Returns a Ruby runtime in one of {@link LocalContextScope}.
     *
     * @deprecated As of JRuby 1.5.0. Use getProvider().getRuntime() method instead.
     *
     * @return Ruby runtime of a specified local context
     */
    @Deprecated
    public Ruby getRuntime() {
<span class="nc" id="L1049">        return provider.getRuntime();</span>
    }

    /**
     * Returns a variable map in one of {@link LocalContextScope}. Variables
     * in this map is used to share between Java and Ruby. Map keys are Ruby's
     * variable names, thus they must be valid Ruby names.
     * 
     * @return a variable map specific to the current thread
     */
    public BiVariableMap getVarMap() {
<span class="nc" id="L1060">        return provider.getVarMap();</span>
    }

    /**
     * Returns a attribute map in one of {@link LocalContextScope}. Attributes
     * in this map accept any key value pair, types of which are java.lang.Object.
     * Ruby scripts do not look up this map.
     * 
     * @return an attribute map specific to the current thread
     */
    public Map getAttributeMap() {
<span class="nc" id="L1071">        return provider.getAttributeMap();</span>
    }

    /**
     * Returns an attribute value associated with the specified key in
     * a attribute map. This is a short cut method of
     * ScriptingContainer#getAttributeMap().get(key).
     * 
     * @param key is the attribute key
     * @return value is a value associated to the specified key
     */
    public Object getAttribute(Object key) {
<span class="nc" id="L1083">        return provider.getAttributeMap().get(key);</span>
    }

    /**
     * Associates the specified value with the specified key in a
     * attribute map. If the map previously contained a mapping for the key,
     * the old value is replaced. This is a short cut method of
     * ScriptingContainer#getAttributeMap().put(key, value).
     * 
     * @param key is a key that the specified value is to be associated with
     * @param value is a value to be associated with the specified key
     * @return the previous value associated with key, or null if there was no mapping for key. 
     */
    public Object setAttribute(Object key, Object value) {
<span class="nc" id="L1097">        return provider.getAttributeMap().put(key, value);</span>
    }

    /**
     * Removes the specified value with the specified key in a
     * attribute map. If the map previously contained a mapping for the key,
     * the old value is returned. This is a short cut method of
     * ScriptingContainer#getAttributeMap().remove(key).
     *
     * @param key is a key that the specified value is to be removed from
     * @return the previous value associated with key, or null if there was no mapping for key.
     */
    public Object removeAttribute(Object key) {
<span class="nc" id="L1110">        return provider.getAttributeMap().remove(key);</span>
    }

    /**
     * Returns a value of the specified key in a top level of runtime or null
     * if this map doesn't have a mapping for the key. The key
     * must be a valid Ruby variable or constant name.
     * 
     * @param key is a key whose associated value is to be returned
     * @return a value to which the specified key is mapped, or null if this
     *         map contains no mapping for the key
     */
    public Object get(String key) {
<span class="nc" id="L1123">        return provider.getVarMap().get(key);</span>
    }

    /**
     * Returns a value of a specified key in a specified receiver or null if
     * a variable map doesn't have a mapping for the key in a given
     * receiver. The key must be a valid Ruby variable or constant name. A global
     * variable doesn't depend on the receiver.
     *
     * @param receiver a receiver to get the value from
     * @param key is a key whose associated value is to be returned
     * @return a value to which the specified key is mapped, or null if this
     *         map contains no mapping for the key
     */
    public Object get(Object receiver, String key) {
<span class="nc" id="L1138">        return provider.getVarMap().get(receiver, key);</span>
    }

    /**
     * Associates the specified value with the specified key in a
     * variable map. This key-value pair is injected to a top level of runtime
     * during evaluation. If the map previously contained a mapping for the key,
     * the old value is replaced. The key must be a valid Ruby variable or 
     * constant name. It will be a top level variable or constant. 
     * 
     * @param key is a key that the specified value is to be associated with
     * @param value is a value to be associated with the specified key
     * @return a previous value associated with a key, or null if there was
     *         no mapping for this key.
     */
    public Object put(String key, Object value) {
<span class="nc" id="L1154">        return provider.getVarMap().put(key, value);</span>
    }

    /**
     * Associates the specified value with the specified key in a variable map.
     * This key-value pair is injected to a given receiver during evaluation.
     * If the map previously contained a mapping for the key,
     * the old value is replaced. The key must be a valid Ruby variable or 
     * constant name. A given receiver limits the scope of a variable or constant.
     * However, a global variable is accessible globally always.
     *
     * @param receiver a receiver to put the value in
     * @param key is a key that the specified value is to be associated with
     * @param value is a value to be associated with the specified key
     * @return a previous value associated with a key, or null if there was
     *         no mapping for this key.
     */
    public Object put(Object receiver, String key, Object value) {
<span class="nc" id="L1172">        return provider.getVarMap().put(receiver, key, value);</span>
    }

    /**
     * Removes the specified Ruby variable with the specified variable name from a
     * variable map and runtime top level. If the map previously contained a
     * mapping for the key, the old value is returned. The key must be a valid
     * Ruby variable name.
     *
     * @param key is a key that the specified value is to be associated with
     * @return a previous value associated with a key, or null if there was
     *         no mapping for this key.
     */
    public Object remove(String key) {
<span class="nc" id="L1186">        return provider.getVarMap().remove(key);</span>
    }

    /**
     * Removes the specified Ruby variable with the specified variable name in a
     * variable map and given receiver. If the map previously contained a mapping for the key,
     * the old value is returned. The key must be a valid Ruby variable name.
     * This is a short cut method of ScriptingContainer#getVarMap().remove(key).
     *
     * @param receiver a receiver to remove the value from
     * @param key is a key that the specified value is to be associated with
     * @return a previous value associated with a key, or null if there was
     *         no mapping for this key.
     */
    public Object remove(Object receiver, String key) {
<span class="nc" id="L1201">        return provider.getVarMap().removeFrom(receiver, key);</span>
    }

    /**
     * Removes all of the mappings from this map.
     * The map will be empty after this call returns. Ruby variables are also
     * removed from Ruby instance. However, Ruby instance keep having global variable
     * names with null value.
     * This is a short cut method of ScriptingContainer#getVarMap().clear().
     */
    public void clear() {
<span class="nc" id="L1212">        provider.getVarMap().clear();</span>
<span class="nc" id="L1213">    }</span>

    /**
     * Parses a script and return an object which can be run(). This allows
     * the script to be parsed once and evaluated many times.
     * 
     * @param script is a Ruby script to be parsed
     * @param lines are linenumbers to display for parse errors and backtraces.
     *        This field is optional. Only the first argument is used for parsing.
     *        When no line number is specified, 0 is applied to.
     * @return an object which can be run
     */
    public EmbedEvalUnit parse(String script, int... lines) {
<span class="nc" id="L1226">        return runtimeAdapter.parse(script, lines);</span>
    }

    /**
     * Parses a script given by a reader and return an object which can be run().
     * This allows the script to be parsed once and evaluated many times.
     * 
     * @param reader is used to read a script from
     * @param filename is used as in information, for example, appears in a stack trace
     *        of an exception
     * @param lines are linenumbers to display for parse errors and backtraces.
     *        This field is optional. Only the first argument is used for parsing.
     *        When no line number is specified, 0 is applied to.
     * @return an object which can be run
     */
    public EmbedEvalUnit parse(Reader reader, String filename, int... lines) {
<span class="nc" id="L1242">        return runtimeAdapter.parse(reader, filename, lines);</span>
    }

    /**
     * Parses a script read from a specified path and return an object which can be run().
     * This allows the script to be parsed once and evaluated many times.
     * 
     * @param type is one of the types {@link PathType} defines
     * @param filename is used as in information, for example, appears in a stack trace
     *        of an exception
     * @param lines are linenumbers to display for parse errors and backtraces.
     *        This field is optional. Only the first argument is used for parsing.
     *        When no line number is specified, 0 is applied to.
     * @return an object which can be run
     */
    public EmbedEvalUnit parse(PathType type, String filename, int... lines) {
<span class="nc" id="L1258">        return runtimeAdapter.parse(type, filename, lines);</span>
    }

    /**
     * Parses a script given by a input stream and return an object which can be run().
     * This allows the script to be parsed once and evaluated many times.
     * 
     * @param istream is an input stream to get a script from
     * @param filename filename is used as in information, for example, appears in a stack trace
     *        of an exception
     * @param lines are linenumbers to display for parse errors and backtraces.
     *        This field is optional. Only the first argument is used for parsing.
     *        When no line number is specified, 0 is applied to.
     * @return an object which can be run
     */
    public EmbedEvalUnit parse(InputStream istream, String filename, int... lines) {
<span class="nc" id="L1274">        return runtimeAdapter.parse(istream, filename, lines);</span>
    }

    /**
     * Evaluates a script under the current scope (perhaps the top-level
     * scope) and returns a result only if a script returns a value.
     * Right after the parsing, the script is evaluated once.
     *
     * @param script is a Ruby script to get run
     * @return an evaluated result converted to a Java object
     */
    public Object runScriptlet(String script) {
<span class="nc" id="L1286">        EmbedEvalUnit unit = parse(script);</span>
<span class="nc" id="L1287">        return runUnit(unit);</span>
    }

    private Object runUnit(EmbedEvalUnit unit) {
<span class="nc bnc" id="L1291" title="All 2 branches missed.">        if (unit == null) {</span>
<span class="nc" id="L1292">            return null;</span>
        }
<span class="nc" id="L1294">        IRubyObject ret = unit.run();</span>
<span class="nc" id="L1295">        return JavaEmbedUtils.rubyToJava(ret);</span>
    }

    /**
     * Evaluates a script read from a reader under the current scope
     * (perhaps the top-level scope) and returns a result only if a script
     * returns a value. Right after the parsing, the script is evaluated once.
     * 
     * @param reader is used to read a script from
     * @param filename is used as in information, for example, appears in a stack trace
     *        of an exception
     * @return an evaluated result converted to a Java object
     */
    public Object runScriptlet(Reader reader, String filename) {
<span class="nc" id="L1309">        EmbedEvalUnit unit = parse(reader, filename);</span>
<span class="nc" id="L1310">        return runUnit(unit);</span>
    }

    /**
     * Evaluates a script read from a input stream under the current scope
     * (perhaps the top-level scope) and returns a result only if a script
     * returns a value. Right after the parsing, the script is evaluated once.
     *
     * @param istream is used to input a script from
     * @param filename is used as in information, for example, appears in a stack trace
     *        of an exception
     * @return an evaluated result converted to a Java object
     */
    public Object runScriptlet(InputStream istream, String filename) {
<span class="nc" id="L1324">        EmbedEvalUnit unit = parse(istream, filename);</span>
<span class="nc" id="L1325">        return runUnit(unit);</span>
    }

    /**
     * Reads a script file from specified path and evaluates it under the current
     * scope (perhaps the top-level scope) and returns a result only if a script
     * returns a value. Right after the parsing, the script is evaluated once.
     * 
     * @param type is one of the types {@link PathType} defines
     * @param filename is used to read the script from and an information
     * @return an evaluated result converted to a Java object
     */
    public Object runScriptlet(PathType type, String filename) {
<span class="nc" id="L1338">        EmbedEvalUnit unit = parse(type, filename);</span>
<span class="nc" id="L1339">        return runUnit(unit);</span>
    }

    /**
     * Returns an instance of {@link EmbedRubyRuntimeAdapter} for embedders to parse
     * scripts.
     * 
     * @return an instance of {@link EmbedRubyRuntimeAdapter}.
     */
    public EmbedRubyRuntimeAdapter newRuntimeAdapter() {
<span class="nc" id="L1349">        return runtimeAdapter;</span>
    }

    /**
     * Returns an instance of {@link EmbedRubyObjectAdapter} for embedders to invoke
     * methods defined by Ruby. The script must be evaluated prior to a method call.
     * In most cases, users don't need to use this method. ScriptingContainer's
     * callMethods are the shortcut and work in the same way.
     *
     * &lt;pre&gt;Example
     *         # calendar.rb
     *         require 'date'
     *         class Calendar
     *           def initialize;@today = DateTime.now;end
     *           def next_year;@today.year + 1;end
     *         end
     *         Calendar.new
     *
     *
     *         ScriptingContainer container = new ScriptingContainer();
     *         String filename =  &quot;ruby/calendar.rb&quot;;
     *         Object receiver = instance.runScriptlet(PathType.CLASSPATH, filename);
     *         EmbedRubyObjectAdapter adapter = instance.newObjectAdapter();
     *         Integer result =
     *             (Integer) adapter.callMethod(receiver, &quot;next_year&quot;, Integer.class);
     *         System.out.println(&quot;next year: &quot; + result);
     *         System.out.println(instance.get(&quot;@today&quot;));
     *
     * Outputs:
     *     next year: 2010
     *     2009-05-19T17:46:44-04:00&lt;/pre&gt;
     * 
     * @return an instance of {@link EmbedRubyObjectAdapter}
     */
    public EmbedRubyObjectAdapter newObjectAdapter() {
<span class="nc" id="L1384">        return objectAdapter;</span>
    }

    /**
     * Executes a method defined in Ruby script. This method is used when a Ruby
     * method does not have any argument.
     *
     * @param receiver is an instance that will receive this method call.
     *                 Ruby's self object will be used if no appropriate receiver
     *                 is given.
     * @param methodName is a method name to be called
     * @param args is an array of method arguments
     * @return an instance of requested Java type
     */
    public Object callMethod(Object receiver, String methodName, Object... args) {
<span class="nc" id="L1399">        return objectAdapter.callMethod(receiver, methodName, args);</span>
    }

    /**
     * Executes a method defined in Ruby script. This method is used when a Ruby
     * method does not have any argument.
     *
     * @param receiver is an instance that will receive this method call
     *                 Ruby's self object will be used if no appropriate receiver
     *                 is given.
     * @param methodName is a method name to be called
     * @param block is a block to be executed in this method
     * @param args is an array of method arguments
     * @return an instance of requested Java type
     */
    public Object callMethod(Object receiver, String methodName, Block block, Object... args) {
<span class="nc" id="L1415">        return objectAdapter.callMethod(receiver, methodName, block, args);</span>
    }
    
    /**
     * Executes a method defined in Ruby script. This method is used when a Ruby
     * method does not have any argument.
     *
     * @param receiver is an instance that will receive this method call.
     *                 Ruby's self object will be used if no appropriate receiver
     *                 is given.
     * @param methodName is a method name to be called
     * @param returnType is the type we want it to convert to
     * @return an instance of requested Java type
     */
    public &lt;T&gt; T callMethod(Object receiver, String methodName, Class&lt;T&gt; returnType) {
<span class="nc" id="L1430">        return objectAdapter.callMethod(receiver, methodName, returnType);</span>
    }

    /**
     * Executes a method defined in Ruby script. This method is used when a Ruby
     * method have only one argument.
     *
     * @param receiver is an instance that will receive this method call.
     *                 Ruby's self object will be used if no appropriate receiver
     *                 is given.
     * @param methodName is a method name to be called
     * @param singleArg is an method argument
     * @param returnType returnType is the type we want it to convert to
     * @return an instance of requested Java type
     */
    public &lt;T&gt; T callMethod(Object receiver, String methodName, Object singleArg, Class&lt;T&gt; returnType) {
<span class="nc" id="L1446">        return objectAdapter.callMethod(receiver, methodName, singleArg, returnType);</span>
    }

    /**
     * Executes a method defined in Ruby script. This method is used when a Ruby
     * method have multiple arguments.
     *
     * @param receiver is an instance that will receive this method call.
     *                 Ruby's self object will be used if no appropriate receiver
     *                 is given.
     * @param methodName is a method name to be called
     * @param args is an array of method arguments
     * @param returnType is the type we want it to convert to
     * @return an instance of requested Java type
     */
    public &lt;T&gt; T callMethod(Object receiver, String methodName, Object[] args, Class&lt;T&gt; returnType) {
<span class="nc" id="L1462">        return objectAdapter.callMethod(receiver, methodName, args, returnType);</span>
    }

    /**
     * Executes a method defined in Ruby script. This method is used when a Ruby
     * method have multiple arguments, one of which is a block.
     *
     * @param receiver is an instance that will receive this method call.
     *                 Ruby's self object will be used if no appropriate receiver
     *                 is given.
     * @param methodName is a method name to be called
     * @param args is an array of method arguments except a block
     * @param block is a block to be executed in this method
     * @param returnType is the type we want it to convert to
     * @return an instance of requested Java type
     */
    public &lt;T&gt; T callMethod(Object receiver, String methodName, Object[] args, Block block, Class&lt;T&gt; returnType) {
<span class="nc" id="L1479">        return objectAdapter.callMethod(receiver, methodName, args, block, returnType);</span>
    }

    /**
     * Executes a method defined in Ruby script. This method is used when a Ruby
     * method does not have any argument, and users want to inject Ruby's local
     * variables' values from Java.
     *
     * @param receiver is an instance that will receive this method call.
     *                 Ruby's self object will be used if no appropriate receiver
     *                 is given.
     * @param methodName is a method name to be called
     * @param returnType is the type we want it to convert to
     * @param unit is parsed unit
     * @return an instance of requested Java type
     */
    public &lt;T&gt; T callMethod(Object receiver, String methodName, Class&lt;T&gt; returnType, EmbedEvalUnit unit) {
<span class="nc" id="L1496">        return objectAdapter.callMethod(receiver, methodName, returnType, unit);</span>
    }

    /**
     * Executes a method defined in Ruby script. This method is used when a Ruby
     * method have multiple arguments, and users want to inject Ruby's local
     * variables' values from Java.
     *
     * @param receiver is an instance that will receive this method call.
     *                 Ruby's self object will be used if no appropriate receiver
     *                 is given.
     * @param methodName is a method name to be called
     * @param args is an array of method arguments
     * @param returnType is the type we want it to convert to
     * @param unit is parsed unit
     * @return an instance of requested Java type
     */
    public &lt;T&gt; T callMethod(Object receiver, String methodName, Object[] args, Class&lt;T&gt; returnType, EmbedEvalUnit unit) {
<span class="nc" id="L1514">        return objectAdapter.callMethod(receiver, methodName, args, returnType, unit);</span>
    }

    /**
     * Executes a method defined in Ruby script. This method is used when a Ruby
     * method have multiple arguments, one of which is a block, and users want to
     * inject Ruby's local variables' values from Java.
     *
     * @param receiver is an instance that will receive this method call.
     *                 Ruby's self object will be used if no appropriate receiver
     *                 is given.
     * @param methodName is a method name to be called
     * @param args is an array of method arguments except a block
     * @param block is a block to be executed in this method
     * @param returnType is the type we want it to convert to
     * @param unit is parsed unit
     * @return is the type we want it to convert to
     */
    public &lt;T&gt; T callMethod(Object receiver, String methodName, Object[] args, Block block, Class&lt;T&gt; returnType, EmbedEvalUnit unit) {
<span class="nc" id="L1533">        return objectAdapter.callMethod(receiver, methodName, args, block, returnType, unit);</span>
    }

    /**
     *
     * @param receiver is an instance that will receive this method call.
     *                 Ruby's self object will be used if no appropriate receiver
     *                 is given.
     * @param args is an array of method arguments
     * @param returnType is the type we want it to convert to
     * @return is the type we want it to convert to
     */
    public &lt;T&gt; T callSuper(Object receiver, Object[] args, Class&lt;T&gt; returnType) {
<span class="nc" id="L1546">        return objectAdapter.callSuper(receiver, args, returnType);</span>
    }

    /**
     *
     * @param receiver is an instance that will receive this method call.
     *                 Ruby's self object will be used if no appropriate receiver
     *                 is given.
     * @param args is an array of method arguments except a block
     * @param block is a block to be executed in this method
     * @param returnType is the type we want it to convert to
     * @return is the type we want it to convert to
     */
    public &lt;T&gt; T callSuper(Object receiver, Object[] args, Block block, Class&lt;T&gt; returnType) {
<span class="nc" id="L1560">        return objectAdapter.callSuper(receiver, args, block, returnType);</span>
    }
    
    /**
     * Executes a method defined in Ruby script. This method is used when a Ruby
     * method does not have any argument.
     *
     * @param returnType is the type we want it to convert to
     * @param receiver is an instance that will receive this method call. The receiver
     *                 can be null or other Java objects as well as RubyObject.
     *                 The null will be converted to RubyNil. Java objects will be
     *                 wrapped in RubyObject.
     * @param methodName is a method name to be called
     * @param args is an array of method arguments
     * @return an instance of requested Java type
     */
    public &lt;T&gt; T runRubyMethod(Class&lt;T&gt; returnType, Object receiver, String methodName, Object... args) {
<span class="nc" id="L1577">        return objectAdapter.runRubyMethod(returnType, receiver, methodName, null, args);</span>
    }

    /**
     * Executes a method defined in Ruby script. This method is used when a Ruby
     * method does not have any argument.
     *
     * @param returnType is the type we want it to convert to
     * @param receiver is an instance that will receive this method call. The receiver
     *                 can be null or other Java objects as well as RubyObject.
     *                 The null will be converted to RubyNil. Java objects will be
     *                 wrapped in RubyObject.
     * @param methodName is a method name to be called
     * @param block is an optional Block object.  Send null for no block.
     * @param args is an array of method arguments
     * @return an instance of requested Java type
     */
    public &lt;T&gt; T runRubyMethod(Class&lt;T&gt; returnType, Object receiver, String methodName, Block block, Object... args) {
<span class="nc" id="L1595">        return objectAdapter.runRubyMethod(returnType, receiver, methodName, block, args);</span>
    }

    /**
     * Returns an instance of a requested interface type. An implementation of
     * the requested interface is done by a Ruby script, which has been evaluated
     * before getting the instance.
     * In most cases, users don't need to use this method. ScriptingContainer's
     * runScriptlet method returns an instance of the interface type that is
     * implemented by Ruby.
     *
     * &lt;pre&gt;Example
     * Interface
     *     //QuadraticFormula.java
     *     package org.jruby.embed;
     *     import java.util.List;
     *     public interface QuadraticFormula {
     *         List solve(int a, int b, int c) throws Exception;
     *     }
     *
     * Implementation
     *     #quadratic_formula.rb
     *     def solve(a, b, c)
     *       v = b ** 2 - 4 * a * c
     *       if v &lt; 0: raise RangeError end
     *       s0 = ((-1)*b - Math.sqrt(v))/(2*a)
     *       s1 = ((-1)*b + Math.sqrt(v))/(2*a)
     *       return s0, s1
     *     end
     *
     * Usage
     *     ScriptingContainer container = new ScriptingContainer();
     *     String filename = &quot;ruby/quadratic_formula_class.rb&quot;;
     *     Object receiver = container.runScriptlet(PathType.CLASSPATH, filename);
     *     QuadraticFormula qf = container.getInstance(receiver, QuadraticFormula.class);
     *     try {
     *          List&lt;Double&gt; solutions = qf.solve(1, -2, -13);
     *          printSolutions(solutions);
     *          solutions = qf.solve(1, -2, 13);
     *          for (double s : solutions) {
     *              System.out.print(s + &quot;, &quot;);
     *          }
     *     } catch (Exception e) {
     *          e.printStackTrace();
     *     }
     *
     * Output
     *     -2.7416573867739413, 4.741657386773941, 
     * &lt;/pre&gt;
     *
     * 
     * @param receiver is an instance that implements the interface
     * @param clazz is a requested interface
     * @return an instance of a requested interface type
     */
    public &lt;T&gt; T getInstance(Object receiver, Class&lt;T&gt; clazz) {
<span class="nc" id="L1651">        return interfaceAdapter.getInstance(receiver, clazz);</span>
    }

    /**
     * Replaces a standard input by a specified reader
     * 
     * @param reader is a reader to be set
     */
    public void setReader(Reader reader) {
<span class="nc bnc" id="L1660" title="All 2 branches missed.">        if (reader == null) {</span>
<span class="nc" id="L1661">            return;</span>
        }
<span class="nc" id="L1663">        Map map = getAttributeMap();</span>
<span class="nc bnc" id="L1664" title="All 2 branches missed.">        if (map.containsKey(AttributeName.READER)) {</span>
<span class="nc" id="L1665">            Reader old = (Reader) map.get(AttributeName.READER);</span>
<span class="nc bnc" id="L1666" title="All 2 branches missed.">            if (old == reader) {</span>
<span class="nc" id="L1667">                return;</span>
            }
        }
<span class="nc" id="L1670">        map.put(AttributeName.READER, reader);</span>
<span class="nc" id="L1671">        InputStream istream = new ReaderInputStream(reader);</span>
<span class="nc" id="L1672">        Ruby runtime = provider.getRuntime();</span>
<span class="nc" id="L1673">        RubyIO io = new RubyIO(runtime, istream);</span>
<span class="nc" id="L1674">        io.getOpenFile().setSync(true);</span>
<span class="nc" id="L1675">        runtime.defineVariable(new InputGlobalVariable(runtime, &quot;$stdin&quot;, io), GlobalVariable.Scope.GLOBAL);</span>
<span class="nc" id="L1676">        runtime.getObject().storeConstant(&quot;STDIN&quot;, io);</span>
<span class="nc" id="L1677">    }</span>

    /**
     * Returns a reader set in an attribute map.
     *
     * @return a reader in an attribute map
     */
    public Reader getReader() {
<span class="nc" id="L1685">        Map map = getAttributeMap();</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">        if (map.containsKey(AttributeName.READER)) {</span>
<span class="nc" id="L1687">            return (Reader) getAttributeMap().get(AttributeName.READER);</span>
        }
<span class="nc" id="L1689">        return null;</span>
    }

    /**
     * Returns an input stream that Ruby runtime has. The stream is set when
     * Ruby runtime is initialized.
     *
     * @deprecated As of JRuby 1.5.0, replaced by getInput().
     * 
     * @return an input stream that Ruby runtime has.
     */
    @Deprecated
    public InputStream getIn() {
<span class="nc" id="L1702">        return getInput();</span>
    }

    /**
     * Replaces a standard output by a specified writer.
     *
     * @param writer is a writer to be set
     */
    public void setWriter(Writer writer) {
<span class="nc bnc" id="L1711" title="All 2 branches missed.">        if (writer == null) {</span>
<span class="nc" id="L1712">            return;</span>
        }
<span class="nc" id="L1714">        Map map = getAttributeMap();</span>
<span class="nc bnc" id="L1715" title="All 2 branches missed.">        if (map.containsKey(AttributeName.WRITER)) {</span>
<span class="nc" id="L1716">            Writer old = (Writer) map.get(AttributeName.WRITER);</span>
<span class="nc bnc" id="L1717" title="All 2 branches missed.">            if (old == writer) {</span>
<span class="nc" id="L1718">                return;</span>
            }
        }
<span class="nc" id="L1721">        map.put(AttributeName.WRITER, writer);</span>
<span class="nc" id="L1722">        PrintStream pstream = new PrintStream(new WriterOutputStream(writer));</span>
<span class="nc" id="L1723">        setOutputStream(pstream);</span>
<span class="nc" id="L1724">    }</span>

    private void setOutputStream(PrintStream pstream) {
<span class="nc bnc" id="L1727" title="All 2 branches missed.">        if (pstream == null) {</span>
<span class="nc" id="L1728">            return;</span>
        }
<span class="nc" id="L1730">        Ruby runtime = provider.getRuntime();</span>
<span class="nc" id="L1731">        RubyIO io = new RubyIO(runtime, pstream);</span>
<span class="nc" id="L1732">        io.getOpenFile().setSync(true);</span>
<span class="nc" id="L1733">        runtime.defineVariable(new OutputGlobalVariable(runtime, &quot;$stdout&quot;, io), GlobalVariable.Scope.GLOBAL);</span>
<span class="nc" id="L1734">        runtime.getObject().storeConstant(&quot;STDOUT&quot;, io);</span>
<span class="nc" id="L1735">        runtime.getGlobalVariables().alias(&quot;$&gt;&quot;, &quot;$stdout&quot;);</span>
<span class="nc" id="L1736">        runtime.getGlobalVariables().alias(&quot;$defout&quot;, &quot;$stdout&quot;);</span>
<span class="nc" id="L1737">    }</span>

    public void resetWriter() {
<span class="nc" id="L1740">        PrintStream pstream = provider.getRubyInstanceConfig().getOutput();</span>
<span class="nc" id="L1741">        setOutputStream(pstream);</span>
<span class="nc" id="L1742">    }</span>

    /**
     * Returns a writer set in an attribute map.
     * 
     * @return a writer in a attribute map
     */
    public Writer getWriter() {
<span class="nc" id="L1750">        Map map = getAttributeMap();</span>
<span class="nc bnc" id="L1751" title="All 2 branches missed.">        if (map.containsKey(AttributeName.WRITER)) {</span>
<span class="nc" id="L1752">            return (Writer) getAttributeMap().get(AttributeName.WRITER);</span>
        }
<span class="nc" id="L1754">        return null;</span>
    }

    /**
     * Returns an output stream that Ruby runtime has. The stream is set when
     * Ruby runtime is initialized.
     *
     * @deprecated As of JRuby 1.5.0, replaced by getOutput().
     * 
     * @return an output stream that Ruby runtime has
     */
    @Deprecated
    public PrintStream getOut() {
<span class="nc" id="L1767">        return getOutput();</span>
    }

    /**
     * Replaces a standard error by a specified writer.
     * 
     * @param errorWriter is a writer to be set
     */
    public void setErrorWriter(Writer errorWriter) {
<span class="nc bnc" id="L1776" title="All 2 branches missed.">        if (errorWriter == null) {</span>
<span class="nc" id="L1777">            return;</span>
        }
<span class="nc" id="L1779">        Map map = getAttributeMap();</span>
<span class="nc bnc" id="L1780" title="All 2 branches missed.">        if (map.containsKey(AttributeName.ERROR_WRITER)) {</span>
<span class="nc" id="L1781">            Writer old = (Writer) map.get(AttributeName.ERROR_WRITER);</span>
<span class="nc bnc" id="L1782" title="All 2 branches missed.">            if (old == errorWriter) {</span>
<span class="nc" id="L1783">                return;</span>
            }
        }
<span class="nc" id="L1786">        map.put(AttributeName.ERROR_WRITER, errorWriter);</span>
<span class="nc" id="L1787">        PrintStream pstream = new PrintStream(new WriterOutputStream(errorWriter));</span>
<span class="nc" id="L1788">        setErrorStream(pstream);</span>
<span class="nc" id="L1789">    }</span>

    private void setErrorStream(PrintStream error) {
<span class="nc bnc" id="L1792" title="All 2 branches missed.">        if (error == null) {</span>
<span class="nc" id="L1793">            return;</span>
        }
<span class="nc" id="L1795">        Ruby runtime = provider.getRuntime();</span>
<span class="nc" id="L1796">        RubyIO io = new RubyIO(runtime, error);</span>
<span class="nc" id="L1797">        io.getOpenFile().setSync(true);</span>
<span class="nc" id="L1798">        runtime.defineVariable(new OutputGlobalVariable(runtime, &quot;$stderr&quot;, io), GlobalVariable.Scope.GLOBAL);</span>
<span class="nc" id="L1799">        runtime.getObject().storeConstant(&quot;STDERR&quot;, io);</span>
<span class="nc" id="L1800">        runtime.getGlobalVariables().alias(&quot;$deferr&quot;, &quot;$stderr&quot;);</span>
<span class="nc" id="L1801">    }</span>

    public void resetErrorWriter() {
<span class="nc" id="L1804">        PrintStream error = provider.getRubyInstanceConfig().getError();</span>
<span class="nc" id="L1805">        setErrorStream(error);</span>
<span class="nc" id="L1806">    }</span>

    /**
     * Returns an error writer set in an attribute map.
     *
     * @return an error writer in a attribute map
     */
    public Writer getErrorWriter() {
<span class="nc" id="L1814">        Map map = getAttributeMap();</span>
<span class="nc bnc" id="L1815" title="All 2 branches missed.">        if (map.containsKey(AttributeName.ERROR_WRITER)) {</span>
<span class="nc" id="L1816">            return (Writer) getAttributeMap().get(AttributeName.ERROR_WRITER);</span>
        }
<span class="nc" id="L1818">        return null;</span>
    }

    /**
     * Returns an error output stream that Ruby runtime has. The stream is set when
     * Ruby runtime is initialized.
     *
     * @deprecated As of JRuby 1.5.0, Replaced by getError()
     * 
     * @return an error output stream that Ruby runtime has
     */
    @Deprecated
    public PrintStream getErr() {
<span class="nc" id="L1831">        return getError();</span>
    }

    /**
     * Cleanly shut down this ScriptingContainer and any JRuby resources it holds.
     * All ScriptingContainer instances should be terminated when you are done with
     * them, rather then leaving them for GC to finalize.
     *
     * @since JRuby 1.5.0
     */
    public void terminate() {
<span class="nc bnc" id="L1842" title="All 2 branches missed.">        if (getProvider().isRuntimeInitialized()) getProvider().getRuntime().tearDown(false);</span>
<span class="nc" id="L1843">        getProvider().terminate();</span>
<span class="nc" id="L1844">    }</span>

    /**
     * Ensure this ScriptingContainer instance is terminated when nobody holds any
     * references to it (and GC wants to reclaim it).
     *
     * Note that {@link org.jruby.embed.LocalContextScope::SINGLETON} containers will not terminate on GC.
     * 
     * @throws Throwable
     * 
     * @since JRuby 1.6.0
     */
    public void finalize() throws Throwable {
<span class="nc" id="L1857">        super.finalize();</span>
        // singleton containers share global runtime, and should not tear it down
<span class="nc bnc" id="L1859" title="All 2 branches missed.">        if (scope != LocalContextScope.SINGLETON) terminate();</span>
<span class="nc" id="L1860">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>