<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Helpers.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby.runtime</a> &gt; <span class="el_source">Helpers.java</span></div><h1>Helpers.java</h1><pre class="source lang-java linenums">package org.jruby.runtime;

import java.io.UnsupportedEncodingException;
import java.lang.reflect.Array;
import java.nio.channels.ClosedChannelException;
import java.nio.charset.Charset;

import jnr.constants.platform.Errno;
import org.jruby.*;
import org.jruby.ast.ArgsNode;
import org.jruby.ast.ArgumentNode;
import org.jruby.ast.DAsgnNode;
import org.jruby.ast.LocalAsgnNode;
import org.jruby.ast.MultipleAsgn19Node;
import org.jruby.ast.Node;
import org.jruby.ast.OptArgNode;
import org.jruby.ast.UnnamedRestArgNode;
import org.jruby.ast.util.ArgsUtil;
import org.jruby.common.IRubyWarnings.ID;
import org.jruby.evaluator.ASTInterpreter;
import org.jruby.exceptions.JumpException;
import org.jruby.exceptions.RaiseException;
import org.jruby.exceptions.Unrescuable;
import org.jruby.internal.runtime.methods.*;
import org.jruby.ir.IRMethod;
import org.jruby.ir.IRScopeType;
import org.jruby.ir.operands.UndefinedValue;
import org.jruby.javasupport.JavaClass;
import org.jruby.javasupport.JavaUtil;
import org.jruby.lexer.yacc.ISourcePosition;
import org.jruby.lexer.yacc.SimpleSourcePosition;
import org.jruby.parser.StaticScope;
import org.jruby.platform.Platform;
import org.jruby.runtime.backtrace.BacktraceData;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.runtime.invokedynamic.MethodNames;
import org.jruby.util.ByteList;
import org.jruby.util.DefinedMessage;
import org.jruby.util.TypeConverter;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;
import org.jcodings.Encoding;
import org.jcodings.specific.ASCIIEncoding;
import org.jcodings.specific.USASCIIEncoding;
import org.jcodings.specific.UTF8Encoding;
import org.jcodings.unicode.UnicodeEncoding;

import static org.jruby.runtime.invokedynamic.MethodNames.EQL;
import static org.jruby.runtime.invokedynamic.MethodNames.OP_EQUAL;
import static org.jruby.util.CodegenUtils.sig;

import org.jruby.util.JavaNameMangler;

/**
 * Helper methods which are called by the compiler.  Note: These will show no consumers, but
 * generated code does call these so don't remove them thinking they are dead code. 
 *
 */
<span class="nc" id="L64">public class Helpers {</span>
    public static CallSite selectAttrAsgnCallSite(IRubyObject receiver, IRubyObject self, CallSite normalSite, CallSite variableSite) {
<span class="nc bnc" id="L66" title="All 2 branches missed.">        if (receiver == self) return variableSite;</span>
<span class="nc" id="L67">        return normalSite;</span>
    }
    public static IRubyObject doAttrAsgn(IRubyObject receiver, CallSite callSite, IRubyObject value, ThreadContext context, IRubyObject caller) {
<span class="nc" id="L70">        callSite.call(context, caller, receiver, value);</span>
<span class="nc" id="L71">        return value;</span>
    }
    public static IRubyObject doAttrAsgn(IRubyObject receiver, CallSite callSite, IRubyObject arg0, IRubyObject value, ThreadContext context, IRubyObject caller) {
<span class="nc" id="L74">        callSite.call(context, caller, receiver, arg0, value);</span>
<span class="nc" id="L75">        return value;</span>
    }
    public static IRubyObject doAttrAsgn(IRubyObject receiver, CallSite callSite, IRubyObject arg0, IRubyObject arg1, IRubyObject value, ThreadContext context, IRubyObject caller) {
<span class="nc" id="L78">        callSite.call(context, caller, receiver, arg0, arg1, value);</span>
<span class="nc" id="L79">        return value;</span>
    }
    public static IRubyObject doAttrAsgn(IRubyObject receiver, CallSite callSite, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2, IRubyObject value, ThreadContext context, IRubyObject caller) {
<span class="nc" id="L82">        callSite.call(context, caller, receiver, arg0, arg1, arg2, value);</span>
<span class="nc" id="L83">        return value;</span>
    }
    public static IRubyObject doAttrAsgn(IRubyObject receiver, CallSite callSite, IRubyObject[] args, ThreadContext context, IRubyObject caller) {
<span class="nc" id="L86">        callSite.call(context, caller, receiver, args);</span>
<span class="nc" id="L87">        return args[args.length - 1];</span>
    }
    public static IRubyObject doAttrAsgn(IRubyObject receiver, CallSite callSite, IRubyObject[] args, IRubyObject value, ThreadContext context, IRubyObject caller) {
<span class="nc" id="L90">        IRubyObject[] newArgs = new IRubyObject[args.length + 1];</span>
<span class="nc" id="L91">        System.arraycopy(args, 0, newArgs, 0, args.length);</span>
<span class="nc" id="L92">        newArgs[args.length] = value;</span>
<span class="nc" id="L93">        callSite.call(context, caller, receiver, newArgs);</span>
<span class="nc" id="L94">        return value;</span>
    }

    public static boolean invokeEqqForCaseWhen(CallSite callSite, ThreadContext context, IRubyObject caller, IRubyObject arg, IRubyObject[] receivers) {
<span class="nc bnc" id="L98" title="All 2 branches missed.">        for (int i = 0; i &lt; receivers.length; i++) {</span>
<span class="nc" id="L99">            IRubyObject receiver = receivers[i];</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">            if (invokeEqqForCaseWhen(callSite, context, caller, arg, receiver)) return true;</span>
        }
<span class="nc" id="L102">        return false;</span>
    }

    public static boolean invokeEqqForCaseWhen(CallSite callSite, ThreadContext context, IRubyObject caller, IRubyObject arg, IRubyObject receiver) {
<span class="nc" id="L106">        IRubyObject result = callSite.call(context, caller, receiver, arg);</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">        if (result.isTrue()) return true;</span>
<span class="nc" id="L108">        return false;</span>
    }

    public static boolean invokeEqqForCaseWhen(CallSite callSite, ThreadContext context, IRubyObject caller, IRubyObject arg, IRubyObject receiver0, IRubyObject receiver1) {
<span class="nc" id="L112">        IRubyObject result = callSite.call(context, caller, receiver0, arg);</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">        if (result.isTrue()) return true;</span>
<span class="nc" id="L114">        return invokeEqqForCaseWhen(callSite, context, caller, arg, receiver1);</span>
    }

    public static boolean invokeEqqForCaseWhen(CallSite callSite, ThreadContext context, IRubyObject caller, IRubyObject arg, IRubyObject receiver0, IRubyObject receiver1, IRubyObject receiver2) {
<span class="nc" id="L118">        IRubyObject result = callSite.call(context, caller, receiver0, arg);</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">        if (result.isTrue()) return true;</span>
<span class="nc" id="L120">        return invokeEqqForCaseWhen(callSite, context, caller, arg, receiver1, receiver2);</span>
    }

    public static boolean invokeEqqForCaselessWhen(IRubyObject[] receivers) {
<span class="nc bnc" id="L124" title="All 2 branches missed.">        for (int i = 0; i &lt; receivers.length; i++) {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            if (receivers[i].isTrue()) return true;</span>
        }
<span class="nc" id="L127">        return false;</span>
    }

    public static boolean invokeEqqForCaselessWhen(IRubyObject receiver) {
<span class="nc" id="L131">        return receiver.isTrue();</span>
    }

    public static boolean invokeEqqForCaselessWhen(IRubyObject receiver0, IRubyObject receiver1) {
<span class="nc bnc" id="L135" title="All 4 branches missed.">        return receiver0.isTrue() || receiver1.isTrue();</span>
    }

    public static boolean invokeEqqForCaselessWhen(IRubyObject receiver0, IRubyObject receiver1, IRubyObject receiver2) {
<span class="nc bnc" id="L139" title="All 6 branches missed.">        return receiver0.isTrue() || receiver1.isTrue() || receiver2.isTrue();</span>
    }
    
    public static CompiledBlockCallback createBlockCallback(Object scriptObject, String closureMethod, String file, int line) {
<span class="nc" id="L143">        Class scriptClass = scriptObject.getClass();</span>
<span class="nc" id="L144">        ClassLoader scriptClassLoader = scriptClass.getClassLoader();</span>
<span class="nc" id="L145">        MethodFactory factory = MethodFactory.createFactory(scriptClassLoader);</span>
        
<span class="nc" id="L147">        return factory.getBlockCallback(closureMethod, file, line, scriptObject);</span>
    }

    public static CompiledBlockCallback19 createBlockCallback19(Object scriptObject, String closureMethod, String file, int line) {
<span class="nc" id="L151">        Class scriptClass = scriptObject.getClass();</span>
<span class="nc" id="L152">        ClassLoader scriptClassLoader = scriptClass.getClassLoader();</span>
<span class="nc" id="L153">        MethodFactory factory = MethodFactory.createFactory(scriptClassLoader);</span>

<span class="nc" id="L155">        return factory.getBlockCallback19(closureMethod, file, line, scriptObject);</span>
    }

    public static byte[] createBlockCallbackOffline(String classPath, String closureMethod, String file, int line) {
<span class="nc" id="L159">        MethodFactory factory = MethodFactory.createFactory(Helpers.class.getClassLoader());</span>

<span class="nc" id="L161">        return factory.getBlockCallbackOffline(closureMethod, file, line, classPath);</span>
    }

    public static byte[] createBlockCallback19Offline(String classPath, String closureMethod, String file, int line) {
<span class="nc" id="L165">        MethodFactory factory = MethodFactory.createFactory(Helpers.class.getClassLoader());</span>

<span class="nc" id="L167">        return factory.getBlockCallback19Offline(closureMethod, file, line, classPath);</span>
    }
    
    public static String[] parseBlockDescriptor(String descriptor) {
<span class="nc" id="L171">        String[] mangled = descriptor.split(&quot;:&quot;);</span>
<span class="nc" id="L172">        mangled[0] = JavaNameMangler.demangleMethodName(mangled[0]);</span>
<span class="nc" id="L173">        mangled[4] = JavaNameMangler.demangleMethodName(mangled[4]);</span>
<span class="nc" id="L174">        return mangled;</span>
    }

    public static BlockBody createCompiledBlockBody(ThreadContext context, Object scriptObject, StaticScope scope, String descriptor) {
<span class="nc" id="L178">        String[] firstSplit = parseBlockDescriptor(descriptor);</span>
<span class="nc" id="L179">        return createCompiledBlockBody(context, scriptObject, firstSplit[0], Integer.parseInt(firstSplit[1]), scope, Boolean.valueOf(firstSplit[2]), Integer.parseInt(firstSplit[3]), firstSplit[4], Integer.parseInt(firstSplit[5]), Boolean.valueOf(firstSplit[6]));</span>
    }
    
    public static BlockBody createCompiledBlockBody(ThreadContext context, Object scriptObject, String closureMethod, int arity,
            StaticScope staticScope, boolean hasMultipleArgsHead, int argsNodeType, String file, int line, boolean light) {
<span class="nc" id="L184">        staticScope.determineModule();</span>
        
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (light) {</span>
<span class="nc" id="L187">            return CompiledBlockLight.newCompiledBlockLight(</span>
<span class="nc" id="L188">                    Arity.createArity(arity), staticScope,</span>
<span class="nc" id="L189">                    createBlockCallback(scriptObject, closureMethod, file, line),</span>
                    hasMultipleArgsHead, argsNodeType);
        } else {
<span class="nc" id="L192">            return CompiledBlock.newCompiledBlock(</span>
<span class="nc" id="L193">                    Arity.createArity(arity), staticScope,</span>
<span class="nc" id="L194">                    createBlockCallback(scriptObject, closureMethod, file, line),</span>
                    hasMultipleArgsHead, argsNodeType);
        }
    }

    public static BlockBody createCompiledBlockBody19(ThreadContext context, Object scriptObject, StaticScope scope, String descriptor) {
<span class="nc" id="L200">        String[] firstSplit = parseBlockDescriptor(descriptor);</span>
<span class="nc" id="L201">        return createCompiledBlockBody19(context, scriptObject, firstSplit[0], Integer.parseInt(firstSplit[1]), scope, Boolean.valueOf(firstSplit[2]), Integer.parseInt(firstSplit[3]), firstSplit[4], Integer.parseInt(firstSplit[5]), Boolean.valueOf(firstSplit[6]), firstSplit[7]);</span>
    }

    public static BlockBody createCompiledBlockBody19(ThreadContext context, Object scriptObject, String closureMethod, int arity,
            StaticScope staticScope, boolean hasMultipleArgsHead, int argsNodeType, String file, int line, boolean light, String parameterList) {
<span class="nc" id="L206">        staticScope.determineModule();</span>

<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (light) {</span>
<span class="nc" id="L209">            return CompiledBlockLight19.newCompiledBlockLight(</span>
<span class="nc" id="L210">                    Arity.createArity(arity), staticScope,</span>
<span class="nc" id="L211">                    createBlockCallback19(scriptObject, closureMethod, file, line),</span>
<span class="nc" id="L212">                    hasMultipleArgsHead, argsNodeType, parameterList.split(&quot;;&quot;));</span>
        } else {
<span class="nc" id="L214">            return CompiledBlock19.newCompiledBlock(</span>
<span class="nc" id="L215">                    Arity.createArity(arity), staticScope,</span>
<span class="nc" id="L216">                    createBlockCallback19(scriptObject, closureMethod, file, line),</span>
<span class="nc" id="L217">                    hasMultipleArgsHead, argsNodeType, parameterList.split(&quot;;&quot;));</span>
        }
    }
    
    public static Block createBlock(ThreadContext context, IRubyObject self, BlockBody body) {
<span class="nc" id="L222">        return CompiledBlock.newCompiledClosure(</span>
                context,
                self,
                body);
    }

    public static Block createBlock19(ThreadContext context, IRubyObject self, BlockBody body) {
<span class="nc" id="L229">        return CompiledBlock19.newCompiledClosure(</span>
                context,
                self,
                body);
    }
    
    public static IRubyObject runBeginBlock(ThreadContext context, IRubyObject self, String scopeString, CompiledBlockCallback callback) {
<span class="nc" id="L236">        StaticScope staticScope = decodeScope(context, context.getCurrentStaticScope(), scopeString);</span>
        
<span class="nc" id="L238">        context.preScopedBody(DynamicScope.newDynamicScope(staticScope, context.getCurrentScope()));</span>
        
<span class="nc" id="L240">        Block block = CompiledBlock.newCompiledClosure(context, self, Arity.createArity(0), staticScope, callback, false, BlockBody.ZERO_ARGS);</span>
        
        try {
<span class="nc" id="L243">            block.yield(context, null);</span>
        } finally {
<span class="nc" id="L245">            context.postScopedBody();</span>
<span class="nc" id="L246">        }</span>

<span class="nc" id="L248">        return context.runtime.getNil();</span>
    }

    public static Block createSharedScopeBlock(ThreadContext context, IRubyObject self, int arity,
            CompiledBlockCallback callback, boolean hasMultipleArgsHead, int argsNodeType) {

<span class="nc" id="L254">        return CompiledSharedScopeBlock.newCompiledSharedScopeClosure(context, self, Arity.createArity(arity),</span>
<span class="nc" id="L255">                context.getCurrentScope(), callback, hasMultipleArgsHead, argsNodeType);</span>
    }

    public static IRubyObject def(ThreadContext context, IRubyObject self, Object scriptObject, String rubyName, String javaName, StaticScope scope,
                                  int arity, String filename, int line, CallConfiguration callConfig, String parameterDesc) {
        // TODO: Need to have access to AST for recompilation. See #1395
<span class="nc" id="L261">        final MethodNodes methodNodes = MethodNodes.lookup(javaName);</span>
<span class="nc" id="L262">        return def(context, self, scriptObject, rubyName, javaName, scope, arity, filename, line, callConfig, parameterDesc, methodNodes);</span>
    }

    public static IRubyObject def(ThreadContext context, IRubyObject self, Object scriptObject, String rubyName, String javaName, StaticScope scope,
                                  int arity, String filename, int line, CallConfiguration callConfig, String parameterDesc, MethodNodes methodNodes) {
<span class="nc" id="L267">        Class compiledClass = scriptObject.getClass();</span>
<span class="nc" id="L268">        Ruby runtime = context.runtime;</span>

<span class="nc" id="L270">        Visibility currVisibility = context.getCurrentVisibility();</span>
<span class="nc" id="L271">        Visibility newVisibility = performNormalMethodChecksAndDetermineVisibility(runtime, null, rubyName, currVisibility);</span>

<span class="nc" id="L273">        MethodFactory factory = MethodFactory.createFactory(compiledClass.getClassLoader());</span>
<span class="nc" id="L274">        DynamicMethod method = constructNormalMethod(</span>
                factory, javaName,
                rubyName, null, new SimpleSourcePosition(filename, line), arity, scope, newVisibility, scriptObject,
                callConfig,
                parameterDesc,
                methodNodes);

        // TODO(CS): The MethodNodes don't pass through to the method object correctly - bypass.

<span class="nc bnc" id="L283" title="All 2 branches missed.">        if (method instanceof CompiledMethod) {</span>
<span class="nc" id="L284">            ((CompiledMethod) method).unsafeSetMethodNodes(methodNodes);</span>
        }

<span class="nc" id="L287">        return addInstanceMethod(null, rubyName, method, currVisibility, context, runtime);</span>
    }

    public static IRubyObject defs(ThreadContext context, IRubyObject self, IRubyObject receiver, Object scriptObject, String rubyName, String javaName, StaticScope scope,
                                   int arity, String filename, int line, CallConfiguration callConfig, String parameterDesc) {
        // TODO: Need to have access to AST for recompilation. See #1395
<span class="nc" id="L293">        final MethodNodes methodNodes = MethodNodes.lookup(javaName);</span>
<span class="nc" id="L294">        return defs(context, self, receiver, scriptObject, rubyName, javaName, scope, arity, filename, line, callConfig, parameterDesc, methodNodes);</span>
    }

    public static IRubyObject defs(ThreadContext context, IRubyObject self, IRubyObject receiver, Object scriptObject, String rubyName, String javaName, StaticScope scope,
            int arity, String filename, int line, CallConfiguration callConfig, String parameterDesc, MethodNodes methodNodes) {
<span class="nc" id="L299">        Class compiledClass = scriptObject.getClass();</span>
<span class="nc" id="L300">        Ruby runtime = context.runtime;</span>

<span class="nc" id="L302">        RubyClass rubyClass = performSingletonMethodChecks(runtime, receiver, rubyName);</span>
        
<span class="nc" id="L304">        MethodFactory factory = MethodFactory.createFactory(compiledClass.getClassLoader());</span>
<span class="nc" id="L305">        DynamicMethod method = constructSingletonMethod(</span>
                factory, rubyName, javaName, rubyClass,
                new SimpleSourcePosition(filename, line), arity, scope,
                scriptObject, callConfig, parameterDesc, methodNodes);

        // TODO(CS): The MethodNodes don't pass through to the method object correctly - bypass.

<span class="nc bnc" id="L312" title="All 2 branches missed.">        if (method instanceof CompiledMethod) {</span>
<span class="nc" id="L313">            ((CompiledMethod) method).unsafeSetMethodNodes(methodNodes);</span>
        }
        
<span class="nc" id="L316">        rubyClass.addMethod(rubyName, method);</span>
        
<span class="nc" id="L318">        callSingletonMethodHook(receiver,context, runtime.fastNewSymbol(rubyName));</span>
        
<span class="nc" id="L320">        return runtime.newSymbol(rubyName);</span>
    }

    public static byte[] defOffline(String rubyName, String javaName, String classPath, String invokerName, Arity arity, StaticScope scope, CallConfiguration callConfig, String filename, int line, MethodNodes methodNodes) {
<span class="nc" id="L324">        MethodFactory factory = MethodFactory.createFactory(Helpers.class.getClassLoader());</span>
<span class="nc" id="L325">        byte[] methodBytes = factory.getCompiledMethodOffline(rubyName, javaName, classPath, invokerName, arity, scope, callConfig, filename, line, methodNodes);</span>

<span class="nc" id="L327">        return methodBytes;</span>
    }
    
    public static RubyClass getSingletonClass(Ruby runtime, IRubyObject receiver) {
<span class="fc bfc" id="L331" title="All 4 branches covered.">        if (receiver instanceof RubyFixnum || receiver instanceof RubySymbol) {</span>
<span class="fc" id="L332">            throw runtime.newTypeError(&quot;can't define singleton&quot;);</span>
        } else {
<span class="fc" id="L334">            return receiver.getSingletonClass();</span>
        }
    }

    // TODO: Only used by interface implementation; eliminate it
    public static IRubyObject invokeMethodMissing(IRubyObject receiver, String name, IRubyObject[] args) {
<span class="nc" id="L340">        ThreadContext context = receiver.getRuntime().getCurrentContext();</span>

        // store call information so method_missing impl can use it
<span class="nc" id="L343">        context.setLastCallStatusAndVisibility(CallType.FUNCTIONAL, Visibility.PUBLIC);</span>

<span class="nc bnc" id="L345" title="All 2 branches missed.">        if (name.equals(&quot;method_missing&quot;)) {</span>
<span class="nc" id="L346">            return RubyKernel.method_missing(context, receiver, args, Block.NULL_BLOCK);</span>
        }

<span class="nc" id="L349">        IRubyObject[] newArgs = prepareMethodMissingArgs(args, context, name);</span>

<span class="nc" id="L351">        return invoke(context, receiver, &quot;method_missing&quot;, newArgs, Block.NULL_BLOCK);</span>
    }

    public static IRubyObject callMethodMissing(ThreadContext context, IRubyObject receiver, Visibility visibility, String name, CallType callType, IRubyObject[] args, Block block) {
<span class="fc" id="L355">        return selectMethodMissing(context, receiver, visibility, name, callType).call(context, receiver, receiver.getMetaClass(), name, args, block);</span>
    }

    public static IRubyObject callMethodMissing(ThreadContext context, IRubyObject receiver, Visibility visibility, String name, CallType callType, IRubyObject arg0, Block block) {
<span class="nc" id="L359">        return selectMethodMissing(context, receiver, visibility, name, callType).call(context, receiver, receiver.getMetaClass(), name, arg0, block);</span>
    }

    public static IRubyObject callMethodMissing(ThreadContext context, IRubyObject receiver, Visibility visibility, String name, CallType callType, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="nc" id="L363">        return selectMethodMissing(context, receiver, visibility, name, callType).call(context, receiver, receiver.getMetaClass(), name, arg0, arg1, block);</span>
    }

    public static IRubyObject callMethodMissing(ThreadContext context, IRubyObject receiver, Visibility visibility, String name, CallType callType, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2, Block block) {
<span class="nc" id="L367">        return selectMethodMissing(context, receiver, visibility, name, callType).call(context, receiver, receiver.getMetaClass(), name, arg0, arg1, arg2, block);</span>
    }

    public static IRubyObject callMethodMissing(ThreadContext context, IRubyObject receiver, Visibility visibility, String name, CallType callType, Block block) {
<span class="fc" id="L371">        return selectMethodMissing(context, receiver, visibility, name, callType).call(context, receiver, receiver.getMetaClass(), name, block);</span>
    }

    public static DynamicMethod selectMethodMissing(ThreadContext context, IRubyObject receiver, Visibility visibility, String name, CallType callType) {
<span class="fc" id="L375">        Ruby runtime = context.runtime;</span>

<span class="pc bpc" id="L377" title="1 of 2 branches missed.">        if (name.equals(&quot;method_missing&quot;)) {</span>
<span class="nc" id="L378">            return selectInternalMM(runtime, visibility, callType);</span>
        }

<span class="fc" id="L381">        DynamicMethod methodMissing = receiver.getMetaClass().searchMethod(&quot;method_missing&quot;);</span>
<span class="fc bfc" id="L382" title="All 4 branches covered.">        if (methodMissing.isUndefined() || methodMissing.equals(runtime.getDefaultMethodMissing())) {</span>
<span class="fc" id="L383">            return selectInternalMM(runtime, visibility, callType);</span>
        }
<span class="fc" id="L385">        return new MethodMissingMethod(methodMissing, callType);</span>
    }

    public static DynamicMethod selectMethodMissing(ThreadContext context, RubyClass selfClass, Visibility visibility, String name, CallType callType) {
<span class="fc" id="L389">        Ruby runtime = context.runtime;</span>

<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        if (name.equals(&quot;method_missing&quot;)) {</span>
<span class="nc" id="L392">            return selectInternalMM(runtime, visibility, callType);</span>
        }

<span class="fc" id="L395">        DynamicMethod methodMissing = selfClass.searchMethod(&quot;method_missing&quot;);</span>
<span class="pc bpc" id="L396" title="2 of 4 branches missed.">        if (methodMissing.isUndefined() || methodMissing.equals(runtime.getDefaultMethodMissing())) {</span>
<span class="fc" id="L397">            return selectInternalMM(runtime, visibility, callType);</span>
        }
<span class="nc" id="L399">        return new MethodMissingMethod(methodMissing, callType);</span>
    }

    public static DynamicMethod selectMethodMissing(RubyClass selfClass, Visibility visibility, String name, CallType callType) {
<span class="nc" id="L403">        Ruby runtime = selfClass.getClassRuntime();</span>

<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (name.equals(&quot;method_missing&quot;)) {</span>
<span class="nc" id="L406">            return selectInternalMM(runtime, visibility, callType);</span>
        }

<span class="nc" id="L409">        DynamicMethod methodMissing = selfClass.searchMethod(&quot;method_missing&quot;);</span>
<span class="nc bnc" id="L410" title="All 4 branches missed.">        if (methodMissing.isUndefined() || methodMissing.equals(runtime.getDefaultMethodMissing())) {</span>
<span class="nc" id="L411">            return selectInternalMM(runtime, visibility, callType);</span>
        }
<span class="nc" id="L413">        return new MethodMissingMethod(methodMissing, callType);</span>
    }

    public static final Map&lt;String, String&gt; map(String... keyValues) {
<span class="fc" id="L417">        HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(keyValues.length / 2);</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">        for (int i = 0; i &lt; keyValues.length;) {</span>
<span class="fc" id="L419">            map.put(keyValues[i++], keyValues[i++]);</span>
        }
<span class="fc" id="L421">        return map;</span>
    }

    /**
     * Should be called on jumps out of blocks.  Inspects the jump, returning or rethrowing as appropriate
     */
    public static IRubyObject handleBlockJump(ThreadContext context, JumpException.FlowControlException jump, Block.Type type) {
        // 'next' and Lambda 'return' are local returns from the block, ending the call or yield
<span class="nc bnc" id="L429" title="All 6 branches missed.">        if (jump instanceof JumpException.NextJump</span>
                || (jump instanceof JumpException.ReturnJump &amp;&amp; type == Block.Type.LAMBDA)) {
<span class="nc bnc" id="L431" title="All 2 branches missed.">            return jump.getValue() == null ? context.runtime.getNil() : (IRubyObject)jump.getValue();</span>
        }

        // other jumps propagate up
<span class="nc" id="L435">        throw jump;</span>
    }

    public static boolean additionOverflowed(long original, long other, long result) {
<span class="fc bfc" id="L439" title="All 2 branches covered.">        return (~(original ^ other) &amp; (original ^ result) &amp; RubyFixnum.SIGN_BIT) != 0;</span>
    }

    public static boolean subtractionOverflowed(long original, long other, long result) {
<span class="fc bfc" id="L443" title="All 2 branches covered.">        return (~(original ^ ~other) &amp; (original ^ result) &amp; RubyFixnum.SIGN_BIT) != 0;</span>
    }

    public static Errno errnoFromException(Throwable t) {
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">        if (t instanceof ClosedChannelException) {</span>
<span class="fc" id="L448">            return Errno.EBADF;</span>
        }

        // TODO: this is kinda gross
<span class="nc bnc" id="L452" title="All 2 branches missed.">        if(t.getMessage() != null) {</span>
<span class="nc" id="L453">            String errorMessage = t.getMessage();</span>

            // All errors to sysread should be SystemCallErrors, but on a closed stream
            // Ruby returns an IOError.  Java throws same exception for all errors so
            // we resort to this hack...

<span class="nc bnc" id="L459" title="All 2 branches missed.">            if (&quot;Bad file descriptor&quot;.equals(errorMessage)) {</span>
<span class="nc" id="L460">                return Errno.EBADF;</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">            } else if (&quot;File not open&quot;.equals(errorMessage)) {</span>
<span class="nc" id="L462">                return null;</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">            } else if (&quot;An established connection was aborted by the software in your host machine&quot;.equals(errorMessage)) {</span>
<span class="nc" id="L464">                return Errno.ECONNABORTED;</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">            } else if (t.getMessage().equals(&quot;Broken pipe&quot;)) {</span>
<span class="nc" id="L466">                return Errno.EPIPE;</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">            } else if (&quot;Connection reset by peer&quot;.equals(errorMessage) ||</span>
<span class="nc bnc" id="L468" title="All 4 branches missed.">                       &quot;An existing connection was forcibly closed by the remote host&quot;.equals(errorMessage) ||</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">                    (Platform.IS_WINDOWS &amp;&amp; errorMessage.contains(&quot;connection was aborted&quot;))) {</span>
<span class="nc" id="L470">                return Errno.ECONNRESET;</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">            } else if (errorMessage.equals(&quot;No space left on device&quot;)) {</span>
<span class="nc" id="L472">                return Errno.ENOSPC;</span>
            }
        }
<span class="nc" id="L475">        return null;</span>
    }

    public static RubyModule getNthScopeModule(StaticScope scope, int depth) {
<span class="fc" id="L479">        int n = depth;</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">        while (n &gt; 0) {</span>
<span class="fc" id="L481">            scope = scope.getEnclosingScope();</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">            if (scope.getScopeType() != null) {</span>
<span class="fc" id="L483">                n--;</span>
            }
        }
<span class="fc" id="L486">        return scope.getModule();</span>
    }

    public static RubyArray viewArgsArray(ThreadContext context, RubyArray rubyArray, int preArgsCount, int postArgsCount) {
<span class="fc" id="L490">        int n = rubyArray.getLength();</span>
<span class="fc bfc" id="L491" title="All 4 branches covered.">        if ((preArgsCount &gt;= n) || (preArgsCount + postArgsCount &gt;= n)) {</span>
<span class="fc" id="L492">            return RubyArray.newEmptyArray(context.runtime);</span>
        } else {
<span class="fc" id="L494">            return (RubyArray)rubyArray.subseqLight(preArgsCount, n - preArgsCount - postArgsCount);</span>
        }
    }

    public static Class[] getStaticMethodParams(Class target, int args) {
<span class="nc bnc" id="L499" title="All 6 branches missed.">        switch (args) {</span>
        case 0:
<span class="nc" id="L501">            return new Class[] {target, ThreadContext.class, IRubyObject.class, Block.class};</span>
        case 1:
<span class="nc" id="L503">            return new Class[] {target, ThreadContext.class, IRubyObject.class, IRubyObject.class, Block.class};</span>
        case 2:
<span class="nc" id="L505">            return new Class[] {target, ThreadContext.class, IRubyObject.class, IRubyObject.class, IRubyObject.class, Block.class};</span>
        case 3:
<span class="nc" id="L507">            return new Class[] {target, ThreadContext.class, IRubyObject.class, IRubyObject.class, IRubyObject.class, IRubyObject.class, Block.class};</span>
        case 4:
<span class="nc" id="L509">            return new Class[] {target, ThreadContext.class, IRubyObject.class, IRubyObject[].class, Block.class};</span>
        default:
<span class="nc" id="L511">            throw new RuntimeException(&quot;unsupported arity: &quot; + args);</span>
        }
    }

    public static String getStaticMethodSignature(String classname, int args) {
<span class="nc bnc" id="L516" title="All 6 branches missed.">        switch (args) {</span>
        case 0:
<span class="nc" id="L518">            return sig(IRubyObject.class, &quot;L&quot; + classname + &quot;;&quot;, ThreadContext.class, IRubyObject.class, Block.class);</span>
        case 1:
<span class="nc" id="L520">            return sig(IRubyObject.class, &quot;L&quot; + classname + &quot;;&quot;, ThreadContext.class, IRubyObject.class, IRubyObject.class, Block.class);</span>
        case 2:
<span class="nc" id="L522">            return sig(IRubyObject.class, &quot;L&quot; + classname + &quot;;&quot;, ThreadContext.class, IRubyObject.class, IRubyObject.class, IRubyObject.class, Block.class);</span>
        case 3:
<span class="nc" id="L524">            return sig(IRubyObject.class, &quot;L&quot; + classname + &quot;;&quot;, ThreadContext.class, IRubyObject.class, IRubyObject.class, IRubyObject.class, IRubyObject.class, Block.class);</span>
        case 4:
<span class="nc" id="L526">            return sig(IRubyObject.class, &quot;L&quot; + classname + &quot;;&quot;, ThreadContext.class, IRubyObject.class, IRubyObject[].class, Block.class);</span>
        default:
<span class="nc" id="L528">            throw new RuntimeException(&quot;unsupported arity: &quot; + args);</span>
        }
    }

<span class="nc" id="L532">    private static class MethodMissingMethod extends DynamicMethod {</span>
        private final DynamicMethod delegate;
        private final CallType lastCallStatus;

<span class="fc" id="L536">        public MethodMissingMethod(DynamicMethod delegate, CallType lastCallStatus) {</span>
<span class="fc" id="L537">            this.delegate = delegate;</span>
<span class="fc" id="L538">            this.lastCallStatus = lastCallStatus;</span>
<span class="fc" id="L539">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="fc" id="L543">            context.setLastCallStatus(lastCallStatus);</span>
<span class="fc" id="L544">            return this.delegate.call(context, self, clazz, &quot;method_missing&quot;, prepareMethodMissingArgs(args, context, name), block);</span>
        }

        @Override
        public DynamicMethod dup() {
<span class="nc" id="L549">            return this;</span>
        }
    }

    private static DynamicMethod selectInternalMM(Ruby runtime, Visibility visibility, CallType callType) {
<span class="fc bfc" id="L554" title="All 2 branches covered.">        if (visibility == Visibility.PRIVATE) {</span>
<span class="fc" id="L555">            return runtime.getPrivateMethodMissing();</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">        } else if (visibility == Visibility.PROTECTED) {</span>
<span class="fc" id="L557">            return runtime.getProtectedMethodMissing();</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">        } else if (callType == CallType.VARIABLE) {</span>
<span class="fc" id="L559">            return runtime.getVariableMethodMissing();</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">        } else if (callType == CallType.SUPER) {</span>
<span class="fc" id="L561">            return runtime.getSuperMethodMissing();</span>
        } else {
<span class="fc" id="L563">            return runtime.getNormalMethodMissing();</span>
        }
    }

    private static IRubyObject[] prepareMethodMissingArgs(IRubyObject[] args, ThreadContext context, String name) {
<span class="fc" id="L568">        IRubyObject[] newArgs = new IRubyObject[args.length + 1];</span>
<span class="fc" id="L569">        System.arraycopy(args, 0, newArgs, 1, args.length);</span>
<span class="fc" id="L570">        newArgs[0] = context.runtime.newSymbol(name);</span>

<span class="fc" id="L572">        return newArgs;</span>
    }
    
    public static IRubyObject invoke(ThreadContext context, IRubyObject self, String name, Block block) {
<span class="fc" id="L576">        return self.getMetaClass().finvoke(context, self, name, block);</span>
    }
    public static IRubyObject invoke(ThreadContext context, IRubyObject self, String name, IRubyObject arg0, Block block) {
<span class="fc" id="L579">        return self.getMetaClass().finvoke(context, self, name, arg0, block);</span>
    }
    public static IRubyObject invoke(ThreadContext context, IRubyObject self, String name, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="nc" id="L582">        return self.getMetaClass().finvoke(context, self, name, arg0, arg1, block);</span>
    }
    public static IRubyObject invoke(ThreadContext context, IRubyObject self, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2, Block block) {
<span class="fc" id="L585">        return self.getMetaClass().finvoke(context, self, name, arg0, arg1, arg2, block);</span>
    }
    public static IRubyObject invoke(ThreadContext context, IRubyObject self, String name, IRubyObject[] args, Block block) {
<span class="fc" id="L588">        return self.getMetaClass().finvoke(context, self, name, args, block);</span>
    }
    
    public static IRubyObject invoke(ThreadContext context, IRubyObject self, String name) {
<span class="fc" id="L592">        return self.getMetaClass().finvoke(context, self, name);</span>
    }
    public static IRubyObject invoke(ThreadContext context, IRubyObject self, String name, IRubyObject arg0) {
<span class="fc" id="L595">        return self.getMetaClass().finvoke(context, self, name, arg0);</span>
    }
    public static IRubyObject invoke(ThreadContext context, IRubyObject self, String name, IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L598">        return self.getMetaClass().finvoke(context, self, name, arg0, arg1);</span>
    }
    public static IRubyObject invoke(ThreadContext context, IRubyObject self, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {
<span class="nc" id="L601">        return self.getMetaClass().finvoke(context, self, name, arg0, arg1, arg2);</span>
    }
    public static IRubyObject invoke(ThreadContext context, IRubyObject self, String name, IRubyObject... args) {
<span class="fc" id="L604">        return self.getMetaClass().finvoke(context, self, name, args);</span>
    }
    
    public static IRubyObject invoke(ThreadContext context, IRubyObject self, String name, CallType callType) {
<span class="nc" id="L608">        return Helpers.invoke(context, self, name, IRubyObject.NULL_ARRAY, callType, Block.NULL_BLOCK);</span>
    }
    public static IRubyObject invoke(ThreadContext context, IRubyObject self, String name, IRubyObject[] args, CallType callType, Block block) {
<span class="fc" id="L611">        return self.getMetaClass().invoke(context, self, name, args, callType, block);</span>
    }
    
    public static IRubyObject invoke(ThreadContext context, IRubyObject self, String name, IRubyObject arg, CallType callType, Block block) {
<span class="fc" id="L615">        return self.getMetaClass().invoke(context, self, name, arg, callType, block);</span>
    }
    
    public static IRubyObject invokeAs(ThreadContext context, RubyClass asClass, IRubyObject self, String name, IRubyObject[] args, Block block) {
<span class="nc" id="L619">        return asClass.finvoke(context, self, name, args, block);</span>
    }
    
    public static IRubyObject invokeAs(ThreadContext context, RubyClass asClass, IRubyObject self, String name, Block block) {
<span class="nc" id="L623">        return asClass.finvoke(context, self, name, block);</span>
    }
    
    public static IRubyObject invokeAs(ThreadContext context, RubyClass asClass, IRubyObject self, String name, IRubyObject arg0, Block block) {
<span class="nc" id="L627">        return asClass.finvoke(context, self, name, arg0, block);</span>
    }
    
    public static IRubyObject invokeAs(ThreadContext context, RubyClass asClass, IRubyObject self, String name, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="nc" id="L631">        return asClass.finvoke(context, self, name, arg0, arg1, block);</span>
    }
    
    public static IRubyObject invokeAs(ThreadContext context, RubyClass asClass, IRubyObject self, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2, Block block) {
<span class="nc" id="L635">        return asClass.finvoke(context, self, name, arg0, arg1, arg2, block);</span>
    }

    public static IRubyObject invokeChecked(ThreadContext context, IRubyObject self, String name) {
<span class="fc" id="L639">        return self.getMetaClass().finvokeChecked(context, self, name);</span>
    }

    /**
     * The protocol for super method invocation is a bit complicated
     * in Ruby. In real terms it involves first finding the real
     * implementation class (the super class), getting the name of the
     * method to call from the frame, and then invoke that on the
     * super class with the current self as the actual object
     * invoking.
     */
    public static IRubyObject invokeSuper(ThreadContext context, IRubyObject self, IRubyObject[] args, Block block) {
<span class="nc" id="L651">        return invokeSuper(context, self, context.getFrameKlazz(), context.getFrameName(), args, block);</span>
    }

    public static IRubyObject invokeSuper(ThreadContext context, IRubyObject self, RubyModule klass, String name, IRubyObject[] args, Block block) {
<span class="nc" id="L655">        checkSuperDisabledOrOutOfMethod(context, klass, name);</span>

<span class="nc" id="L657">        RubyClass superClass = findImplementerIfNecessary(self.getMetaClass(), klass).getSuperClass();</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">        DynamicMethod method = superClass != null ? superClass.searchMethod(name) : UndefinedMethod.INSTANCE;</span>

<span class="nc bnc" id="L660" title="All 2 branches missed.">        if (method.isUndefined()) {</span>
<span class="nc" id="L661">            return callMethodMissing(context, self, method.getVisibility(), name, CallType.SUPER, args, block);</span>
        }
<span class="nc" id="L663">        return method.call(context, self, superClass, name, args, block);</span>
    }
    
    public static IRubyObject invokeSuper(ThreadContext context, IRubyObject self, Block block) {
<span class="fc" id="L667">        checkSuperDisabledOrOutOfMethod(context);</span>
<span class="fc" id="L668">        RubyModule klazz = context.getFrameKlazz();</span>
<span class="fc" id="L669">        String name = context.getFrameName();</span>

<span class="fc" id="L671">        RubyClass superClass = findImplementerIfNecessary(self.getMetaClass(), klazz).getSuperClass();</span>
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">        DynamicMethod method = superClass != null ? superClass.searchMethod(name) : UndefinedMethod.INSTANCE;</span>

<span class="pc bpc" id="L674" title="1 of 2 branches missed.">        if (method.isUndefined()) {</span>
<span class="nc" id="L675">            return callMethodMissing(context, self, method.getVisibility(), name, CallType.SUPER, block);</span>
        }
<span class="fc" id="L677">        return method.call(context, self, superClass, name, block);</span>
    }
    
    public static IRubyObject invokeSuper(ThreadContext context, IRubyObject self, IRubyObject arg0, Block block) {
<span class="fc" id="L681">        checkSuperDisabledOrOutOfMethod(context);</span>
<span class="fc" id="L682">        RubyModule klazz = context.getFrameKlazz();</span>
<span class="fc" id="L683">        String name = context.getFrameName();</span>

<span class="fc" id="L685">        RubyClass superClass = findImplementerIfNecessary(self.getMetaClass(), klazz).getSuperClass();</span>
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">        DynamicMethod method = superClass != null ? superClass.searchMethod(name) : UndefinedMethod.INSTANCE;</span>

<span class="pc bpc" id="L688" title="1 of 2 branches missed.">        if (method.isUndefined()) {</span>
<span class="nc" id="L689">            return callMethodMissing(context, self, method.getVisibility(), name, CallType.SUPER, arg0, block);</span>
        }
<span class="fc" id="L691">        return method.call(context, self, superClass, name, arg0, block);</span>
    }
    
    public static IRubyObject invokeSuper(ThreadContext context, IRubyObject self, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="nc" id="L695">        checkSuperDisabledOrOutOfMethod(context);</span>
<span class="nc" id="L696">        RubyModule klazz = context.getFrameKlazz();</span>
<span class="nc" id="L697">        String name = context.getFrameName();</span>

<span class="nc" id="L699">        RubyClass superClass = findImplementerIfNecessary(self.getMetaClass(), klazz).getSuperClass();</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">        DynamicMethod method = superClass != null ? superClass.searchMethod(name) : UndefinedMethod.INSTANCE;</span>

<span class="nc bnc" id="L702" title="All 2 branches missed.">        if (method.isUndefined()) {</span>
<span class="nc" id="L703">            return callMethodMissing(context, self, method.getVisibility(), name, CallType.SUPER, arg0, arg1, block);</span>
        }
<span class="nc" id="L705">        return method.call(context, self, superClass, name, arg0, arg1, block);</span>
    }
    
    public static IRubyObject invokeSuper(ThreadContext context, IRubyObject self, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2, Block block) {
<span class="nc" id="L709">        checkSuperDisabledOrOutOfMethod(context);</span>
<span class="nc" id="L710">        RubyModule klazz = context.getFrameKlazz();</span>
<span class="nc" id="L711">        String name = context.getFrameName();</span>

<span class="nc" id="L713">        RubyClass superClass = findImplementerIfNecessary(self.getMetaClass(), klazz).getSuperClass();</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">        DynamicMethod method = superClass != null ? superClass.searchMethod(name) : UndefinedMethod.INSTANCE;</span>

<span class="nc bnc" id="L716" title="All 2 branches missed.">        if (method.isUndefined()) {</span>
<span class="nc" id="L717">            return callMethodMissing(context, self, method.getVisibility(), name, CallType.SUPER, arg0, arg1, arg2, block);</span>
        }
<span class="nc" id="L719">        return method.call(context, self, superClass, name, arg0, arg1, arg2, block);</span>
    }

    public static RubyArray ensureRubyArray(IRubyObject value) {
<span class="nc" id="L723">        return ensureRubyArray(value.getRuntime(), value);</span>
    }

    public static RubyArray ensureRubyArray(Ruby runtime, IRubyObject value) {
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">        return value instanceof RubyArray ? (RubyArray)value : RubyArray.newArray(runtime, value);</span>
    }

    public static RubyArray ensureMultipleAssignableRubyArray(IRubyObject value, Ruby runtime, boolean masgnHasHead) {
<span class="nc bnc" id="L731" title="All 2 branches missed.">        if (!(value instanceof RubyArray)) {</span>
<span class="nc" id="L732">            value = ArgsUtil.convertToRubyArray19(runtime, value, masgnHasHead);</span>
        }
<span class="nc" id="L734">        return (RubyArray) value;</span>
    }
    
    public static IRubyObject fetchClassVariable(Ruby runtime, StaticScope scope,
            IRubyObject self, String name) {
<span class="nc" id="L739">        RubyModule rubyClass = ASTInterpreter.getClassVariableBase(runtime, scope);</span>
   
<span class="nc bnc" id="L741" title="All 2 branches missed.">        if (rubyClass == null) rubyClass = self.getMetaClass();</span>

<span class="nc" id="L743">        return rubyClass.getClassVar(name);</span>
    }
    
    public static IRubyObject getConstant(ThreadContext context, String internedName) {
<span class="nc" id="L747">        Ruby runtime = context.runtime;</span>

<span class="nc" id="L749">        return context.getCurrentScope().getStaticScope().getConstantWithConstMissing(internedName);</span>
    }

    public static IRubyObject nullToNil(IRubyObject value, ThreadContext context) {
<span class="nc bnc" id="L753" title="All 2 branches missed.">        return value != null ? value : context.nil;</span>
    }
    
    public static IRubyObject nullToNil(IRubyObject value, Ruby runtime) {
<span class="nc bnc" id="L757" title="All 2 branches missed.">        return value != null ? value : runtime.getNil();</span>
    }
    
    public static IRubyObject nullToNil(IRubyObject value, IRubyObject nil) {
<span class="nc bnc" id="L761" title="All 2 branches missed.">        return value != null ? value : nil;</span>
    }
    
    public static RubyClass prepareSuperClass(Ruby runtime, IRubyObject rubyClass) {
<span class="nc" id="L765">        RubyClass.checkInheritable(rubyClass); // use the same logic as in EvaluationState</span>
<span class="nc" id="L766">        return (RubyClass)rubyClass;</span>
    }
    
    public static RubyModule prepareClassNamespace(ThreadContext context, StaticScope scope, IRubyObject rubyModule) {
<span class="nc bnc" id="L770" title="All 4 branches missed.">        if (rubyModule == null || rubyModule.isNil()) {</span>
<span class="nc" id="L771">            rubyModule = scope.getModule();</span>

<span class="nc bnc" id="L773" title="All 2 branches missed.">            if (rubyModule == null) {</span>
<span class="nc" id="L774">                throw context.runtime.newTypeError(&quot;no outer class/module&quot;);</span>
            }
        }

<span class="nc bnc" id="L778" title="All 2 branches missed.">        if (rubyModule instanceof RubyModule) {</span>
<span class="nc" id="L779">            return (RubyModule)rubyModule;</span>
        } else {
<span class="nc" id="L781">            throw context.runtime.newTypeError(rubyModule + &quot; is not a class/module&quot;);</span>
        }
    }
    
    public static IRubyObject setClassVariable(Ruby runtime, StaticScope scope,
            IRubyObject self, String name, IRubyObject value) {
<span class="nc" id="L787">        RubyModule rubyClass = ASTInterpreter.getClassVariableBase(runtime, scope);</span>
   
<span class="nc bnc" id="L789" title="All 2 branches missed.">        if (rubyClass == null) rubyClass = self.getMetaClass();</span>

<span class="nc" id="L791">        rubyClass.setClassVar(name, value);</span>
   
<span class="nc" id="L793">        return value;</span>
    }
    
    public static IRubyObject declareClassVariable(Ruby runtime, StaticScope scope, IRubyObject self, String name, IRubyObject value) {
        // FIXME: This isn't quite right; it shouldn't evaluate the value if it's going to throw the error
<span class="nc" id="L798">        RubyModule rubyClass = ASTInterpreter.getClassVariableBase(runtime, scope);</span>
   
<span class="nc bnc" id="L800" title="All 2 branches missed.">        if (rubyClass == null) throw runtime.newTypeError(&quot;no class/module to define class variable&quot;);</span>
        
<span class="nc" id="L802">        rubyClass.setClassVar(name, value);</span>
   
<span class="nc" id="L804">        return value;</span>
    }
    
    public static void handleArgumentSizes(ThreadContext context, Ruby runtime, int given, int required, int opt, int rest) {
<span class="nc bnc" id="L808" title="All 2 branches missed.">        if (opt == 0) {</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">            if (rest &lt; 0) {</span>
                // no opt, no rest, exact match
<span class="nc bnc" id="L811" title="All 2 branches missed.">                if (given != required) {</span>
<span class="nc" id="L812">                    throw runtime.newArgumentError(&quot;wrong number of arguments (&quot; + given + &quot; for &quot; + required + &quot;)&quot;);</span>
                }
            } else {
                // only rest, must be at least required
<span class="nc bnc" id="L816" title="All 2 branches missed.">                if (given &lt; required) {</span>
<span class="nc" id="L817">                    throw runtime.newArgumentError(&quot;wrong number of arguments (&quot; + given + &quot; for &quot; + required + &quot;)&quot;);</span>
                }
            }
        } else {
<span class="nc bnc" id="L821" title="All 2 branches missed.">            if (rest &lt; 0) {</span>
                // opt but no rest, must be at least required and no more than required + opt
<span class="nc bnc" id="L823" title="All 2 branches missed.">                if (given &lt; required) {</span>
<span class="nc" id="L824">                    throw runtime.newArgumentError(&quot;wrong number of arguments (&quot; + given + &quot; for &quot; + required + &quot;)&quot;);</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">                } else if (given &gt; (required + opt)) {</span>
<span class="nc" id="L826">                    throw runtime.newArgumentError(&quot;wrong number of arguments (&quot; + given + &quot; for &quot; + (required + opt) + &quot;)&quot;);</span>
                }
            } else {
                // opt and rest, must be at least required
<span class="nc bnc" id="L830" title="All 2 branches missed.">                if (given &lt; required) {</span>
<span class="nc" id="L831">                    throw runtime.newArgumentError(&quot;wrong number of arguments (&quot; + given + &quot; for &quot; + required + &quot;)&quot;);</span>
                }
            }
        }
<span class="nc" id="L835">    }</span>
    
    public static String getLocalJumpTypeOrRethrow(RaiseException re) {
<span class="nc" id="L838">        RubyException exception = re.getException();</span>
<span class="nc" id="L839">        Ruby runtime = exception.getRuntime();</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">        if (runtime.getLocalJumpError().isInstance(exception)) {</span>
<span class="nc" id="L841">            RubyLocalJumpError jumpError = (RubyLocalJumpError)re.getException();</span>

<span class="nc" id="L843">            IRubyObject reason = jumpError.reason();</span>

<span class="nc" id="L845">            return reason.asJavaString();</span>
        }

<span class="nc" id="L848">        throw re;</span>
    }
    
    public static IRubyObject unwrapLocalJumpErrorValue(RaiseException re) {
<span class="nc" id="L852">        return ((RubyLocalJumpError)re.getException()).exit_value();</span>
    }
    
    public static IRubyObject processBlockArgument(Ruby runtime, Block block) {
<span class="nc bnc" id="L856" title="All 2 branches missed.">        if (!block.isGiven()) {</span>
<span class="nc" id="L857">            return runtime.getNil();</span>
        }
        
<span class="nc" id="L860">        return processGivenBlock(block, runtime);</span>
    }

    private static IRubyObject processGivenBlock(Block block, Ruby runtime) {
<span class="nc" id="L864">        RubyProc blockArg = block.getProcObject();</span>

<span class="nc bnc" id="L866" title="All 2 branches missed.">        if (blockArg == null) {</span>
<span class="nc" id="L867">            blockArg = runtime.newBlockPassProc(Block.Type.PROC, block);</span>
<span class="nc" id="L868">            blockArg.getBlock().type = Block.Type.PROC;</span>
        }

<span class="nc" id="L871">        return blockArg;</span>
    }
    
    public static Block getBlockFromBlockPassBody(Ruby runtime, IRubyObject proc, Block currentBlock) {
        // No block from a nil proc
<span class="nc bnc" id="L876" title="All 2 branches missed.">        if (proc.isNil()) return Block.NULL_BLOCK;</span>

        // If not already a proc then we should try and make it one.
<span class="nc bnc" id="L879" title="All 2 branches missed.">        if (!(proc instanceof RubyProc)) {</span>
<span class="nc" id="L880">            proc = coerceProc(proc, runtime);</span>
        }

<span class="nc" id="L883">        return getBlockFromProc(currentBlock, proc);</span>
    }

    private static IRubyObject coerceProc(IRubyObject proc, Ruby runtime) throws RaiseException {
<span class="nc" id="L887">        proc = TypeConverter.convertToType(proc, runtime.getProc(), &quot;to_proc&quot;, false);</span>

<span class="nc bnc" id="L889" title="All 2 branches missed.">        if (!(proc instanceof RubyProc)) {</span>
<span class="nc" id="L890">            throw runtime.newTypeError(&quot;wrong argument type &quot; + proc.getMetaClass().getName() + &quot; (expected Proc)&quot;);</span>
        }
<span class="nc" id="L892">        return proc;</span>
    }

    private static Block getBlockFromProc(Block currentBlock, IRubyObject proc) {
        // TODO: Add safety check for taintedness
<span class="nc bnc" id="L897" title="All 4 branches missed.">        if (currentBlock != null &amp;&amp; currentBlock.isGiven()) {</span>
<span class="nc" id="L898">            RubyProc procObject = currentBlock.getProcObject();</span>
            // The current block is already associated with proc.  No need to create a new one
<span class="nc bnc" id="L900" title="All 4 branches missed.">            if (procObject != null &amp;&amp; procObject == proc) {</span>
<span class="nc" id="L901">                return currentBlock;</span>
            }
        }

<span class="nc" id="L905">        return ((RubyProc) proc).getBlock();       </span>
    }
    
    public static Block getBlockFromBlockPassBody(IRubyObject proc, Block currentBlock) {
<span class="nc" id="L909">        return getBlockFromBlockPassBody(proc.getRuntime(), proc, currentBlock);</span>

    }
    
    public static IRubyObject backref(ThreadContext context) {
<span class="nc" id="L914">        IRubyObject backref = context.getBackRef();</span>
        
<span class="nc bnc" id="L916" title="All 2 branches missed.">        if(backref instanceof RubyMatchData) {</span>
<span class="nc" id="L917">            ((RubyMatchData)backref).use();</span>
        }
<span class="nc" id="L919">        return backref;</span>
    }
    
    public static IRubyObject backrefLastMatch(ThreadContext context) {
<span class="nc" id="L923">        IRubyObject backref = context.getBackRef();</span>
        
<span class="nc" id="L925">        return RubyRegexp.last_match(backref);</span>
    }
    
    public static IRubyObject backrefMatchPre(ThreadContext context) {
<span class="nc" id="L929">        IRubyObject backref = context.getBackRef();</span>
        
<span class="nc" id="L931">        return RubyRegexp.match_pre(backref);</span>
    }
    
    public static IRubyObject backrefMatchPost(ThreadContext context) {
<span class="nc" id="L935">        IRubyObject backref = context.getBackRef();</span>
        
<span class="nc" id="L937">        return RubyRegexp.match_post(backref);</span>
    }
    
    public static IRubyObject backrefMatchLast(ThreadContext context) {
<span class="nc" id="L941">        IRubyObject backref = context.getBackRef();</span>
        
<span class="nc" id="L943">        return RubyRegexp.match_last(backref);</span>
    }

    public static IRubyObject[] getArgValues(ThreadContext context) {
<span class="nc" id="L947">        return context.getCurrentScope().getArgValues();</span>
    }
    
    public static IRubyObject callZSuper(Ruby runtime, ThreadContext context, Block block, IRubyObject self) {
        // Has the method that is calling super received a block argument
<span class="nc bnc" id="L952" title="All 2 branches missed.">        if (!block.isGiven()) block = context.getCurrentFrame().getBlock(); </span>
        
<span class="nc" id="L954">        return Helpers.invokeSuper(context, self, context.getCurrentScope().getArgValues(), block);</span>
    }
    
    public static IRubyObject[] appendToObjectArray(IRubyObject[] array, IRubyObject add) {
<span class="nc" id="L958">        IRubyObject[] newArray = new IRubyObject[array.length + 1];</span>
<span class="nc" id="L959">        System.arraycopy(array, 0, newArray, 0, array.length);</span>
<span class="nc" id="L960">        newArray[array.length] = add;</span>
<span class="nc" id="L961">        return newArray;</span>
    }
    
    public static IRubyObject breakLocalJumpError(Ruby runtime, IRubyObject value) {
<span class="nc" id="L965">        throw runtime.newLocalJumpError(RubyLocalJumpError.Reason.BREAK, value, &quot;unexpected break&quot;);</span>
    }
    
    public static IRubyObject[] concatObjectArrays(IRubyObject[] array, IRubyObject[] add) {
<span class="nc" id="L969">        return toArray(array, add);</span>
    }
    
    public static IRubyObject[] toArray(IRubyObject[] array, IRubyObject... add) {
<span class="nc" id="L973">        IRubyObject[] newArray = new IRubyObject[array.length + add.length];</span>
<span class="nc" id="L974">        System.arraycopy(array, 0, newArray, 0, array.length);</span>
<span class="nc" id="L975">        System.arraycopy(add, 0, newArray, array.length, add.length);</span>
<span class="nc" id="L976">        return newArray;</span>
    }
    
    public static IRubyObject[] toArray(IRubyObject obj, IRubyObject... rest) {
<span class="nc" id="L980">        IRubyObject[] newArray = new IRubyObject[rest.length + 1];</span>
<span class="nc" id="L981">        newArray[0] = obj;</span>
<span class="nc" id="L982">        System.arraycopy(rest, 0, newArray, 1, rest.length);</span>
<span class="nc" id="L983">        return newArray;</span>
    }
    
    public static IRubyObject[] toArray(IRubyObject obj0, IRubyObject obj1, IRubyObject... rest) {
<span class="nc" id="L987">        IRubyObject[] newArray = new IRubyObject[rest.length + 2];</span>
<span class="nc" id="L988">        newArray[0] = obj0;</span>
<span class="nc" id="L989">        newArray[1] = obj1;</span>
<span class="nc" id="L990">        System.arraycopy(rest, 0, newArray, 2, rest.length);</span>
<span class="nc" id="L991">        return newArray;</span>
    }
    
    public static IRubyObject[] toArray(IRubyObject obj0, IRubyObject obj1, IRubyObject obj2, IRubyObject... rest) {
<span class="nc" id="L995">        IRubyObject[] newArray = new IRubyObject[rest.length + 3];</span>
<span class="nc" id="L996">        newArray[0] = obj0;</span>
<span class="nc" id="L997">        newArray[1] = obj1;</span>
<span class="nc" id="L998">        newArray[2] = obj2;</span>
<span class="nc" id="L999">        System.arraycopy(rest, 0, newArray, 3, rest.length);</span>
<span class="nc" id="L1000">        return newArray;</span>
    }

    public static IRubyObject isExceptionHandled(RubyException currentException, IRubyObject[] exceptions, ThreadContext context) {
<span class="nc bnc" id="L1004" title="All 2 branches missed.">        for (int i = 0; i &lt; exceptions.length; i++) {</span>
<span class="nc" id="L1005">            IRubyObject result = isExceptionHandled(currentException, exceptions[i], context);</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">            if (result.isTrue()) return result;</span>
        }
<span class="nc" id="L1008">        return context.runtime.getFalse();</span>
    }

    public static IRubyObject isExceptionHandled(RubyException currentException, IRubyObject exception, ThreadContext context) {
<span class="nc" id="L1012">        return isExceptionHandled((IRubyObject)currentException, exception, context);</span>
    }

    public static IRubyObject isExceptionHandled(IRubyObject currentException, IRubyObject exception, ThreadContext context) {
<span class="nc" id="L1016">        Ruby runtime = context.runtime;</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">        if (!runtime.getModule().isInstance(exception)) {</span>
<span class="nc" id="L1018">            throw runtime.newTypeError(&quot;class or module required for rescue clause&quot;);</span>
        }
<span class="nc" id="L1020">        IRubyObject result = invoke(context, exception, &quot;===&quot;, currentException);</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">        if (result.isTrue()) return result;</span>
<span class="nc" id="L1022">        return runtime.getFalse();</span>
    }
    
    public static IRubyObject isExceptionHandled(RubyException currentException, IRubyObject exception0, IRubyObject exception1, ThreadContext context) {
<span class="nc" id="L1026">        IRubyObject result = isExceptionHandled(currentException, exception0, context);</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">        if (result.isTrue()) return result;</span>
<span class="nc" id="L1028">        return isExceptionHandled(currentException, exception1, context);</span>
    }

    public static IRubyObject isExceptionHandled(RubyException currentException, IRubyObject exception0, IRubyObject exception1, IRubyObject exception2, ThreadContext context) {
<span class="nc" id="L1032">        IRubyObject result = isExceptionHandled(currentException, exception0, context);</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">        if (result.isTrue()) return result;</span>
<span class="nc" id="L1034">        return isExceptionHandled(currentException, exception1, exception2, context);</span>
    }

    public static boolean checkJavaException(Throwable throwable, IRubyObject catchable, ThreadContext context) {
<span class="nc" id="L1038">        Ruby runtime = context.runtime;</span>
<span class="nc" id="L1039">        if (</span>
                // rescue exception needs to catch Java exceptions
<span class="nc bnc" id="L1041" title="All 2 branches missed.">                runtime.getException() == catchable ||</span>

                // rescue Object needs to catch Java exceptions
<span class="nc bnc" id="L1044" title="All 2 branches missed.">                runtime.getObject() == catchable ||</span>

                // rescue StandardError needs to catch Java exceptions
<span class="nc bnc" id="L1047" title="All 2 branches missed.">                runtime.getStandardError() == catchable) {</span>

<span class="nc bnc" id="L1049" title="All 2 branches missed.">            if (throwable instanceof RaiseException) {</span>
<span class="nc" id="L1050">                return isExceptionHandled(((RaiseException)throwable).getException(), catchable, context).isTrue();</span>
            }

            // let Ruby exceptions decide if they handle it
<span class="nc" id="L1054">            return isExceptionHandled(JavaUtil.convertJavaToUsableRubyObject(runtime, throwable), catchable, context).isTrue();</span>

<span class="nc bnc" id="L1056" title="All 2 branches missed.">        } else if (runtime.getNativeException() == catchable) {</span>
            // NativeException catches Java exceptions, lazily creating the wrapper
<span class="nc" id="L1058">            return true;</span>

<span class="nc bnc" id="L1060" title="All 4 branches missed.">        } else if (catchable instanceof RubyClass &amp;&amp; catchable.getInstanceVariables().hasInstanceVariable(&quot;@java_class&quot;)) {</span>
<span class="nc" id="L1061">            RubyClass rubyClass = (RubyClass)catchable;</span>
<span class="nc" id="L1062">            JavaClass javaClass = (JavaClass)rubyClass.getInstanceVariable(&quot;@java_class&quot;);</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">            if (javaClass != null) {</span>
<span class="nc" id="L1064">                Class cls = javaClass.javaClass();</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">                if (cls.isInstance(throwable)) {</span>
<span class="nc" id="L1066">                    return true;</span>
                }
            }

<span class="nc bnc" id="L1070" title="All 2 branches missed.">        } else if (catchable instanceof RubyModule) {</span>
<span class="nc" id="L1071">            IRubyObject exception = JavaUtil.convertJavaToUsableRubyObject(runtime, throwable);</span>
<span class="nc" id="L1072">            IRubyObject result = invoke(context, catchable, &quot;===&quot;, exception);</span>
<span class="nc" id="L1073">            return result.isTrue();</span>

        }

<span class="nc" id="L1077">        return false;</span>
    }
    
    public static IRubyObject isJavaExceptionHandled(Throwable currentThrowable, IRubyObject[] throwables, ThreadContext context) {
<span class="nc bnc" id="L1081" title="All 2 branches missed.">        if (currentThrowable instanceof Unrescuable) {</span>
<span class="nc" id="L1082">            throwException(currentThrowable);</span>
        }

<span class="nc bnc" id="L1085" title="All 2 branches missed.">        if (currentThrowable instanceof RaiseException) {</span>
<span class="nc" id="L1086">            return isExceptionHandled(((RaiseException)currentThrowable).getException(), throwables, context);</span>
        } else {
<span class="nc bnc" id="L1088" title="All 2 branches missed.">            if (throwables.length == 0) {</span>
                // no rescue means StandardError, which rescues Java exceptions
<span class="nc" id="L1090">                return context.runtime.getTrue();</span>
            } else {
<span class="nc bnc" id="L1092" title="All 2 branches missed.">                for (int i = 0; i &lt; throwables.length; i++) {</span>
<span class="nc bnc" id="L1093" title="All 2 branches missed.">                    if (checkJavaException(currentThrowable, throwables[i], context)) {</span>
<span class="nc" id="L1094">                        return context.runtime.getTrue();</span>
                    }
                }
            }

<span class="nc" id="L1099">            return context.runtime.getFalse();</span>
        }
    }

    public static IRubyObject isJavaExceptionHandled(Throwable currentThrowable, IRubyObject throwable, ThreadContext context) {
<span class="nc bnc" id="L1104" title="All 2 branches missed.">        if (currentThrowable instanceof Unrescuable) {</span>
<span class="nc" id="L1105">            throwException(currentThrowable);</span>
        }

<span class="nc bnc" id="L1108" title="All 2 branches missed.">        if (currentThrowable instanceof RaiseException) {</span>
<span class="nc" id="L1109">            return isExceptionHandled(((RaiseException)currentThrowable).getException(), throwable, context);</span>
        } else {
<span class="nc bnc" id="L1111" title="All 2 branches missed.">            if (checkJavaException(currentThrowable, throwable, context)) {</span>
<span class="nc" id="L1112">                return context.runtime.getTrue();</span>
            }

<span class="nc" id="L1115">            return context.runtime.getFalse();</span>
        }
    }

    public static IRubyObject isJavaExceptionHandled(Throwable currentThrowable, IRubyObject throwable0, IRubyObject throwable1, ThreadContext context) {
<span class="nc bnc" id="L1120" title="All 2 branches missed.">        if (currentThrowable instanceof Unrescuable) {</span>
<span class="nc" id="L1121">            throwException(currentThrowable);</span>
        }

<span class="nc bnc" id="L1124" title="All 2 branches missed.">        if (currentThrowable instanceof RaiseException) {</span>
<span class="nc" id="L1125">            return isExceptionHandled(((RaiseException)currentThrowable).getException(), throwable0, throwable1, context);</span>
        } else {
<span class="nc bnc" id="L1127" title="All 2 branches missed.">            if (checkJavaException(currentThrowable, throwable0, context)) {</span>
<span class="nc" id="L1128">                return context.runtime.getTrue();</span>
            }
<span class="nc bnc" id="L1130" title="All 2 branches missed.">            if (checkJavaException(currentThrowable, throwable1, context)) {</span>
<span class="nc" id="L1131">                return context.runtime.getTrue();</span>
            }

<span class="nc" id="L1134">            return context.runtime.getFalse();</span>
        }
    }

    public static IRubyObject isJavaExceptionHandled(Throwable currentThrowable, IRubyObject throwable0, IRubyObject throwable1, IRubyObject throwable2, ThreadContext context) {
<span class="nc bnc" id="L1139" title="All 2 branches missed.">        if (currentThrowable instanceof Unrescuable) {</span>
<span class="nc" id="L1140">            throwException(currentThrowable);</span>
        }
        
<span class="nc bnc" id="L1143" title="All 2 branches missed.">        if (currentThrowable instanceof RaiseException) {</span>
<span class="nc" id="L1144">            return isExceptionHandled(((RaiseException)currentThrowable).getException(), throwable0, throwable1, throwable2, context);</span>
        } else {
<span class="nc bnc" id="L1146" title="All 2 branches missed.">            if (checkJavaException(currentThrowable, throwable0, context)) {</span>
<span class="nc" id="L1147">                return context.runtime.getTrue();</span>
            }
<span class="nc bnc" id="L1149" title="All 2 branches missed.">            if (checkJavaException(currentThrowable, throwable1, context)) {</span>
<span class="nc" id="L1150">                return context.runtime.getTrue();</span>
            }
<span class="nc bnc" id="L1152" title="All 2 branches missed.">            if (checkJavaException(currentThrowable, throwable2, context)) {</span>
<span class="nc" id="L1153">                return context.runtime.getTrue();</span>
            }

<span class="nc" id="L1156">            return context.runtime.getFalse();</span>
        }
    }

    public static void storeExceptionInErrorInfo(Throwable currentThrowable, ThreadContext context) {
<span class="nc" id="L1161">        IRubyObject exception = null;</span>
<span class="nc bnc" id="L1162" title="All 2 branches missed.">        if (currentThrowable instanceof RaiseException) {</span>
<span class="nc" id="L1163">            exception = ((RaiseException)currentThrowable).getException();</span>
        } else {
<span class="nc" id="L1165">            exception = JavaUtil.convertJavaToUsableRubyObject(context.runtime, currentThrowable);</span>
        }
<span class="nc" id="L1167">        context.setErrorInfo(exception);</span>
<span class="nc" id="L1168">    }</span>

    public static void storeNativeExceptionInErrorInfo(Throwable currentThrowable, ThreadContext context) {
<span class="nc" id="L1171">        IRubyObject exception = null;</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">        if (currentThrowable instanceof RaiseException) {</span>
<span class="nc" id="L1173">            exception = ((RaiseException)currentThrowable).getException();</span>
        } else {
<span class="nc" id="L1175">            Ruby runtime = context.runtime;</span>

            // wrap Throwable in a NativeException object
<span class="nc" id="L1178">            exception = new NativeException(runtime, runtime.getNativeException(), currentThrowable);</span>
<span class="nc" id="L1179">            ((NativeException)exception).prepareIntegratedBacktrace(context, currentThrowable.getStackTrace());</span>
        }
<span class="nc" id="L1181">        context.setErrorInfo(exception);</span>
<span class="nc" id="L1182">    }</span>

    public static void clearErrorInfo(ThreadContext context) {
<span class="nc" id="L1185">        context.setErrorInfo(context.runtime.getNil());</span>
<span class="nc" id="L1186">    }</span>
    
    public static void checkSuperDisabledOrOutOfMethod(ThreadContext context) {
<span class="fc" id="L1189">        checkSuperDisabledOrOutOfMethod(context, context.getFrameKlazz(), context.getFrameName());</span>
<span class="fc" id="L1190">    }</span>

    public static void checkSuperDisabledOrOutOfMethod(ThreadContext context, RubyModule klass, String name) {
<span class="pc bpc" id="L1193" title="1 of 2 branches missed.">        if (klass == null) {</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">            if (name != null) {</span>
<span class="nc" id="L1195">                throw context.runtime.newNameError(&quot;superclass method '&quot; + name + &quot;' disabled&quot;, name);</span>
            } else {
<span class="nc" id="L1197">                throw context.runtime.newNoMethodError(&quot;super called outside of method&quot;, null, context.nil);</span>
            }
        }
<span class="fc" id="L1200">    }</span>
    
    public static Block ensureSuperBlock(Block given, Block parent) {
<span class="nc bnc" id="L1203" title="All 2 branches missed.">        if (!given.isGiven()) {</span>
<span class="nc" id="L1204">            return parent;</span>
        }
<span class="nc" id="L1206">        return given;</span>
    }
    
    public static RubyModule findImplementerIfNecessary(RubyModule clazz, RubyModule implementationClass) {
<span class="fc bfc" id="L1210" title="All 2 branches covered.">        if (implementationClass.needsImplementer()) {</span>
            // modules are included with a shim class; we must find that shim to handle super() appropriately
<span class="fc" id="L1212">            return clazz.findImplementer(implementationClass);</span>
        } else {
            // classes are directly in the hierarchy, so no special logic is necessary for implementer
<span class="fc" id="L1215">            return implementationClass;</span>
        }
    }
    
    public static RubyArray createSubarray(RubyArray input, int start) {
<span class="nc" id="L1220">        return (RubyArray)input.subseqLight(start, input.size() - start);</span>
    }

    public static RubyArray createSubarray(RubyArray input, int start, int post) {
<span class="nc" id="L1224">        return (RubyArray)input.subseqLight(start, input.size() - post - start);</span>
    }
    
    public static RubyArray createSubarray(IRubyObject[] input, Ruby runtime, int start) {
<span class="nc bnc" id="L1228" title="All 2 branches missed.">        if (start &gt;= input.length) {</span>
<span class="nc" id="L1229">            return RubyArray.newEmptyArray(runtime);</span>
        } else {
<span class="nc" id="L1231">            return RubyArray.newArrayNoCopy(runtime, input, start);</span>
        }
    }

    public static RubyArray createSubarray(IRubyObject[] input, Ruby runtime, int start, int exclude) {
<span class="nc" id="L1236">        int length = input.length - exclude - start;</span>
<span class="nc bnc" id="L1237" title="All 2 branches missed.">        if (length &lt;= 0) {</span>
<span class="nc" id="L1238">            return RubyArray.newEmptyArray(runtime);</span>
        } else {
<span class="nc" id="L1240">            return RubyArray.newArrayNoCopy(runtime, input, start, length);</span>
        }
    }

    public static IRubyObject elementOrNull(IRubyObject[] input, int element) {
<span class="nc bnc" id="L1245" title="All 2 branches missed.">        if (element &gt;= input.length) {</span>
<span class="nc" id="L1246">            return null;</span>
        } else {
<span class="nc" id="L1248">            return input[element];</span>
        }
    }

    public static IRubyObject optElementOrNull(IRubyObject[] input, int element, int postCount) {
<span class="nc bnc" id="L1253" title="All 2 branches missed.">        if (element + postCount &gt;= input.length) {</span>
<span class="nc" id="L1254">            return null;</span>
        } else {
<span class="nc" id="L1256">            return input[element];</span>
        }
    }

    public static IRubyObject elementOrNil(IRubyObject[] input, int element, IRubyObject nil) {
<span class="nc bnc" id="L1261" title="All 2 branches missed.">        if (element &gt;= input.length) {</span>
<span class="nc" id="L1262">            return nil;</span>
        } else {
<span class="nc" id="L1264">            return input[element];</span>
        }
    }

    public static IRubyObject postElementOrNil(IRubyObject[] input, int postCount, int postIndex, IRubyObject nil) {
<span class="nc" id="L1269">        int aryIndex = input.length - postCount + postIndex;</span>
<span class="nc bnc" id="L1270" title="All 4 branches missed.">        if (aryIndex &gt;= input.length || aryIndex &lt; 0) {</span>
<span class="nc" id="L1271">            return nil;</span>
        } else {
<span class="nc" id="L1273">            return input[aryIndex];</span>
        }
    }
    
    public static RubyBoolean isWhenTriggered(IRubyObject expression, IRubyObject expressionsObject, ThreadContext context) {
<span class="nc" id="L1278">        RubyArray expressions = Helpers.splatValue(expressionsObject);</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">        for (int j = 0,k = expressions.getLength(); j &lt; k; j++) {</span>
<span class="nc" id="L1280">            IRubyObject condition = expressions.eltInternal(j);</span>

<span class="nc bnc" id="L1282" title="All 6 branches missed.">            if ((expression != null &amp;&amp; condition.callMethod(context, &quot;===&quot;, expression).isTrue()) ||</span>
<span class="nc bnc" id="L1283" title="All 2 branches missed.">                    (expression == null &amp;&amp; condition.isTrue())) {</span>
<span class="nc" id="L1284">                return context.runtime.getTrue();</span>
            }
        }

<span class="nc" id="L1288">        return context.runtime.getFalse();</span>
    }
    
    public static IRubyObject setConstantInModule(ThreadContext context, String name, IRubyObject value, IRubyObject module) {
<span class="nc bnc" id="L1292" title="All 2 branches missed.">        if (!(module instanceof RubyModule)) {</span>
<span class="nc" id="L1293">            throw context.runtime.newTypeError(module.toString() + &quot; is not a class/module&quot;);</span>
        }
<span class="nc" id="L1295">        ((RubyModule)module).setConstant(name, value);</span>

<span class="nc" id="L1297">        return value;</span>
    }

    public static IRubyObject setConstantInCurrent(IRubyObject value, ThreadContext context, String name) {
<span class="nc" id="L1301">        return context.getCurrentStaticScope().setConstant(name, value);</span>
    }

    public static IRubyObject retryJump() {
<span class="nc" id="L1305">        throw JumpException.RETRY_JUMP;</span>
    }

    public static IRubyObject redoJump() {
<span class="nc" id="L1309">        throw JumpException.REDO_JUMP;</span>
    }

    public static IRubyObject redoLocalJumpError(Ruby runtime) {
<span class="nc" id="L1313">        throw runtime.newLocalJumpError(RubyLocalJumpError.Reason.REDO, runtime.getNil(), &quot;unexpected redo&quot;);</span>
    }

    public static IRubyObject nextJump(IRubyObject value) {
<span class="nc bnc" id="L1317" title="All 2 branches missed.">        if (value.isNil()) throw JumpException.NEXT_JUMP;</span>

<span class="nc" id="L1319">        throw new JumpException.NextJump(value);</span>
    }
    
    public static IRubyObject nextLocalJumpError(Ruby runtime, IRubyObject value) {
<span class="nc" id="L1323">        throw runtime.newLocalJumpError(RubyLocalJumpError.Reason.NEXT, value, &quot;unexpected next&quot;);</span>
    }
    
    public static final int MAX_SPECIFIC_ARITY_OBJECT_ARRAY = 10;
    
    public static IRubyObject[] anewarrayIRubyObjects(int size) {
<span class="fc" id="L1329">        return new IRubyObject[size];</span>
    }
    
    public static IRubyObject[] aastoreIRubyObjects(IRubyObject[] ary, IRubyObject one, int start) {
<span class="fc" id="L1333">        ary[start] = one;</span>
<span class="fc" id="L1334">        return ary;</span>
    }
    
    public static IRubyObject[] aastoreIRubyObjects(IRubyObject[] ary, IRubyObject one, IRubyObject two, int start) {
<span class="fc" id="L1338">        ary[start] = one;</span>
<span class="fc" id="L1339">        ary[start+1] = two;</span>
<span class="fc" id="L1340">        return ary;</span>
    }
    
    public static IRubyObject[] aastoreIRubyObjects(IRubyObject[] ary, IRubyObject one, IRubyObject two, IRubyObject three, int start) {
<span class="fc" id="L1344">        ary[start] = one;</span>
<span class="fc" id="L1345">        ary[start+1] = two;</span>
<span class="fc" id="L1346">        ary[start+2] = three;</span>
<span class="fc" id="L1347">        return ary;</span>
    }
    
    public static IRubyObject[] aastoreIRubyObjects(IRubyObject[] ary, IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, int start) {
<span class="fc" id="L1351">        ary[start] = one;</span>
<span class="fc" id="L1352">        ary[start+1] = two;</span>
<span class="fc" id="L1353">        ary[start+2] = three;</span>
<span class="fc" id="L1354">        ary[start+3] = four;</span>
<span class="fc" id="L1355">        return ary;</span>
    }
    
    public static IRubyObject[] aastoreIRubyObjects(IRubyObject[] ary, IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, IRubyObject five, int start) {
<span class="fc" id="L1359">        ary[start] = one;</span>
<span class="fc" id="L1360">        ary[start+1] = two;</span>
<span class="fc" id="L1361">        ary[start+2] = three;</span>
<span class="fc" id="L1362">        ary[start+3] = four;</span>
<span class="fc" id="L1363">        ary[start+4] = five;</span>
<span class="fc" id="L1364">        return ary;</span>
    }
    
    public static IRubyObject[] aastoreIRubyObjects(IRubyObject[] ary, IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, IRubyObject five, IRubyObject six, int start) {
<span class="fc" id="L1368">        ary[start] = one;</span>
<span class="fc" id="L1369">        ary[start+1] = two;</span>
<span class="fc" id="L1370">        ary[start+2] = three;</span>
<span class="fc" id="L1371">        ary[start+3] = four;</span>
<span class="fc" id="L1372">        ary[start+4] = five;</span>
<span class="fc" id="L1373">        ary[start+5] = six;</span>
<span class="fc" id="L1374">        return ary;</span>
    }
    
    public static IRubyObject[] aastoreIRubyObjects(IRubyObject[] ary, IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, IRubyObject five, IRubyObject six, IRubyObject seven, int start) {
<span class="nc" id="L1378">        ary[start] = one;</span>
<span class="nc" id="L1379">        ary[start+1] = two;</span>
<span class="nc" id="L1380">        ary[start+2] = three;</span>
<span class="nc" id="L1381">        ary[start+3] = four;</span>
<span class="nc" id="L1382">        ary[start+4] = five;</span>
<span class="nc" id="L1383">        ary[start+5] = six;</span>
<span class="nc" id="L1384">        ary[start+6] = seven;</span>
<span class="nc" id="L1385">        return ary;</span>
    }
    
    public static IRubyObject[] aastoreIRubyObjects(IRubyObject[] ary, IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, IRubyObject five, IRubyObject six, IRubyObject seven, IRubyObject eight, int start) {
<span class="nc" id="L1389">        ary[start] = one;</span>
<span class="nc" id="L1390">        ary[start+1] = two;</span>
<span class="nc" id="L1391">        ary[start+2] = three;</span>
<span class="nc" id="L1392">        ary[start+3] = four;</span>
<span class="nc" id="L1393">        ary[start+4] = five;</span>
<span class="nc" id="L1394">        ary[start+5] = six;</span>
<span class="nc" id="L1395">        ary[start+6] = seven;</span>
<span class="nc" id="L1396">        ary[start+7] = eight;</span>
<span class="nc" id="L1397">        return ary;</span>
    }
    
    public static IRubyObject[] aastoreIRubyObjects(IRubyObject[] ary, IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, IRubyObject five, IRubyObject six, IRubyObject seven, IRubyObject eight, IRubyObject nine, int start) {
<span class="nc" id="L1401">        ary[start] = one;</span>
<span class="nc" id="L1402">        ary[start+1] = two;</span>
<span class="nc" id="L1403">        ary[start+2] = three;</span>
<span class="nc" id="L1404">        ary[start+3] = four;</span>
<span class="nc" id="L1405">        ary[start+4] = five;</span>
<span class="nc" id="L1406">        ary[start+5] = six;</span>
<span class="nc" id="L1407">        ary[start+6] = seven;</span>
<span class="nc" id="L1408">        ary[start+7] = eight;</span>
<span class="nc" id="L1409">        ary[start+8] = nine;</span>
<span class="nc" id="L1410">        return ary;</span>
    }
    
    public static IRubyObject[] aastoreIRubyObjects(IRubyObject[] ary, IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, IRubyObject five, IRubyObject six, IRubyObject seven, IRubyObject eight, IRubyObject nine, IRubyObject ten, int start) {
<span class="nc" id="L1414">        ary[start] = one;</span>
<span class="nc" id="L1415">        ary[start+1] = two;</span>
<span class="nc" id="L1416">        ary[start+2] = three;</span>
<span class="nc" id="L1417">        ary[start+3] = four;</span>
<span class="nc" id="L1418">        ary[start+4] = five;</span>
<span class="nc" id="L1419">        ary[start+5] = six;</span>
<span class="nc" id="L1420">        ary[start+6] = seven;</span>
<span class="nc" id="L1421">        ary[start+7] = eight;</span>
<span class="nc" id="L1422">        ary[start+8] = nine;</span>
<span class="nc" id="L1423">        ary[start+9] = ten;</span>
<span class="nc" id="L1424">        return ary;</span>
    }
    
    public static IRubyObject[] constructObjectArray(IRubyObject one) {
<span class="nc" id="L1428">        return new IRubyObject[] {one};</span>
    }
    
    public static IRubyObject[] constructObjectArray(IRubyObject one, IRubyObject two) {
<span class="nc" id="L1432">        return new IRubyObject[] {one, two};</span>
    }
    
    public static IRubyObject[] constructObjectArray(IRubyObject one, IRubyObject two, IRubyObject three) {
<span class="nc" id="L1436">        return new IRubyObject[] {one, two, three};</span>
    }
    
    public static IRubyObject[] constructObjectArray(IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four) {
<span class="nc" id="L1440">        return new IRubyObject[] {one, two, three, four};</span>
    }
    
    public static IRubyObject[] constructObjectArray(IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, IRubyObject five) {
<span class="nc" id="L1444">        return new IRubyObject[] {one, two, three, four, five};</span>
    }
    
    public static IRubyObject[] constructObjectArray(IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, IRubyObject five, IRubyObject six) {
<span class="nc" id="L1448">        return new IRubyObject[] {one, two, three, four, five, six};</span>
    }
    
    public static IRubyObject[] constructObjectArray(IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, IRubyObject five, IRubyObject six, IRubyObject seven) {
<span class="nc" id="L1452">        return new IRubyObject[] {one, two, three, four, five, six, seven};</span>
    }
    
    public static IRubyObject[] constructObjectArray(IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, IRubyObject five, IRubyObject six, IRubyObject seven, IRubyObject eight) {
<span class="nc" id="L1456">        return new IRubyObject[] {one, two, three, four, five, six, seven, eight};</span>
    }
    
    public static IRubyObject[] constructObjectArray(IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, IRubyObject five, IRubyObject six, IRubyObject seven, IRubyObject eight, IRubyObject nine) {
<span class="nc" id="L1460">        return new IRubyObject[] {one, two, three, four, five, six, seven, eight, nine};</span>
    }
    
    public static IRubyObject[] constructObjectArray(IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, IRubyObject five, IRubyObject six, IRubyObject seven, IRubyObject eight, IRubyObject nine, IRubyObject ten) {
<span class="nc" id="L1464">        return new IRubyObject[] {one, two, three, four, five, six, seven, eight, nine, ten};</span>
    }

    public static RubyArray constructRubyArray(Ruby runtime, IRubyObject one) {
<span class="nc" id="L1468">        return RubyArray.newArrayLight(runtime, one);</span>
    }

    public static RubyArray constructRubyArray(Ruby runtime, IRubyObject one, IRubyObject two) {
<span class="nc" id="L1472">        return RubyArray.newArrayLight(runtime, one, two);</span>
    }

    public static RubyArray constructRubyArray(Ruby runtime, IRubyObject one, IRubyObject two, IRubyObject three) {
<span class="nc" id="L1476">        return RubyArray.newArrayLight(runtime, one, two, three);</span>
    }

    public static RubyArray constructRubyArray(Ruby runtime, IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four) {
<span class="nc" id="L1480">        return RubyArray.newArrayLight(runtime, one, two, three, four);</span>
    }

    public static RubyArray constructRubyArray(Ruby runtime, IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, IRubyObject five) {
<span class="nc" id="L1484">        return RubyArray.newArrayLight(runtime, one, two, three, four, five);</span>
    }

    public static RubyArray constructRubyArray(Ruby runtime, IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, IRubyObject five, IRubyObject six) {
<span class="nc" id="L1488">        return RubyArray.newArrayLight(runtime, one, two, three, four, five, six);</span>
    }

    public static RubyArray constructRubyArray(Ruby runtime, IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, IRubyObject five, IRubyObject six, IRubyObject seven) {
<span class="nc" id="L1492">        return RubyArray.newArrayLight(runtime, one, two, three, four, five, six, seven);</span>
    }

    public static RubyArray constructRubyArray(Ruby runtime, IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, IRubyObject five, IRubyObject six, IRubyObject seven, IRubyObject eight) {
<span class="nc" id="L1496">        return RubyArray.newArrayLight(runtime, one, two, three, four, five, six, seven, eight);</span>
    }

    public static RubyArray constructRubyArray(Ruby runtime, IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, IRubyObject five, IRubyObject six, IRubyObject seven, IRubyObject eight, IRubyObject nine) {
<span class="nc" id="L1500">        return RubyArray.newArrayLight(runtime, one, two, three, four, five, six, seven, eight, nine);</span>
    }

    public static RubyArray constructRubyArray(Ruby runtime, IRubyObject one, IRubyObject two, IRubyObject three, IRubyObject four, IRubyObject five, IRubyObject six, IRubyObject seven, IRubyObject eight, IRubyObject nine, IRubyObject ten) {
<span class="nc" id="L1504">        return RubyArray.newArrayLight(runtime, one, two, three, four, five, six, seven, eight, nine, ten);</span>
    }
    
    public static String[] constructStringArray(String one) {
<span class="nc" id="L1508">        return new String[] {one};</span>
    }
    
    public static String[] constructStringArray(String one, String two) {
<span class="nc" id="L1512">        return new String[] {one, two};</span>
    }
    
    public static String[] constructStringArray(String one, String two, String three) {
<span class="nc" id="L1516">        return new String[] {one, two, three};</span>
    }
    
    public static String[] constructStringArray(String one, String two, String three, String four) {
<span class="nc" id="L1520">        return new String[] {one, two, three, four};</span>
    }
    
    public static String[] constructStringArray(String one, String two, String three, String four, String five) {
<span class="nc" id="L1524">        return new String[] {one, two, three, four, five};</span>
    }
    
    public static String[] constructStringArray(String one, String two, String three, String four, String five, String six) {
<span class="nc" id="L1528">        return new String[] {one, two, three, four, five, six};</span>
    }
    
    public static String[] constructStringArray(String one, String two, String three, String four, String five, String six, String seven) {
<span class="nc" id="L1532">        return new String[] {one, two, three, four, five, six, seven};</span>
    }
    
    public static String[] constructStringArray(String one, String two, String three, String four, String five, String six, String seven, String eight) {
<span class="nc" id="L1536">        return new String[] {one, two, three, four, five, six, seven, eight};</span>
    }
    
    public static String[] constructStringArray(String one, String two, String three, String four, String five, String six, String seven, String eight, String nine) {
<span class="nc" id="L1540">        return new String[] {one, two, three, four, five, six, seven, eight, nine};</span>
    }
    
    public static String[] constructStringArray(String one, String two, String three, String four, String five, String six, String seven, String eight, String nine, String ten) {
<span class="nc" id="L1544">        return new String[] {one, two, three, four, five, six, seven, eight, nine, ten};</span>
    }

    public static final int MAX_SPECIFIC_ARITY_HASH = 5;

    public static RubyHash constructHash(Ruby runtime,
                                         IRubyObject key1, IRubyObject value1, boolean prepareString1) {
<span class="nc" id="L1551">        RubyHash hash = RubyHash.newHash(runtime);</span>
<span class="nc" id="L1552">        hash.fastASet(runtime, key1, value1, prepareString1);</span>
<span class="nc" id="L1553">        return hash;</span>
    }

    public static RubyHash constructHash(Ruby runtime,
                                         IRubyObject key1, IRubyObject value1, boolean prepareString1,
                                         IRubyObject key2, IRubyObject value2, boolean prepareString2) {
<span class="nc" id="L1559">        RubyHash hash = RubyHash.newHash(runtime);</span>
<span class="nc" id="L1560">        hash.fastASet(runtime, key1, value1, prepareString1);</span>
<span class="nc" id="L1561">        hash.fastASet(runtime, key2, value2, prepareString2);</span>
<span class="nc" id="L1562">        return hash;</span>
    }

    public static RubyHash constructHash(Ruby runtime,
                                         IRubyObject key1, IRubyObject value1, boolean prepareString1,
                                         IRubyObject key2, IRubyObject value2, boolean prepareString2,
                                         IRubyObject key3, IRubyObject value3, boolean prepareString3) {
<span class="nc" id="L1569">        RubyHash hash = RubyHash.newHash(runtime);</span>
<span class="nc" id="L1570">        hash.fastASet(runtime, key1, value1, prepareString1);</span>
<span class="nc" id="L1571">        hash.fastASet(runtime, key2, value2, prepareString2);</span>
<span class="nc" id="L1572">        hash.fastASet(runtime, key3, value3, prepareString3);</span>
<span class="nc" id="L1573">        return hash;</span>
    }

    public static RubyHash constructHash(Ruby runtime,
                                         IRubyObject key1, IRubyObject value1, boolean prepareString1,
                                         IRubyObject key2, IRubyObject value2, boolean prepareString2,
                                         IRubyObject key3, IRubyObject value3, boolean prepareString3,
                                         IRubyObject key4, IRubyObject value4, boolean prepareString4) {
<span class="nc" id="L1581">        RubyHash hash = RubyHash.newHash(runtime);</span>
<span class="nc" id="L1582">        hash.fastASet(runtime, key1, value1, prepareString1);</span>
<span class="nc" id="L1583">        hash.fastASet(runtime, key2, value2, prepareString2);</span>
<span class="nc" id="L1584">        hash.fastASet(runtime, key3, value3, prepareString3);</span>
<span class="nc" id="L1585">        hash.fastASet(runtime, key4, value4, prepareString4);</span>
<span class="nc" id="L1586">        return hash;</span>
    }

    public static RubyHash constructHash(Ruby runtime,
                                         IRubyObject key1, IRubyObject value1, boolean prepareString1,
                                         IRubyObject key2, IRubyObject value2, boolean prepareString2,
                                         IRubyObject key3, IRubyObject value3, boolean prepareString3,
                                         IRubyObject key4, IRubyObject value4, boolean prepareString4,
                                         IRubyObject key5, IRubyObject value5, boolean prepareString5) {
<span class="nc" id="L1595">        RubyHash hash = RubyHash.newHash(runtime);</span>
<span class="nc" id="L1596">        hash.fastASet(runtime, key1, value1, prepareString1);</span>
<span class="nc" id="L1597">        hash.fastASet(runtime, key2, value2, prepareString2);</span>
<span class="nc" id="L1598">        hash.fastASet(runtime, key3, value3, prepareString3);</span>
<span class="nc" id="L1599">        hash.fastASet(runtime, key4, value4, prepareString4);</span>
<span class="nc" id="L1600">        hash.fastASet(runtime, key5, value5, prepareString5);</span>
<span class="nc" id="L1601">        return hash;</span>
    }

    public static RubyHash constructSmallHash(Ruby runtime,
                                              IRubyObject key1, IRubyObject value1, boolean prepareString1) {
<span class="nc" id="L1606">        RubyHash hash = RubyHash.newSmallHash(runtime);</span>
<span class="nc" id="L1607">        hash.fastASetSmall(runtime, key1, value1, prepareString1);</span>
<span class="nc" id="L1608">        return hash;</span>
    }

    public static RubyHash constructSmallHash(Ruby runtime,
                                              IRubyObject key1, IRubyObject value1, boolean prepareString1,
                                              IRubyObject key2, IRubyObject value2, boolean prepareString2) {
<span class="nc" id="L1614">        RubyHash hash = RubyHash.newSmallHash(runtime);</span>
<span class="nc" id="L1615">        hash.fastASetSmall(runtime, key1, value1, prepareString1);</span>
<span class="nc" id="L1616">        hash.fastASetSmall(runtime, key2, value2, prepareString2);</span>
<span class="nc" id="L1617">        return hash;</span>
    }

    public static RubyHash constructSmallHash(Ruby runtime,
                                              IRubyObject key1, IRubyObject value1, boolean prepareString1,
                                              IRubyObject key2, IRubyObject value2, boolean prepareString2,
                                              IRubyObject key3, IRubyObject value3, boolean prepareString3) {
<span class="nc" id="L1624">        RubyHash hash = RubyHash.newSmallHash(runtime);</span>
<span class="nc" id="L1625">        hash.fastASetSmall(runtime, key1, value1, prepareString1);</span>
<span class="nc" id="L1626">        hash.fastASetSmall(runtime, key2, value2, prepareString2);</span>
<span class="nc" id="L1627">        hash.fastASetSmall(runtime, key3, value3, prepareString3);</span>
<span class="nc" id="L1628">        return hash;</span>
    }

    public static RubyHash constructSmallHash(Ruby runtime,
                                              IRubyObject key1, IRubyObject value1, boolean prepareString1,
                                              IRubyObject key2, IRubyObject value2, boolean prepareString2,
                                              IRubyObject key3, IRubyObject value3, boolean prepareString3,
                                              IRubyObject key4, IRubyObject value4, boolean prepareString4) {
<span class="nc" id="L1636">        RubyHash hash = RubyHash.newSmallHash(runtime);</span>
<span class="nc" id="L1637">        hash.fastASetSmall(runtime, key1, value1, prepareString1);</span>
<span class="nc" id="L1638">        hash.fastASetSmall(runtime, key2, value2, prepareString2);</span>
<span class="nc" id="L1639">        hash.fastASetSmall(runtime, key3, value3, prepareString3);</span>
<span class="nc" id="L1640">        hash.fastASetSmall(runtime, key4, value4, prepareString4);</span>
<span class="nc" id="L1641">        return hash;</span>
    }

    public static RubyHash constructSmallHash(Ruby runtime,
                                              IRubyObject key1, IRubyObject value1, boolean prepareString1,
                                              IRubyObject key2, IRubyObject value2, boolean prepareString2,
                                              IRubyObject key3, IRubyObject value3, boolean prepareString3,
                                              IRubyObject key4, IRubyObject value4, boolean prepareString4,
                                              IRubyObject key5, IRubyObject value5, boolean prepareString5) {
<span class="nc" id="L1650">        RubyHash hash = RubyHash.newSmallHash(runtime);</span>
<span class="nc" id="L1651">        hash.fastASetSmall(runtime, key1, value1, prepareString1);</span>
<span class="nc" id="L1652">        hash.fastASetSmall(runtime, key2, value2, prepareString2);</span>
<span class="nc" id="L1653">        hash.fastASetSmall(runtime, key3, value3, prepareString3);</span>
<span class="nc" id="L1654">        hash.fastASetSmall(runtime, key4, value4, prepareString4);</span>
<span class="nc" id="L1655">        hash.fastASetSmall(runtime, key5, value5, prepareString5);</span>
<span class="nc" id="L1656">        return hash;</span>
    }

    public static IRubyObject undefMethod(ThreadContext context, Object nameArg) {
<span class="nc" id="L1660">        RubyModule module = null; // context.getRubyClass();</span>
<span class="nc bnc" id="L1661" title="All 2 branches missed.">        String name = (nameArg instanceof String) ?</span>
<span class="nc" id="L1662">            (String) nameArg : nameArg.toString();</span>

<span class="nc bnc" id="L1664" title="All 2 branches missed.">        if (module == null) {</span>
<span class="nc" id="L1665">            throw context.runtime.newTypeError(&quot;No class to undef method '&quot; + name + &quot;'.&quot;);</span>
        }

<span class="nc" id="L1668">        module.undef(context, name);</span>

<span class="nc" id="L1670">        return context.runtime.getNil();</span>
    }
    
    public static IRubyObject defineAlias(ThreadContext context, IRubyObject self, Object newNameArg, Object oldNameArg) {
<span class="nc" id="L1674">        Ruby runtime = context.runtime;</span>
<span class="nc" id="L1675">        RubyModule module = null; // context.getRubyClass();</span>
   
<span class="nc bnc" id="L1677" title="All 6 branches missed.">        if (module == null || self instanceof RubyFixnum || self instanceof RubySymbol){</span>
<span class="nc" id="L1678">            throw runtime.newTypeError(&quot;no class to make alias&quot;);</span>
        }

<span class="nc" id="L1681">        String newName = newNameArg.toString();</span>
<span class="nc" id="L1682">        String oldName = oldNameArg.toString();</span>

<span class="nc" id="L1684">        module.defineAlias(newName, oldName);</span>
<span class="nc" id="L1685">        module.callMethod(context, &quot;method_added&quot;, runtime.newSymbol(newName));</span>
   
<span class="nc" id="L1687">        return runtime.getNil();</span>
    }
    
    public static IRubyObject negate(IRubyObject value, Ruby runtime) {
<span class="nc bnc" id="L1691" title="All 2 branches missed.">        if (value.isTrue()) return runtime.getFalse();</span>
<span class="nc" id="L1692">        return runtime.getTrue();</span>
    }
    
    public static IRubyObject stringOrNil(ByteList value, ThreadContext context) {
<span class="nc bnc" id="L1696" title="All 2 branches missed.">        if (value == null) return context.nil;</span>
<span class="nc" id="L1697">        return RubyString.newStringShared(context.runtime, value);</span>
    }
    
    public static StaticScope preLoad(ThreadContext context, String[] varNames) {
<span class="fc" id="L1701">        StaticScope staticScope = context.runtime.getStaticScopeFactory().newLocalScope(null, varNames);</span>
<span class="fc" id="L1702">        preLoadCommon(context, staticScope, false);</span>

<span class="fc" id="L1704">        return staticScope;</span>
    }

    public static StaticScope preLoad(ThreadContext context, String scopeString, boolean wrap) {
<span class="nc" id="L1708">        StaticScope staticScope = decodeScope(context, null, scopeString);</span>
<span class="nc" id="L1709">        preLoadCommon(context, staticScope, wrap);</span>

<span class="nc" id="L1711">        return staticScope;</span>
    }

    public static void preLoadCommon(ThreadContext context, StaticScope staticScope, boolean wrap) {
<span class="pc bpc" id="L1715" title="1 of 2 branches missed.">        if (wrap) {</span>
<span class="nc" id="L1716">            staticScope.setModule(RubyModule.newModule(context.runtime));</span>
        } else {
<span class="fc" id="L1718">            staticScope.setModule(context.runtime.getObject());</span>
        }
<span class="fc" id="L1720">        DynamicScope scope = DynamicScope.newDynamicScope(staticScope);</span>

        // Each root node has a top-level scope that we need to push
<span class="fc" id="L1723">        context.preScopedBody(scope);</span>
<span class="fc" id="L1724">        context.preNodeEval(context.runtime.getTopSelf());</span>
<span class="fc" id="L1725">    }</span>
    
    public static void postLoad(ThreadContext context) {
<span class="fc" id="L1728">        context.postNodeEval();</span>
<span class="fc" id="L1729">        context.postScopedBody();</span>
<span class="fc" id="L1730">    }</span>
    
    public static void registerEndBlock(Block block, Ruby runtime) {
<span class="nc" id="L1733">        runtime.pushExitBlock(runtime.newProc(Block.Type.LAMBDA, block));</span>
<span class="nc" id="L1734">    }</span>
    
    public static IRubyObject match3(RubyRegexp regexp, IRubyObject value, ThreadContext context) {
<span class="nc bnc" id="L1737" title="All 2 branches missed.">        if (value instanceof RubyString) {</span>
<span class="nc" id="L1738">            return regexp.op_match(context, value);</span>
        } else {
<span class="nc" id="L1740">            return value.callMethod(context, &quot;=~&quot;, regexp);</span>
        }
    }

    public static IRubyObject match3_19(RubyRegexp regexp, IRubyObject value, ThreadContext context) {
<span class="nc bnc" id="L1745" title="All 2 branches missed.">        if (value instanceof RubyString) {</span>
<span class="nc" id="L1746">            return regexp.op_match19(context, value);</span>
        } else {
<span class="nc" id="L1748">            return value.callMethod(context, &quot;=~&quot;, regexp);</span>
        }
    }
    
    public static IRubyObject getErrorInfo(Ruby runtime) {
<span class="fc" id="L1753">        return runtime.getGlobalVariables().get(&quot;$!&quot;);</span>
    }
    
    public static void setErrorInfo(Ruby runtime, IRubyObject error) {
<span class="fc" id="L1757">        runtime.getGlobalVariables().set(&quot;$!&quot;, error);</span>
<span class="fc" id="L1758">    }</span>

    public static IRubyObject setLastLine(Ruby runtime, ThreadContext context, IRubyObject value) {
<span class="fc" id="L1761">        return context.setLastLine(value);</span>
    }

    public static IRubyObject getLastLine(Ruby runtime, ThreadContext context) {
<span class="fc" id="L1765">        return context.getLastLine();</span>
    }

    public static IRubyObject setBackref(Ruby runtime, ThreadContext context, IRubyObject value) {
<span class="fc bfc" id="L1769" title="All 4 branches covered.">        if (!value.isNil() &amp;&amp; !(value instanceof RubyMatchData)) throw runtime.newTypeError(value, runtime.getMatchData());</span>
<span class="fc" id="L1770">        return context.setBackRef(value);</span>
    }

    public static IRubyObject getBackref(Ruby runtime, ThreadContext context) {
<span class="fc" id="L1774">        IRubyObject backref = context.getBackRef();</span>
<span class="fc bfc" id="L1775" title="All 2 branches covered.">        if (backref instanceof RubyMatchData) ((RubyMatchData)backref).use();</span>
<span class="fc" id="L1776">        return backref;</span>
    }
    
    public static IRubyObject preOpAsgnWithOrAnd(IRubyObject receiver, ThreadContext context, IRubyObject self, CallSite varSite) {
<span class="nc" id="L1780">        return varSite.call(context, self, receiver);</span>
    }
    
    public static IRubyObject postOpAsgnWithOrAnd(IRubyObject receiver, IRubyObject value, ThreadContext context, IRubyObject self, CallSite varAsgnSite) {
<span class="nc" id="L1784">        varAsgnSite.call(context, self, receiver, value);</span>
<span class="nc" id="L1785">        return value;</span>
    }
    
    public static IRubyObject opAsgnWithMethod(ThreadContext context, IRubyObject self, IRubyObject receiver, IRubyObject arg, CallSite varSite, CallSite opSite, CallSite opAsgnSite) {
<span class="nc" id="L1789">        IRubyObject var = varSite.call(context, self, receiver);</span>
<span class="nc" id="L1790">        IRubyObject result = opSite.call(context, self, var, arg);</span>
<span class="nc" id="L1791">        opAsgnSite.call(context, self, receiver, result);</span>

<span class="nc" id="L1793">        return result;</span>
    }
    
    public static IRubyObject opElementAsgnWithMethod(ThreadContext context, IRubyObject self, IRubyObject receiver, IRubyObject value, CallSite elementSite, CallSite opSite, CallSite elementAsgnSite) {
<span class="nc" id="L1797">        IRubyObject var = elementSite.call(context, self, receiver);</span>
<span class="nc" id="L1798">        IRubyObject result = opSite.call(context, self, var, value);</span>
<span class="nc" id="L1799">        elementAsgnSite.call(context, self, receiver, result);</span>

<span class="nc" id="L1801">        return result;</span>
    }
    
    public static IRubyObject opElementAsgnWithMethod(ThreadContext context, IRubyObject self, IRubyObject receiver, IRubyObject arg, IRubyObject value, CallSite elementSite, CallSite opSite, CallSite elementAsgnSite) {
<span class="nc" id="L1805">        IRubyObject var = elementSite.call(context, self, receiver, arg);</span>
<span class="nc" id="L1806">        IRubyObject result = opSite.call(context, self, var, value);</span>
<span class="nc" id="L1807">        elementAsgnSite.call(context, self, receiver, arg, result);</span>

<span class="nc" id="L1809">        return result;</span>
    }
    
    public static IRubyObject opElementAsgnWithMethod(ThreadContext context, IRubyObject self, IRubyObject receiver, IRubyObject arg1, IRubyObject arg2, IRubyObject value, CallSite elementSite, CallSite opSite, CallSite elementAsgnSite) {
<span class="nc" id="L1813">        IRubyObject var = elementSite.call(context, self, receiver, arg1, arg2);</span>
<span class="nc" id="L1814">        IRubyObject result = opSite.call(context, self, var, value);</span>
<span class="nc" id="L1815">        elementAsgnSite.call(context, self, receiver, arg1, arg2, result);</span>

<span class="nc" id="L1817">        return result;</span>
    }
    
    public static IRubyObject opElementAsgnWithMethod(ThreadContext context, IRubyObject self, IRubyObject receiver, IRubyObject arg1, IRubyObject arg2, IRubyObject arg3, IRubyObject value, CallSite elementSite, CallSite opSite, CallSite elementAsgnSite) {
<span class="nc" id="L1821">        IRubyObject var = elementSite.call(context, self, receiver, arg1, arg2, arg3);</span>
<span class="nc" id="L1822">        IRubyObject result = opSite.call(context, self, var, value);</span>
<span class="nc" id="L1823">        elementAsgnSite.call(context, self, receiver, new IRubyObject[] {arg1, arg2, arg3, result});</span>

<span class="nc" id="L1825">        return result;</span>
    }
    
    public static IRubyObject opElementAsgnWithMethod(ThreadContext context, IRubyObject self, IRubyObject receiver, IRubyObject[] args, IRubyObject value, CallSite elementSite, CallSite opSite, CallSite elementAsgnSite) {
<span class="nc" id="L1829">        IRubyObject var = elementSite.call(context, self, receiver);</span>
<span class="nc" id="L1830">        IRubyObject result = opSite.call(context, self, var, value);</span>
<span class="nc" id="L1831">        elementAsgnSite.call(context, self, receiver, appendToObjectArray(args, result));</span>

<span class="nc" id="L1833">        return result;</span>
    }

    
    public static IRubyObject opElementAsgnWithOrPartTwoOneArg(ThreadContext context, IRubyObject self, IRubyObject receiver, IRubyObject arg, IRubyObject value, CallSite asetSite) {
<span class="nc" id="L1838">        asetSite.call(context, self, receiver, arg, value);</span>
<span class="nc" id="L1839">        return value;</span>
    }
    
    public static IRubyObject opElementAsgnWithOrPartTwoTwoArgs(ThreadContext context, IRubyObject self, IRubyObject receiver, IRubyObject[] args, IRubyObject value, CallSite asetSite) {
<span class="nc" id="L1843">        asetSite.call(context, self, receiver, args[0], args[1], value);</span>
<span class="nc" id="L1844">        return value;</span>
    }
    
    public static IRubyObject opElementAsgnWithOrPartTwoThreeArgs(ThreadContext context, IRubyObject self, IRubyObject receiver, IRubyObject[] args, IRubyObject value, CallSite asetSite) {
<span class="nc" id="L1848">        asetSite.call(context, self, receiver, new IRubyObject[] {args[0], args[1], args[2], value});</span>
<span class="nc" id="L1849">        return value;</span>
    }
    
    public static IRubyObject opElementAsgnWithOrPartTwoNArgs(ThreadContext context, IRubyObject self, IRubyObject receiver, IRubyObject[] args, IRubyObject value, CallSite asetSite) {
<span class="nc" id="L1853">        IRubyObject[] newArgs = new IRubyObject[args.length + 1];</span>
<span class="nc" id="L1854">        System.arraycopy(args, 0, newArgs, 0, args.length);</span>
<span class="nc" id="L1855">        newArgs[args.length] = value;</span>
<span class="nc" id="L1856">        asetSite.call(context, self, receiver, newArgs);</span>
<span class="nc" id="L1857">        return value;</span>
    }

    public static RubyArray arrayValue(IRubyObject value) {
<span class="fc" id="L1861">        Ruby runtime = value.getRuntime();</span>
<span class="fc" id="L1862">        return arrayValue(runtime.getCurrentContext(), runtime, value);</span>
    }
    
    public static RubyArray arrayValue(ThreadContext context, Ruby runtime, IRubyObject value) {
<span class="fc" id="L1866">        IRubyObject tmp = value.checkArrayType();</span>

<span class="fc bfc" id="L1868" title="All 2 branches covered.">        if (tmp.isNil()) {</span>
            // Object#to_a is obsolete.  We match Ruby's hack until to_a goes away.  Then we can
            // remove this hack too.

<span class="pc bpc" id="L1872" title="1 of 4 branches missed.">            if (value.respondsTo(&quot;to_a&quot;) &amp;&amp; value.getMetaClass().searchMethod(&quot;to_a&quot;).getImplementationClass() != runtime.getKernel()) {</span>
<span class="fc" id="L1873">                IRubyObject avalue = value.callMethod(context, &quot;to_a&quot;);</span>
<span class="fc bfc" id="L1874" title="All 2 branches covered.">                if (!(avalue instanceof RubyArray)) {</span>
<span class="fc bfc" id="L1875" title="All 2 branches covered.">                    if (avalue.isNil()) {</span>
<span class="fc" id="L1876">                        return runtime.newArray(value);</span>
                    } else {
<span class="fc" id="L1878">                        throw runtime.newTypeError(&quot;`to_a' did not return Array&quot;);</span>
                    }
                }
<span class="fc" id="L1881">                return (RubyArray)avalue;</span>
            } else {
<span class="fc" id="L1883">                return runtime.newArray(value);</span>
            }
        }
<span class="fc" id="L1886">        RubyArray arr = (RubyArray) tmp;</span>
        
<span class="fc" id="L1888">        return arr.aryDup();</span>
    }

    public static RubyArray asArray18(ThreadContext context, IRubyObject value) {
<span class="nc" id="L1892">        Ruby runtime = context.runtime;</span>
<span class="nc" id="L1893">        IRubyObject tmp = value.checkArrayType();</span>

<span class="nc bnc" id="L1895" title="All 2 branches missed.">        if (tmp.isNil()) {</span>
            // Object#to_a is obsolete.  We match Ruby's hack until to_a goes away.  Then we can
            // remove this hack too.

<span class="nc bnc" id="L1899" title="All 4 branches missed.">            if (value.respondsTo(&quot;to_a&quot;) &amp;&amp; value.getMetaClass().searchMethod(&quot;to_a&quot;).getImplementationClass() != runtime.getKernel()) {</span>
<span class="nc" id="L1900">                IRubyObject avalue = value.callMethod(context, &quot;to_a&quot;);</span>
<span class="nc bnc" id="L1901" title="All 2 branches missed.">                if (!(avalue instanceof RubyArray)) {</span>
<span class="nc bnc" id="L1902" title="All 2 branches missed.">                    if (avalue.isNil()) {</span>
<span class="nc" id="L1903">                        return runtime.newArray(value);</span>
                    } else {
<span class="nc" id="L1905">                        throw runtime.newTypeError(&quot;`to_a' did not return Array&quot;);</span>
                    }
                }
<span class="nc" id="L1908">                return (RubyArray)avalue;</span>
            } else {
<span class="nc" id="L1910">                return runtime.newArray(value);</span>
            }
        }
        
<span class="nc" id="L1914">        return (RubyArray) tmp;</span>
    }
    
    // mri: rb_Array
    // FIXME: Replace arrayValue/asArray18 with this on 9k (currently dead -- respond_to? logic broken further down the line -- fix that first)
    public static RubyArray asArray(ThreadContext context, IRubyObject value) {
<span class="nc" id="L1920">        return TypeConverter.rb_Array(context, value);</span>
    }
    
    public static IRubyObject aryToAry(IRubyObject value) {
<span class="fc bfc" id="L1924" title="All 2 branches covered.">        if (value instanceof RubyArray) return value;</span>

<span class="fc bfc" id="L1926" title="All 2 branches covered.">        if (value.respondsTo(&quot;to_ary&quot;)) {</span>
<span class="fc" id="L1927">            return TypeConverter.convertToType(value, value.getRuntime().getArray(), &quot;to_ary&quot;, false);</span>
        }

<span class="fc" id="L1930">        return value.getRuntime().newArray(value);</span>
    }

    public static IRubyObject aValueSplat(IRubyObject value) {
<span class="nc bnc" id="L1934" title="All 4 branches missed.">        if (!(value instanceof RubyArray) || ((RubyArray) value).length().getLongValue() == 0) {</span>
<span class="nc" id="L1935">            return value.getRuntime().getNil();</span>
        }

<span class="nc" id="L1938">        RubyArray array = (RubyArray) value;</span>

<span class="nc bnc" id="L1940" title="All 2 branches missed.">        return array.getLength() == 1 ? array.first() : array;</span>
    }

    public static IRubyObject aValueSplat19(IRubyObject value) {
<span class="nc bnc" id="L1944" title="All 2 branches missed.">        if (!(value instanceof RubyArray)) {</span>
<span class="nc" id="L1945">            return value.getRuntime().getNil();</span>
        }

<span class="nc" id="L1948">        return (RubyArray) value;</span>
    }

    public static RubyArray splatValue(IRubyObject value) {
<span class="nc bnc" id="L1952" title="All 2 branches missed.">        if (value.isNil()) {</span>
<span class="nc" id="L1953">            return value.getRuntime().newArray(value);</span>
        }

<span class="nc" id="L1956">        return arrayValue(value);</span>
    }

    public static RubyArray splatValue19(IRubyObject value) {
<span class="fc bfc" id="L1960" title="All 2 branches covered.">        if (value.isNil()) {</span>
<span class="fc" id="L1961">            return value.getRuntime().newEmptyArray();</span>
        }

<span class="fc" id="L1964">        return arrayValue(value);</span>
    }
    
    public static IRubyObject unsplatValue19(IRubyObject argsResult) {
<span class="nc bnc" id="L1968" title="All 2 branches missed.">        if (argsResult instanceof RubyArray) {</span>
<span class="nc" id="L1969">            RubyArray array = (RubyArray) argsResult;</span>
                    
<span class="nc bnc" id="L1971" title="All 2 branches missed.">            if (array.size() == 1) {</span>
<span class="nc" id="L1972">                IRubyObject newResult = array.eltInternal(0);</span>
<span class="nc bnc" id="L1973" title="All 4 branches missed.">                if (!((newResult instanceof RubyArray) &amp;&amp; ((RubyArray) newResult).size() == 0)) {</span>
<span class="nc" id="L1974">                    argsResult = newResult;</span>
                }
            }
        }        
<span class="nc" id="L1978">        return argsResult;</span>
    }

    public static IRubyObject unsplatValue19IfArityOne(IRubyObject argsResult, Block block) {
<span class="nc bnc" id="L1982" title="All 4 branches missed.">        if (block.isGiven() &amp;&amp; block.arity().getValue() &gt; 1) argsResult = Helpers.unsplatValue19(argsResult);</span>
<span class="nc" id="L1983">        return argsResult;</span>
    }
        
    public static IRubyObject[] splatToArguments(IRubyObject value) {
<span class="nc" id="L1987">        Ruby runtime = value.getRuntime();</span>
        
<span class="nc bnc" id="L1989" title="All 2 branches missed.">        if (value.isNil()) {</span>
<span class="nc" id="L1990">            return runtime.getSingleNilArray();</span>
        }
        
<span class="nc" id="L1993">        return splatToArgumentsCommon(runtime, value);</span>
    }
    
    public static IRubyObject[] splatToArguments19(IRubyObject value) {
<span class="nc" id="L1997">        Ruby runtime = value.getRuntime();</span>
        
<span class="nc bnc" id="L1999" title="All 2 branches missed.">        if (value.isNil()) {</span>
<span class="nc" id="L2000">            return IRubyObject.NULL_ARRAY;</span>
        }
        
<span class="nc" id="L2003">        return splatToArgumentsCommon(runtime, value);</span>
    }
    
    private static IRubyObject[] splatToArgumentsCommon(Ruby runtime, IRubyObject value) {
        
<span class="nc bnc" id="L2008" title="All 2 branches missed.">        if (value.isNil()) {</span>
<span class="nc" id="L2009">            return runtime.getSingleNilArray();</span>
        }
        
<span class="nc" id="L2012">        IRubyObject tmp = value.checkArrayType();</span>

<span class="nc bnc" id="L2014" title="All 2 branches missed.">        if (tmp.isNil()) {</span>
<span class="nc" id="L2015">            return convertSplatToJavaArray(runtime, value);</span>
        }
<span class="nc" id="L2017">        return ((RubyArray)tmp).toJavaArrayMaybeUnsafe();</span>
    }
    
    private static IRubyObject[] convertSplatToJavaArray(Ruby runtime, IRubyObject value) {
        // Object#to_a is obsolete.  We match Ruby's hack until to_a goes away.  Then we can
        // remove this hack too.

<span class="nc" id="L2024">        RubyClass metaClass = value.getMetaClass();</span>
<span class="nc" id="L2025">        DynamicMethod method = metaClass.searchMethod(&quot;to_a&quot;);</span>
<span class="nc bnc" id="L2026" title="All 4 branches missed.">        if (method.isUndefined() || method.isImplementedBy(runtime.getKernel())) {</span>
<span class="nc" id="L2027">            return new IRubyObject[] {value};</span>
        }

<span class="nc" id="L2030">        IRubyObject avalue = method.call(runtime.getCurrentContext(), value, metaClass, &quot;to_a&quot;);</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">        if (!(avalue instanceof RubyArray)) {</span>
<span class="nc bnc" id="L2032" title="All 2 branches missed.">            if (avalue.isNil()) {</span>
<span class="nc" id="L2033">                return new IRubyObject[] {value};</span>
            } else {
<span class="nc" id="L2035">                throw runtime.newTypeError(&quot;`to_a' did not return Array&quot;);</span>
            }
        }
<span class="nc" id="L2038">        return ((RubyArray)avalue).toJavaArray();</span>
    }
    
    public static IRubyObject[] argsCatToArguments(IRubyObject[] args, IRubyObject cat) {
<span class="nc" id="L2042">        IRubyObject[] ary = splatToArguments(cat);</span>
<span class="nc" id="L2043">        return argsCatToArgumentsCommon(args, ary);</span>
    }
    
    public static IRubyObject[] argsCatToArguments19(IRubyObject[] args, IRubyObject cat) {
<span class="nc" id="L2047">        IRubyObject[] ary = splatToArguments19(cat);</span>
<span class="nc" id="L2048">        return argsCatToArgumentsCommon(args, ary);</span>
    }
    
    private static IRubyObject[] argsCatToArgumentsCommon(IRubyObject[] args, IRubyObject[] ary) {
<span class="nc bnc" id="L2052" title="All 2 branches missed.">        if (ary.length &gt; 0) {</span>
<span class="nc" id="L2053">            IRubyObject[] newArgs = new IRubyObject[args.length + ary.length];</span>
<span class="nc" id="L2054">            System.arraycopy(args, 0, newArgs, 0, args.length);</span>
<span class="nc" id="L2055">            System.arraycopy(ary, 0, newArgs, args.length, ary.length);</span>
<span class="nc" id="L2056">            args = newArgs;</span>
        }
        
<span class="nc" id="L2059">        return args;</span>
    }

    public static RubySymbol addInstanceMethod(RubyModule containingClass, String name, DynamicMethod method, Visibility visibility, ThreadContext context, Ruby runtime) {
<span class="fc" id="L2063">        containingClass.addMethod(name, method);</span>

<span class="fc" id="L2065">        RubySymbol sym = runtime.fastNewSymbol(name);</span>
<span class="fc bfc" id="L2066" title="All 2 branches covered.">        if (visibility == Visibility.MODULE_FUNCTION) {</span>
<span class="fc" id="L2067">            addModuleMethod(containingClass, name, method, context, sym);</span>
        }

<span class="fc" id="L2070">        callNormalMethodHook(containingClass, context, sym);</span>

<span class="fc" id="L2072">        return sym;</span>
    }

    private static void addModuleMethod(RubyModule containingClass, String name, DynamicMethod method, ThreadContext context, RubySymbol sym) {
<span class="fc" id="L2076">        containingClass.getSingletonClass().addMethod(name, new WrapperMethod(containingClass.getSingletonClass(), method, Visibility.PUBLIC));</span>
<span class="fc" id="L2077">        containingClass.callMethod(context, &quot;singleton_method_added&quot;, sym);</span>
<span class="fc" id="L2078">    }</span>

    private static void callNormalMethodHook(RubyModule containingClass, ThreadContext context, RubySymbol name) {
        // 'class &lt;&lt; state.self' and 'class &lt;&lt; obj' uses defn as opposed to defs
<span class="fc bfc" id="L2082" title="All 2 branches covered.">        if (containingClass.isSingleton()) {</span>
<span class="fc" id="L2083">            callSingletonMethodHook(((MetaClass) containingClass).getAttached(), context, name);</span>
        } else {
<span class="fc" id="L2085">            containingClass.callMethod(context, &quot;method_added&quot;, name);</span>
        }
<span class="fc" id="L2087">    }</span>

    private static void callSingletonMethodHook(IRubyObject receiver, ThreadContext context, RubySymbol name) {
<span class="fc" id="L2090">        receiver.callMethod(context, &quot;singleton_method_added&quot;, name);</span>
<span class="fc" id="L2091">    }</span>

    private static DynamicMethod constructNormalMethod(
            MethodFactory factory,
            String javaName,
            String name,
            RubyModule containingClass,
            ISourcePosition position,
            int arity,
            StaticScope scope,
            Visibility visibility,
            Object scriptObject,
            CallConfiguration callConfig,
            String parameterDesc,
            MethodNodes methodNodes) {
        
        DynamicMethod method;
<span class="nc" id="L2108">        final Ruby runtime = containingClass.getRuntime();</span>

<span class="nc bnc" id="L2110" title="All 12 branches missed.">        if (name.equals(&quot;initialize&quot;) || name.equals(&quot;initialize_copy&quot;) || name.equals(&quot;initialize_clone&quot;) || name.equals(&quot;initialize_dup&quot;) || name.equals(&quot;respond_to_missing?&quot;) || visibility == Visibility.MODULE_FUNCTION) {</span>
<span class="nc" id="L2111">            visibility = Visibility.PRIVATE;</span>
        }
        
<span class="nc bnc" id="L2114" title="All 2 branches missed.">        if (RubyInstanceConfig.LAZYHANDLES_COMPILE) {</span>
<span class="nc" id="L2115">            method = factory.getCompiledMethodLazily(</span>
                    containingClass,
                    name,
                    javaName,
<span class="nc" id="L2119">                    Arity.createArity(arity),</span>
                    visibility,
                    scope,
                    scriptObject,
                    callConfig,
                    position,
                    parameterDesc,
                    methodNodes);
        } else {
<span class="nc" id="L2128">            method = factory.getCompiledMethod(</span>
                    containingClass,
                    name,
                    javaName,
<span class="nc" id="L2132">                    Arity.createArity(arity),</span>
                    visibility,
                    scope,
                    scriptObject,
                    callConfig,
                    position,
                    parameterDesc,
                    methodNodes);
        }

<span class="nc" id="L2142">        return method;</span>
    }

    private static DynamicMethod constructSingletonMethod(
            MethodFactory factory,
            String rubyName,
            String javaName,
            RubyClass rubyClass,
            ISourcePosition position,
            int arity,
            StaticScope scope,
            Object scriptObject,
            CallConfiguration callConfig,
            String parameterDesc,
            MethodNodes methodNodes) {
        
<span class="nc bnc" id="L2158" title="All 2 branches missed.">        if (RubyInstanceConfig.LAZYHANDLES_COMPILE) {</span>
<span class="nc" id="L2159">            return factory.getCompiledMethodLazily(</span>
                    rubyClass,
                    rubyName,
                    javaName,
<span class="nc" id="L2163">                    Arity.createArity(arity),</span>
                    Visibility.PUBLIC,
                    scope,
                    scriptObject,
                    callConfig,
                    position,
                    parameterDesc,
                    methodNodes);
        } else {
<span class="nc" id="L2172">            return factory.getCompiledMethod(</span>
                    rubyClass,
                    rubyName,
                    javaName,
<span class="nc" id="L2176">                    Arity.createArity(arity),</span>
                    Visibility.PUBLIC,
                    scope,
                    scriptObject,
                    callConfig,
                    position,
                    parameterDesc,
                    methodNodes);
        }
    }

    public static String encodeScope(StaticScope scope) {
<span class="nc" id="L2188">        StringBuilder namesBuilder = new StringBuilder(scope.getType().name());</span>

<span class="nc" id="L2190">        namesBuilder.append(',');</span>

<span class="nc" id="L2192">        boolean first = true;</span>
<span class="nc bnc" id="L2193" title="All 2 branches missed.">        for (String name : scope.getVariables()) {</span>
<span class="nc bnc" id="L2194" title="All 2 branches missed.">            if (!first) namesBuilder.append(';');</span>
<span class="nc" id="L2195">            first = false;</span>
<span class="nc" id="L2196">            namesBuilder.append(name);</span>
        }
<span class="nc" id="L2198">        namesBuilder</span>
<span class="nc" id="L2199">                .append(',')</span>
<span class="nc" id="L2200">                .append(scope.getRequiredArgs())</span>
<span class="nc" id="L2201">                .append(',')</span>
<span class="nc" id="L2202">                .append(scope.getOptionalArgs())</span>
<span class="nc" id="L2203">                .append(',')</span>
<span class="nc" id="L2204">                .append(scope.getRestArg())</span>
<span class="nc" id="L2205">                .append(',')</span>
<span class="nc" id="L2206">                .append(scope.getScopeType());</span>

<span class="nc" id="L2208">        return namesBuilder.toString();</span>
    }

    public static StaticScope decodeScope(ThreadContext context, StaticScope parent, String scopeString) {
<span class="nc" id="L2212">        String[][] decodedScope = decodeScopeDescriptor(scopeString);</span>
<span class="nc" id="L2213">        StaticScope scope = null;</span>
<span class="nc bnc" id="L2214" title="All 4 branches missed.">        switch (StaticScope.Type.valueOf(decodedScope[0][0])) {</span>
            case BLOCK:
<span class="nc" id="L2216">                scope = context.runtime.getStaticScopeFactory().newBlockScope(parent, decodedScope[1]);</span>
<span class="nc" id="L2217">                break;</span>
            case EVAL:
<span class="nc" id="L2219">                scope = context.runtime.getStaticScopeFactory().newEvalScope(parent, decodedScope[1]);</span>
<span class="nc" id="L2220">                break;</span>
            case LOCAL:
<span class="nc" id="L2222">                scope = context.runtime.getStaticScopeFactory().newLocalScope(parent, decodedScope[1]);</span>
                break;
        }
<span class="nc" id="L2225">        setAritiesFromDecodedScope(scope, decodedScope[0]);</span>
<span class="nc" id="L2226">        scope.setScopeType(IRScopeType.valueOf(decodedScope[0][5]));</span>
<span class="nc" id="L2227">        return scope;</span>
    }

    private static String[][] decodeScopeDescriptor(String scopeString) {
<span class="nc" id="L2231">        String[] scopeElements = scopeString.split(&quot;,&quot;);</span>
<span class="nc bnc" id="L2232" title="All 2 branches missed.">        String[] scopeNames = scopeElements[1].length() == 0 ? new String[0] : getScopeNames(scopeElements[1]);</span>
<span class="nc" id="L2233">        return new String[][] {scopeElements, scopeNames};</span>
    }

    private static void setAritiesFromDecodedScope(StaticScope scope, String[] scopeElements) {
<span class="nc" id="L2237">        scope.setArities(Integer.parseInt(scopeElements[2]), Integer.parseInt(scopeElements[3]), Integer.parseInt(scopeElements[4]));</span>
<span class="nc" id="L2238">    }</span>

    public static StaticScope decodeScopeAndDetermineModule(ThreadContext context, StaticScope parent, String scopeString) {
<span class="nc" id="L2241">        StaticScope scope = decodeScope(context, parent, scopeString);</span>
<span class="nc" id="L2242">        scope.determineModule();</span>

<span class="nc" id="L2244">        return scope;</span>
    }

    public static Visibility performNormalMethodChecksAndDetermineVisibility(Ruby runtime, RubyModule clazz, String name, Visibility visibility) throws RaiseException {
<span class="pc bpc" id="L2248" title="1 of 2 branches missed.">        if (clazz == runtime.getDummy()) {</span>
<span class="nc" id="L2249">            throw runtime.newTypeError(&quot;no class/module to add method&quot;);</span>
        }

<span class="pc bpc" id="L2252" title="1 of 4 branches missed.">        if (clazz == runtime.getObject() &amp;&amp; &quot;initialize&quot;.equals(name)) {</span>
<span class="nc" id="L2253">            runtime.getWarnings().warn(ID.REDEFINING_DANGEROUS, &quot;redefining Object#initialize may cause infinite loop&quot;);</span>
        }

<span class="pc bpc" id="L2256" title="1 of 4 branches missed.">        if (&quot;__id__&quot;.equals(name) || &quot;__send__&quot;.equals(name)) {</span>
<span class="fc" id="L2257">            runtime.getWarnings().warn(ID.REDEFINING_DANGEROUS, &quot;redefining `&quot; + name + &quot;' may cause serious problem&quot;);</span>
        }

<span class="fc bfc" id="L2260" title="All 12 branches covered.">        if (&quot;initialize&quot;.equals(name) || &quot;initialize_copy&quot;.equals(name) || name.equals(&quot;initialize_dup&quot;) || name.equals(&quot;initialize_clone&quot;) || name.equals(&quot;respond_to_missing?&quot;) || visibility == Visibility.MODULE_FUNCTION) {</span>
<span class="fc" id="L2261">            visibility = Visibility.PRIVATE;</span>
        }

<span class="fc" id="L2264">        return visibility;</span>
    }

    public static RubyClass performSingletonMethodChecks(Ruby runtime, IRubyObject receiver, String name) throws RaiseException {
<span class="nc bnc" id="L2268" title="All 4 branches missed.">        if (receiver instanceof RubyFixnum || receiver instanceof RubySymbol) {</span>
<span class="nc" id="L2269">            throw runtime.newTypeError(&quot;can't define singleton method \&quot;&quot; + name + &quot;\&quot; for &quot; + receiver.getMetaClass().getBaseName());</span>
        }

<span class="nc bnc" id="L2272" title="All 2 branches missed.">        if (receiver.isFrozen()) {</span>
<span class="nc" id="L2273">            throw runtime.newFrozenError(&quot;object&quot;);</span>
        }
        
<span class="nc" id="L2276">        RubyClass rubyClass = receiver.getSingletonClass();</span>
        
<span class="nc" id="L2278">        return rubyClass;</span>
    }
    
    public static IRubyObject arrayEntryOrNil(RubyArray array, int index) {
<span class="nc bnc" id="L2282" title="All 2 branches missed.">        if (index &lt; array.getLength()) {</span>
<span class="nc" id="L2283">            return array.eltInternal(index);</span>
        } else {
<span class="nc" id="L2285">            return array.getRuntime().getNil();</span>
        }
    }

    public static IRubyObject arrayEntryOrNilZero(RubyArray array) {
<span class="nc bnc" id="L2290" title="All 2 branches missed.">        if (0 &lt; array.getLength()) {</span>
<span class="nc" id="L2291">            return array.eltInternal(0);</span>
        } else {
<span class="nc" id="L2293">            return array.getRuntime().getNil();</span>
        }
    }

    public static IRubyObject arrayEntryOrNilOne(RubyArray array) {
<span class="nc bnc" id="L2298" title="All 2 branches missed.">        if (1 &lt; array.getLength()) {</span>
<span class="nc" id="L2299">            return array.eltInternal(1);</span>
        } else {
<span class="nc" id="L2301">            return array.getRuntime().getNil();</span>
        }
    }

    public static IRubyObject arrayEntryOrNilTwo(RubyArray array) {
<span class="nc bnc" id="L2306" title="All 2 branches missed.">        if (2 &lt; array.getLength()) {</span>
<span class="nc" id="L2307">            return array.eltInternal(2);</span>
        } else {
<span class="nc" id="L2309">            return array.getRuntime().getNil();</span>
        }
    }

    public static IRubyObject arrayPostOrNil(RubyArray array, int pre, int post, int index) {
<span class="nc bnc" id="L2314" title="All 2 branches missed.">        if (pre + post &lt; array.getLength()) {</span>
<span class="nc" id="L2315">            return array.eltInternal(array.getLength() - post + index);</span>
<span class="nc bnc" id="L2316" title="All 2 branches missed.">        } else if (pre + index &lt; array.getLength()) {</span>
<span class="nc" id="L2317">            return array.eltInternal(pre + index);</span>
        } else {
<span class="nc" id="L2319">            return array.getRuntime().getNil();</span>
        }
    }

    public static IRubyObject arrayPostOrNilZero(RubyArray array, int pre, int post) {
<span class="nc bnc" id="L2324" title="All 2 branches missed.">        if (pre + post &lt; array.getLength()) {</span>
<span class="nc" id="L2325">            return array.eltInternal(array.getLength() - post + 0);</span>
<span class="nc bnc" id="L2326" title="All 2 branches missed.">        } else if (pre + 0 &lt; array.getLength()) {</span>
<span class="nc" id="L2327">            return array.eltInternal(pre + 0);</span>
        } else {
<span class="nc" id="L2329">            return array.getRuntime().getNil();</span>
        }
    }

    public static IRubyObject arrayPostOrNilOne(RubyArray array, int pre, int post) {
<span class="nc bnc" id="L2334" title="All 2 branches missed.">        if (pre + post &lt; array.getLength()) {</span>
<span class="nc" id="L2335">            return array.eltInternal(array.getLength() - post + 1);</span>
<span class="nc bnc" id="L2336" title="All 2 branches missed.">        } else if (pre + 1 &lt; array.getLength()) {</span>
<span class="nc" id="L2337">            return array.eltInternal(pre + 1);</span>
        } else {
<span class="nc" id="L2339">            return array.getRuntime().getNil();</span>
        }
    }

    public static IRubyObject arrayPostOrNilTwo(RubyArray array, int pre, int post) {
<span class="nc bnc" id="L2344" title="All 2 branches missed.">        if (pre + post &lt; array.getLength()) {</span>
<span class="nc" id="L2345">            return array.eltInternal(array.getLength() - post + 2);</span>
<span class="nc bnc" id="L2346" title="All 2 branches missed.">        } else if (pre + 2 &lt; array.getLength()) {</span>
<span class="nc" id="L2347">            return array.eltInternal(pre + 2);</span>
        } else {
<span class="nc" id="L2349">            return array.getRuntime().getNil();</span>
        }
    }
    
    public static RubyArray subarrayOrEmpty(RubyArray array, Ruby runtime, int index) {
<span class="nc bnc" id="L2354" title="All 2 branches missed.">        if (index &lt; array.getLength()) {</span>
<span class="nc" id="L2355">            return createSubarray(array, index);</span>
        } else {
<span class="nc" id="L2357">            return RubyArray.newEmptyArray(runtime);</span>
        }
    }

    public static RubyArray subarrayOrEmpty(RubyArray array, Ruby runtime, int index, int post) {
<span class="nc bnc" id="L2362" title="All 2 branches missed.">        if (index + post &lt; array.getLength()) {</span>
<span class="nc" id="L2363">            return createSubarray(array, index, post);</span>
        } else {
<span class="nc" id="L2365">            return RubyArray.newEmptyArray(runtime);</span>
        }
    }
    
    public static RubyModule checkIsModule(IRubyObject maybeModule) {
<span class="nc bnc" id="L2370" title="All 2 branches missed.">        if (maybeModule instanceof RubyModule) return (RubyModule)maybeModule;</span>
        
<span class="nc" id="L2372">        throw maybeModule.getRuntime().newTypeError(maybeModule + &quot; is not a class/module&quot;);</span>
    }
    
    public static IRubyObject getGlobalVariable(Ruby runtime, String name) {
<span class="nc" id="L2376">        return runtime.getGlobalVariables().get(name);</span>
    }
    
    public static IRubyObject setGlobalVariable(IRubyObject value, Ruby runtime, String name) {
<span class="nc" id="L2380">        return runtime.getGlobalVariables().set(name, value);</span>
    }

    public static IRubyObject getInstanceVariable(IRubyObject self, Ruby runtime, String internedName) {
<span class="fc" id="L2384">        IRubyObject result = self.getInstanceVariables().getInstanceVariable(internedName);</span>
<span class="pc bpc" id="L2385" title="1 of 2 branches missed.">        if (result != null) return result;</span>
<span class="nc bnc" id="L2386" title="All 2 branches missed.">        if (runtime.isVerbose()) warnAboutUninitializedIvar(runtime, internedName);</span>
<span class="nc" id="L2387">        return runtime.getNil();</span>
    }

    public static IRubyObject getInstanceVariableNoWarn(IRubyObject self, ThreadContext context, String internedName) {
<span class="fc" id="L2391">        IRubyObject result = self.getInstanceVariables().getInstanceVariable(internedName);</span>
<span class="fc bfc" id="L2392" title="All 2 branches covered.">        if (result != null) return result;</span>
<span class="fc" id="L2393">        return context.nil;</span>
    }

    private static void warnAboutUninitializedIvar(Ruby runtime, String internedName) {
<span class="nc" id="L2397">        runtime.getWarnings().warning(ID.IVAR_NOT_INITIALIZED, &quot;instance variable &quot; + internedName + &quot; not initialized&quot;);</span>
<span class="nc" id="L2398">    }</span>

    public static IRubyObject setInstanceVariable(IRubyObject value, IRubyObject self, String name) {
<span class="fc" id="L2401">        return self.getInstanceVariables().setInstanceVariable(name, value);</span>
    }

    public static RubyProc newLiteralLambda(ThreadContext context, Block block, IRubyObject self) {
<span class="nc" id="L2405">        return RubyProc.newProc(context.runtime, block, Block.Type.LAMBDA);</span>
    }

    public static void fillNil(IRubyObject[]arr, int from, int to, Ruby runtime) {
<span class="fc bfc" id="L2409" title="All 2 branches covered.">        if (arr.length == 0) return;</span>
<span class="fc" id="L2410">        IRubyObject nils[] = runtime.getNilPrefilledArray();</span>
        int i;

<span class="fc bfc" id="L2413" title="All 2 branches covered.">        for (i = from; i + Ruby.NIL_PREFILLED_ARRAY_SIZE &lt; to; i += Ruby.NIL_PREFILLED_ARRAY_SIZE) {</span>
<span class="fc" id="L2414">            System.arraycopy(nils, 0, arr, i, Ruby.NIL_PREFILLED_ARRAY_SIZE);</span>
        }
<span class="fc" id="L2416">        System.arraycopy(nils, 0, arr, i, to - i);</span>
<span class="fc" id="L2417">    }</span>

    public static void fillNil(IRubyObject[]arr, Ruby runtime) {
<span class="fc bfc" id="L2420" title="All 2 branches covered.">        if (arr.length == 0) return;</span>
<span class="fc" id="L2421">        fillNil(arr, 0, arr.length, runtime);</span>
<span class="fc" id="L2422">    }</span>

    public static boolean isFastSwitchableString(IRubyObject str) {
<span class="nc" id="L2425">        return str instanceof RubyString;</span>
    }

    public static boolean isFastSwitchableSingleCharString(IRubyObject str) {
<span class="nc bnc" id="L2429" title="All 4 branches missed.">        return str instanceof RubyString &amp;&amp; ((RubyString)str).getByteList().length() == 1;</span>
    }

    public static int getFastSwitchString(IRubyObject str) {
<span class="nc" id="L2433">        ByteList byteList = ((RubyString)str).getByteList();</span>
<span class="nc" id="L2434">        return byteList.hashCode();</span>
    }

    public static int getFastSwitchSingleCharString(IRubyObject str) {
<span class="nc" id="L2438">        ByteList byteList = ((RubyString)str).getByteList();</span>
<span class="nc" id="L2439">        return byteList.get(0);</span>
    }

    public static boolean isFastSwitchableSymbol(IRubyObject sym) {
<span class="nc" id="L2443">        return sym instanceof RubySymbol;</span>
    }

    public static boolean isFastSwitchableSingleCharSymbol(IRubyObject sym) {
<span class="nc bnc" id="L2447" title="All 4 branches missed.">        return sym instanceof RubySymbol &amp;&amp; ((RubySymbol)sym).asJavaString().length() == 1;</span>
    }

    public static int getFastSwitchSymbol(IRubyObject sym) {
<span class="nc" id="L2451">        String str = ((RubySymbol)sym).asJavaString();</span>
<span class="nc" id="L2452">        return str.hashCode();</span>
    }

    public static int getFastSwitchSingleCharSymbol(IRubyObject sym) {
<span class="nc" id="L2456">        String str = ((RubySymbol)sym).asJavaString();</span>
<span class="nc" id="L2457">        return (int)str.charAt(0);</span>
    }

    public static Block getBlock(ThreadContext context, IRubyObject self, Node node) {
<span class="nc" id="L2461">        throw new RuntimeException(&quot;Should not be called&quot;);</span>
    }

    public static Block getBlock(Ruby runtime, ThreadContext context, IRubyObject self, Node node, Block aBlock) {
<span class="nc" id="L2465">        throw new RuntimeException(&quot;Should not be called&quot;);</span>
    }

    /**
     * Equivalent to rb_equal in MRI
     *
     * @param context
     * @param a
     * @param b
     * @return
     */
    public static RubyBoolean rbEqual(ThreadContext context, IRubyObject a, IRubyObject b) {
<span class="fc" id="L2477">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L2478" title="All 2 branches covered.">        if (a == b) return runtime.getTrue();</span>
<span class="fc" id="L2479">        IRubyObject res = invokedynamic(context, a, OP_EQUAL, b);</span>
<span class="fc" id="L2480">        return runtime.newBoolean(res.isTrue());</span>
    }

    /**
     * Equivalent to rb_eql in MRI
     *
     * @param context
     * @param a
     * @param b
     * @return
     */
    public static RubyBoolean rbEql(ThreadContext context, IRubyObject a, IRubyObject b) {
<span class="fc" id="L2492">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L2493" title="All 2 branches covered.">        if (a == b) return runtime.getTrue();</span>
<span class="fc" id="L2494">        IRubyObject res = invokedynamic(context, a, EQL, b);</span>
<span class="fc" id="L2495">        return runtime.newBoolean(res.isTrue());</span>
    }

    /**
     * Used by the compiler to simplify arg checking in variable-arity paths
     *
     * @param context thread context
     * @param args arguments array
     * @param min minimum required
     * @param max maximum allowed
     */
    public static void checkArgumentCount(ThreadContext context, IRubyObject[] args, int min, int max) {
<span class="nc" id="L2507">        checkArgumentCount(context, args.length, min, max);</span>
<span class="nc" id="L2508">    }</span>

    /**
     * Used by the compiler to simplify arg checking in variable-arity paths
     *
     * @param context thread context
     * @param args arguments array
     * @param req required number
     */
    public static void checkArgumentCount(ThreadContext context, IRubyObject[] args, int req) {
<span class="nc" id="L2518">        checkArgumentCount(context, args.length, req, req);</span>
<span class="nc" id="L2519">    }</span>
    
    public static void checkArgumentCount(ThreadContext context, int length, int min, int max) {
<span class="nc" id="L2522">        int expected = 0;</span>
<span class="nc bnc" id="L2523" title="All 2 branches missed.">        if (length &lt; min) {</span>
<span class="nc" id="L2524">            expected = min;</span>
<span class="nc bnc" id="L2525" title="All 4 branches missed.">        } else if (max &gt; -1 &amp;&amp; length &gt; max) {</span>
<span class="nc" id="L2526">            expected = max;</span>
        } else {
<span class="nc" id="L2528">            return;</span>
        }
<span class="nc" id="L2530">        throw context.runtime.newArgumentError(length, expected);</span>
    }

    public static boolean isModuleAndHasConstant(IRubyObject left, String name) {
<span class="pc bpc" id="L2534" title="1 of 4 branches missed.">        return left instanceof RubyModule &amp;&amp; ((RubyModule) left).getConstantFromNoConstMissing(name, false) != null;</span>
    }

    public static RubyString getDefinedConstantOrBoundMethod(IRubyObject left, String name) {
<span class="fc bfc" id="L2538" title="All 2 branches covered.">        if (isModuleAndHasConstant(left, name)) return left.getRuntime().getDefinedMessage(DefinedMessage.CONSTANT);</span>
<span class="pc bpc" id="L2539" title="1 of 2 branches missed.">        if (left.getMetaClass().isMethodBound(name, true)) left.getRuntime().getDefinedMessage(DefinedMessage.METHOD);</span>
<span class="fc" id="L2540">        return null;</span>
    }

    public static RubyModule getSuperClassForDefined(Ruby runtime, RubyModule klazz) {
<span class="nc" id="L2544">        RubyModule superklazz = klazz.getSuperClass();</span>

<span class="nc bnc" id="L2546" title="All 4 branches missed.">        if (superklazz == null &amp;&amp; klazz.isModule()) superklazz = runtime.getObject();</span>

<span class="nc" id="L2548">        return superklazz;</span>
    }

    public static boolean isGenerationEqual(IRubyObject object, int generation) {
        RubyClass metaClass;
<span class="nc bnc" id="L2553" title="All 2 branches missed.">        if (object instanceof RubyBasicObject) {</span>
<span class="nc" id="L2554">            metaClass = ((RubyBasicObject)object).getMetaClass();</span>
        } else {
<span class="nc" id="L2556">            metaClass = object.getMetaClass();</span>
        }
<span class="nc bnc" id="L2558" title="All 2 branches missed.">        return metaClass.getGeneration() == generation;</span>
    }

    public static String[] getScopeNames(String scopeNames) {
<span class="nc" id="L2562">        StringTokenizer toker = new StringTokenizer(scopeNames, &quot;;&quot;);</span>
<span class="nc" id="L2563">        ArrayList list = new ArrayList(10);</span>
<span class="nc bnc" id="L2564" title="All 2 branches missed.">        while (toker.hasMoreTokens()) {</span>
<span class="nc" id="L2565">            list.add(toker.nextToken().intern());</span>
        }
<span class="nc" id="L2567">        return (String[])list.toArray(new String[list.size()]);</span>
    }

    public static IRubyObject[] arraySlice1N(IRubyObject arrayish) {
<span class="nc" id="L2571">        arrayish = aryToAry(arrayish);</span>
<span class="nc" id="L2572">        RubyArray arrayish2 = ensureMultipleAssignableRubyArray(arrayish, arrayish.getRuntime(), true);</span>
<span class="nc" id="L2573">        return new IRubyObject[] {arrayEntryOrNilZero(arrayish2), subarrayOrEmpty(arrayish2, arrayish2.getRuntime(), 1)};</span>
    }

    public static IRubyObject arraySlice1(IRubyObject arrayish) {
<span class="nc" id="L2577">        arrayish = aryToAry(arrayish);</span>
<span class="nc" id="L2578">        RubyArray arrayish2 = ensureMultipleAssignableRubyArray(arrayish, arrayish.getRuntime(), true);</span>
<span class="nc" id="L2579">        return arrayEntryOrNilZero(arrayish2);</span>
    }

    public static RubyClass metaclass(IRubyObject object) {
<span class="nc bnc" id="L2583" title="All 2 branches missed.">        return object instanceof RubyBasicObject ?</span>
<span class="nc" id="L2584">            ((RubyBasicObject)object).getMetaClass() :</span>
<span class="nc" id="L2585">            object.getMetaClass();</span>
    }

    public static String rawBytesToString(byte[] bytes) {
        // stuff bytes into chars
<span class="nc" id="L2590">        char[] chars = new char[bytes.length];</span>
<span class="nc bnc" id="L2591" title="All 2 branches missed.">        for (int i = 0; i &lt; bytes.length; i++) chars[i] = (char)bytes[i];</span>
<span class="nc" id="L2592">        return new String(chars);</span>
    }

    public static byte[] stringToRawBytes(String string) {
<span class="nc" id="L2596">        char[] chars = string.toCharArray();</span>
<span class="nc" id="L2597">        byte[] bytes = new byte[chars.length];</span>
<span class="nc bnc" id="L2598" title="All 2 branches missed.">        for (int i = 0; i &lt; chars.length; i++) bytes[i] = (byte)chars[i];</span>
<span class="nc" id="L2599">        return bytes;</span>
    }

    public static String encodeCaptureOffsets(int[] scopeOffsets) {
<span class="nc" id="L2603">        char[] encoded = new char[scopeOffsets.length * 2];</span>
<span class="nc bnc" id="L2604" title="All 2 branches missed.">        for (int i = 0; i &lt; scopeOffsets.length; i++) {</span>
<span class="nc" id="L2605">            int offDepth = scopeOffsets[i];</span>
<span class="nc" id="L2606">            char off = (char)(offDepth &amp; 0xFFFF);</span>
<span class="nc" id="L2607">            char depth = (char)(offDepth &gt;&gt; 16);</span>
<span class="nc" id="L2608">            encoded[2 * i] = off;</span>
<span class="nc" id="L2609">            encoded[2 * i + 1] = depth;</span>
        }
<span class="nc" id="L2611">        return new String(encoded);</span>
    }

    public static int[] decodeCaptureOffsets(String encoded) {
<span class="nc" id="L2615">        char[] chars = encoded.toCharArray();</span>
<span class="nc" id="L2616">        int[] scopeOffsets = new int[chars.length / 2];</span>
<span class="nc bnc" id="L2617" title="All 2 branches missed.">        for (int i = 0; i &lt; scopeOffsets.length; i++) {</span>
<span class="nc" id="L2618">            char off = chars[2 * i];</span>
<span class="nc" id="L2619">            char depth = chars[2 * i + 1];</span>
<span class="nc" id="L2620">            scopeOffsets[i] = (((int)depth) &lt;&lt; 16) | (int)off;</span>
        }
<span class="nc" id="L2622">        return scopeOffsets;</span>
    }

    public static IRubyObject match2AndUpdateScope(IRubyObject receiver, ThreadContext context, IRubyObject value, String scopeOffsets) {
<span class="nc" id="L2626">        IRubyObject match = ((RubyRegexp)receiver).op_match(context, value);</span>
<span class="nc" id="L2627">        updateScopeWithCaptures(context, decodeCaptureOffsets(scopeOffsets), match);</span>
<span class="nc" id="L2628">        return match;</span>
    }

    public static IRubyObject match2AndUpdateScope19(IRubyObject receiver, ThreadContext context, IRubyObject value, String scopeOffsets) {
<span class="nc" id="L2632">        IRubyObject match = ((RubyRegexp)receiver).op_match19(context, value);</span>
<span class="nc" id="L2633">        updateScopeWithCaptures(context, decodeCaptureOffsets(scopeOffsets), match);</span>
<span class="nc" id="L2634">        return match;</span>
    }

    public static void updateScopeWithCaptures(ThreadContext context, int[] scopeOffsets, IRubyObject result) {
<span class="nc" id="L2638">        Ruby runtime = context.runtime;</span>
<span class="nc bnc" id="L2639" title="All 2 branches missed.">        if (result.isNil()) { // match2 directly calls match so we know we can count on result</span>
<span class="nc" id="L2640">            IRubyObject nil = runtime.getNil();</span>

<span class="nc bnc" id="L2642" title="All 2 branches missed.">            for (int i = 0; i &lt; scopeOffsets.length; i++) {</span>
                // SSS FIXME: This is not doing the offset/depth extraction as in the else case
<span class="nc" id="L2644">                context.getCurrentScope().setValue(nil, scopeOffsets[i], 0);</span>
            }
<span class="nc" id="L2646">        } else {</span>
<span class="nc" id="L2647">            RubyMatchData matchData = (RubyMatchData)context.getBackRef();</span>
            // FIXME: Mass assignment is possible since we know they are all locals in the same
            //   scope that are also contiguous
<span class="nc" id="L2650">            IRubyObject[] namedValues = matchData.getNamedBackrefValues(runtime);</span>

<span class="nc bnc" id="L2652" title="All 2 branches missed.">            for (int i = 0; i &lt; scopeOffsets.length; i++) {</span>
<span class="nc" id="L2653">                context.getCurrentScope().setValue(namedValues[i], scopeOffsets[i] &amp; 0xffff, scopeOffsets[i] &gt;&gt; 16);</span>
            }
        }
<span class="nc" id="L2656">    }</span>

    public static RubyArray argsPush(RubyArray first, IRubyObject second) {
<span class="fc" id="L2659">        return ((RubyArray)first.dup()).append(second);</span>
    }

    public static RubyArray argsCat(IRubyObject first, IRubyObject second) {
<span class="fc" id="L2663">        Ruby runtime = first.getRuntime();</span>
        IRubyObject secondArgs;
<span class="fc" id="L2665">        secondArgs = Helpers.splatValue19(second);</span>

<span class="fc" id="L2667">        return ((RubyArray) Helpers.ensureRubyArray(runtime, first).dup()).concat(secondArgs);</span>
    }

    public static String encodeParameterList(ArgsNode argsNode) {
<span class="fc" id="L2671">        StringBuilder builder = new StringBuilder();</span>
        
<span class="fc" id="L2673">        boolean added = false;</span>
<span class="fc bfc" id="L2674" title="All 2 branches covered.">        if (argsNode.getPre() != null) {</span>
<span class="fc bfc" id="L2675" title="All 2 branches covered.">            for (Node preNode : argsNode.getPre().childNodes()) {</span>
<span class="fc bfc" id="L2676" title="All 2 branches covered.">                if (added) builder.append(';');</span>
<span class="fc" id="L2677">                added = true;</span>
<span class="fc bfc" id="L2678" title="All 2 branches covered.">                if (preNode instanceof MultipleAsgn19Node) {</span>
<span class="fc" id="L2679">                    builder.append(&quot;nil&quot;);</span>
                } else {
<span class="fc" id="L2681">                    builder.append(&quot;q&quot;).append(((ArgumentNode)preNode).getName());</span>
                }
<span class="fc" id="L2683">            }</span>
        }

<span class="fc bfc" id="L2686" title="All 2 branches covered.">        if (argsNode.getOptArgs() != null) {</span>
<span class="fc bfc" id="L2687" title="All 2 branches covered.">            for (Node optNode : argsNode.getOptArgs().childNodes()) {</span>
<span class="fc bfc" id="L2688" title="All 2 branches covered.">                if (added) builder.append(';');</span>
<span class="fc" id="L2689">                added = true;</span>
<span class="fc" id="L2690">                builder.append(&quot;o&quot;);</span>
<span class="pc bpc" id="L2691" title="1 of 2 branches missed.">                if (optNode instanceof OptArgNode) {</span>
<span class="fc" id="L2692">                    builder.append(((OptArgNode)optNode).getName());</span>
<span class="nc bnc" id="L2693" title="All 2 branches missed.">                } else if (optNode instanceof LocalAsgnNode) {</span>
<span class="nc" id="L2694">                    builder.append(((LocalAsgnNode)optNode).getName());</span>
<span class="nc bnc" id="L2695" title="All 2 branches missed.">                } else if (optNode instanceof DAsgnNode) {</span>
<span class="nc" id="L2696">                    builder.append(((DAsgnNode)optNode).getName());</span>
                }
<span class="fc" id="L2698">            }</span>
        }

<span class="fc bfc" id="L2701" title="All 2 branches covered.">        if (argsNode.getRestArg() &gt;= 0) {</span>
<span class="fc bfc" id="L2702" title="All 2 branches covered.">            if (added) builder.append(';');</span>
<span class="fc" id="L2703">            added = true;</span>
<span class="fc bfc" id="L2704" title="All 2 branches covered.">            if (argsNode.getRestArgNode() instanceof UnnamedRestArgNode) {</span>
<span class="fc bfc" id="L2705" title="All 2 branches covered.">                if (((UnnamedRestArgNode) argsNode.getRestArgNode()).isStar()) builder.append(&quot;R&quot;);</span>
            } else {
<span class="fc" id="L2707">                builder.append(&quot;r&quot;).append(argsNode.getRestArgNode().getName());</span>
            }
        }

<span class="fc bfc" id="L2711" title="All 2 branches covered.">        if (argsNode.getPost() != null) {</span>
<span class="fc bfc" id="L2712" title="All 2 branches covered.">            for (Node postNode : argsNode.getPost().childNodes()) {</span>
<span class="pc bpc" id="L2713" title="1 of 2 branches missed.">                if (added) builder.append(';');</span>
<span class="fc" id="L2714">                added = true;</span>
<span class="fc bfc" id="L2715" title="All 2 branches covered.">                if (postNode instanceof MultipleAsgn19Node) {</span>
<span class="fc" id="L2716">                    builder.append(&quot;nil&quot;);</span>
                } else {
<span class="fc" id="L2718">                    builder.append(&quot;q&quot;).append(((ArgumentNode)postNode).getName());</span>
                }
<span class="fc" id="L2720">            }</span>
        }

<span class="fc bfc" id="L2723" title="All 2 branches covered.">        if (argsNode.getBlock() != null) {</span>
<span class="fc bfc" id="L2724" title="All 2 branches covered.">            if (added) builder.append(';');</span>
<span class="fc" id="L2725">            added = true;</span>
<span class="fc" id="L2726">            builder.append(&quot;b&quot;).append(argsNode.getBlock().getName());</span>
        }

<span class="fc bfc" id="L2729" title="All 2 branches covered.">        if (!added) {</span>
<span class="fc" id="L2730">          return &quot;NONE&quot;;</span>
        }

<span class="fc" id="L2733">        return builder.toString();</span>
    }

    public static String encodeParameterList(List&lt;String[]&gt; args) {
<span class="nc bnc" id="L2737" title="All 2 branches missed.">        if (args.size() == 0) return &quot;NONE&quot;;</span>

<span class="nc" id="L2739">        StringBuilder builder = new StringBuilder();</span>

<span class="nc" id="L2741">        boolean added = false;</span>
<span class="nc bnc" id="L2742" title="All 2 branches missed.">        for (String[] desc : args) {</span>
<span class="nc bnc" id="L2743" title="All 2 branches missed.">            if (added) builder.append(';');</span>
<span class="nc" id="L2744">            builder.append(desc[0]).append(desc[1]);</span>
<span class="nc" id="L2745">            added = true;</span>
<span class="nc" id="L2746">        }</span>

<span class="nc" id="L2748">        return builder.toString();</span>
    }

    public static RubyArray parameterListToParameters(Ruby runtime, String[] parameterList, boolean isLambda) {
<span class="fc" id="L2752">        RubyArray parms = RubyArray.newEmptyArray(runtime);</span>

<span class="fc bfc" id="L2754" title="All 2 branches covered.">        for (String param : parameterList) {</span>
<span class="fc bfc" id="L2755" title="All 2 branches covered.">            if (param.equals(&quot;NONE&quot;)) break;</span>

<span class="fc" id="L2757">            RubyArray elem = RubyArray.newEmptyArray(runtime);</span>
<span class="fc bfc" id="L2758" title="All 2 branches covered.">            if (param.equals(&quot;nil&quot;)) {</span>
                // marker for masgn args (the parens in &quot;a, b, (c, d)&quot;
<span class="pc bpc" id="L2760" title="1 of 2 branches missed.">                elem.add(RubySymbol.newSymbol(runtime, isLambda ? &quot;req&quot; : &quot;opt&quot;));</span>
<span class="fc" id="L2761">                parms.add(elem);</span>
<span class="fc" id="L2762">                continue;</span>
            }

<span class="pc bpc" id="L2765" title="1 of 2 branches missed.">            if (param.length() == 0) System.out.println(Arrays.toString(parameterList));</span>
<span class="fc bfc" id="L2766" title="All 2 branches covered.">            if (param.charAt(0) == 'q') {</span>
                // required/normal arg
<span class="fc bfc" id="L2768" title="All 2 branches covered.">                elem.add(RubySymbol.newSymbol(runtime, isLambda ? &quot;req&quot; : &quot;opt&quot;));</span>
<span class="fc bfc" id="L2769" title="All 2 branches covered.">            } else if (param.charAt(0) == 'r') {</span>
                // named rest arg
<span class="fc" id="L2771">                elem.add(RubySymbol.newSymbol(runtime, &quot;rest&quot;));</span>
<span class="fc bfc" id="L2772" title="All 2 branches covered.">            } else if (param.charAt(0) == 'R') {</span>
                // unnamed rest arg (star)
<span class="fc" id="L2774">                elem.add(RubySymbol.newSymbol(runtime, &quot;rest&quot;));</span>
<span class="fc" id="L2775">                parms.add(elem);</span>
<span class="fc" id="L2776">                continue;</span>
<span class="fc bfc" id="L2777" title="All 2 branches covered.">            } else if (param.charAt(0) == 'o') {</span>
                // optional arg
<span class="fc" id="L2779">                elem.add(RubySymbol.newSymbol(runtime, &quot;opt&quot;));</span>
<span class="pc bpc" id="L2780" title="1 of 2 branches missed.">                if (param.length() == 1) {</span>
                    // no name; continue
<span class="nc" id="L2782">                    parms.add(elem);</span>
<span class="nc" id="L2783">                    continue;</span>
                }
<span class="pc bpc" id="L2785" title="1 of 2 branches missed.">            } else if (param.charAt(0) == 'b') {</span>
                // block arg
<span class="fc" id="L2787">                elem.add(RubySymbol.newSymbol(runtime, &quot;block&quot;));</span>
            }

<span class="pc bpc" id="L2790" title="1 of 2 branches missed.">            if (param.length() &gt; 1) {</span>
<span class="fc" id="L2791">                elem.add(RubySymbol.newSymbol(runtime, param.substring(1)));</span>
            }

<span class="fc" id="L2794">            parms.add(elem);</span>
        }

<span class="fc" id="L2797">        return parms;</span>
    }

    public static String[] irMethodArgsToParameters(List&lt;String[]&gt; argDesc) {
<span class="nc" id="L2801">        String[] tmp = new String[argDesc.size()];</span>
<span class="nc bnc" id="L2802" title="All 2 branches missed.">        for (int i = 0; i &lt; tmp.length; i++) {</span>
<span class="nc" id="L2803">            String[] arg = argDesc.get(i);</span>
<span class="nc" id="L2804">            String encoded = arg[0].charAt(0) + arg[1];</span>
<span class="nc" id="L2805">            tmp[i] = encoded;</span>
        }

<span class="nc" id="L2808">        return tmp;</span>
    }

    public static RubyString getDefinedCall(ThreadContext context, IRubyObject self, IRubyObject receiver, String name) {
<span class="fc" id="L2812">        RubyClass metaClass = receiver.getMetaClass();</span>
<span class="fc" id="L2813">        DynamicMethod method = metaClass.searchMethod(name);</span>
<span class="fc" id="L2814">        Visibility visibility = method.getVisibility();</span>

<span class="fc bfc" id="L2816" title="All 4 branches covered.">        if (visibility != Visibility.PRIVATE &amp;&amp;</span>
<span class="pc bpc" id="L2817" title="1 of 4 branches missed.">                (visibility != Visibility.PROTECTED || metaClass.getRealClass().isInstance(self)) &amp;&amp; !method.isUndefined()) {</span>
<span class="fc" id="L2818">            return context.runtime.getDefinedMessage(DefinedMessage.METHOD);</span>
        }

<span class="fc" id="L2821">        if (receiver.callMethod(context, &quot;respond_to_missing?&quot;,</span>
<span class="fc bfc" id="L2822" title="All 2 branches covered.">            new IRubyObject[]{context.runtime.newSymbol(name), context.runtime.getFalse()}).isTrue()) {</span>
<span class="fc" id="L2823">            return context.runtime.getDefinedMessage(DefinedMessage.METHOD);</span>
        }
<span class="fc" id="L2825">        return null;</span>
    }

    public static RubyString getDefinedNot(Ruby runtime, RubyString definition) {
<span class="nc bnc" id="L2829" title="All 2 branches missed.">        if (definition != null) {</span>
<span class="nc" id="L2830">            definition = runtime.getDefinedMessage(DefinedMessage.METHOD);</span>
        }

<span class="nc" id="L2833">        return definition;</span>
    }

    public static IRubyObject invokedynamic(ThreadContext context, IRubyObject self, MethodNames method) {
<span class="fc" id="L2837">        RubyClass metaclass = self.getMetaClass();</span>
<span class="fc" id="L2838">        String name = method.realName();</span>
<span class="fc" id="L2839">        return getMethodCached(context, metaclass, method.ordinal(), name).call(context, self, metaclass, name);</span>
    }

    public static IRubyObject invokedynamic(ThreadContext context, IRubyObject self, MethodNames method, IRubyObject arg0) {
<span class="fc" id="L2843">        RubyClass metaclass = self.getMetaClass();</span>
<span class="fc" id="L2844">        String name = method.realName();</span>
<span class="fc" id="L2845">        return getMethodCached(context, metaclass, method.ordinal(), name).call(context, self, metaclass, name, arg0);</span>
    }
    
    private static DynamicMethod getMethodCached(ThreadContext context, RubyClass metaclass, int index, String name) {
<span class="pc bpc" id="L2849" title="1 of 2 branches missed.">        if (metaclass.getClassIndex() == ClassIndex.NO_INDEX) return metaclass.searchMethod(name);</span>
<span class="fc" id="L2850">        return context.runtimeCache.getMethod(context, metaclass, metaclass.getClassIndex().ordinal() * (index + 1), name);</span>
    }
    
    public static IRubyObject lastElement(IRubyObject[] ary) {
<span class="nc" id="L2854">        return ary[ary.length - 1];</span>
    }
    
    public static RubyString appendAsString(RubyString target, IRubyObject other) {
<span class="nc" id="L2858">        return target.append(other.asString());</span>
    }
    
    public static RubyString appendAsString19(RubyString target, IRubyObject other) {
<span class="nc" id="L2862">        return target.append19(other.asString());</span>
    }

    /**
     * We need to splat incoming array to a block when |a, *b| (any required +
     * rest) or |a, b| (&gt;1 required).
     */
    public static boolean needsSplat19(int requiredCount, boolean isRest) {
<span class="fc bfc" id="L2870" title="All 8 branches covered.">        return (isRest &amp;&amp; requiredCount &gt; 0) || (!isRest &amp;&amp; requiredCount &gt; 1);</span>
    }

    // . Array given to rest should pass itself
    // . Array with rest + other args should extract array
    // . Array with multiple values and NO rest should extract args if there are more than one argument
    // Note: In 1.9 alreadyArray is only relevent from our internal Java code in core libs.  We never use it
    // from interpreter or JIT.  FIXME: Change core lib consumers to stop using alreadyArray param.
    public static IRubyObject[] restructureBlockArgs19(IRubyObject value, Arity arity, Block.Type type, boolean needsSplat, boolean alreadyArray) {
<span class="pc bpc" id="L2879" title="1 of 4 branches missed.">        if (!type.checkArity &amp;&amp; arity == Arity.NO_ARGUMENTS) return IRubyObject.NULL_ARRAY;</span>
        
<span class="pc bpc" id="L2881" title="4 of 6 branches missed.">        if (value != null &amp;&amp; !(value instanceof RubyArray) &amp;&amp; needsSplat) value = Helpers.aryToAry(value);</span>

        IRubyObject[] parameters;
<span class="pc bpc" id="L2884" title="1 of 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L2885">            parameters = IRubyObject.NULL_ARRAY;</span>
<span class="pc bpc" id="L2886" title="4 of 6 branches missed.">        } else if (value instanceof RubyArray &amp;&amp; (alreadyArray || needsSplat)) {</span>
<span class="fc" id="L2887">            parameters = ((RubyArray) value).toJavaArray();</span>
        } else {
<span class="nc" id="L2889">            parameters = new IRubyObject[] { value };</span>
        }

<span class="fc" id="L2892">        return parameters;</span>
    }

    public static boolean BEQ(ThreadContext context, IRubyObject value1, IRubyObject value2) {
<span class="nc" id="L2896">        return value1.op_equal(context, value2).isTrue();</span>
    }

    public static boolean BNE(ThreadContext context, IRubyObject value1, IRubyObject value2) {
<span class="pc bpc" id="L2900" title="2 of 6 branches missed.">        boolean eql = value2 == context.nil || value2 == UndefinedValue.UNDEFINED ?</span>
<span class="pc" id="L2901">                value1 == value2 : value1.op_equal(context, value2).isTrue();</span>

<span class="fc bfc" id="L2903" title="All 2 branches covered.">        return !eql;</span>
    }

    public static RubyModule checkIsRubyModule(ThreadContext context, Object object) {
<span class="nc bnc" id="L2907" title="All 2 branches missed.">        if (!(object instanceof RubyModule)) {</span>
<span class="nc" id="L2908">            throw context.runtime.newTypeError(&quot;no outer class/module&quot;);</span>
        }

<span class="nc" id="L2911">        return (RubyModule)object;</span>
    }

    public static RubyClass newClassForIR(ThreadContext context, String name, IRubyObject self, RubyModule classContainer, Object superClass, boolean meta) {
<span class="nc bnc" id="L2915" title="All 2 branches missed.">        if (meta) return classContainer.getMetaClass();</span>

<span class="nc" id="L2917">        RubyClass sc = null;</span>

<span class="nc bnc" id="L2919" title="All 2 branches missed.">        if (superClass == UndefinedValue.UNDEFINED) {</span>
<span class="nc" id="L2920">            sc = null;</span>
<span class="nc bnc" id="L2921" title="All 2 branches missed.">        } else if (superClass != null) {</span>
<span class="nc" id="L2922">            RubyClass.checkInheritable((IRubyObject)superClass);</span>

<span class="nc" id="L2924">            sc = (RubyClass) superClass;</span>
        }


<span class="nc" id="L2928">        return classContainer.defineOrGetClassUnder(name, sc);</span>
    }

    public static RubyString appendByteList(RubyString target, ByteList source) {
<span class="nc" id="L2932">        target.getByteList().append(source);</span>
<span class="nc" id="L2933">        return target;</span>
    }

    public static RubyString appendByteList19(RubyString target, ByteList source, int codeRange) {
<span class="nc" id="L2937">        target.cat19(source, codeRange);</span>
<span class="nc" id="L2938">        return target;</span>
    }

    public static RubyString shortcutAppend18(RubyString string, IRubyObject object) {
<span class="nc bnc" id="L2942" title="All 6 branches missed.">        if (object instanceof RubyFixnum || object instanceof RubyFloat || object instanceof RubySymbol) {</span>
<span class="nc" id="L2943">            return string.append(object);</span>
        } else {
<span class="nc" id="L2945">            return string.append(object.asString());</span>
        }
    }

    public static RubyString shortcutAppend(RubyString string, IRubyObject object) {
<span class="nc bnc" id="L2950" title="All 6 branches missed.">        if (object instanceof RubyFixnum || object instanceof RubyFloat || object instanceof RubySymbol) {</span>
<span class="nc" id="L2951">            return string.append19(object);</span>
        } else {
<span class="nc" id="L2953">            return string.append19(object.asString());</span>
        }
    }

    public static void irCheckArgsArrayArity(ThreadContext context, RubyArray args, int required, int opt, int rest) {
<span class="nc" id="L2958">        int numArgs = args.size();</span>
<span class="nc bnc" id="L2959" title="All 6 branches missed.">        if ((numArgs &lt; required) || ((rest == -1) &amp;&amp; (numArgs &gt; (required + opt)))) {</span>
<span class="nc" id="L2960">            Arity.raiseArgumentError(context.runtime, numArgs, required, required + opt);</span>
        }
<span class="nc" id="L2962">    }</span>

    @Deprecated
    public static IRubyObject invokedynamic(ThreadContext context, IRubyObject self, int index) {
<span class="nc" id="L2966">        return invokedynamic(context, self, MethodNames.values()[index]);</span>
    }

    @Deprecated
    public static IRubyObject invokedynamic(ThreadContext context, IRubyObject self, int index, IRubyObject arg0) {
<span class="nc" id="L2971">        return invokedynamic(context, self, MethodNames.values()[index], arg0);</span>
    }
    
    public static void throwException(final Throwable e) {
<span class="nc" id="L2975">        Helpers.&lt;RuntimeException&gt;throwsUnchecked(e);</span>
<span class="nc" id="L2976">    }</span>
    
    private static &lt;T extends Throwable&gt; void throwsUnchecked(Throwable t) throws T {
<span class="fc" id="L2979">        throw (T)t;</span>
    }
    
    /**
     * Decode the given value to a Java string using the following rules:
     * 
     * * If the string is all US-ASCII characters, it will be decoded as US-ASCII.
     * * If the string is a unicode encoding, it will be decoded as such.
     * * If the string is any other encoding, it will be encoded as raw bytes
     *   using ISO-8859-1.
     * 
     * This allows non-unicode, non-US-ASCII encodings to be represented in the
     * symbol table as their raw versions, but properly decodes unicode-
     * encoded strings.
     * 
     * @param value the value to decode
     * @return the resulting symbol string
     */
    public static String symbolBytesToString(ByteList value) {
<span class="nc" id="L2998">        Encoding encoding = value.getEncoding();</span>
<span class="nc bnc" id="L2999" title="All 4 branches missed.">        if (encoding == USASCIIEncoding.INSTANCE || encoding == ASCIIEncoding.INSTANCE) {</span>
<span class="nc" id="L3000">            return value.toString(); // raw</span>
<span class="nc bnc" id="L3001" title="All 2 branches missed.">        } else if (encoding instanceof UnicodeEncoding) {</span>
<span class="nc" id="L3002">            return new String(value.getUnsafeBytes(), value.getBegin(), value.getRealSize(), value.getEncoding().getCharset());</span>
        } else {
<span class="nc" id="L3004">            return value.toString(); // raw</span>
        }
    }

    /**
     * Decode a given ByteList to a Java string.
     *
     * @param runtime the current runtime
     * @param value the bytelist
     * @return a Java String representation of the ByteList
     */
    public static String decodeByteList(Ruby runtime, ByteList value) {
<span class="fc" id="L3016">        byte[] unsafeBytes = value.getUnsafeBytes();</span>
<span class="fc" id="L3017">        int begin = value.getBegin();</span>
<span class="fc" id="L3018">        int length = value.length();</span>
        
<span class="fc" id="L3020">        Encoding encoding = value.getEncoding();</span>

<span class="fc bfc" id="L3022" title="All 2 branches covered.">        if (encoding == UTF8Encoding.INSTANCE) {</span>
<span class="fc" id="L3023">            return RubyEncoding.decodeUTF8(unsafeBytes, begin, length);</span>
        }

<span class="fc" id="L3026">        Charset charset = runtime.getEncodingService().charsetForEncoding(encoding);</span>

<span class="pc bpc" id="L3028" title="1 of 2 branches missed.">        if (charset == null) {</span>
            try {
<span class="nc" id="L3030">                return new String(unsafeBytes, begin, length, encoding.toString());</span>
<span class="nc" id="L3031">            } catch (UnsupportedEncodingException uee) {</span>
<span class="nc" id="L3032">                return value.toString();</span>
            }
        }

<span class="fc" id="L3036">        return RubyEncoding.decode(unsafeBytes, begin, length, charset);</span>
    }
    
    /**
     * Convert a ByteList into a Java String by using its Encoding's Charset. If
     * the Charset is not available, fall back on other logic.
     * 
     * @param byteList the bytelist to decode
     * @return the decoded string
     */
    public static String byteListToString(ByteList byteList) {
<span class="pc bpc" id="L3047" title="1 of 2 branches missed.">        if (byteList.getEncoding().getCharset() != null) {</span>
<span class="fc" id="L3048">            return new String(byteList.getUnsafeBytes(), byteList.getBegin(), byteList.getRealSize(), byteList.getEncoding().getCharset());</span>
        }
        
<span class="nc" id="L3051">        return byteList.toString();</span>
    }

    public static IRubyObject rewriteStackTraceAndThrow(ThreadContext context, Throwable t) {
<span class="nc" id="L3055">        Ruby runtime = context.runtime;</span>

<span class="nc" id="L3057">        StackTraceElement[] javaTrace = t.getStackTrace();</span>
<span class="nc" id="L3058">        BacktraceData backtraceData = runtime.getInstanceConfig().getTraceType().getIntegratedBacktrace(context, javaTrace);</span>
<span class="nc" id="L3059">        t.setStackTrace(RaiseException.javaTraceFromRubyTrace(backtraceData.getBacktrace(runtime)));</span>
<span class="nc" id="L3060">        throwException(t);</span>

        // not reached
<span class="nc" id="L3063">        return null;</span>
    }

    public static String stringJoin(String delimiter, String[] strings) {
<span class="nc bnc" id="L3067" title="All 2 branches missed.">        if (strings.length == 0) return &quot;&quot;;</span>
<span class="nc" id="L3068">        StringBuilder sb = new StringBuilder(strings[0]);</span>
<span class="nc bnc" id="L3069" title="All 2 branches missed.">        for (int i = 1; i &lt; strings.length; i++) {</span>
<span class="nc" id="L3070">            sb.append(delimiter)</span>
<span class="nc" id="L3071">                    .append(strings[i]);</span>
        }
<span class="nc" id="L3073">        return sb.toString();</span>
    }

    public static &lt;T&gt; T[] arrayOf(T... values) {
<span class="fc" id="L3077">        return values;</span>
    }

    public static &lt;T&gt; T[] arrayOf(Class&lt;T&gt; t, int size, T fill) {
<span class="fc" id="L3081">        T[] ary = (T[])Array.newInstance(t, size);</span>
<span class="fc" id="L3082">        Arrays.fill(ary, fill);</span>
<span class="fc" id="L3083">        return ary;</span>
    }

    public static int memchr(boolean[] ary, int start, int len, boolean find) {
<span class="fc bfc" id="L3087" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc bfc" id="L3088" title="All 2 branches covered.">            if (ary[i + start] == find) return i + start;</span>
        }
<span class="fc" id="L3090">        return -1;</span>
    }

    @Deprecated
    public static StaticScope decodeRootScope(ThreadContext context, String scopeString) {
<span class="nc" id="L3095">        return decodeScope(context, null, scopeString);</span>
    }

    @Deprecated
    public static StaticScope decodeLocalScope(ThreadContext context, String scopeString) {
<span class="nc" id="L3100">        return decodeScope(context, context.getCurrentStaticScope(), scopeString);</span>
    }

    @Deprecated
    public static StaticScope decodeLocalScope(ThreadContext context, StaticScope parent, String scopeString) {
<span class="nc" id="L3105">        return decodeScope(context, parent, scopeString);</span>
    }

    @Deprecated
    public static StaticScope decodeBlockScope(ThreadContext context, String scopeString) {
<span class="nc" id="L3110">        return decodeScope(context, context.getCurrentStaticScope(), scopeString);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>