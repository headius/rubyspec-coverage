<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RubyParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby.parser</a> &gt; <span class="el_source">RubyParser.java</span></div><h1>RubyParser.java</h1><pre class="source lang-java linenums">// created by jay 1.0.2 (c) 2002-2004 ats@cs.rit.edu
// skeleton Java 1.0 (c) 2002 ats@cs.rit.edu

					// line 2 &quot;RubyParser.y&quot;
/***** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Common Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/cpl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2008-2009 Thomas E Enebo &lt;enebo@acm.org&gt;
 * 
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby.parser;

import java.io.IOException;

import org.jruby.ast.ArgsNode;
import org.jruby.ast.ArgumentNode;
import org.jruby.ast.ArrayNode;
import org.jruby.ast.AssignableNode;
import org.jruby.ast.BackRefNode;
import org.jruby.ast.BeginNode;
import org.jruby.ast.BlockAcceptingNode;
import org.jruby.ast.BlockArgNode;
import org.jruby.ast.BlockNode;
import org.jruby.ast.BlockPassNode;
import org.jruby.ast.BreakNode;
import org.jruby.ast.CallNode;
import org.jruby.ast.ClassNode;
import org.jruby.ast.ClassVarNode;
import org.jruby.ast.ClassVarAsgnNode;
import org.jruby.ast.Colon3Node;
import org.jruby.ast.ConstNode;
import org.jruby.ast.ConstDeclNode;
import org.jruby.ast.DStrNode;
import org.jruby.ast.DSymbolNode;
import org.jruby.ast.DXStrNode;
import org.jruby.ast.DefnNode;
import org.jruby.ast.DefsNode;
import org.jruby.ast.DotNode;
import org.jruby.ast.EncodingNode;
import org.jruby.ast.EnsureNode;
import org.jruby.ast.EvStrNode;
import org.jruby.ast.FalseNode;
import org.jruby.ast.FileNode;
import org.jruby.ast.FCallNode;
import org.jruby.ast.FixnumNode;
import org.jruby.ast.FloatNode;
import org.jruby.ast.ForNode;
import org.jruby.ast.GlobalAsgnNode;
import org.jruby.ast.GlobalVarNode;
import org.jruby.ast.HashNode;
import org.jruby.ast.IfNode;
import org.jruby.ast.InstAsgnNode;
import org.jruby.ast.InstVarNode;
import org.jruby.ast.IterNode;
import org.jruby.ast.LambdaNode;
import org.jruby.ast.ListNode;
import org.jruby.ast.LiteralNode;
import org.jruby.ast.ModuleNode;
import org.jruby.ast.MultipleAsgn19Node;
import org.jruby.ast.NextNode;
import org.jruby.ast.NilImplicitNode;
import org.jruby.ast.NilNode;
import org.jruby.ast.Node;
import org.jruby.ast.NonLocalControlFlowNode;
import org.jruby.ast.OpAsgnAndNode;
import org.jruby.ast.OpAsgnNode;
import org.jruby.ast.OpAsgnOrNode;
import org.jruby.ast.OptArgNode;
import org.jruby.ast.PostExeNode;
import org.jruby.ast.PreExe19Node;
import org.jruby.ast.RationalNode;
import org.jruby.ast.RedoNode;
import org.jruby.ast.RegexpNode;
import org.jruby.ast.RequiredKeywordArgumentValueNode;
import org.jruby.ast.RescueBodyNode;
import org.jruby.ast.RescueNode;
import org.jruby.ast.RestArgNode;
import org.jruby.ast.RetryNode;
import org.jruby.ast.ReturnNode;
import org.jruby.ast.SClassNode;
import org.jruby.ast.SelfNode;
import org.jruby.ast.StarNode;
import org.jruby.ast.StrNode;
import org.jruby.ast.SymbolNode;
import org.jruby.ast.TrueNode;
import org.jruby.ast.UnnamedRestArgNode;
import org.jruby.ast.UntilNode;
import org.jruby.ast.VAliasNode;
import org.jruby.ast.WhileNode;
import org.jruby.ast.XStrNode;
import org.jruby.ast.YieldNode;
import org.jruby.ast.ZArrayNode;
import org.jruby.ast.ZSuperNode;
import org.jruby.ast.ZYieldNode;
import org.jruby.ast.types.ILiteralNode;
import org.jruby.common.IRubyWarnings;
import org.jruby.common.IRubyWarnings.ID;
import org.jruby.lexer.yacc.ISourcePosition;
import org.jruby.lexer.yacc.ISourcePositionHolder;
import org.jruby.lexer.yacc.LexerSource;
import org.jruby.lexer.yacc.RubyLexer;
import org.jruby.lexer.yacc.RubyLexer.LexState;
import org.jruby.lexer.yacc.StrTerm;
import org.jruby.lexer.yacc.SyntaxException;
import org.jruby.lexer.yacc.SyntaxException.PID;
import org.jruby.util.ByteList;
import org.jruby.util.KeyValuePair;
import org.jruby.util.cli.Options;

public class RubyParser {
    protected ParserSupport support;
    protected RubyLexer lexer;

    public RubyParser() {
<span class="fc" id="L136">        this(new ParserSupport());</span>
<span class="fc" id="L137">    }</span>

<span class="fc" id="L139">    public RubyParser(ParserSupport support) {</span>
<span class="fc" id="L140">        this.support = support;</span>
<span class="fc" id="L141">        lexer = new RubyLexer();</span>
<span class="fc" id="L142">        lexer.setParserSupport(support);</span>
<span class="fc" id="L143">        support.setLexer(lexer);</span>
<span class="fc" id="L144">    }</span>

    public void setWarnings(IRubyWarnings warnings) {
<span class="fc" id="L147">        support.setWarnings(warnings);</span>
<span class="fc" id="L148">        lexer.setWarnings(warnings);</span>
<span class="fc" id="L149">    }</span>
					// line 151 &quot;-&quot;
  // %token constants
  public static final int kCLASS = 257;
  public static final int kMODULE = 258;
  public static final int kDEF = 259;
  public static final int kUNDEF = 260;
  public static final int kBEGIN = 261;
  public static final int kRESCUE = 262;
  public static final int kENSURE = 263;
  public static final int kEND = 264;
  public static final int kIF = 265;
  public static final int kUNLESS = 266;
  public static final int kTHEN = 267;
  public static final int kELSIF = 268;
  public static final int kELSE = 269;
  public static final int kCASE = 270;
  public static final int kWHEN = 271;
  public static final int kWHILE = 272;
  public static final int kUNTIL = 273;
  public static final int kFOR = 274;
  public static final int kBREAK = 275;
  public static final int kNEXT = 276;
  public static final int kREDO = 277;
  public static final int kRETRY = 278;
  public static final int kIN = 279;
  public static final int kDO = 280;
  public static final int kDO_COND = 281;
  public static final int kDO_BLOCK = 282;
  public static final int kRETURN = 283;
  public static final int kYIELD = 284;
  public static final int kSUPER = 285;
  public static final int kSELF = 286;
  public static final int kNIL = 287;
  public static final int kTRUE = 288;
  public static final int kFALSE = 289;
  public static final int kAND = 290;
  public static final int kOR = 291;
  public static final int kNOT = 292;
  public static final int kIF_MOD = 293;
  public static final int kUNLESS_MOD = 294;
  public static final int kWHILE_MOD = 295;
  public static final int kUNTIL_MOD = 296;
  public static final int kRESCUE_MOD = 297;
  public static final int kALIAS = 298;
  public static final int kDEFINED = 299;
  public static final int klBEGIN = 300;
  public static final int klEND = 301;
  public static final int k__LINE__ = 302;
  public static final int k__FILE__ = 303;
  public static final int k__ENCODING__ = 304;
  public static final int kDO_LAMBDA = 305;
  public static final int tIDENTIFIER = 306;
  public static final int tFID = 307;
  public static final int tGVAR = 308;
  public static final int tIVAR = 309;
  public static final int tCONSTANT = 310;
  public static final int tCVAR = 311;
  public static final int tLABEL = 312;
  public static final int tCHAR = 313;
  public static final int tUPLUS = 314;
  public static final int tUMINUS = 315;
  public static final int tUMINUS_NUM = 316;
  public static final int tPOW = 317;
  public static final int tCMP = 318;
  public static final int tEQ = 319;
  public static final int tEQQ = 320;
  public static final int tNEQ = 321;
  public static final int tGEQ = 322;
  public static final int tLEQ = 323;
  public static final int tANDOP = 324;
  public static final int tOROP = 325;
  public static final int tMATCH = 326;
  public static final int tNMATCH = 327;
  public static final int tDOT = 328;
  public static final int tDOT2 = 329;
  public static final int tDOT3 = 330;
  public static final int tAREF = 331;
  public static final int tASET = 332;
  public static final int tLSHFT = 333;
  public static final int tRSHFT = 334;
  public static final int tCOLON2 = 335;
  public static final int tCOLON3 = 336;
  public static final int tOP_ASGN = 337;
  public static final int tASSOC = 338;
  public static final int tLPAREN = 339;
  public static final int tLPAREN2 = 340;
  public static final int tRPAREN = 341;
  public static final int tLPAREN_ARG = 342;
  public static final int tLBRACK = 343;
  public static final int tRBRACK = 344;
  public static final int tLBRACE = 345;
  public static final int tLBRACE_ARG = 346;
  public static final int tSTAR = 347;
  public static final int tSTAR2 = 348;
  public static final int tAMPER = 349;
  public static final int tAMPER2 = 350;
  public static final int tTILDE = 351;
  public static final int tPERCENT = 352;
  public static final int tDIVIDE = 353;
  public static final int tPLUS = 354;
  public static final int tMINUS = 355;
  public static final int tLT = 356;
  public static final int tGT = 357;
  public static final int tPIPE = 358;
  public static final int tBANG = 359;
  public static final int tCARET = 360;
  public static final int tLCURLY = 361;
  public static final int tRCURLY = 362;
  public static final int tBACK_REF2 = 363;
  public static final int tSYMBEG = 364;
  public static final int tSTRING_BEG = 365;
  public static final int tXSTRING_BEG = 366;
  public static final int tREGEXP_BEG = 367;
  public static final int tWORDS_BEG = 368;
  public static final int tQWORDS_BEG = 369;
  public static final int tSTRING_DBEG = 370;
  public static final int tSTRING_DVAR = 371;
  public static final int tSTRING_END = 372;
  public static final int tLAMBDA = 373;
  public static final int tLAMBEG = 374;
  public static final int tNTH_REF = 375;
  public static final int tBACK_REF = 376;
  public static final int tSTRING_CONTENT = 377;
  public static final int tINTEGER = 378;
  public static final int tIMAGINARY = 379;
  public static final int tFLOAT = 380;
  public static final int tRATIONAL = 381;
  public static final int tREGEXP_END = 382;
  public static final int tSYMBOLS_BEG = 383;
  public static final int tQSYMBOLS_BEG = 384;
  public static final int tDSTAR = 385;
  public static final int tSTRING_DEND = 386;
  public static final int tLOWEST = 387;
  public static final int yyErrorCode = 256;

  /** number of final state.
    */
  protected static final int yyFinal = 1;

  /** parser tables.
      Order is mandated by &lt;i&gt;jay&lt;/i&gt;.
    */
<span class="fc" id="L292">  protected static final short[] yyLhs = {</span>
//yyLhs 632
    -1,   140,     0,   133,   134,   134,   134,   134,   135,   143,
   135,    37,    36,    38,    38,    38,    38,    44,   144,    44,
   145,    39,    39,    39,    39,    39,    39,    39,    39,    39,
    39,    39,    39,    39,    39,    39,    39,    39,    39,    39,
    39,    39,    39,    39,    33,    33,    40,    40,    40,    40,
    40,    40,    45,    34,    34,    59,    59,   147,   110,   139,
    43,    43,    43,    43,    43,    43,    43,    43,    43,    43,
    43,   111,   111,   122,   122,   112,   112,   112,   112,   112,
   112,   112,   112,   112,   112,    71,    71,   100,   100,   101,
   101,    72,    72,    72,    72,    72,    72,    72,    72,    72,
    72,    72,    72,    72,    72,    72,    72,    72,    72,    72,
    77,    77,    77,    77,    77,    77,    77,    77,    77,    77,
    77,    77,    77,    77,    77,    77,    77,    77,    77,     6,
     6,    32,    32,    32,     7,     7,     7,     7,     7,   115,
   115,   116,   116,    61,   148,    61,     8,     8,     8,     8,
     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,
     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,
     8,     8,     8,     8,     8,     8,   131,   131,   131,   131,
   131,   131,   131,   131,   131,   131,   131,   131,   131,   131,
   131,   131,   131,   131,   131,   131,   131,   131,   131,   131,
   131,   131,   131,   131,   131,   131,   131,   131,   131,   131,
   131,   131,   131,   131,   131,   131,   131,   131,    41,    41,
    41,    41,    41,    41,    41,    41,    41,    41,    41,    41,
    41,    41,    41,    41,    41,    41,    41,    41,    41,    41,
    41,    41,    41,    41,    41,    41,    41,    41,    41,    41,
    41,    41,    41,    41,    41,    41,    41,    41,    41,    41,
    41,    41,    73,    76,    76,    76,    76,    53,    57,    57,
   125,   125,   125,   125,   125,    51,    51,    51,    51,    51,
   150,    55,   104,   103,   103,    79,    79,    79,    79,    35,
    35,    70,    70,    70,    42,    42,    42,    42,    42,    42,
    42,    42,    42,    42,    42,    42,   151,    42,   152,    42,
    42,    42,    42,    42,    42,    42,    42,    42,    42,    42,
    42,    42,    42,    42,    42,    42,    42,    42,   154,   156,
    42,   157,   158,    42,    42,    42,   159,   160,    42,   161,
    42,   163,   164,    42,   165,    42,   166,    42,   167,   168,
    42,    42,    42,    42,    42,    46,   153,   153,   153,   155,
   155,    49,    49,    47,    47,   124,   124,   126,   126,    84,
    84,   127,   127,   127,   127,   127,   127,   127,   127,   127,
    91,    91,    91,    91,    90,    90,    67,    67,    67,    67,
    67,    67,    67,    67,    67,    67,    67,    67,    67,    67,
    67,    69,    69,    68,    68,    68,   119,   119,   118,   118,
   128,   128,   169,   121,    66,    66,   120,   120,   170,   109,
    58,    58,    58,    58,    23,    23,    23,    23,    23,    23,
    23,    23,    23,   171,   108,   172,   108,    74,    48,    48,
   113,   113,    75,    75,    75,    50,    50,    52,    52,    28,
    28,    28,    15,    16,    16,    16,    17,    18,    19,    25,
    25,    81,    81,    27,    27,    87,    87,    85,    85,    26,
    26,    88,    88,    80,    80,    86,    86,    20,    20,    21,
    21,    24,    24,    22,   173,    22,   174,    22,    62,    62,
    62,    62,     2,     1,     1,     1,     1,    31,    29,    29,
    30,    30,    30,    30,    56,    56,    56,    56,    56,    56,
    56,    56,    56,    56,    56,    56,   114,   114,   114,   114,
   114,   114,   114,   114,   114,   114,   114,   114,    63,    63,
    54,   175,    54,    54,    65,    65,    92,    92,    92,    92,
    89,    89,    64,    64,    64,    64,    64,    64,    64,    64,
    64,    64,    64,    64,    64,    64,    64,   132,   132,   132,
   132,     9,     9,   117,   117,    82,    82,   138,    93,    93,
    94,    94,    95,    95,    96,    96,   136,   136,   137,   137,
    60,   123,   102,   102,    83,    83,    11,    11,    13,    13,
    12,    12,   107,   106,   106,    14,   176,    14,    97,    97,
    98,    98,    99,    99,    99,     3,     3,     3,     4,     4,
     4,     4,     5,     5,     5,    10,    10,   141,   141,   146,
   146,   129,   130,   149,   149,   149,   162,   162,   142,   142,
    78,   105,
<span class="fc" id="L358">    }, yyLen = {</span>
//yyLen 632
     2,     0,     2,     2,     1,     1,     3,     2,     1,     0,
     5,     4,     2,     1,     1,     3,     2,     1,     0,     5,
     0,     4,     3,     3,     3,     2,     3,     3,     3,     3,
     3,     4,     1,     3,     3,     6,     5,     5,     5,     5,
     3,     3,     3,     1,     3,     3,     1,     3,     3,     3,
     2,     1,     1,     1,     1,     1,     4,     0,     5,     1,
     2,     3,     4,     5,     4,     5,     2,     2,     2,     2,
     2,     1,     3,     1,     3,     1,     2,     3,     5,     2,
     4,     2,     4,     1,     3,     1,     3,     2,     3,     1,
     3,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     4,     3,     3,     3,     3,     2,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     4,     3,     3,     3,     3,     2,     1,     1,
     1,     2,     1,     3,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     0,     4,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     3,     5,
     3,     5,     6,     5,     5,     5,     5,     4,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     4,     2,     2,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     2,     2,     3,     3,     3,     3,     3,
     6,     1,     1,     1,     2,     4,     2,     3,     1,     1,
     1,     1,     2,     4,     2,     1,     2,     2,     4,     1,
     0,     2,     2,     2,     1,     1,     2,     3,     4,     1,
     1,     3,     4,     2,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     3,     0,     3,     0,     4,
     3,     3,     2,     3,     3,     1,     4,     3,     1,     5,
     4,     3,     2,     1,     2,     2,     6,     6,     0,     0,
     7,     0,     0,     7,     5,     4,     0,     0,     9,     0,
     6,     0,     0,     8,     0,     5,     0,     6,     0,     0,
     9,     1,     1,     1,     1,     1,     1,     1,     2,     1,
     1,     1,     5,     1,     2,     1,     1,     1,     3,     1,
     3,     1,     4,     6,     3,     5,     2,     4,     1,     3,
     4,     2,     2,     1,     2,     0,     6,     8,     4,     6,
     4,     2,     6,     2,     4,     6,     2,     4,     2,     4,
     1,     1,     1,     3,     1,     4,     1,     4,     1,     3,
     1,     1,     0,     3,     4,     1,     3,     3,     0,     5,
     2,     4,     5,     5,     2,     4,     4,     3,     3,     3,
     2,     1,     4,     0,     5,     0,     5,     5,     1,     1,
     6,     0,     1,     1,     1,     2,     1,     2,     1,     1,
     1,     1,     1,     1,     1,     2,     3,     3,     3,     3,
     3,     0,     3,     1,     2,     3,     3,     0,     3,     3,
     3,     3,     3,     0,     3,     0,     3,     0,     2,     0,
     2,     0,     2,     1,     0,     3,     0,     4,     1,     1,
     1,     1,     2,     1,     1,     1,     1,     3,     1,     2,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     0,     4,     2,     3,     2,     4,     2,     2,     1,
     2,     0,     6,     8,     4,     6,     4,     6,     2,     4,
     6,     2,     4,     2,     4,     1,     0,     1,     1,     1,
     1,     1,     1,     1,     3,     1,     3,     1,     2,     1,
     2,     1,     1,     3,     1,     3,     1,     1,     2,     1,
     3,     3,     1,     3,     1,     3,     1,     1,     2,     1,
     1,     1,     2,     2,     0,     1,     0,     4,     1,     2,
     1,     3,     3,     2,     2,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     0,     1,     0,
     1,     2,     2,     0,     1,     1,     1,     1,     1,     2,
     0,     0,
<span class="fc" id="L424">    }, yyDefRed = {</span>
//yyDefRed 1081
     1,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,   328,   331,     0,     0,     0,   353,   354,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     9,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
   453,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   477,   479,   481,     0,     0,   412,   528,
   529,   500,   503,   501,   502,     0,     0,   450,    59,   295,
     0,   454,   296,   297,     0,   298,   299,   294,   449,   498,
   451,    32,    46,     0,     0,     0,     0,     0,     0,   302,
     0,    54,     0,     0,    85,     0,     4,   300,   301,     0,
     0,    71,     0,     2,     0,     5,     0,     7,   351,   352,
   315,     0,     0,   510,   509,   511,   512,     0,     0,   514,
   513,   515,     0,   506,   505,     0,   508,     0,     0,     0,
     0,   132,     0,   355,     0,   303,     0,   344,   186,   197,
   187,   210,   183,   203,   193,   192,   208,   191,   190,   185,
   211,   195,   184,   198,   202,   204,   196,   189,   205,   212,
   207,     0,     0,     0,     0,   182,   201,   200,   213,   214,
   215,   216,   217,   181,   188,   179,   180,     0,     0,     0,
     0,   136,     0,   171,   172,   168,   149,   150,   151,   158,
   155,   157,   152,   153,   173,   174,   159,   160,   596,   165,
   164,   148,   170,   167,   166,   162,   163,   156,   154,   146,
   169,   147,   175,   161,   346,   137,     0,   595,   138,   206,
   199,   209,   194,   176,   177,   178,   134,   135,   140,   139,
   142,     0,   141,   143,     0,     0,     0,     0,     0,     0,
    14,    13,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,   626,   627,     0,     0,     0,   628,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   365,   366,     0,     0,     0,
     0,     0,     0,     0,   275,    69,     0,     0,     0,   600,
   279,    70,    68,     0,    67,     0,     0,   430,    66,     0,
   620,     0,     0,    20,     0,     0,     0,   238,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   263,
     0,     0,     0,   598,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   254,    50,   253,   495,   494,   496,   492,
   493,     0,     0,     0,     0,     0,     0,     0,     0,   325,
     0,     0,     0,     0,     0,   455,   435,   433,   324,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,   418,   420,     0,     0,     0,   615,   616,     0,
     0,    87,     0,     0,     0,     0,     0,     0,     3,     0,
   424,     0,   322,     0,   499,     0,   129,     0,   131,     0,
   531,   339,   530,     0,     0,     0,     0,     0,     0,   348,
   144,     0,     0,     0,     0,   305,    12,     0,     0,   357,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,   629,     0,     0,     0,     0,     0,     0,   336,
   603,   286,   282,   604,     0,     0,   276,   284,     0,   277,
     0,   317,     0,   281,   271,   270,     0,     0,     0,     0,
   321,    49,    22,    24,    23,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   310,     0,     0,   307,   313,
     0,   624,   264,     0,   266,   314,   599,     0,    89,     0,
     0,     0,     0,     0,   486,   484,   497,   483,   480,   456,
   478,   457,   458,   482,   459,   460,   463,     0,   469,   470,
     0,   562,   559,   558,   557,   560,   567,   576,     0,     0,
   587,   586,   591,   590,   577,     0,     0,     0,     0,   584,
   415,     0,     0,     0,   555,   574,     0,   539,   565,   561,
     0,     0,     0,   465,   466,     0,   471,   472,     0,     0,
     0,    26,    27,    28,    29,    30,    47,    48,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,   610,     0,     0,   611,
   428,     0,     0,     0,     0,   427,     0,   429,     0,   608,
   609,     0,    40,     0,     0,    45,    44,     0,    41,   285,
     0,     0,     0,     0,     0,    88,    33,    42,   289,     0,
    34,     0,     6,    57,    61,     0,   533,     0,     0,     0,
     0,     0,     0,   133,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   443,     0,     0,   444,     0,     0,   363,
    15,     0,   358,     0,     0,     0,     0,     0,     0,     0,
     0,     0,   335,   360,   329,   359,   332,     0,     0,     0,
     0,     0,     0,   602,     0,     0,     0,   283,   601,   316,
   621,     0,     0,   267,   320,    21,     0,     0,    31,     0,
     0,     0,   309,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   462,   464,   474,     0,     0,   367,     0,
   369,     0,     0,     0,   588,   592,     0,   553,     0,     0,
   413,     0,   548,     0,   551,     0,   537,   578,     0,   538,
   568,   468,   476,   404,     0,   402,     0,   401,     0,     0,
     0,     0,     0,   269,     0,   425,   268,     0,     0,   426,
     0,     0,     0,     0,     0,     0,     0,     0,     0,    86,
     0,     0,     0,     0,   342,     0,     0,   432,   345,   597,
     0,   535,     0,   349,   145,     0,     0,     0,   446,   364,
     0,    11,   448,     0,   361,     0,     0,     0,     0,     0,
     0,     0,   334,     0,     0,     0,     0,     0,     0,   288,
   278,     0,   319,    10,   265,    90,     0,     0,   488,   489,
   490,   485,   491,     0,     0,     0,     0,   564,     0,     0,
   580,   563,     0,   540,     0,     0,     0,     0,   566,     0,
   585,     0,   575,   593,     0,     0,     0,     0,     0,   400,
   572,     0,     0,   383,     0,   582,     0,     0,     0,     0,
     0,     0,    36,     0,    37,     0,    63,    39,     0,    38,
     0,    65,     0,   622,   423,   422,     0,     0,     0,     0,
     0,     0,     0,   532,   340,   534,   347,     0,    19,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,   445,     0,   447,     0,   326,     0,
   327,   287,     0,     0,     0,   337,     0,   487,   368,     0,
     0,     0,   370,   414,     0,     0,   554,   417,   416,     0,
   546,     0,   544,     0,   549,   552,   536,     0,     0,   398,
     0,     0,   393,     0,   381,     0,   396,   403,   382,     0,
     0,     0,     0,   436,   434,     0,   419,    35,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   438,
   437,   439,   330,   333,     0,     0,     0,     0,     0,   410,
     0,   408,   411,     0,     0,     0,     0,     0,     0,   384,
   405,     0,     0,   573,     0,     0,     0,   583,   312,     0,
    58,   343,     0,     0,     0,     0,     0,     0,   440,     0,
     0,     0,     0,     0,   407,   547,     0,   542,   545,   550,
     0,   399,     0,   390,     0,   388,   380,     0,   394,   397,
     0,     0,   350,     0,   362,   338,     0,   409,     0,     0,
     0,     0,     0,   543,   392,     0,   386,   389,   395,     0,
   387,
<span class="fc" id="L535">    }, yyDgoto = {</span>
//yyDgoto 177
     1,   359,    67,    68,   672,   635,   131,   229,   629,   861,
   419,   566,   567,   568,   216,    69,    70,    71,    72,    73,
   362,   361,   538,    74,   364,    75,    76,   547,    77,    78,
    79,    80,   132,    81,    82,   657,   236,   237,   238,   239,
    84,    85,    86,    87,   240,   256,   318,   824,  1000,   825,
   817,   494,   821,   637,   441,   304,    89,   785,    90,    91,
   569,   231,   851,   258,   678,   679,   571,   877,   775,   776,
   648,    93,    94,   296,   471,   685,   328,   259,   241,   496,
   368,   366,   572,   573,   749,   372,   374,    97,    98,   757,
   969,  1019,   863,   575,   880,   881,   576,   334,   497,   299,
    99,   529,   882,   486,   300,   487,   766,   577,   432,   413,
   664,   100,   101,   454,   260,   232,   233,   578,  1010,   858,
   760,   369,   325,   885,   287,   498,   750,   751,  1011,   491,
   791,   218,   579,   103,   104,   105,   580,   581,   582,   136,
     2,   265,   266,   315,   452,   505,   492,   803,   681,   522,
   305,   327,   517,   460,   268,   704,   835,   269,   836,   712,
  1004,   668,   461,   665,   912,   446,   448,   680,   917,   370,
   624,   590,   589,   742,   741,   667,   447,
<span class="fc" id="L555">    }, yySindex = {</span>
//yySindex 1081
     0,     0, 17608, 18768, 20432, 20816, 17046, 17382, 17737, 19920,
 19920,  7728,     0,     0, 20560,  4129,  4129,     0,     0,  4129,
  -165,  -130,     0,     0,     0,     0,    59, 17270,   216,     0,
  -114,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0, 20048, 20048,  1198,   -54, 17866, 19920, 18252, 18639,  2626,
 20048, 20176, 17158,     0,     0,     0,   231,   290,     0,     0,
     0,     0,     0,     0,     0,   297,   313,     0,     0,     0,
   -16,     0,     0,     0,  -152,     0,     0,     0,     0,     0,
     0,     0,     0,   557,   364, 16187,     0,    73,    30,     0,
  -138,     0,    25,   328,     0,   321,     0,     0,     0, 20688,
   331,     0,    37,     0,   173,     0,  -119,     0,     0,     0,
     0,  -165,  -130,     0,     0,     0,     0,   211,   216,     0,
     0,     0,     0,     0,     0,     0,     0,  1198, 19920,    46,
 17737,     0,   107,     0,    33,     0,  -119,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,  -138,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   376,     0,     0, 18896, 17737,   196,   282,   173,   557,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,   262,   364,    72,   469,   218,   528,
   270,    72,     0,     0,   173,   342,   566,     0, 19920, 19920,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,   317,   731,     0,     0,     0,   361, 20048, 20048,
 20048, 20048, 20048, 16187,     0,     0,   306,   604,   615,     0,
     0,     0,     0,  6553,     0,  4129,  4129,     0,     0,  7856,
     0, 19920,   -95,     0, 19024,   300, 17737,     0,   755,   349,
   367,   353, 17866,   350,     0,   216,   364,   216,   359,     0,
   183,   194,   306,     0,   332,   194,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,   397, 20944,
   783,     0,   668,     0,     0,     0,     0,     0,     0,     0,
     0,   428,   690,   827,   -52,   345,   835,   346,  -137,     0,
  3183,   356,   891,   360,   -39,     0,     0,     0,     0, 19920,
 19920, 19920, 19920, 18896, 19920, 19920, 20048, 20048, 20048, 20048,
 20048, 20048, 20048, 20048, 20048, 20048, 20048, 20048, 20048, 20048,
 20048, 20048, 20048, 20048, 20048, 20048, 20048, 20048, 20048, 20048,
 20048, 20048,     0,     0,  3009,  3093,  4129,     0,     0,  5631,
 20176,     0, 19152, 17866,  5120,   678, 19152, 20176,     0,  4640,
     0,   391,     0,   407,     0,   364,     0,     0,     0,   173,
     0,     0,     0,  3557,  4011,  4129, 17737, 19920,  3640,     0,
     0,   557,   387, 19280,   482,     0,     0, 16862,   353,     0,
 17737,   485,  5503,  5576,  4129, 20048, 20048, 20048, 17737,   342,
 19408,   490,     0,    61,    61,     0,  6133, 21279,  4129,     0,
     0,     0,     0,     0, 20048, 17994,     0,     0, 18381,     0,
   216,     0,   418,     0,     0,     0,   717,   718,   216,   158,
     0,     0,     0,     0,     0, 17382, 19920, 16187, 17608,   402,
  5503,  5576, 20048, 20048,   216,     0,     0,   216,     0,     0,
 18510,     0,     0, 18639,     0,     0,     0,     0,     0,   721,
 21334, 21389,  4129, 20944,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,   187,     0,     0,
   738,     0,     0,     0,     0,     0,     0,     0,  1716,  3658,
     0,     0,     0,     0,     0,   712,   468,   478,   746,     0,
     0,  -128,   752,   777,     0,     0,   788,     0,     0,     0,
   532,   795, 20048,     0,     0,   229,     0,     0,   834,  -125,
  -125,     0,     0,     0,     0,     0,     0,     0,   349,  3678,
  3678,  3678,  3678,  2664,  2664,  5678,  5001,  3678,  3678,  3487,
  3487,   388,   388,   349,  3150,   349,   349,   427,   427,  2664,
  2664,  3037,  3037,  2500,  -125,   530,     0,   536,  -130,     0,
     0,   539,     0,   540,  -130,     0,     0,     0,   216,     0,
     0,  -130,     0, 16187, 20048,     0,     0,  6064,     0,     0,
   808,   841,   216, 20944,   846,     0,     0,     0,     0,     0,
     0, 16942,     0,     0,     0,   173,     0, 19920, 17737,  -130,
     0,     0,  -130,     0,   216,   635,   158,  3658,   173, 17737,
 17494, 17382, 17608,     0,     0,   553,     0, 17737,   638,     0,
     0,   401,     0,   570,   575,   576,   579,   216,  6064,   482,
   655,   143,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   216, 19920,     0, 20048,   306,   615,     0,     0,     0,
     0, 17994, 18381,     0,     0,     0,   158,   558,     0,   349,
 16187,     0,     0,   194, 20944,     0,     0,     0,     0,   216,
   721, 17737,   869,     0,     0,     0,  1716,  1072,     0,   880,
     0,   216,   216, 20048,     0,     0,  2081,     0, 17737, 17737,
     0,  3658,     0,  3658,     0,   971,     0,     0,   -51,     0,
     0,     0,     0,     0,   508,     0, 17737,     0, 17737,   871,
 17737, 20176, 20176,     0,   391,     0,     0, 20176, 20176,     0,
   391,   597,   610,    73,  -152,     0, 20048, 20176, 19536,     0,
   721, 20944, 20048,  -125,     0,   173,   692,     0,     0,     0,
   216,     0,   701,     0,     0,   596, 21072,    72,     0,     0,
 17737,     0,     0, 19920,     0,   706, 20048, 20048, 20048, 20048,
   639,   715,     0, 19664, 17737, 17737, 17737,     0,    61,     0,
     0,   936,     0,     0,     0,     0,     0,   625,     0,     0,
     0,     0,     0,   216,  1339,   945,  1950,     0,   656,   941,
     0,     0,   961,     0,   739,   662,   970,   973,     0,   987,
     0,   961,     0,     0,   795,   977,   995,   216,   997,     0,
     0,   998,  1001,     0,   697,     0,   795, 21200,   793,   686,
 20048,   794,     0, 16187,     0, 16187,     0,     0, 16187,     0,
 16187,     0, 20176,     0,     0,     0, 16187, 20048,     0,   721,
 16187, 17737, 17737,     0,     0,     0,     0,  3640,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   759,   854,     0,     0, 17737,     0,    72,     0, 20048,
     0,     0,    43,   811,   814,     0, 18381,     0,     0,  1044,
  1339,  1444,     0,     0,  1540,  2081,     0,     0,     0,  2081,
     0,  3658,     0,  2081,     0,     0,     0, 21200,  2081,     0,
   734,  4517,     0,   971,     0,  4517,     0,     0,     0,     0,
     0,   786,   866,     0,     0, 16187,     0,     0, 16187,     0,
   736,   839, 17737,     0, 21444, 21499,  4129,   196, 17737,     0,
     0,     0,     0,     0, 17737,  1339,  1044,  1339,  1064,     0,
   206,     0,     0,   961,  1073,   961,   961,   866,  1078,     0,
     0,  1082,  1088,     0,   795,  1097,  1078,     0,     0, 21554,
     0,     0,   882,     0,     0,     0,     0,   216,     0,   401,
   884,  1044,  1339,  1540,     0,     0,  2081,     0,     0,     0,
  2081,     0,  2081,     0,  4517,     0,     0,  2081,     0,     0,
     0,     0,     0,     0,     0,     0,  1044,     0,   961,  1078,
  1106,  1078,  1078,     0,     0,  2081,     0,     0,     0,  1078,
     0,
<span class="fc" id="L666">    }, yyRindex = {</span>
//yyRindex 1081
     0,     0,   201,     0,     0,     0,     0,     0,   904,     0,
     0,   828,     0,     0,     0, 14459, 14570,     0,     0, 14672,
  4921,  4420, 14960, 15098, 15174, 15292, 20304,     0, 19792,     0,
     0, 15462, 15580, 15656,  5282,  3418, 15762, 15944,  5411, 16050,
     0,     0,     0,     0,     0,   144,   163,   807,   800,   178,
     0,     0,  1300,     0,     0,     0,  1374,   -29,     0,     0,
     0,     0,     0,     0,     0,  1403,    -6,     0,     0,     0,
  9891,     0,     0,     0, 10023,     0,     0,     0,     0,     0,
     0,     0,     0,   122, 15116, 14978, 10132, 16068,     0,     0,
 16647,     0, 16126,     0,     0,     0,     0,     0,     0,   322,
     0,     0,     0,     0,    47,     0, 18123,     0,     0,     0,
     0, 10240,  8147,     0,     0,     0,     0,     0,   815,     0,
     0,     0,  6685,     0,     0,  6814,     0,     0,     0,     0,
   144,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   931,  1161,  1208,  1385,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,  1473,  1576,  1737,
  2009,     0,  2093,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0, 16661,     0,     0,     0,   153,   462,     0,  1674,   524,
     0,     0,  8260,  8387,  8627,  8736,  8844,  8976,  9085,  2284,
  9193,  9325,  2416,  9434,     0,  1345,     0,     0,  9674,     0,
     0,     0,     0,     0,   828,     0,   893,     0,     0,     0,
   609,  1090,  1202,  1386,  1413,  1497,  1578,  1754,  1620,  1624,
  2025,  1765,     0,     0,  1988,     0,     0,     0,     0,     0,
     0,     0,     0, 14220,     0,     0, 15882, 16382, 16382,     0,
     0,     0,     0,   843,     0,     0,   208,     0,     0,   843,
     0,     0,     0,     0,     0,     0,    85,     0,     0, 10481,
 10372, 16232,   144,     0,    96,   843,   245,   843,     0,     0,
   825,   825,     0,     0,     0,   824,   685,  1332,  1377,  1782,
  1997,  2180,  5285,  2183,  5470,  5915,  8235,  6946,     0,     0,
     0,  7075,   324,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
  -123,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,    80,     0,     0,     0,
     0,     0,     0,   144,   529,   621,     0,     0,     0,    79,
     0, 16487,     0,     0,     0,   186,     0,  7201,     0,     0,
     0,     0,     0,     0,     0,    80,   904,     0,   220,     0,
     0,   838,     0,    70,   446,     0,     0,  2108,  9783,     0,
   813,  7330,     0,     0,    80,     0,     0,     0,  1055,     0,
     0,     0,     0,     0,     0,  2034,     0,     0,    80,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
   843,     0,     0,     0,     0,     0,   221,   221,   843,   843,
     0,     0,     0,     0,     0,     0,     0, 13285,    85,     0,
     0,     0,     0,     0,   843,     0,    90,   843,     0,     0,
   848,     0,     0,   -35,     0,     0,     0,  7204,     0,   631,
     0,     0,    80,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   148,
     0,     0,     0,     0,     0,    39,    45,     0,    26,     0,
     0,     0,    26,    26,     0,     0,    93,     0,     0,     0,
   155,    93,   161,     0,     0,     0,     0,     0,     0,  7459,
  7599,     0,     0,     0,     0,     0,     0,     0, 10589, 12426,
 12513, 12602, 12699, 11971, 12089, 12786, 13059, 12876, 12972, 13149,
 13189, 11405, 11514, 10721, 11634, 10830, 10938, 11179, 11297, 12212,
 12329, 11754, 11863,  1132,  7459,  5783,     0,  5912,  4792,     0,
     0,  6284,  3790,  6413, 18123,     0,  3919,     0,   851,     0,
     0,  1870,     0, 13370,     0,     0,     0,  1573,     0,     0,
     0,     0,   843,     0,   647,     0,     0,     0,     0, 13097,
     0, 14278,     0,     0,     0,     0,     0,     0,   904,  9542,
  6943,  7072,     0,     0,   851,     0,   843,   261,     0,   904,
     0,     0,    85,     0,   694,   169,     0,   664,   938,     0,
     0,   938,     0,  2788,  2917,  3289,  4291,   851, 14363,   938,
     0,     0,     0,     0,     0,     0,     0,  2166,  2174,  3126,
   972,   851,     0,     0,     0, 16342, 16382,     0,     0,     0,
     0,   226,   227,     0,     0,     0,   843,     0,     0, 11056,
 13455,   234,     0,   825,     0, 10806, 11155, 11271,  1024,   851,
   652,    85,     0,     0,     0,     0,     0,   263,     0,   274,
     0,   843,    50,     0,     0,     0,     0,     0,   132,    85,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,    54,     0,   132,     0,    85,     0,
   132,     0,     0,     0, 16524,     0,     0,     0,     0,     0,
 16607, 14810,     0, 16703,  8510, 15036,     0,     0,     0,     0,
   688,     0,     0,  7599,     0,     0,     0,     0,     0,     0,
   843,     0,     0,     0,     0,     0,     0,     0,     0,     0,
   132,     0,     0,     0,     0,     0,     0,     0,     0,     0,
  8019,     0,     0,     0,   959,   132,   132,   667,     0,     0,
     0,   221,     0,     0,     0,     0,  1430,     0,     0,     0,
     0,     0,     0,   843,     0,   275,     0,     0,     0,   -69,
     0,     0,    26,     0,     0,     0,    26,    26,     0,    26,
     0,    26,     0,     0,    93,    68,   133,    54,   133,     0,
     0,   139,   133,     0,     0,     0,   139,    86,     0,     0,
     0,     0,     0, 13540,     0, 13625,     0,     0, 13710,     0,
 13795,     0,     0,     0,     0,     0, 13880,     0, 16753,   689,
 13965,    85,   904,     0,     0,     0,     0,   220,     0,  1061,
  1084,  1117,  1217,  1226,  1240,  1246,   256,  1259,  1475,   830,
  1476,     0,     0,  1505,     0,   904,     0,     0,     0,     0,
     0,     0,   938,     0,     0,     0,   238,     0,     0,   277,
     0,   283,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   170,     0,     0,     0,     0,     0,     0,     0,  1912,
  4480,     0,    97,     0,     0, 14050,     0,     0, 14135, 16764,
     0,     0,   904,  1562,     0,     0,    80,   462,   813,     0,
     0,     0,     0,     0,   132,     0,   287,     0,   291,     0,
   -53,     0,     0,    26,    26,    26,    26,   130,   133,     0,
     0,   133,   133,     0,   139,   133,   133,     0,     0,     0,
     0,     0,     0,   894,  1066,  1094,   784,   851,     0,   938,
     0,   292,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
  7937,   205,     0,   126,     0,     0,   293,     0,    26,   133,
   133,   133,   133,     0,     0,     0,     0,     0,     0,   133,
     0,
<span class="fc" id="L777">    }, yyGindex = {</span>
//yyGindex 177
     0,     0,     4,     0,  -375,     0,   -68,    22,    -4,   393,
   993,     0,     0,   118,     0,     0,     0,  1133,     0,     0,
     0,  1157,   419,     0,     0,     0,     0,   844,     0,     0,
   141,    15,  1210,  -413,   121,     0,   455,  -414,     0,    24,
   213,  1586,    11,     5,   760,     8,    48,  -425,     0,   199,
     0,   818,     0,   -20,     0,    17,  1220,   611,     0,     0,
  -637,     0,     0,   764,  -259,   340,     0,     0,     0,  -430,
  -201,   -87,   -19,    89,  -456,     0,     0,   903,    -2,    99,
     0,     0, 11268,   497,  -716,     0,     0,     0,     0,   115,
  1961,   486,  -364,   499,   301,     0,     0,     0,    18,  -447,
     0,  -363,   294,  -291,  -415,     0,  -546,  7483,   -70,   480,
  -498,  1263,   -28,   285,  1019,     0,   -13,  -111,     0,  -624,
     0,     0,  -153,  -811,     0,  -373,  -748,   538,   244,   646,
  -572,     0,  -835,  -346,     0,    51,     0,  2887,  1897,   627,
     0,    82,    29,     0,     0,     0,   -18,     0,     0,  -254,
     0,     0,     0,  -256,     0,  -399,     0,     0,     0,     0,
     0,     0,   137,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,
    };
<span class="fc" id="L798">    protected static final short[] yyTable = YyTables.yyTable();</span>
<span class="fc" id="L799">    protected static final short[] yyCheck = YyTables.yyCheck();</span>

  /** maps symbol value to printable name.
      @see #yyExpecting
    */
<span class="fc" id="L804">  protected static final String[] yyNames = {</span>
    &quot;end-of-file&quot;,null,null,null,null,null,null,null,null,null,&quot;'\\n'&quot;,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,&quot;' '&quot;,null,null,null,null,null,
    null,null,null,null,null,null,&quot;','&quot;,null,null,null,null,null,null,
    null,null,null,null,null,null,null,&quot;':'&quot;,&quot;';'&quot;,null,&quot;'='&quot;,null,&quot;'?'&quot;,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,
    &quot;'['&quot;,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,
    &quot;kCLASS&quot;,&quot;kMODULE&quot;,&quot;kDEF&quot;,&quot;kUNDEF&quot;,&quot;kBEGIN&quot;,&quot;kRESCUE&quot;,&quot;kENSURE&quot;,
    &quot;kEND&quot;,&quot;kIF&quot;,&quot;kUNLESS&quot;,&quot;kTHEN&quot;,&quot;kELSIF&quot;,&quot;kELSE&quot;,&quot;kCASE&quot;,&quot;kWHEN&quot;,
    &quot;kWHILE&quot;,&quot;kUNTIL&quot;,&quot;kFOR&quot;,&quot;kBREAK&quot;,&quot;kNEXT&quot;,&quot;kREDO&quot;,&quot;kRETRY&quot;,&quot;kIN&quot;,
    &quot;kDO&quot;,&quot;kDO_COND&quot;,&quot;kDO_BLOCK&quot;,&quot;kRETURN&quot;,&quot;kYIELD&quot;,&quot;kSUPER&quot;,&quot;kSELF&quot;,
    &quot;kNIL&quot;,&quot;kTRUE&quot;,&quot;kFALSE&quot;,&quot;kAND&quot;,&quot;kOR&quot;,&quot;kNOT&quot;,&quot;kIF_MOD&quot;,&quot;kUNLESS_MOD&quot;,
    &quot;kWHILE_MOD&quot;,&quot;kUNTIL_MOD&quot;,&quot;kRESCUE_MOD&quot;,&quot;kALIAS&quot;,&quot;kDEFINED&quot;,&quot;klBEGIN&quot;,
    &quot;klEND&quot;,&quot;k__LINE__&quot;,&quot;k__FILE__&quot;,&quot;k__ENCODING__&quot;,&quot;kDO_LAMBDA&quot;,
    &quot;tIDENTIFIER&quot;,&quot;tFID&quot;,&quot;tGVAR&quot;,&quot;tIVAR&quot;,&quot;tCONSTANT&quot;,&quot;tCVAR&quot;,&quot;tLABEL&quot;,
    &quot;tCHAR&quot;,&quot;tUPLUS&quot;,&quot;tUMINUS&quot;,&quot;tUMINUS_NUM&quot;,&quot;tPOW&quot;,&quot;tCMP&quot;,&quot;tEQ&quot;,&quot;tEQQ&quot;,
    &quot;tNEQ&quot;,&quot;tGEQ&quot;,&quot;tLEQ&quot;,&quot;tANDOP&quot;,&quot;tOROP&quot;,&quot;tMATCH&quot;,&quot;tNMATCH&quot;,&quot;tDOT&quot;,
    &quot;tDOT2&quot;,&quot;tDOT3&quot;,&quot;tAREF&quot;,&quot;tASET&quot;,&quot;tLSHFT&quot;,&quot;tRSHFT&quot;,&quot;tCOLON2&quot;,&quot;tCOLON3&quot;,
    &quot;tOP_ASGN&quot;,&quot;tASSOC&quot;,&quot;tLPAREN&quot;,&quot;tLPAREN2&quot;,&quot;tRPAREN&quot;,&quot;tLPAREN_ARG&quot;,
    &quot;tLBRACK&quot;,&quot;tRBRACK&quot;,&quot;tLBRACE&quot;,&quot;tLBRACE_ARG&quot;,&quot;tSTAR&quot;,&quot;tSTAR2&quot;,&quot;tAMPER&quot;,
    &quot;tAMPER2&quot;,&quot;tTILDE&quot;,&quot;tPERCENT&quot;,&quot;tDIVIDE&quot;,&quot;tPLUS&quot;,&quot;tMINUS&quot;,&quot;tLT&quot;,&quot;tGT&quot;,
    &quot;tPIPE&quot;,&quot;tBANG&quot;,&quot;tCARET&quot;,&quot;tLCURLY&quot;,&quot;tRCURLY&quot;,&quot;tBACK_REF2&quot;,&quot;tSYMBEG&quot;,
    &quot;tSTRING_BEG&quot;,&quot;tXSTRING_BEG&quot;,&quot;tREGEXP_BEG&quot;,&quot;tWORDS_BEG&quot;,&quot;tQWORDS_BEG&quot;,
    &quot;tSTRING_DBEG&quot;,&quot;tSTRING_DVAR&quot;,&quot;tSTRING_END&quot;,&quot;tLAMBDA&quot;,&quot;tLAMBEG&quot;,
    &quot;tNTH_REF&quot;,&quot;tBACK_REF&quot;,&quot;tSTRING_CONTENT&quot;,&quot;tINTEGER&quot;,&quot;tIMAGINARY&quot;,
    &quot;tFLOAT&quot;,&quot;tRATIONAL&quot;,&quot;tREGEXP_END&quot;,&quot;tSYMBOLS_BEG&quot;,&quot;tQSYMBOLS_BEG&quot;,
    &quot;tDSTAR&quot;,&quot;tSTRING_DEND&quot;,&quot;tLOWEST&quot;,
    };

  /** printable rules for debugging.
    */
<span class="fc" id="L848">  protected static final String [] yyRule = {</span>
    &quot;$accept : program&quot;,
    &quot;$$1 :&quot;,
    &quot;program : $$1 top_compstmt&quot;,
    &quot;top_compstmt : top_stmts opt_terms&quot;,
    &quot;top_stmts : none&quot;,
    &quot;top_stmts : top_stmt&quot;,
    &quot;top_stmts : top_stmts terms top_stmt&quot;,
    &quot;top_stmts : error top_stmt&quot;,
    &quot;top_stmt : stmt&quot;,
    &quot;$$2 :&quot;,
    &quot;top_stmt : klBEGIN $$2 tLCURLY top_compstmt tRCURLY&quot;,
    &quot;bodystmt : compstmt opt_rescue opt_else opt_ensure&quot;,
    &quot;compstmt : stmts opt_terms&quot;,
    &quot;stmts : none&quot;,
    &quot;stmts : stmt_or_begin&quot;,
    &quot;stmts : stmts terms stmt_or_begin&quot;,
    &quot;stmts : error stmt&quot;,
    &quot;stmt_or_begin : stmt&quot;,
    &quot;$$3 :&quot;,
    &quot;stmt_or_begin : kBEGIN $$3 tLCURLY top_compstmt tRCURLY&quot;,
    &quot;$$4 :&quot;,
    &quot;stmt : kALIAS fitem $$4 fitem&quot;,
    &quot;stmt : kALIAS tGVAR tGVAR&quot;,
    &quot;stmt : kALIAS tGVAR tBACK_REF&quot;,
    &quot;stmt : kALIAS tGVAR tNTH_REF&quot;,
    &quot;stmt : kUNDEF undef_list&quot;,
    &quot;stmt : stmt kIF_MOD expr_value&quot;,
    &quot;stmt : stmt kUNLESS_MOD expr_value&quot;,
    &quot;stmt : stmt kWHILE_MOD expr_value&quot;,
    &quot;stmt : stmt kUNTIL_MOD expr_value&quot;,
    &quot;stmt : stmt kRESCUE_MOD stmt&quot;,
    &quot;stmt : klEND tLCURLY compstmt tRCURLY&quot;,
    &quot;stmt : command_asgn&quot;,
    &quot;stmt : mlhs '=' command_call&quot;,
    &quot;stmt : var_lhs tOP_ASGN command_call&quot;,
    &quot;stmt : primary_value '[' opt_call_args rbracket tOP_ASGN command_call&quot;,
    &quot;stmt : primary_value tDOT tIDENTIFIER tOP_ASGN command_call&quot;,
    &quot;stmt : primary_value tDOT tCONSTANT tOP_ASGN command_call&quot;,
    &quot;stmt : primary_value tCOLON2 tCONSTANT tOP_ASGN command_call&quot;,
    &quot;stmt : primary_value tCOLON2 tIDENTIFIER tOP_ASGN command_call&quot;,
    &quot;stmt : backref tOP_ASGN command_call&quot;,
    &quot;stmt : lhs '=' mrhs&quot;,
    &quot;stmt : mlhs '=' mrhs_arg&quot;,
    &quot;stmt : expr&quot;,
    &quot;command_asgn : lhs '=' command_call&quot;,
    &quot;command_asgn : lhs '=' command_asgn&quot;,
    &quot;expr : command_call&quot;,
    &quot;expr : expr kAND expr&quot;,
    &quot;expr : expr kOR expr&quot;,
    &quot;expr : kNOT opt_nl expr&quot;,
    &quot;expr : tBANG command_call&quot;,
    &quot;expr : arg&quot;,
    &quot;expr_value : expr&quot;,
    &quot;command_call : command&quot;,
    &quot;command_call : block_command&quot;,
    &quot;block_command : block_call&quot;,
    &quot;block_command : block_call dot_or_colon operation2 command_args&quot;,
    &quot;$$5 :&quot;,
    &quot;cmd_brace_block : tLBRACE_ARG $$5 opt_block_param compstmt tRCURLY&quot;,
    &quot;fcall : operation&quot;,
    &quot;command : fcall command_args&quot;,
    &quot;command : fcall command_args cmd_brace_block&quot;,
    &quot;command : primary_value tDOT operation2 command_args&quot;,
    &quot;command : primary_value tDOT operation2 command_args cmd_brace_block&quot;,
    &quot;command : primary_value tCOLON2 operation2 command_args&quot;,
    &quot;command : primary_value tCOLON2 operation2 command_args cmd_brace_block&quot;,
    &quot;command : kSUPER command_args&quot;,
    &quot;command : kYIELD command_args&quot;,
    &quot;command : kRETURN call_args&quot;,
    &quot;command : kBREAK call_args&quot;,
    &quot;command : kNEXT call_args&quot;,
    &quot;mlhs : mlhs_basic&quot;,
    &quot;mlhs : tLPAREN mlhs_inner rparen&quot;,
    &quot;mlhs_inner : mlhs_basic&quot;,
    &quot;mlhs_inner : tLPAREN mlhs_inner rparen&quot;,
    &quot;mlhs_basic : mlhs_head&quot;,
    &quot;mlhs_basic : mlhs_head mlhs_item&quot;,
    &quot;mlhs_basic : mlhs_head tSTAR mlhs_node&quot;,
    &quot;mlhs_basic : mlhs_head tSTAR mlhs_node ',' mlhs_post&quot;,
    &quot;mlhs_basic : mlhs_head tSTAR&quot;,
    &quot;mlhs_basic : mlhs_head tSTAR ',' mlhs_post&quot;,
    &quot;mlhs_basic : tSTAR mlhs_node&quot;,
    &quot;mlhs_basic : tSTAR mlhs_node ',' mlhs_post&quot;,
    &quot;mlhs_basic : tSTAR&quot;,
    &quot;mlhs_basic : tSTAR ',' mlhs_post&quot;,
    &quot;mlhs_item : mlhs_node&quot;,
    &quot;mlhs_item : tLPAREN mlhs_inner rparen&quot;,
    &quot;mlhs_head : mlhs_item ','&quot;,
    &quot;mlhs_head : mlhs_head mlhs_item ','&quot;,
    &quot;mlhs_post : mlhs_item&quot;,
    &quot;mlhs_post : mlhs_post ',' mlhs_item&quot;,
    &quot;mlhs_node : tIDENTIFIER&quot;,
    &quot;mlhs_node : tIVAR&quot;,
    &quot;mlhs_node : tGVAR&quot;,
    &quot;mlhs_node : tCONSTANT&quot;,
    &quot;mlhs_node : tCVAR&quot;,
    &quot;mlhs_node : kNIL&quot;,
    &quot;mlhs_node : kSELF&quot;,
    &quot;mlhs_node : kTRUE&quot;,
    &quot;mlhs_node : kFALSE&quot;,
    &quot;mlhs_node : k__FILE__&quot;,
    &quot;mlhs_node : k__LINE__&quot;,
    &quot;mlhs_node : k__ENCODING__&quot;,
    &quot;mlhs_node : primary_value '[' opt_call_args rbracket&quot;,
    &quot;mlhs_node : primary_value tDOT tIDENTIFIER&quot;,
    &quot;mlhs_node : primary_value tCOLON2 tIDENTIFIER&quot;,
    &quot;mlhs_node : primary_value tDOT tCONSTANT&quot;,
    &quot;mlhs_node : primary_value tCOLON2 tCONSTANT&quot;,
    &quot;mlhs_node : tCOLON3 tCONSTANT&quot;,
    &quot;mlhs_node : backref&quot;,
    &quot;lhs : tIDENTIFIER&quot;,
    &quot;lhs : tIVAR&quot;,
    &quot;lhs : tGVAR&quot;,
    &quot;lhs : tCONSTANT&quot;,
    &quot;lhs : tCVAR&quot;,
    &quot;lhs : kNIL&quot;,
    &quot;lhs : kSELF&quot;,
    &quot;lhs : kTRUE&quot;,
    &quot;lhs : kFALSE&quot;,
    &quot;lhs : k__FILE__&quot;,
    &quot;lhs : k__LINE__&quot;,
    &quot;lhs : k__ENCODING__&quot;,
    &quot;lhs : primary_value '[' opt_call_args rbracket&quot;,
    &quot;lhs : primary_value tDOT tIDENTIFIER&quot;,
    &quot;lhs : primary_value tCOLON2 tIDENTIFIER&quot;,
    &quot;lhs : primary_value tDOT tCONSTANT&quot;,
    &quot;lhs : primary_value tCOLON2 tCONSTANT&quot;,
    &quot;lhs : tCOLON3 tCONSTANT&quot;,
    &quot;lhs : backref&quot;,
    &quot;cname : tIDENTIFIER&quot;,
    &quot;cname : tCONSTANT&quot;,
    &quot;cpath : tCOLON3 cname&quot;,
    &quot;cpath : cname&quot;,
    &quot;cpath : primary_value tCOLON2 cname&quot;,
    &quot;fname : tIDENTIFIER&quot;,
    &quot;fname : tCONSTANT&quot;,
    &quot;fname : tFID&quot;,
    &quot;fname : op&quot;,
    &quot;fname : reswords&quot;,
    &quot;fsym : fname&quot;,
    &quot;fsym : symbol&quot;,
    &quot;fitem : fsym&quot;,
    &quot;fitem : dsym&quot;,
    &quot;undef_list : fitem&quot;,
    &quot;$$6 :&quot;,
    &quot;undef_list : undef_list ',' $$6 fitem&quot;,
    &quot;op : tPIPE&quot;,
    &quot;op : tCARET&quot;,
    &quot;op : tAMPER2&quot;,
    &quot;op : tCMP&quot;,
    &quot;op : tEQ&quot;,
    &quot;op : tEQQ&quot;,
    &quot;op : tMATCH&quot;,
    &quot;op : tNMATCH&quot;,
    &quot;op : tGT&quot;,
    &quot;op : tGEQ&quot;,
    &quot;op : tLT&quot;,
    &quot;op : tLEQ&quot;,
    &quot;op : tNEQ&quot;,
    &quot;op : tLSHFT&quot;,
    &quot;op : tRSHFT&quot;,
    &quot;op : tDSTAR&quot;,
    &quot;op : tPLUS&quot;,
    &quot;op : tMINUS&quot;,
    &quot;op : tSTAR2&quot;,
    &quot;op : tSTAR&quot;,
    &quot;op : tDIVIDE&quot;,
    &quot;op : tPERCENT&quot;,
    &quot;op : tPOW&quot;,
    &quot;op : tBANG&quot;,
    &quot;op : tTILDE&quot;,
    &quot;op : tUPLUS&quot;,
    &quot;op : tUMINUS&quot;,
    &quot;op : tAREF&quot;,
    &quot;op : tASET&quot;,
    &quot;op : tBACK_REF2&quot;,
    &quot;reswords : k__LINE__&quot;,
    &quot;reswords : k__FILE__&quot;,
    &quot;reswords : k__ENCODING__&quot;,
    &quot;reswords : klBEGIN&quot;,
    &quot;reswords : klEND&quot;,
    &quot;reswords : kALIAS&quot;,
    &quot;reswords : kAND&quot;,
    &quot;reswords : kBEGIN&quot;,
    &quot;reswords : kBREAK&quot;,
    &quot;reswords : kCASE&quot;,
    &quot;reswords : kCLASS&quot;,
    &quot;reswords : kDEF&quot;,
    &quot;reswords : kDEFINED&quot;,
    &quot;reswords : kDO&quot;,
    &quot;reswords : kELSE&quot;,
    &quot;reswords : kELSIF&quot;,
    &quot;reswords : kEND&quot;,
    &quot;reswords : kENSURE&quot;,
    &quot;reswords : kFALSE&quot;,
    &quot;reswords : kFOR&quot;,
    &quot;reswords : kIN&quot;,
    &quot;reswords : kMODULE&quot;,
    &quot;reswords : kNEXT&quot;,
    &quot;reswords : kNIL&quot;,
    &quot;reswords : kNOT&quot;,
    &quot;reswords : kOR&quot;,
    &quot;reswords : kREDO&quot;,
    &quot;reswords : kRESCUE&quot;,
    &quot;reswords : kRETRY&quot;,
    &quot;reswords : kRETURN&quot;,
    &quot;reswords : kSELF&quot;,
    &quot;reswords : kSUPER&quot;,
    &quot;reswords : kTHEN&quot;,
    &quot;reswords : kTRUE&quot;,
    &quot;reswords : kUNDEF&quot;,
    &quot;reswords : kWHEN&quot;,
    &quot;reswords : kYIELD&quot;,
    &quot;reswords : kIF_MOD&quot;,
    &quot;reswords : kUNLESS_MOD&quot;,
    &quot;reswords : kWHILE_MOD&quot;,
    &quot;reswords : kUNTIL_MOD&quot;,
    &quot;reswords : kRESCUE_MOD&quot;,
    &quot;arg : lhs '=' arg&quot;,
    &quot;arg : lhs '=' arg kRESCUE_MOD arg&quot;,
    &quot;arg : var_lhs tOP_ASGN arg&quot;,
    &quot;arg : var_lhs tOP_ASGN arg kRESCUE_MOD arg&quot;,
    &quot;arg : primary_value '[' opt_call_args rbracket tOP_ASGN arg&quot;,
    &quot;arg : primary_value tDOT tIDENTIFIER tOP_ASGN arg&quot;,
    &quot;arg : primary_value tDOT tCONSTANT tOP_ASGN arg&quot;,
    &quot;arg : primary_value tCOLON2 tIDENTIFIER tOP_ASGN arg&quot;,
    &quot;arg : primary_value tCOLON2 tCONSTANT tOP_ASGN arg&quot;,
    &quot;arg : tCOLON3 tCONSTANT tOP_ASGN arg&quot;,
    &quot;arg : backref tOP_ASGN arg&quot;,
    &quot;arg : arg tDOT2 arg&quot;,
    &quot;arg : arg tDOT3 arg&quot;,
    &quot;arg : arg tPLUS arg&quot;,
    &quot;arg : arg tMINUS arg&quot;,
    &quot;arg : arg tSTAR2 arg&quot;,
    &quot;arg : arg tDIVIDE arg&quot;,
    &quot;arg : arg tPERCENT arg&quot;,
    &quot;arg : arg tPOW arg&quot;,
    &quot;arg : tUMINUS_NUM simple_numeric tPOW arg&quot;,
    &quot;arg : tUPLUS arg&quot;,
    &quot;arg : tUMINUS arg&quot;,
    &quot;arg : arg tPIPE arg&quot;,
    &quot;arg : arg tCARET arg&quot;,
    &quot;arg : arg tAMPER2 arg&quot;,
    &quot;arg : arg tCMP arg&quot;,
    &quot;arg : arg tGT arg&quot;,
    &quot;arg : arg tGEQ arg&quot;,
    &quot;arg : arg tLT arg&quot;,
    &quot;arg : arg tLEQ arg&quot;,
    &quot;arg : arg tEQ arg&quot;,
    &quot;arg : arg tEQQ arg&quot;,
    &quot;arg : arg tNEQ arg&quot;,
    &quot;arg : arg tMATCH arg&quot;,
    &quot;arg : arg tNMATCH arg&quot;,
    &quot;arg : tBANG arg&quot;,
    &quot;arg : tTILDE arg&quot;,
    &quot;arg : arg tLSHFT arg&quot;,
    &quot;arg : arg tRSHFT arg&quot;,
    &quot;arg : arg tANDOP arg&quot;,
    &quot;arg : arg tOROP arg&quot;,
    &quot;arg : kDEFINED opt_nl arg&quot;,
    &quot;arg : arg '?' arg opt_nl ':' arg&quot;,
    &quot;arg : primary&quot;,
    &quot;arg_value : arg&quot;,
    &quot;aref_args : none&quot;,
    &quot;aref_args : args trailer&quot;,
    &quot;aref_args : args ',' assocs trailer&quot;,
    &quot;aref_args : assocs trailer&quot;,
    &quot;paren_args : tLPAREN2 opt_call_args rparen&quot;,
    &quot;opt_paren_args : none&quot;,
    &quot;opt_paren_args : paren_args&quot;,
    &quot;opt_call_args : none&quot;,
    &quot;opt_call_args : call_args&quot;,
    &quot;opt_call_args : args ','&quot;,
    &quot;opt_call_args : args ',' assocs ','&quot;,
    &quot;opt_call_args : assocs ','&quot;,
    &quot;call_args : command&quot;,
    &quot;call_args : args opt_block_arg&quot;,
    &quot;call_args : assocs opt_block_arg&quot;,
    &quot;call_args : args ',' assocs opt_block_arg&quot;,
    &quot;call_args : block_arg&quot;,
    &quot;$$7 :&quot;,
    &quot;command_args : $$7 call_args&quot;,
    &quot;block_arg : tAMPER arg_value&quot;,
    &quot;opt_block_arg : ',' block_arg&quot;,
    &quot;opt_block_arg : none_block_pass&quot;,
    &quot;args : arg_value&quot;,
    &quot;args : tSTAR arg_value&quot;,
    &quot;args : args ',' arg_value&quot;,
    &quot;args : args ',' tSTAR arg_value&quot;,
    &quot;mrhs_arg : mrhs&quot;,
    &quot;mrhs_arg : arg_value&quot;,
    &quot;mrhs : args ',' arg_value&quot;,
    &quot;mrhs : args ',' tSTAR arg_value&quot;,
    &quot;mrhs : tSTAR arg_value&quot;,
    &quot;primary : literal&quot;,
    &quot;primary : strings&quot;,
    &quot;primary : xstring&quot;,
    &quot;primary : regexp&quot;,
    &quot;primary : words&quot;,
    &quot;primary : qwords&quot;,
    &quot;primary : symbols&quot;,
    &quot;primary : qsymbols&quot;,
    &quot;primary : var_ref&quot;,
    &quot;primary : backref&quot;,
    &quot;primary : tFID&quot;,
    &quot;primary : kBEGIN bodystmt kEND&quot;,
    &quot;$$8 :&quot;,
    &quot;primary : tLPAREN_ARG $$8 rparen&quot;,
    &quot;$$9 :&quot;,
    &quot;primary : tLPAREN_ARG expr $$9 rparen&quot;,
    &quot;primary : tLPAREN compstmt tRPAREN&quot;,
    &quot;primary : primary_value tCOLON2 tCONSTANT&quot;,
    &quot;primary : tCOLON3 tCONSTANT&quot;,
    &quot;primary : tLBRACK aref_args tRBRACK&quot;,
    &quot;primary : tLBRACE assoc_list tRCURLY&quot;,
    &quot;primary : kRETURN&quot;,
    &quot;primary : kYIELD tLPAREN2 call_args rparen&quot;,
    &quot;primary : kYIELD tLPAREN2 rparen&quot;,
    &quot;primary : kYIELD&quot;,
    &quot;primary : kDEFINED opt_nl tLPAREN2 expr rparen&quot;,
    &quot;primary : kNOT tLPAREN2 expr rparen&quot;,
    &quot;primary : kNOT tLPAREN2 rparen&quot;,
    &quot;primary : fcall brace_block&quot;,
    &quot;primary : method_call&quot;,
    &quot;primary : method_call brace_block&quot;,
    &quot;primary : tLAMBDA lambda&quot;,
    &quot;primary : kIF expr_value then compstmt if_tail kEND&quot;,
    &quot;primary : kUNLESS expr_value then compstmt opt_else kEND&quot;,
    &quot;$$10 :&quot;,
    &quot;$$11 :&quot;,
    &quot;primary : kWHILE $$10 expr_value do $$11 compstmt kEND&quot;,
    &quot;$$12 :&quot;,
    &quot;$$13 :&quot;,
    &quot;primary : kUNTIL $$12 expr_value do $$13 compstmt kEND&quot;,
    &quot;primary : kCASE expr_value opt_terms case_body kEND&quot;,
    &quot;primary : kCASE opt_terms case_body kEND&quot;,
    &quot;$$14 :&quot;,
    &quot;$$15 :&quot;,
    &quot;primary : kFOR for_var kIN $$14 expr_value do $$15 compstmt kEND&quot;,
    &quot;$$16 :&quot;,
    &quot;primary : kCLASS cpath superclass $$16 bodystmt kEND&quot;,
    &quot;$$17 :&quot;,
    &quot;$$18 :&quot;,
    &quot;primary : kCLASS tLSHFT expr $$17 term $$18 bodystmt kEND&quot;,
    &quot;$$19 :&quot;,
    &quot;primary : kMODULE cpath $$19 bodystmt kEND&quot;,
    &quot;$$20 :&quot;,
    &quot;primary : kDEF fname $$20 f_arglist bodystmt kEND&quot;,
    &quot;$$21 :&quot;,
    &quot;$$22 :&quot;,
    &quot;primary : kDEF singleton dot_or_colon $$21 fname $$22 f_arglist bodystmt kEND&quot;,
    &quot;primary : kBREAK&quot;,
    &quot;primary : kNEXT&quot;,
    &quot;primary : kREDO&quot;,
    &quot;primary : kRETRY&quot;,
    &quot;primary_value : primary&quot;,
    &quot;then : term&quot;,
    &quot;then : kTHEN&quot;,
    &quot;then : term kTHEN&quot;,
    &quot;do : term&quot;,
    &quot;do : kDO_COND&quot;,
    &quot;if_tail : opt_else&quot;,
    &quot;if_tail : kELSIF expr_value then compstmt if_tail&quot;,
    &quot;opt_else : none&quot;,
    &quot;opt_else : kELSE compstmt&quot;,
    &quot;for_var : lhs&quot;,
    &quot;for_var : mlhs&quot;,
    &quot;f_marg : f_norm_arg&quot;,
    &quot;f_marg : tLPAREN f_margs rparen&quot;,
    &quot;f_marg_list : f_marg&quot;,
    &quot;f_marg_list : f_marg_list ',' f_marg&quot;,
    &quot;f_margs : f_marg_list&quot;,
    &quot;f_margs : f_marg_list ',' tSTAR f_norm_arg&quot;,
    &quot;f_margs : f_marg_list ',' tSTAR f_norm_arg ',' f_marg_list&quot;,
    &quot;f_margs : f_marg_list ',' tSTAR&quot;,
    &quot;f_margs : f_marg_list ',' tSTAR ',' f_marg_list&quot;,
    &quot;f_margs : tSTAR f_norm_arg&quot;,
    &quot;f_margs : tSTAR f_norm_arg ',' f_marg_list&quot;,
    &quot;f_margs : tSTAR&quot;,
    &quot;f_margs : tSTAR ',' f_marg_list&quot;,
    &quot;block_args_tail : f_block_kwarg ',' f_kwrest opt_f_block_arg&quot;,
    &quot;block_args_tail : f_block_kwarg opt_f_block_arg&quot;,
    &quot;block_args_tail : f_kwrest opt_f_block_arg&quot;,
    &quot;block_args_tail : f_block_arg&quot;,
    &quot;opt_block_args_tail : ',' block_args_tail&quot;,
    &quot;opt_block_args_tail :&quot;,
    &quot;block_param : f_arg ',' f_block_optarg ',' f_rest_arg opt_block_args_tail&quot;,
    &quot;block_param : f_arg ',' f_block_optarg ',' f_rest_arg ',' f_arg opt_block_args_tail&quot;,
    &quot;block_param : f_arg ',' f_block_optarg opt_block_args_tail&quot;,
    &quot;block_param : f_arg ',' f_block_optarg ',' f_arg opt_block_args_tail&quot;,
    &quot;block_param : f_arg ',' f_rest_arg opt_block_args_tail&quot;,
    &quot;block_param : f_arg ','&quot;,
    &quot;block_param : f_arg ',' f_rest_arg ',' f_arg opt_block_args_tail&quot;,
    &quot;block_param : f_arg opt_block_args_tail&quot;,
    &quot;block_param : f_block_optarg ',' f_rest_arg opt_block_args_tail&quot;,
    &quot;block_param : f_block_optarg ',' f_rest_arg ',' f_arg opt_block_args_tail&quot;,
    &quot;block_param : f_block_optarg opt_block_args_tail&quot;,
    &quot;block_param : f_block_optarg ',' f_arg opt_block_args_tail&quot;,
    &quot;block_param : f_rest_arg opt_block_args_tail&quot;,
    &quot;block_param : f_rest_arg ',' f_arg opt_block_args_tail&quot;,
    &quot;block_param : block_args_tail&quot;,
    &quot;opt_block_param : none&quot;,
    &quot;opt_block_param : block_param_def&quot;,
    &quot;block_param_def : tPIPE opt_bv_decl tPIPE&quot;,
    &quot;block_param_def : tOROP&quot;,
    &quot;block_param_def : tPIPE block_param opt_bv_decl tPIPE&quot;,
    &quot;opt_bv_decl : opt_nl&quot;,
    &quot;opt_bv_decl : opt_nl ';' bv_decls opt_nl&quot;,
    &quot;bv_decls : bvar&quot;,
    &quot;bv_decls : bv_decls ',' bvar&quot;,
    &quot;bvar : tIDENTIFIER&quot;,
    &quot;bvar : f_bad_arg&quot;,
    &quot;$$23 :&quot;,
    &quot;lambda : $$23 f_larglist lambda_body&quot;,
    &quot;f_larglist : tLPAREN2 f_args opt_bv_decl tRPAREN&quot;,
    &quot;f_larglist : f_args&quot;,
    &quot;lambda_body : tLAMBEG compstmt tRCURLY&quot;,
    &quot;lambda_body : kDO_LAMBDA compstmt kEND&quot;,
    &quot;$$24 :&quot;,
    &quot;do_block : kDO_BLOCK $$24 opt_block_param compstmt kEND&quot;,
    &quot;block_call : command do_block&quot;,
    &quot;block_call : block_call dot_or_colon operation2 opt_paren_args&quot;,
    &quot;block_call : block_call dot_or_colon operation2 opt_paren_args brace_block&quot;,
    &quot;block_call : block_call dot_or_colon operation2 command_args do_block&quot;,
    &quot;method_call : fcall paren_args&quot;,
    &quot;method_call : primary_value tDOT operation2 opt_paren_args&quot;,
    &quot;method_call : primary_value tCOLON2 operation2 paren_args&quot;,
    &quot;method_call : primary_value tCOLON2 operation3&quot;,
    &quot;method_call : primary_value tDOT paren_args&quot;,
    &quot;method_call : primary_value tCOLON2 paren_args&quot;,
    &quot;method_call : kSUPER paren_args&quot;,
    &quot;method_call : kSUPER&quot;,
    &quot;method_call : primary_value '[' opt_call_args rbracket&quot;,
    &quot;$$25 :&quot;,
    &quot;brace_block : tLCURLY $$25 opt_block_param compstmt tRCURLY&quot;,
    &quot;$$26 :&quot;,
    &quot;brace_block : kDO $$26 opt_block_param compstmt kEND&quot;,
    &quot;case_body : kWHEN args then compstmt cases&quot;,
    &quot;cases : opt_else&quot;,
    &quot;cases : case_body&quot;,
    &quot;opt_rescue : kRESCUE exc_list exc_var then compstmt opt_rescue&quot;,
    &quot;opt_rescue :&quot;,
    &quot;exc_list : arg_value&quot;,
    &quot;exc_list : mrhs&quot;,
    &quot;exc_list : none&quot;,
    &quot;exc_var : tASSOC lhs&quot;,
    &quot;exc_var : none&quot;,
    &quot;opt_ensure : kENSURE compstmt&quot;,
    &quot;opt_ensure : none&quot;,
    &quot;literal : numeric&quot;,
    &quot;literal : symbol&quot;,
    &quot;literal : dsym&quot;,
    &quot;strings : string&quot;,
    &quot;string : tCHAR&quot;,
    &quot;string : string1&quot;,
    &quot;string : string string1&quot;,
    &quot;string1 : tSTRING_BEG string_contents tSTRING_END&quot;,
    &quot;xstring : tXSTRING_BEG xstring_contents tSTRING_END&quot;,
    &quot;regexp : tREGEXP_BEG regexp_contents tREGEXP_END&quot;,
    &quot;words : tWORDS_BEG ' ' tSTRING_END&quot;,
    &quot;words : tWORDS_BEG word_list tSTRING_END&quot;,
    &quot;word_list :&quot;,
    &quot;word_list : word_list word ' '&quot;,
    &quot;word : string_content&quot;,
    &quot;word : word string_content&quot;,
    &quot;symbols : tSYMBOLS_BEG ' ' tSTRING_END&quot;,
    &quot;symbols : tSYMBOLS_BEG symbol_list tSTRING_END&quot;,
    &quot;symbol_list :&quot;,
    &quot;symbol_list : symbol_list word ' '&quot;,
    &quot;qwords : tQWORDS_BEG ' ' tSTRING_END&quot;,
    &quot;qwords : tQWORDS_BEG qword_list tSTRING_END&quot;,
    &quot;qsymbols : tQSYMBOLS_BEG ' ' tSTRING_END&quot;,
    &quot;qsymbols : tQSYMBOLS_BEG qsym_list tSTRING_END&quot;,
    &quot;qword_list :&quot;,
    &quot;qword_list : qword_list tSTRING_CONTENT ' '&quot;,
    &quot;qsym_list :&quot;,
    &quot;qsym_list : qsym_list tSTRING_CONTENT ' '&quot;,
    &quot;string_contents :&quot;,
    &quot;string_contents : string_contents string_content&quot;,
    &quot;xstring_contents :&quot;,
    &quot;xstring_contents : xstring_contents string_content&quot;,
    &quot;regexp_contents :&quot;,
    &quot;regexp_contents : regexp_contents string_content&quot;,
    &quot;string_content : tSTRING_CONTENT&quot;,
    &quot;$$27 :&quot;,
    &quot;string_content : tSTRING_DVAR $$27 string_dvar&quot;,
    &quot;$$28 :&quot;,
    &quot;string_content : tSTRING_DBEG $$28 compstmt tRCURLY&quot;,
    &quot;string_dvar : tGVAR&quot;,
    &quot;string_dvar : tIVAR&quot;,
    &quot;string_dvar : tCVAR&quot;,
    &quot;string_dvar : backref&quot;,
    &quot;symbol : tSYMBEG sym&quot;,
    &quot;sym : fname&quot;,
    &quot;sym : tIVAR&quot;,
    &quot;sym : tGVAR&quot;,
    &quot;sym : tCVAR&quot;,
    &quot;dsym : tSYMBEG xstring_contents tSTRING_END&quot;,
    &quot;numeric : simple_numeric&quot;,
    &quot;numeric : tUMINUS_NUM simple_numeric&quot;,
    &quot;simple_numeric : tINTEGER&quot;,
    &quot;simple_numeric : tFLOAT&quot;,
    &quot;simple_numeric : tRATIONAL&quot;,
    &quot;simple_numeric : tIMAGINARY&quot;,
    &quot;var_ref : tIDENTIFIER&quot;,
    &quot;var_ref : tIVAR&quot;,
    &quot;var_ref : tGVAR&quot;,
    &quot;var_ref : tCONSTANT&quot;,
    &quot;var_ref : tCVAR&quot;,
    &quot;var_ref : kNIL&quot;,
    &quot;var_ref : kSELF&quot;,
    &quot;var_ref : kTRUE&quot;,
    &quot;var_ref : kFALSE&quot;,
    &quot;var_ref : k__FILE__&quot;,
    &quot;var_ref : k__LINE__&quot;,
    &quot;var_ref : k__ENCODING__&quot;,
    &quot;var_lhs : tIDENTIFIER&quot;,
    &quot;var_lhs : tIVAR&quot;,
    &quot;var_lhs : tGVAR&quot;,
    &quot;var_lhs : tCONSTANT&quot;,
    &quot;var_lhs : tCVAR&quot;,
    &quot;var_lhs : kNIL&quot;,
    &quot;var_lhs : kSELF&quot;,
    &quot;var_lhs : kTRUE&quot;,
    &quot;var_lhs : kFALSE&quot;,
    &quot;var_lhs : k__FILE__&quot;,
    &quot;var_lhs : k__LINE__&quot;,
    &quot;var_lhs : k__ENCODING__&quot;,
    &quot;backref : tNTH_REF&quot;,
    &quot;backref : tBACK_REF&quot;,
    &quot;superclass : term&quot;,
    &quot;$$29 :&quot;,
    &quot;superclass : tLT $$29 expr_value term&quot;,
    &quot;superclass : error term&quot;,
    &quot;f_arglist : tLPAREN2 f_args rparen&quot;,
    &quot;f_arglist : f_args term&quot;,
    &quot;args_tail : f_kwarg ',' f_kwrest opt_f_block_arg&quot;,
    &quot;args_tail : f_kwarg opt_f_block_arg&quot;,
    &quot;args_tail : f_kwrest opt_f_block_arg&quot;,
    &quot;args_tail : f_block_arg&quot;,
    &quot;opt_args_tail : ',' args_tail&quot;,
    &quot;opt_args_tail :&quot;,
    &quot;f_args : f_arg ',' f_optarg ',' f_rest_arg opt_args_tail&quot;,
    &quot;f_args : f_arg ',' f_optarg ',' f_rest_arg ',' f_arg opt_args_tail&quot;,
    &quot;f_args : f_arg ',' f_optarg opt_args_tail&quot;,
    &quot;f_args : f_arg ',' f_optarg ',' f_arg opt_args_tail&quot;,
    &quot;f_args : f_arg ',' f_rest_arg opt_args_tail&quot;,
    &quot;f_args : f_arg ',' f_rest_arg ',' f_arg opt_args_tail&quot;,
    &quot;f_args : f_arg opt_args_tail&quot;,
    &quot;f_args : f_optarg ',' f_rest_arg opt_args_tail&quot;,
    &quot;f_args : f_optarg ',' f_rest_arg ',' f_arg opt_args_tail&quot;,
    &quot;f_args : f_optarg opt_args_tail&quot;,
    &quot;f_args : f_optarg ',' f_arg opt_args_tail&quot;,
    &quot;f_args : f_rest_arg opt_args_tail&quot;,
    &quot;f_args : f_rest_arg ',' f_arg opt_args_tail&quot;,
    &quot;f_args : args_tail&quot;,
    &quot;f_args :&quot;,
    &quot;f_bad_arg : tCONSTANT&quot;,
    &quot;f_bad_arg : tIVAR&quot;,
    &quot;f_bad_arg : tGVAR&quot;,
    &quot;f_bad_arg : tCVAR&quot;,
    &quot;f_norm_arg : f_bad_arg&quot;,
    &quot;f_norm_arg : tIDENTIFIER&quot;,
    &quot;f_arg_item : f_norm_arg&quot;,
    &quot;f_arg_item : tLPAREN f_margs rparen&quot;,
    &quot;f_arg : f_arg_item&quot;,
    &quot;f_arg : f_arg ',' f_arg_item&quot;,
    &quot;f_label : tLABEL&quot;,
    &quot;f_kw : f_label arg_value&quot;,
    &quot;f_kw : f_label&quot;,
    &quot;f_block_kw : f_label primary_value&quot;,
    &quot;f_block_kw : f_label&quot;,
    &quot;f_block_kwarg : f_block_kw&quot;,
    &quot;f_block_kwarg : f_block_kwarg ',' f_block_kw&quot;,
    &quot;f_kwarg : f_kw&quot;,
    &quot;f_kwarg : f_kwarg ',' f_kw&quot;,
    &quot;kwrest_mark : tPOW&quot;,
    &quot;kwrest_mark : tDSTAR&quot;,
    &quot;f_kwrest : kwrest_mark tIDENTIFIER&quot;,
    &quot;f_kwrest : kwrest_mark&quot;,
    &quot;f_opt : f_norm_arg '=' arg_value&quot;,
    &quot;f_block_opt : tIDENTIFIER '=' primary_value&quot;,
    &quot;f_block_optarg : f_block_opt&quot;,
    &quot;f_block_optarg : f_block_optarg ',' f_block_opt&quot;,
    &quot;f_optarg : f_opt&quot;,
    &quot;f_optarg : f_optarg ',' f_opt&quot;,
    &quot;restarg_mark : tSTAR2&quot;,
    &quot;restarg_mark : tSTAR&quot;,
    &quot;f_rest_arg : restarg_mark tIDENTIFIER&quot;,
    &quot;f_rest_arg : restarg_mark&quot;,
    &quot;blkarg_mark : tAMPER2&quot;,
    &quot;blkarg_mark : tAMPER&quot;,
    &quot;f_block_arg : blkarg_mark tIDENTIFIER&quot;,
    &quot;opt_f_block_arg : ',' f_block_arg&quot;,
    &quot;opt_f_block_arg :&quot;,
    &quot;singleton : var_ref&quot;,
    &quot;$$30 :&quot;,
    &quot;singleton : tLPAREN2 $$30 expr rparen&quot;,
    &quot;assoc_list : none&quot;,
    &quot;assoc_list : assocs trailer&quot;,
    &quot;assocs : assoc&quot;,
    &quot;assocs : assocs ',' assoc&quot;,
    &quot;assoc : arg_value tASSOC arg_value&quot;,
    &quot;assoc : tLABEL arg_value&quot;,
    &quot;assoc : tDSTAR arg_value&quot;,
    &quot;operation : tIDENTIFIER&quot;,
    &quot;operation : tCONSTANT&quot;,
    &quot;operation : tFID&quot;,
    &quot;operation2 : tIDENTIFIER&quot;,
    &quot;operation2 : tCONSTANT&quot;,
    &quot;operation2 : tFID&quot;,
    &quot;operation2 : op&quot;,
    &quot;operation3 : tIDENTIFIER&quot;,
    &quot;operation3 : tFID&quot;,
    &quot;operation3 : op&quot;,
    &quot;dot_or_colon : tDOT&quot;,
    &quot;dot_or_colon : tCOLON2&quot;,
    &quot;opt_terms :&quot;,
    &quot;opt_terms : terms&quot;,
    &quot;opt_nl :&quot;,
    &quot;opt_nl : '\\n'&quot;,
    &quot;rparen : opt_nl tRPAREN&quot;,
    &quot;rbracket : opt_nl tRBRACK&quot;,
    &quot;trailer :&quot;,
    &quot;trailer : '\\n'&quot;,
    &quot;trailer : ','&quot;,
    &quot;term : ';'&quot;,
    &quot;term : '\\n'&quot;,
    &quot;terms : term&quot;,
    &quot;terms : terms ';'&quot;,
    &quot;none :&quot;,
    &quot;none_block_pass :&quot;,
    };

  protected org.jruby.parser.YYDebug yydebug;

  /** index-checked interface to {@link #yyNames}.
      @param token single character or &lt;tt&gt;%token&lt;/tt&gt; value.
      @return token name or &lt;tt&gt;[illegal]&lt;/tt&gt; or &lt;tt&gt;[unknown]&lt;/tt&gt;.
    */
  public static String yyName (int token) {
<span class="nc bnc" id="L1490" title="All 4 branches missed.">    if (token &lt; 0 || token &gt; yyNames.length) return &quot;[illegal]&quot;;</span>
    String name;
<span class="nc bnc" id="L1492" title="All 2 branches missed.">    if ((name = yyNames[token]) != null) return name;</span>
<span class="nc" id="L1493">    return &quot;[unknown]&quot;;</span>
  }


  /** computes list of expected tokens on error by tracing the tables.
      @param state for which to compute the list.
      @return list of token names.
    */
  protected String[] yyExpecting (int state) {
<span class="fc" id="L1502">    int token, n, len = 0;</span>
<span class="fc" id="L1503">    boolean[] ok = new boolean[yyNames.length];</span>

<span class="pc bpc" id="L1505" title="1 of 2 branches missed.">    if ((n = yySindex[state]) != 0)</span>
<span class="fc bfc" id="L1506" title="All 2 branches covered.">      for (token = n &lt; 0 ? -n : 0;</span>
<span class="pc bpc" id="L1507" title="1 of 4 branches missed.">           token &lt; yyNames.length &amp;&amp; n+token &lt; yyTable.length; ++ token)</span>
<span class="pc bpc" id="L1508" title="1 of 6 branches missed.">        if (yyCheck[n+token] == token &amp;&amp; !ok[token] &amp;&amp; yyNames[token] != null) {</span>
<span class="fc" id="L1509">          ++ len;</span>
<span class="fc" id="L1510">          ok[token] = true;</span>
        }
<span class="fc bfc" id="L1512" title="All 2 branches covered.">    if ((n = yyRindex[state]) != 0)</span>
<span class="fc bfc" id="L1513" title="All 2 branches covered.">      for (token = n &lt; 0 ? -n : 0;</span>
<span class="pc bpc" id="L1514" title="1 of 4 branches missed.">           token &lt; yyNames.length &amp;&amp; n+token &lt; yyTable.length; ++ token)</span>
<span class="pc bpc" id="L1515" title="1 of 6 branches missed.">        if (yyCheck[n+token] == token &amp;&amp; !ok[token] &amp;&amp; yyNames[token] != null) {</span>
<span class="fc" id="L1516">          ++ len;</span>
<span class="fc" id="L1517">          ok[token] = true;</span>
        }

<span class="fc" id="L1520">    String result[] = new String[len];</span>
<span class="fc bfc" id="L1521" title="All 2 branches covered.">    for (n = token = 0; n &lt; len;  ++ token)</span>
<span class="fc bfc" id="L1522" title="All 2 branches covered.">      if (ok[token]) result[n++] = yyNames[token];</span>
<span class="fc" id="L1523">    return result;</span>
  }

  /** the generated parser, with debugging messages.
      Maintains a dynamic state and value stack.
      @param yyLex scanner.
      @param yydebug debug message writer implementing &lt;tt&gt;yyDebug&lt;/tt&gt;, or &lt;tt&gt;null&lt;/tt&gt;.
      @return result of the last reduction, if any.
    */
  public Object yyparse (RubyLexer yyLex, Object ayydebug)
				throws java.io.IOException {
<span class="fc" id="L1534">    this.yydebug = (org.jruby.parser.YYDebug) ayydebug;</span>
<span class="fc" id="L1535">    return yyparse(yyLex);</span>
  }

  /** initial size and increment of the state/value stack [default 256].
      This is not final so that it can be overwritten outside of invocations
      of {@link #yyparse}.
    */
  protected int yyMax;

  /** executed at the beginning of a reduce action.
      Used as &lt;tt&gt;$$ = yyDefault($1)&lt;/tt&gt;, prior to the user-specified action, if any.
      Can be overwritten to provide deep copy, etc.
      @param first value for &lt;tt&gt;$1&lt;/tt&gt;, or &lt;tt&gt;null&lt;/tt&gt;.
      @return first.
    */
  protected Object yyDefault (Object first) {
<span class="fc" id="L1551">    return first;</span>
  }

  /** the generated parser.
      Maintains a dynamic state and value stack.
      @param yyLex scanner.
      @return result of the last reduction, if any.
    */
  public Object yyparse (RubyLexer yyLex) throws java.io.IOException {
<span class="pc bpc" id="L1560" title="1 of 2 branches missed.">    if (yyMax &lt;= 0) yyMax = 256;			// initial size</span>
<span class="fc" id="L1561">    int yyState = 0, yyStates[] = new int[yyMax];	// state stack</span>
<span class="fc" id="L1562">    Object yyVal = null, yyVals[] = new Object[yyMax];	// value stack</span>
<span class="fc" id="L1563">    int yyToken = -1;					// current input</span>
<span class="fc" id="L1564">    int yyErrorFlag = 0;				// #tokens to shift</span>

<span class="fc" id="L1566">    yyLoop: for (int yyTop = 0;; ++ yyTop) {</span>
<span class="pc bpc" id="L1567" title="1 of 2 branches missed.">      if (yyTop &gt;= yyStates.length) {			// dynamically increase</span>
<span class="nc" id="L1568">        int[] i = new int[yyStates.length+yyMax];</span>
<span class="nc" id="L1569">        System.arraycopy(yyStates, 0, i, 0, yyStates.length);</span>
<span class="nc" id="L1570">        yyStates = i;</span>
<span class="nc" id="L1571">        Object[] o = new Object[yyVals.length+yyMax];</span>
<span class="nc" id="L1572">        System.arraycopy(yyVals, 0, o, 0, yyVals.length);</span>
<span class="nc" id="L1573">        yyVals = o;</span>
      }
<span class="fc" id="L1575">      yyStates[yyTop] = yyState;</span>
<span class="fc" id="L1576">      yyVals[yyTop] = yyVal;</span>
<span class="pc bpc" id="L1577" title="1 of 2 branches missed.">      if (yydebug != null) yydebug.push(yyState, yyVal);</span>

      yyDiscarded: for (;;) {	// discarding a token does not change stack
        int yyN;
<span class="fc bfc" id="L1581" title="All 2 branches covered.">        if ((yyN = yyDefRed[yyState]) == 0) {	// else [default] reduce (yyN)</span>
<span class="fc bfc" id="L1582" title="All 2 branches covered.">          if (yyToken &lt; 0) {</span>
//            yyToken = yyLex.advance() ? yyLex.token() : 0;
<span class="fc" id="L1584">            yyToken = yyLex.nextToken();</span>
<span class="pc bpc" id="L1585" title="1 of 2 branches missed.">            if (yydebug != null)</span>
<span class="nc" id="L1586">              yydebug.lex(yyState, yyToken, yyName(yyToken), yyLex.value());</span>
          }
<span class="pc bpc" id="L1588" title="1 of 8 branches missed.">          if ((yyN = yySindex[yyState]) != 0 &amp;&amp; (yyN += yyToken) &gt;= 0</span>
              &amp;&amp; yyN &lt; yyTable.length &amp;&amp; yyCheck[yyN] == yyToken) {
<span class="pc bpc" id="L1590" title="1 of 2 branches missed.">            if (yydebug != null)</span>
<span class="nc" id="L1591">              yydebug.shift(yyState, yyTable[yyN], yyErrorFlag-1);</span>
<span class="fc" id="L1592">            yyState = yyTable[yyN];		// shift to yyN</span>
<span class="fc" id="L1593">            yyVal = yyLex.value();</span>
<span class="fc" id="L1594">            yyToken = -1;</span>
<span class="pc bpc" id="L1595" title="1 of 2 branches missed.">            if (yyErrorFlag &gt; 0) -- yyErrorFlag;</span>
            continue yyLoop;
          }
<span class="pc bpc" id="L1598" title="2 of 8 branches missed.">          if ((yyN = yyRindex[yyState]) != 0 &amp;&amp; (yyN += yyToken) &gt;= 0</span>
              &amp;&amp; yyN &lt; yyTable.length &amp;&amp; yyCheck[yyN] == yyToken)
<span class="fc" id="L1600">            yyN = yyTable[yyN];			// reduce (yyN)</span>
          else
<span class="nc bnc" id="L1602" title="All 4 branches missed.">            switch (yyErrorFlag) {</span>
  
            case 0:
<span class="nc" id="L1605">              support.yyerror(&quot;syntax error&quot;, yyExpecting(yyState), yyNames[yyToken]);</span>
<span class="nc bnc" id="L1606" title="All 2 branches missed.">              if (yydebug != null) yydebug.error(&quot;syntax error&quot;);</span>
  
            case 1: case 2:
<span class="nc" id="L1609">              yyErrorFlag = 3;</span>
              do {
<span class="nc bnc" id="L1611" title="All 8 branches missed.">                if ((yyN = yySindex[yyStates[yyTop]]) != 0</span>
                    &amp;&amp; (yyN += yyErrorCode) &gt;= 0 &amp;&amp; yyN &lt; yyTable.length
                    &amp;&amp; yyCheck[yyN] == yyErrorCode) {
<span class="nc bnc" id="L1614" title="All 2 branches missed.">                  if (yydebug != null)</span>
<span class="nc" id="L1615">                    yydebug.shift(yyStates[yyTop], yyTable[yyN], 3);</span>
<span class="nc" id="L1616">                  yyState = yyTable[yyN];</span>
<span class="nc" id="L1617">                  yyVal = yyLex.value();</span>
<span class="nc" id="L1618">                  continue yyLoop;</span>
                }
<span class="nc bnc" id="L1620" title="All 2 branches missed.">                if (yydebug != null) yydebug.pop(yyStates[yyTop]);</span>
<span class="nc bnc" id="L1621" title="All 2 branches missed.">              } while (-- yyTop &gt;= 0);</span>
<span class="nc bnc" id="L1622" title="All 2 branches missed.">              if (yydebug != null) yydebug.reject();</span>
<span class="nc" id="L1623">              support.yyerror(&quot;irrecoverable syntax error&quot;);</span>
  
            case 3:
<span class="nc bnc" id="L1626" title="All 2 branches missed.">              if (yyToken == 0) {</span>
<span class="nc bnc" id="L1627" title="All 2 branches missed.">                if (yydebug != null) yydebug.reject();</span>
<span class="nc" id="L1628">                support.yyerror(&quot;irrecoverable syntax error at end-of-file&quot;);</span>
              }
<span class="nc bnc" id="L1630" title="All 2 branches missed.">              if (yydebug != null)</span>
<span class="nc" id="L1631">                yydebug.discard(yyState, yyToken, yyName(yyToken),</span>
<span class="nc" id="L1632">  							yyLex.value());</span>
<span class="nc" id="L1633">              yyToken = -1;</span>
<span class="nc" id="L1634">              continue yyDiscarded;		// leave stack alone</span>
            }
        }
<span class="fc" id="L1637">        int yyV = yyTop + 1-yyLen[yyN];</span>
<span class="pc bpc" id="L1638" title="1 of 2 branches missed.">        if (yydebug != null)</span>
<span class="nc" id="L1639">          yydebug.reduce(yyState, yyStates[yyV-1], yyN, yyRule[yyN], yyLen[yyN]);</span>
<span class="fc" id="L1640">        ParserState state = states[yyN];</span>
<span class="fc bfc" id="L1641" title="All 2 branches covered.">        if (state == null) {</span>
<span class="fc bfc" id="L1642" title="All 2 branches covered.">            yyVal = yyDefault(yyV &gt; yyTop ? null : yyVals[yyV]);</span>
        } else {
<span class="fc" id="L1644">            yyVal = state.execute(support, lexer, yyVal, yyVals, yyTop);</span>
        }
//        switch (yyN) {
// ACTIONS_END
//        }
<span class="fc" id="L1649">        yyTop -= yyLen[yyN];</span>
<span class="fc" id="L1650">        yyState = yyStates[yyTop];</span>
<span class="fc" id="L1651">        int yyM = yyLhs[yyN];</span>
<span class="fc bfc" id="L1652" title="All 4 branches covered.">        if (yyState == 0 &amp;&amp; yyM == 0) {</span>
<span class="pc bpc" id="L1653" title="1 of 2 branches missed.">          if (yydebug != null) yydebug.shift(0, yyFinal);</span>
<span class="fc" id="L1654">          yyState = yyFinal;</span>
<span class="pc bpc" id="L1655" title="1 of 2 branches missed.">          if (yyToken &lt; 0) {</span>
<span class="nc" id="L1656">            yyToken = yyLex.nextToken();</span>
//            yyToken = yyLex.advance() ? yyLex.token() : 0;
<span class="nc bnc" id="L1658" title="All 2 branches missed.">            if (yydebug != null)</span>
<span class="nc" id="L1659">               yydebug.lex(yyState, yyToken,yyName(yyToken), yyLex.value());</span>
          }
<span class="pc bpc" id="L1661" title="1 of 2 branches missed.">          if (yyToken == 0) {</span>
<span class="pc bpc" id="L1662" title="1 of 2 branches missed.">            if (yydebug != null) yydebug.accept(yyVal);</span>
<span class="fc" id="L1663">            return yyVal;</span>
          }
          continue yyLoop;
        }
<span class="pc bpc" id="L1667" title="1 of 8 branches missed.">        if ((yyN = yyGindex[yyM]) != 0 &amp;&amp; (yyN += yyState) &gt;= 0</span>
            &amp;&amp; yyN &lt; yyTable.length &amp;&amp; yyCheck[yyN] == yyState)
<span class="fc" id="L1669">          yyState = yyTable[yyN];</span>
        else
<span class="fc" id="L1671">          yyState = yyDgoto[yyM];</span>
<span class="pc bpc" id="L1672" title="1 of 2 branches missed.">        if (yydebug != null) yydebug.shift(yyStates[yyTop], yyState);</span>
        continue yyLoop;
      }
    }
  }

<span class="fc" id="L1678">static ParserState[] states = new ParserState[632];</span>
static {
<span class="fc" id="L1680">states[1] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1682">                  lexer.setState(LexState.EXPR_BEG);</span>
<span class="fc" id="L1683">                  support.initTopLocalVariables();</span>
<span class="fc" id="L1684">    return yyVal;</span>
  }
};
<span class="fc" id="L1687">states[2] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
  /* ENEBO: Removed !compile_for_eval which probably is to reduce warnings*/
<span class="fc bfc" id="L1690" title="All 2 branches covered.">                  if (((Node)yyVals[0+yyTop]) != null) {</span>
                      /* last expression should not be void */
<span class="fc bfc" id="L1692" title="All 2 branches covered.">                      if (((Node)yyVals[0+yyTop]) instanceof BlockNode) {</span>
<span class="fc" id="L1693">                          support.checkUselessStatement(((BlockNode)yyVals[0+yyTop]).getLast());</span>
                      } else {
<span class="fc" id="L1695">                          support.checkUselessStatement(((Node)yyVals[0+yyTop]));</span>
                      }
                  }
<span class="fc" id="L1698">                  support.getResult().setAST(support.addRootNode(((Node)yyVals[0+yyTop])));</span>
<span class="fc" id="L1699">    return yyVal;</span>
  }
};
<span class="fc" id="L1702">states[3] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc bfc" id="L1704" title="All 2 branches covered.">                  if (((Node)yyVals[-1+yyTop]) instanceof BlockNode) {</span>
<span class="fc" id="L1705">                      support.checkUselessStatements(((BlockNode)yyVals[-1+yyTop]));</span>
                  }
<span class="fc" id="L1707">                  yyVal = ((Node)yyVals[-1+yyTop]);</span>
<span class="fc" id="L1708">    return yyVal;</span>
  }
};
<span class="fc" id="L1711">states[5] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1713">                    yyVal = support.newline_node(((Node)yyVals[0+yyTop]), support.getPosition(((Node)yyVals[0+yyTop])));</span>
<span class="fc" id="L1714">    return yyVal;</span>
  }
};
<span class="fc" id="L1717">states[6] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1719">                    yyVal = support.appendToBlock(((Node)yyVals[-2+yyTop]), support.newline_node(((Node)yyVals[0+yyTop]), support.getPosition(((Node)yyVals[0+yyTop]))));</span>
<span class="fc" id="L1720">    return yyVal;</span>
  }
};
<span class="fc" id="L1723">states[7] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L1725">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="nc" id="L1726">    return yyVal;</span>
  }
};
<span class="fc" id="L1729">states[9] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L1731" title="2 of 4 branches missed.">                    if (support.isInDef() || support.isInSingle()) {</span>
<span class="nc" id="L1732">                        support.yyerror(&quot;BEGIN in method&quot;);</span>
                    }
<span class="fc" id="L1734">    return yyVal;</span>
  }
};
<span class="fc" id="L1737">states[10] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1739">                    support.getResult().addBeginNode(new PreExe19Node(((ISourcePosition)yyVals[-4+yyTop]), support.getCurrentScope(), ((Node)yyVals[-1+yyTop])));</span>
<span class="fc" id="L1740">                    yyVal = null;</span>
<span class="fc" id="L1741">    return yyVal;</span>
  }
};
<span class="fc" id="L1744">states[11] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1746">                  Node node = ((Node)yyVals[-3+yyTop]);</span>

<span class="fc bfc" id="L1748" title="All 2 branches covered.">                  if (((RescueBodyNode)yyVals[-2+yyTop]) != null) {</span>
<span class="fc" id="L1749">                      node = new RescueNode(support.getPosition(((Node)yyVals[-3+yyTop])), ((Node)yyVals[-3+yyTop]), ((RescueBodyNode)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop]));</span>
<span class="pc bpc" id="L1750" title="1 of 2 branches missed.">                  } else if (((Node)yyVals[-1+yyTop]) != null) {</span>
<span class="nc" id="L1751">                      support.warn(ID.ELSE_WITHOUT_RESCUE, support.getPosition(((Node)yyVals[-3+yyTop])), &quot;else without rescue is useless&quot;);</span>
<span class="nc" id="L1752">                      node = support.appendToBlock(((Node)yyVals[-3+yyTop]), ((Node)yyVals[-1+yyTop]));</span>
                  }
<span class="fc bfc" id="L1754" title="All 2 branches covered.">                  if (((Node)yyVals[0+yyTop]) != null) {</span>
<span class="pc bpc" id="L1755" title="1 of 2 branches missed.">                      if (node == null) node = NilImplicitNode.NIL;</span>
<span class="fc" id="L1756">                      node = new EnsureNode(support.getPosition(((Node)yyVals[-3+yyTop])), node, ((Node)yyVals[0+yyTop]));</span>
                  }

<span class="fc" id="L1759">                  support.fixpos(node, ((Node)yyVals[-3+yyTop]));</span>
<span class="fc" id="L1760">                  yyVal = node;</span>
<span class="fc" id="L1761">    return yyVal;</span>
  }
};
<span class="fc" id="L1764">states[12] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc bfc" id="L1766" title="All 2 branches covered.">                    if (((Node)yyVals[-1+yyTop]) instanceof BlockNode) {</span>
<span class="fc" id="L1767">                        support.checkUselessStatements(((BlockNode)yyVals[-1+yyTop]));</span>
                    }
<span class="fc" id="L1769">                    yyVal = ((Node)yyVals[-1+yyTop]);</span>
<span class="fc" id="L1770">    return yyVal;</span>
  }
};
<span class="fc" id="L1773">states[14] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1775">                    yyVal = support.newline_node(((Node)yyVals[0+yyTop]), support.getPosition(((Node)yyVals[0+yyTop])));</span>
<span class="fc" id="L1776">    return yyVal;</span>
  }
};
<span class="fc" id="L1779">states[15] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1781">                    yyVal = support.appendToBlock(((Node)yyVals[-2+yyTop]), support.newline_node(((Node)yyVals[0+yyTop]), support.getPosition(((Node)yyVals[0+yyTop]))));</span>
<span class="fc" id="L1782">    return yyVal;</span>
  }
};
<span class="fc" id="L1785">states[16] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L1787">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="nc" id="L1788">    return yyVal;</span>
  }
};
<span class="fc" id="L1791">states[17] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1793">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L1794">    return yyVal;</span>
  }
};
<span class="fc" id="L1797">states[18] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L1799">                   support.yyerror(&quot;BEGIN is permitted only at toplevel&quot;);</span>
<span class="nc" id="L1800">    return yyVal;</span>
  }
};
<span class="fc" id="L1803">states[19] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc bnc" id="L1805" title="All 2 branches missed.">                    yyVal = new BeginNode(((ISourcePosition)yyVals[-4+yyTop]), ((Node)yyVals[-3+yyTop]) == null ? NilImplicitNode.NIL : ((Node)yyVals[-3+yyTop]));</span>
<span class="nc" id="L1806">    return yyVal;</span>
  }
};
<span class="fc" id="L1809">states[20] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1811">                    lexer.setState(LexState.EXPR_FNAME);</span>
<span class="fc" id="L1812">    return yyVal;</span>
  }
};
<span class="fc" id="L1815">states[21] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1817">                    yyVal = support.newAlias(((ISourcePosition)yyVals[-3+yyTop]), ((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L1818">    return yyVal;</span>
  }
};
<span class="fc" id="L1821">states[22] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L1823">                    yyVal = new VAliasNode(((ISourcePosition)yyVals[-2+yyTop]), ((String)yyVals[-1+yyTop]), ((String)yyVals[0+yyTop]));</span>
<span class="nc" id="L1824">    return yyVal;</span>
  }
};
<span class="fc" id="L1827">states[23] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L1829">                    yyVal = new VAliasNode(((ISourcePosition)yyVals[-2+yyTop]), ((String)yyVals[-1+yyTop]), &quot;$&quot; + ((BackRefNode)yyVals[0+yyTop]).getType());</span>
<span class="nc" id="L1830">    return yyVal;</span>
  }
};
<span class="fc" id="L1833">states[24] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L1835">                    support.yyerror(&quot;can't make alias for the number variables&quot;);</span>
<span class="nc" id="L1836">    return yyVal;</span>
  }
};
<span class="fc" id="L1839">states[25] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1841">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L1842">    return yyVal;</span>
  }
};
<span class="fc" id="L1845">states[26] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1847">                    yyVal = new IfNode(support.getPosition(((Node)yyVals[-2+yyTop])), support.getConditionNode(((Node)yyVals[0+yyTop])), ((Node)yyVals[-2+yyTop]), null);</span>
<span class="fc" id="L1848">                    support.fixpos(((Node)yyVal), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L1849">    return yyVal;</span>
  }
};
<span class="fc" id="L1852">states[27] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1854">                    yyVal = new IfNode(support.getPosition(((Node)yyVals[-2+yyTop])), support.getConditionNode(((Node)yyVals[0+yyTop])), null, ((Node)yyVals[-2+yyTop]));</span>
<span class="fc" id="L1855">                    support.fixpos(((Node)yyVal), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L1856">    return yyVal;</span>
  }
};
<span class="fc" id="L1859">states[28] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L1861" title="1 of 4 branches missed.">                    if (((Node)yyVals[-2+yyTop]) != null &amp;&amp; ((Node)yyVals[-2+yyTop]) instanceof BeginNode) {</span>
<span class="fc" id="L1862">                        yyVal = new WhileNode(support.getPosition(((Node)yyVals[-2+yyTop])), support.getConditionNode(((Node)yyVals[0+yyTop])), ((BeginNode)yyVals[-2+yyTop]).getBodyNode(), false);</span>
                    } else {
<span class="fc" id="L1864">                        yyVal = new WhileNode(support.getPosition(((Node)yyVals[-2+yyTop])), support.getConditionNode(((Node)yyVals[0+yyTop])), ((Node)yyVals[-2+yyTop]), true);</span>
                    }
<span class="fc" id="L1866">    return yyVal;</span>
  }
};
<span class="fc" id="L1869">states[29] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L1871" title="1 of 4 branches missed.">                    if (((Node)yyVals[-2+yyTop]) != null &amp;&amp; ((Node)yyVals[-2+yyTop]) instanceof BeginNode) {</span>
<span class="fc" id="L1872">                        yyVal = new UntilNode(support.getPosition(((Node)yyVals[-2+yyTop])), support.getConditionNode(((Node)yyVals[0+yyTop])), ((BeginNode)yyVals[-2+yyTop]).getBodyNode(), false);</span>
                    } else {
<span class="fc" id="L1874">                        yyVal = new UntilNode(support.getPosition(((Node)yyVals[-2+yyTop])), support.getConditionNode(((Node)yyVals[0+yyTop])), ((Node)yyVals[-2+yyTop]), true);</span>
                    }
<span class="fc" id="L1876">    return yyVal;</span>
  }
};
<span class="fc" id="L1879">states[30] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L1881" title="1 of 2 branches missed.">                    Node body = ((Node)yyVals[0+yyTop]) == null ? NilImplicitNode.NIL : ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L1882">                    yyVal = new RescueNode(support.getPosition(((Node)yyVals[-2+yyTop])), ((Node)yyVals[-2+yyTop]), new RescueBodyNode(support.getPosition(((Node)yyVals[-2+yyTop])), null, body, null), null);</span>
<span class="fc" id="L1883">    return yyVal;</span>
  }
};
<span class="fc" id="L1886">states[31] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc bnc" id="L1888" title="All 4 branches missed.">                    if (support.isInDef() || support.isInSingle()) {</span>
<span class="nc" id="L1889">                        support.warn(ID.END_IN_METHOD, ((ISourcePosition)yyVals[-3+yyTop]), &quot;END in method; use at_exit&quot;);</span>
                    }
<span class="nc" id="L1891">                    yyVal = new PostExeNode(((ISourcePosition)yyVals[-3+yyTop]), ((Node)yyVals[-1+yyTop]));</span>
<span class="nc" id="L1892">    return yyVal;</span>
  }
};
<span class="fc" id="L1895">states[33] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1897">                    support.checkExpression(((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L1898">                    ((MultipleAsgn19Node)yyVals[-2+yyTop]).setValueNode(((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L1899">                    yyVal = ((MultipleAsgn19Node)yyVals[-2+yyTop]);</span>
<span class="fc" id="L1900">    return yyVal;</span>
  }
};
<span class="fc" id="L1903">states[34] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1905">                    support.checkExpression(((Node)yyVals[0+yyTop]));</span>

<span class="fc" id="L1907">                    ISourcePosition pos = ((AssignableNode)yyVals[-2+yyTop]).getPosition();</span>
<span class="fc" id="L1908">                    String asgnOp = ((String)yyVals[-1+yyTop]);</span>
<span class="fc bfc" id="L1909" title="All 2 branches covered.">                    if (asgnOp.equals(&quot;||&quot;)) {</span>
<span class="fc" id="L1910">                        ((AssignableNode)yyVals[-2+yyTop]).setValueNode(((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L1911">                        yyVal = new OpAsgnOrNode(pos, support.gettable2(((AssignableNode)yyVals[-2+yyTop])), ((AssignableNode)yyVals[-2+yyTop]));</span>
<span class="fc bfc" id="L1912" title="All 2 branches covered.">                    } else if (asgnOp.equals(&quot;&amp;&amp;&quot;)) {</span>
<span class="fc" id="L1913">                        ((AssignableNode)yyVals[-2+yyTop]).setValueNode(((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L1914">                        yyVal = new OpAsgnAndNode(pos, support.gettable2(((AssignableNode)yyVals[-2+yyTop])), ((AssignableNode)yyVals[-2+yyTop]));</span>
                    } else {
<span class="fc" id="L1916">                        ((AssignableNode)yyVals[-2+yyTop]).setValueNode(support.getOperatorCallNode(support.gettable2(((AssignableNode)yyVals[-2+yyTop])), asgnOp, ((Node)yyVals[0+yyTop])));</span>
<span class="fc" id="L1917">                        ((AssignableNode)yyVals[-2+yyTop]).setPosition(pos);</span>
<span class="fc" id="L1918">                        yyVal = ((AssignableNode)yyVals[-2+yyTop]);</span>
                    }
<span class="fc" id="L1920">    return yyVal;</span>
  }
};
<span class="fc" id="L1923">states[35] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
  /* FIXME: arg_concat logic missing for opt_call_args*/
<span class="nc" id="L1926">                    yyVal = support.new_opElementAsgnNode(((Node)yyVals[-5+yyTop]), ((String)yyVals[-1+yyTop]), ((Node)yyVals[-3+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="nc" id="L1927">    return yyVal;</span>
  }
};
<span class="fc" id="L1930">states[36] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L1932">                    yyVal = new OpAsgnNode(support.getPosition(((Node)yyVals[-4+yyTop])), ((Node)yyVals[-4+yyTop]), ((Node)yyVals[0+yyTop]), ((String)yyVals[-2+yyTop]), ((String)yyVals[-1+yyTop]));</span>
<span class="nc" id="L1933">    return yyVal;</span>
  }
};
<span class="fc" id="L1936">states[37] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L1938">                    yyVal = new OpAsgnNode(support.getPosition(((Node)yyVals[-4+yyTop])), ((Node)yyVals[-4+yyTop]), ((Node)yyVals[0+yyTop]), ((String)yyVals[-2+yyTop]), ((String)yyVals[-1+yyTop]));</span>
<span class="nc" id="L1939">    return yyVal;</span>
  }
};
<span class="fc" id="L1942">states[38] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L1944">                    support.yyerror(&quot;can't make alias for the number variables&quot;);</span>
<span class="nc" id="L1945">                    yyVal = null;</span>
<span class="nc" id="L1946">    return yyVal;</span>
  }
};
<span class="fc" id="L1949">states[39] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L1951">                    yyVal = new OpAsgnNode(support.getPosition(((Node)yyVals[-4+yyTop])), ((Node)yyVals[-4+yyTop]), ((Node)yyVals[0+yyTop]), ((String)yyVals[-2+yyTop]), ((String)yyVals[-1+yyTop]));</span>
<span class="nc" id="L1952">    return yyVal;</span>
  }
};
<span class="fc" id="L1955">states[40] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L1957">                    support.backrefAssignError(((Node)yyVals[-2+yyTop]));</span>
<span class="nc" id="L1958">    return yyVal;</span>
  }
};
<span class="fc" id="L1961">states[41] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1963">                    yyVal = support.node_assign(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L1964">    return yyVal;</span>
  }
};
<span class="fc" id="L1967">states[42] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1969">                    ((AssignableNode)yyVals[-2+yyTop]).setValueNode(((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L1970">                    yyVal = ((MultipleAsgn19Node)yyVals[-2+yyTop]);</span>
<span class="fc" id="L1971">                    ((MultipleAsgn19Node)yyVals[-2+yyTop]).setPosition(support.getPosition(((MultipleAsgn19Node)yyVals[-2+yyTop])));</span>
<span class="fc" id="L1972">    return yyVal;</span>
  }
};
<span class="fc" id="L1975">states[44] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1977">                    support.checkExpression(((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L1978">                    yyVal = support.node_assign(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L1979">    return yyVal;</span>
  }
};
<span class="fc" id="L1982">states[45] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L1984">                    support.checkExpression(((Node)yyVals[0+yyTop]));</span>
<span class="nc" id="L1985">                    yyVal = support.node_assign(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="nc" id="L1986">    return yyVal;</span>
  }
};
<span class="fc" id="L1989">states[47] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1991">                    yyVal = support.newAndNode(support.getPosition(((Node)yyVals[-2+yyTop])), ((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L1992">    return yyVal;</span>
  }
};
<span class="fc" id="L1995">states[48] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L1997">                    yyVal = support.newOrNode(support.getPosition(((Node)yyVals[-2+yyTop])), ((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L1998">    return yyVal;</span>
  }
};
<span class="fc" id="L2001">states[49] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2003">                    yyVal = support.getOperatorCallNode(support.getConditionNode(((Node)yyVals[0+yyTop])), &quot;!&quot;);</span>
<span class="fc" id="L2004">    return yyVal;</span>
  }
};
<span class="fc" id="L2007">states[50] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2009">                    yyVal = support.getOperatorCallNode(support.getConditionNode(((Node)yyVals[0+yyTop])), &quot;!&quot;);</span>
<span class="fc" id="L2010">    return yyVal;</span>
  }
};
<span class="fc" id="L2013">states[52] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2015">                    support.checkExpression(((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L2016">    return yyVal;</span>
  }
};
<span class="fc" id="L2019">states[56] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2021">                    yyVal = support.new_call(((Node)yyVals[-3+yyTop]), ((String)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), null);</span>
<span class="nc" id="L2022">    return yyVal;</span>
  }
};
<span class="fc" id="L2025">states[57] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2027">                    support.pushBlockScope();</span>
<span class="fc" id="L2028">    return yyVal;</span>
  }
};
<span class="fc" id="L2031">states[58] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2033">                    yyVal = new IterNode(((ISourcePosition)yyVals[-4+yyTop]), ((ArgsNode)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop]), support.getCurrentScope());</span>
<span class="fc" id="L2034">                    support.popCurrentScope();</span>
<span class="fc" id="L2035">    return yyVal;</span>
  }
};
<span class="fc" id="L2038">states[59] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2040">                    yyVal = support.new_fcall(((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L2041">    return yyVal;</span>
  }
};
<span class="fc" id="L2044">states[60] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2046">                    support.frobnicate_fcall_args(((FCallNode)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), null);</span>
<span class="fc" id="L2047">                    yyVal = ((FCallNode)yyVals[-1+yyTop]);</span>
<span class="fc" id="L2048">    return yyVal;</span>
  }
};
<span class="fc" id="L2051">states[61] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2053">                    support.frobnicate_fcall_args(((FCallNode)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop]), ((IterNode)yyVals[0+yyTop]));</span>
<span class="nc" id="L2054">                    yyVal = ((FCallNode)yyVals[-2+yyTop]);</span>
<span class="nc" id="L2055">    return yyVal;</span>
  }
};
<span class="fc" id="L2058">states[62] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2060">                    yyVal = support.new_call(((Node)yyVals[-3+yyTop]), ((String)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), null);</span>
<span class="fc" id="L2061">    return yyVal;</span>
  }
};
<span class="fc" id="L2064">states[63] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2066">                    yyVal = support.new_call(((Node)yyVals[-4+yyTop]), ((String)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop]), ((IterNode)yyVals[0+yyTop])); </span>
<span class="fc" id="L2067">    return yyVal;</span>
  }
};
<span class="fc" id="L2070">states[64] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2072">                    yyVal = support.new_call(((Node)yyVals[-3+yyTop]), ((String)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), null);</span>
<span class="fc" id="L2073">    return yyVal;</span>
  }
};
<span class="fc" id="L2076">states[65] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2078">                    yyVal = support.new_call(((Node)yyVals[-4+yyTop]), ((String)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop]), ((IterNode)yyVals[0+yyTop]));</span>
<span class="nc" id="L2079">    return yyVal;</span>
  }
};
<span class="fc" id="L2082">states[66] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2084">                    yyVal = support.new_super(((ISourcePosition)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L2085">    return yyVal;</span>
  }
};
<span class="fc" id="L2088">states[67] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2090">                    yyVal = support.new_yield(((ISourcePosition)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L2091">    return yyVal;</span>
  }
};
<span class="fc" id="L2094">states[68] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2096">                    yyVal = new ReturnNode(((ISourcePosition)yyVals[-1+yyTop]), support.ret_args(((Node)yyVals[0+yyTop]), ((ISourcePosition)yyVals[-1+yyTop])));</span>
<span class="fc" id="L2097">    return yyVal;</span>
  }
};
<span class="fc" id="L2100">states[69] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2102">                    yyVal = new BreakNode(((ISourcePosition)yyVals[-1+yyTop]), support.ret_args(((Node)yyVals[0+yyTop]), ((ISourcePosition)yyVals[-1+yyTop])));</span>
<span class="fc" id="L2103">    return yyVal;</span>
  }
};
<span class="fc" id="L2106">states[70] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2108">                    yyVal = new NextNode(((ISourcePosition)yyVals[-1+yyTop]), support.ret_args(((Node)yyVals[0+yyTop]), ((ISourcePosition)yyVals[-1+yyTop])));</span>
<span class="fc" id="L2109">    return yyVal;</span>
  }
};
<span class="fc" id="L2112">states[72] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2114">                    yyVal = ((Node)yyVals[-1+yyTop]);</span>
<span class="fc" id="L2115">    return yyVal;</span>
  }
};
<span class="fc" id="L2118">states[73] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2120">                    yyVal = ((MultipleAsgn19Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L2121">    return yyVal;</span>
  }
};
<span class="fc" id="L2124">states[74] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2126">                    yyVal = new MultipleAsgn19Node(((ISourcePosition)yyVals[-2+yyTop]), support.newArrayNode(((ISourcePosition)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop])), null, null);</span>
<span class="nc" id="L2127">    return yyVal;</span>
  }
};
<span class="fc" id="L2130">states[75] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2132">                    yyVal = new MultipleAsgn19Node(((ListNode)yyVals[0+yyTop]).getPosition(), ((ListNode)yyVals[0+yyTop]), null, null);</span>
<span class="fc" id="L2133">    return yyVal;</span>
  }
};
<span class="fc" id="L2136">states[76] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2138">                    yyVal = new MultipleAsgn19Node(((ListNode)yyVals[-1+yyTop]).getPosition(), ((ListNode)yyVals[-1+yyTop]).add(((Node)yyVals[0+yyTop])), null, null);</span>
<span class="fc" id="L2139">    return yyVal;</span>
  }
};
<span class="fc" id="L2142">states[77] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2144">                    yyVal = new MultipleAsgn19Node(((ListNode)yyVals[-2+yyTop]).getPosition(), ((ListNode)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]), (ListNode) null);</span>
<span class="fc" id="L2145">    return yyVal;</span>
  }
};
<span class="fc" id="L2148">states[78] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2150">                    yyVal = new MultipleAsgn19Node(((ListNode)yyVals[-4+yyTop]).getPosition(), ((ListNode)yyVals[-4+yyTop]), ((Node)yyVals[-2+yyTop]), ((ListNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L2151">    return yyVal;</span>
  }
};
<span class="fc" id="L2154">states[79] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2156">                    yyVal = new MultipleAsgn19Node(((ListNode)yyVals[-1+yyTop]).getPosition(), ((ListNode)yyVals[-1+yyTop]), new StarNode(lexer.getPosition()), null);</span>
<span class="nc" id="L2157">    return yyVal;</span>
  }
};
<span class="fc" id="L2160">states[80] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2162">                    yyVal = new MultipleAsgn19Node(((ListNode)yyVals[-3+yyTop]).getPosition(), ((ListNode)yyVals[-3+yyTop]), new StarNode(lexer.getPosition()), ((ListNode)yyVals[0+yyTop]));</span>
<span class="nc" id="L2163">    return yyVal;</span>
  }
};
<span class="fc" id="L2166">states[81] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2168">                    yyVal = new MultipleAsgn19Node(((Node)yyVals[0+yyTop]).getPosition(), null, ((Node)yyVals[0+yyTop]), null);</span>
<span class="fc" id="L2169">    return yyVal;</span>
  }
};
<span class="fc" id="L2172">states[82] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2174">                    yyVal = new MultipleAsgn19Node(((Node)yyVals[-2+yyTop]).getPosition(), null, ((Node)yyVals[-2+yyTop]), ((ListNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L2175">    return yyVal;</span>
  }
};
<span class="fc" id="L2178">states[83] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2180">                      yyVal = new MultipleAsgn19Node(lexer.getPosition(), null, new StarNode(lexer.getPosition()), null);</span>
<span class="fc" id="L2181">    return yyVal;</span>
  }
};
<span class="fc" id="L2184">states[84] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2186">                      yyVal = new MultipleAsgn19Node(lexer.getPosition(), null, new StarNode(lexer.getPosition()), ((ListNode)yyVals[0+yyTop]));</span>
<span class="nc" id="L2187">    return yyVal;</span>
  }
};
<span class="fc" id="L2190">states[86] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2192">                    yyVal = ((Node)yyVals[-1+yyTop]);</span>
<span class="fc" id="L2193">    return yyVal;</span>
  }
};
<span class="fc" id="L2196">states[87] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2198">                    yyVal = support.newArrayNode(((Node)yyVals[-1+yyTop]).getPosition(), ((Node)yyVals[-1+yyTop]));</span>
<span class="fc" id="L2199">    return yyVal;</span>
  }
};
<span class="fc" id="L2202">states[88] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2204">                    yyVal = ((ListNode)yyVals[-2+yyTop]).add(((Node)yyVals[-1+yyTop]));</span>
<span class="fc" id="L2205">    return yyVal;</span>
  }
};
<span class="fc" id="L2208">states[89] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2210">                    yyVal = support.newArrayNode(((Node)yyVals[0+yyTop]).getPosition(), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L2211">    return yyVal;</span>
  }
};
<span class="fc" id="L2214">states[90] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2216">                    yyVal = ((ListNode)yyVals[-2+yyTop]).add(((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L2217">    return yyVal;</span>
  }
};
<span class="fc" id="L2220">states[91] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2222">                    yyVal = support.assignableLabelOrIdentifier(((String)yyVals[0+yyTop]), null);</span>
<span class="fc" id="L2223">    return yyVal;</span>
  }
};
<span class="fc" id="L2226">states[92] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2228">                   yyVal = new InstAsgnNode(lexer.getPosition(), ((String)yyVals[0+yyTop]), NilImplicitNode.NIL);</span>
<span class="fc" id="L2229">    return yyVal;</span>
  }
};
<span class="fc" id="L2232">states[93] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2234">                   yyVal = new GlobalAsgnNode(lexer.getPosition(), ((String)yyVals[0+yyTop]), NilImplicitNode.NIL);</span>
<span class="fc" id="L2235">    return yyVal;</span>
  }
};
<span class="fc" id="L2238">states[94] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc bnc" id="L2240" title="All 4 branches missed.">                    if (support.isInDef() || support.isInSingle()) support.compile_error(&quot;dynamic constant assignment&quot;);</span>

<span class="nc" id="L2242">                    yyVal = new ConstDeclNode(lexer.getPosition(), ((String)yyVals[0+yyTop]), null, NilImplicitNode.NIL);</span>
<span class="nc" id="L2243">    return yyVal;</span>
  }
};
<span class="fc" id="L2246">states[95] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2248">                    yyVal = new ClassVarAsgnNode(lexer.getPosition(), ((String)yyVals[0+yyTop]), NilImplicitNode.NIL);</span>
<span class="fc" id="L2249">    return yyVal;</span>
  }
};
<span class="fc" id="L2252">states[96] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2254">                    support.compile_error(&quot;Can't assign to nil&quot;);</span>
<span class="nc" id="L2255">                    yyVal = null;</span>
<span class="nc" id="L2256">    return yyVal;</span>
  }
};
<span class="fc" id="L2259">states[97] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2261">                    support.compile_error(&quot;Can't change the value of self&quot;);</span>
<span class="nc" id="L2262">                    yyVal = null;</span>
<span class="nc" id="L2263">    return yyVal;</span>
  }
};
<span class="fc" id="L2266">states[98] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2268">                    support.compile_error(&quot;Can't assign to true&quot;);</span>
<span class="nc" id="L2269">                    yyVal = null;</span>
<span class="nc" id="L2270">    return yyVal;</span>
  }
};
<span class="fc" id="L2273">states[99] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2275">                    support.compile_error(&quot;Can't assign to false&quot;);</span>
<span class="nc" id="L2276">                    yyVal = null;</span>
<span class="nc" id="L2277">    return yyVal;</span>
  }
};
<span class="fc" id="L2280">states[100] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2282">                    support.compile_error(&quot;Can't assign to __FILE__&quot;);</span>
<span class="nc" id="L2283">                    yyVal = null;</span>
<span class="nc" id="L2284">    return yyVal;</span>
  }
};
<span class="fc" id="L2287">states[101] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2289">                    support.compile_error(&quot;Can't assign to __LINE__&quot;);</span>
<span class="nc" id="L2290">                    yyVal = null;</span>
<span class="nc" id="L2291">    return yyVal;</span>
  }
};
<span class="fc" id="L2294">states[102] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2296">                    support.compile_error(&quot;Can't assign to __ENCODING__&quot;);</span>
<span class="nc" id="L2297">                    yyVal = null;</span>
<span class="nc" id="L2298">    return yyVal;</span>
  }
};
<span class="fc" id="L2301">states[103] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2303">                    yyVal = support.aryset(((Node)yyVals[-3+yyTop]), ((Node)yyVals[-1+yyTop]));</span>
<span class="fc" id="L2304">    return yyVal;</span>
  }
};
<span class="fc" id="L2307">states[104] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2309">                    yyVal = support.attrset(((Node)yyVals[-2+yyTop]), ((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L2310">    return yyVal;</span>
  }
};
<span class="fc" id="L2313">states[105] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2315">                    yyVal = support.attrset(((Node)yyVals[-2+yyTop]), ((String)yyVals[0+yyTop]));</span>
<span class="nc" id="L2316">    return yyVal;</span>
  }
};
<span class="fc" id="L2319">states[106] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2321">                    yyVal = support.attrset(((Node)yyVals[-2+yyTop]), ((String)yyVals[0+yyTop]));</span>
<span class="nc" id="L2322">    return yyVal;</span>
  }
};
<span class="fc" id="L2325">states[107] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc bnc" id="L2327" title="All 4 branches missed.">                    if (support.isInDef() || support.isInSingle()) {</span>
<span class="nc" id="L2328">                        support.yyerror(&quot;dynamic constant assignment&quot;);</span>
                    }

<span class="nc" id="L2331">                    ISourcePosition position = support.getPosition(((Node)yyVals[-2+yyTop]));</span>

<span class="nc" id="L2333">                    yyVal = new ConstDeclNode(position, null, support.new_colon2(position, ((Node)yyVals[-2+yyTop]), ((String)yyVals[0+yyTop])), NilImplicitNode.NIL);</span>
<span class="nc" id="L2334">    return yyVal;</span>
  }
};
<span class="fc" id="L2337">states[108] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc bnc" id="L2339" title="All 4 branches missed.">                    if (support.isInDef() || support.isInSingle()) {</span>
<span class="nc" id="L2340">                        support.yyerror(&quot;dynamic constant assignment&quot;);</span>
                    }

<span class="nc" id="L2343">                    ISourcePosition position = lexer.getPosition();</span>

<span class="nc" id="L2345">                    yyVal = new ConstDeclNode(position, null, support.new_colon3(position, ((String)yyVals[0+yyTop])), NilImplicitNode.NIL);</span>
<span class="nc" id="L2346">    return yyVal;</span>
  }
};
<span class="fc" id="L2349">states[109] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2351">                    support.backrefAssignError(((Node)yyVals[0+yyTop]));</span>
<span class="nc" id="L2352">    return yyVal;</span>
  }
};
<span class="fc" id="L2355">states[110] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2357">                    yyVal = support.assignableLabelOrIdentifier(((String)yyVals[0+yyTop]), null);</span>
<span class="fc" id="L2358">    return yyVal;</span>
  }
};
<span class="fc" id="L2361">states[111] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2363">                   yyVal = new InstAsgnNode(lexer.getPosition(), ((String)yyVals[0+yyTop]), NilImplicitNode.NIL);</span>
<span class="fc" id="L2364">    return yyVal;</span>
  }
};
<span class="fc" id="L2367">states[112] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2369">                   yyVal = new GlobalAsgnNode(lexer.getPosition(), ((String)yyVals[0+yyTop]), NilImplicitNode.NIL);</span>
<span class="fc" id="L2370">    return yyVal;</span>
  }
};
<span class="fc" id="L2373">states[113] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L2375" title="2 of 4 branches missed.">                    if (support.isInDef() || support.isInSingle()) support.compile_error(&quot;dynamic constant assignment&quot;);</span>

<span class="fc" id="L2377">                    yyVal = new ConstDeclNode(lexer.getPosition(), ((String)yyVals[0+yyTop]), null, NilImplicitNode.NIL);</span>
<span class="fc" id="L2378">    return yyVal;</span>
  }
};
<span class="fc" id="L2381">states[114] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2383">                    yyVal = new ClassVarAsgnNode(lexer.getPosition(), ((String)yyVals[0+yyTop]), NilImplicitNode.NIL);</span>
<span class="fc" id="L2384">    return yyVal;</span>
  }
};
<span class="fc" id="L2387">states[115] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2389">                    support.compile_error(&quot;Can't assign to nil&quot;);</span>
<span class="nc" id="L2390">                    yyVal = null;</span>
<span class="nc" id="L2391">    return yyVal;</span>
  }
};
<span class="fc" id="L2394">states[116] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2396">                    support.compile_error(&quot;Can't change the value of self&quot;);</span>
<span class="nc" id="L2397">                    yyVal = null;</span>
<span class="nc" id="L2398">    return yyVal;</span>
  }
};
<span class="fc" id="L2401">states[117] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2403">                    support.compile_error(&quot;Can't assign to true&quot;);</span>
<span class="nc" id="L2404">                    yyVal = null;</span>
<span class="nc" id="L2405">    return yyVal;</span>
  }
};
<span class="fc" id="L2408">states[118] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2410">                    support.compile_error(&quot;Can't assign to false&quot;);</span>
<span class="nc" id="L2411">                    yyVal = null;</span>
<span class="nc" id="L2412">    return yyVal;</span>
  }
};
<span class="fc" id="L2415">states[119] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2417">                    support.compile_error(&quot;Can't assign to __FILE__&quot;);</span>
<span class="nc" id="L2418">                    yyVal = null;</span>
<span class="nc" id="L2419">    return yyVal;</span>
  }
};
<span class="fc" id="L2422">states[120] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2424">                    support.compile_error(&quot;Can't assign to __LINE__&quot;);</span>
<span class="nc" id="L2425">                    yyVal = null;</span>
<span class="nc" id="L2426">    return yyVal;</span>
  }
};
<span class="fc" id="L2429">states[121] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2431">                    support.compile_error(&quot;Can't assign to __ENCODING__&quot;);</span>
<span class="nc" id="L2432">                    yyVal = null;</span>
<span class="nc" id="L2433">    return yyVal;</span>
  }
};
<span class="fc" id="L2436">states[122] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2438">                    yyVal = support.aryset(((Node)yyVals[-3+yyTop]), ((Node)yyVals[-1+yyTop]));</span>
<span class="fc" id="L2439">    return yyVal;</span>
  }
};
<span class="fc" id="L2442">states[123] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2444">                    yyVal = support.attrset(((Node)yyVals[-2+yyTop]), ((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L2445">    return yyVal;</span>
  }
};
<span class="fc" id="L2448">states[124] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2450">                    yyVal = support.attrset(((Node)yyVals[-2+yyTop]), ((String)yyVals[0+yyTop]));</span>
<span class="nc" id="L2451">    return yyVal;</span>
  }
};
<span class="fc" id="L2454">states[125] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2456">                    yyVal = support.attrset(((Node)yyVals[-2+yyTop]), ((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L2457">    return yyVal;</span>
  }
};
<span class="fc" id="L2460">states[126] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L2462" title="2 of 4 branches missed.">                    if (support.isInDef() || support.isInSingle()) {</span>
<span class="nc" id="L2463">                        support.yyerror(&quot;dynamic constant assignment&quot;);</span>
                    }

<span class="fc" id="L2466">                    ISourcePosition position = support.getPosition(((Node)yyVals[-2+yyTop]));</span>

<span class="fc" id="L2468">                    yyVal = new ConstDeclNode(position, null, support.new_colon2(position, ((Node)yyVals[-2+yyTop]), ((String)yyVals[0+yyTop])), NilImplicitNode.NIL);</span>
<span class="fc" id="L2469">    return yyVal;</span>
  }
};
<span class="fc" id="L2472">states[127] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L2474" title="2 of 4 branches missed.">                    if (support.isInDef() || support.isInSingle()) {</span>
<span class="nc" id="L2475">                        support.yyerror(&quot;dynamic constant assignment&quot;);</span>
                    }

<span class="fc" id="L2478">                    ISourcePosition position = lexer.getPosition();</span>

<span class="fc" id="L2480">                    yyVal = new ConstDeclNode(position, null, support.new_colon3(position, ((String)yyVals[0+yyTop])), NilImplicitNode.NIL);</span>
<span class="fc" id="L2481">    return yyVal;</span>
  }
};
<span class="fc" id="L2484">states[128] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2486">                    support.backrefAssignError(((Node)yyVals[0+yyTop]));</span>
<span class="nc" id="L2487">    return yyVal;</span>
  }
};
<span class="fc" id="L2490">states[129] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2492">                    support.yyerror(&quot;class/module name must be CONSTANT&quot;);</span>
<span class="nc" id="L2493">    return yyVal;</span>
  }
};
<span class="fc" id="L2496">states[131] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2498">                    yyVal = support.new_colon3(lexer.getPosition(), ((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L2499">    return yyVal;</span>
  }
};
<span class="fc" id="L2502">states[132] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2504">                    yyVal = support.new_colon2(lexer.getPosition(), null, ((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L2505">    return yyVal;</span>
  }
};
<span class="fc" id="L2508">states[133] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2510">                    yyVal = support.new_colon2(support.getPosition(((Node)yyVals[-2+yyTop])), ((Node)yyVals[-2+yyTop]), ((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L2511">    return yyVal;</span>
  }
};
<span class="fc" id="L2514">states[137] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2516">                   lexer.setState(LexState.EXPR_ENDFN);</span>
<span class="fc" id="L2517">                   yyVal = ((String)yyVals[0+yyTop]);</span>
<span class="fc" id="L2518">    return yyVal;</span>
  }
};
<span class="fc" id="L2521">states[138] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2523">                   lexer.setState(LexState.EXPR_ENDFN);</span>
<span class="fc" id="L2524">                   yyVal = ((String)yyVals[0+yyTop]);</span>
<span class="fc" id="L2525">    return yyVal;</span>
  }
};
<span class="fc" id="L2528">states[139] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2530">                    yyVal = new LiteralNode(lexer.getPosition(), ((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L2531">    return yyVal;</span>
  }
};
<span class="fc" id="L2534">states[140] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2536">                    yyVal = new LiteralNode(lexer.getPosition(), ((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L2537">    return yyVal;</span>
  }
};
<span class="fc" id="L2540">states[141] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2542">                    yyVal = ((LiteralNode)yyVals[0+yyTop]);</span>
<span class="fc" id="L2543">    return yyVal;</span>
  }
};
<span class="fc" id="L2546">states[142] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2548">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="nc" id="L2549">    return yyVal;</span>
  }
};
<span class="fc" id="L2552">states[143] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2554">                    yyVal = support.newUndef(((Node)yyVals[0+yyTop]).getPosition(), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L2555">    return yyVal;</span>
  }
};
<span class="fc" id="L2558">states[144] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2560">                    lexer.setState(LexState.EXPR_FNAME);</span>
<span class="nc" id="L2561">    return yyVal;</span>
  }
};
<span class="fc" id="L2564">states[145] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2566">                    yyVal = support.appendToBlock(((Node)yyVals[-3+yyTop]), support.newUndef(((Node)yyVals[-3+yyTop]).getPosition(), ((Node)yyVals[0+yyTop])));</span>
<span class="nc" id="L2567">    return yyVal;</span>
  }
};
<span class="fc" id="L2570">states[176] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2572">                    yyVal = &quot;__LINE__&quot;;</span>
<span class="nc" id="L2573">    return yyVal;</span>
  }
};
<span class="fc" id="L2576">states[177] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2578">                    yyVal = &quot;__FILE__&quot;;</span>
<span class="nc" id="L2579">    return yyVal;</span>
  }
};
<span class="fc" id="L2582">states[178] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2584">                    yyVal = &quot;__ENCODING__&quot;;</span>
<span class="nc" id="L2585">    return yyVal;</span>
  }
};
<span class="fc" id="L2588">states[179] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2590">                    yyVal = &quot;BEGIN&quot;;</span>
<span class="nc" id="L2591">    return yyVal;</span>
  }
};
<span class="fc" id="L2594">states[180] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2596">                    yyVal = &quot;END&quot;;</span>
<span class="nc" id="L2597">    return yyVal;</span>
  }
};
<span class="fc" id="L2600">states[181] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2602">                    yyVal = &quot;alias&quot;;</span>
<span class="nc" id="L2603">    return yyVal;</span>
  }
};
<span class="fc" id="L2606">states[182] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2608">                    yyVal = &quot;and&quot;;</span>
<span class="nc" id="L2609">    return yyVal;</span>
  }
};
<span class="fc" id="L2612">states[183] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2614">                    yyVal = &quot;begin&quot;;</span>
<span class="fc" id="L2615">    return yyVal;</span>
  }
};
<span class="fc" id="L2618">states[184] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2620">                    yyVal = &quot;break&quot;;</span>
<span class="fc" id="L2621">    return yyVal;</span>
  }
};
<span class="fc" id="L2624">states[185] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2626">                    yyVal = &quot;case&quot;;</span>
<span class="nc" id="L2627">    return yyVal;</span>
  }
};
<span class="fc" id="L2630">states[186] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2632">                    yyVal = &quot;class&quot;;</span>
<span class="fc" id="L2633">    return yyVal;</span>
  }
};
<span class="fc" id="L2636">states[187] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2638">                    yyVal = &quot;def&quot;;</span>
<span class="fc" id="L2639">    return yyVal;</span>
  }
};
<span class="fc" id="L2642">states[188] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2644">                    yyVal = &quot;defined?&quot;;</span>
<span class="nc" id="L2645">    return yyVal;</span>
  }
};
<span class="fc" id="L2648">states[189] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2650">                    yyVal = &quot;do&quot;;</span>
<span class="fc" id="L2651">    return yyVal;</span>
  }
};
<span class="fc" id="L2654">states[190] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2656">                    yyVal = &quot;else&quot;;</span>
<span class="nc" id="L2657">    return yyVal;</span>
  }
};
<span class="fc" id="L2660">states[191] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2662">                    yyVal = &quot;elsif&quot;;</span>
<span class="nc" id="L2663">    return yyVal;</span>
  }
};
<span class="fc" id="L2666">states[192] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2668">                    yyVal = &quot;end&quot;;</span>
<span class="fc" id="L2669">    return yyVal;</span>
  }
};
<span class="fc" id="L2672">states[193] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2674">                    yyVal = &quot;ensure&quot;;</span>
<span class="fc" id="L2675">    return yyVal;</span>
  }
};
<span class="fc" id="L2678">states[194] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2680">                    yyVal = &quot;false&quot;;</span>
<span class="nc" id="L2681">    return yyVal;</span>
  }
};
<span class="fc" id="L2684">states[195] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2686">                    yyVal = &quot;for&quot;;</span>
<span class="nc" id="L2687">    return yyVal;</span>
  }
};
<span class="fc" id="L2690">states[196] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2692">                    yyVal = &quot;in&quot;;</span>
<span class="fc" id="L2693">    return yyVal;</span>
  }
};
<span class="fc" id="L2696">states[197] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2698">                    yyVal = &quot;module&quot;;</span>
<span class="fc" id="L2699">    return yyVal;</span>
  }
};
<span class="fc" id="L2702">states[198] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2704">                    yyVal = &quot;next&quot;;</span>
<span class="fc" id="L2705">    return yyVal;</span>
  }
};
<span class="fc" id="L2708">states[199] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2710">                    yyVal = &quot;nil&quot;;</span>
<span class="fc" id="L2711">    return yyVal;</span>
  }
};
<span class="fc" id="L2714">states[200] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2716">                    yyVal = &quot;not&quot;;</span>
<span class="nc" id="L2717">    return yyVal;</span>
  }
};
<span class="fc" id="L2720">states[201] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2722">                    yyVal = &quot;or&quot;;</span>
<span class="nc" id="L2723">    return yyVal;</span>
  }
};
<span class="fc" id="L2726">states[202] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2728">                    yyVal = &quot;redo&quot;;</span>
<span class="nc" id="L2729">    return yyVal;</span>
  }
};
<span class="fc" id="L2732">states[203] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2734">                    yyVal = &quot;rescue&quot;;</span>
<span class="nc" id="L2735">    return yyVal;</span>
  }
};
<span class="fc" id="L2738">states[204] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2740">                    yyVal = &quot;retry&quot;;</span>
<span class="nc" id="L2741">    return yyVal;</span>
  }
};
<span class="fc" id="L2744">states[205] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2746">                    yyVal = &quot;return&quot;;</span>
<span class="nc" id="L2747">    return yyVal;</span>
  }
};
<span class="fc" id="L2750">states[206] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2752">                    yyVal = &quot;self&quot;;</span>
<span class="fc" id="L2753">    return yyVal;</span>
  }
};
<span class="fc" id="L2756">states[207] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2758">                    yyVal = &quot;super&quot;;</span>
<span class="nc" id="L2759">    return yyVal;</span>
  }
};
<span class="fc" id="L2762">states[208] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2764">                    yyVal = &quot;then&quot;;</span>
<span class="nc" id="L2765">    return yyVal;</span>
  }
};
<span class="fc" id="L2768">states[209] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2770">                    yyVal = &quot;true&quot;;</span>
<span class="fc" id="L2771">    return yyVal;</span>
  }
};
<span class="fc" id="L2774">states[210] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2776">                    yyVal = &quot;undef&quot;;</span>
<span class="fc" id="L2777">    return yyVal;</span>
  }
};
<span class="fc" id="L2780">states[211] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2782">                    yyVal = &quot;when&quot;;</span>
<span class="nc" id="L2783">    return yyVal;</span>
  }
};
<span class="fc" id="L2786">states[212] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2788">                    yyVal = &quot;yield&quot;;</span>
<span class="fc" id="L2789">    return yyVal;</span>
  }
};
<span class="fc" id="L2792">states[213] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2794">                    yyVal = &quot;if&quot;;</span>
<span class="nc" id="L2795">    return yyVal;</span>
  }
};
<span class="fc" id="L2798">states[214] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2800">                    yyVal = &quot;unless&quot;;</span>
<span class="nc" id="L2801">    return yyVal;</span>
  }
};
<span class="fc" id="L2804">states[215] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2806">                    yyVal = &quot;while&quot;;</span>
<span class="nc" id="L2807">    return yyVal;</span>
  }
};
<span class="fc" id="L2810">states[216] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2812">                    yyVal = &quot;until&quot;;</span>
<span class="nc" id="L2813">    return yyVal;</span>
  }
};
<span class="fc" id="L2816">states[217] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2818">                    yyVal = &quot;rescue&quot;;</span>
<span class="fc" id="L2819">    return yyVal;</span>
  }
};
<span class="fc" id="L2822">states[218] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2824">                    yyVal = support.node_assign(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));</span>
                    /* FIXME: Consider fixing node_assign itself rather than single case*/
<span class="fc" id="L2826">                    ((Node)yyVal).setPosition(support.getPosition(((Node)yyVals[-2+yyTop])));</span>
<span class="fc" id="L2827">    return yyVal;</span>
  }
};
<span class="fc" id="L2830">states[219] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2832">                    ISourcePosition position = support.getPosition(((Node)yyVals[-4+yyTop]));</span>
<span class="pc bpc" id="L2833" title="1 of 2 branches missed.">                    Node body = ((Node)yyVals[0+yyTop]) == null ? NilImplicitNode.NIL : ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L2834">                    yyVal = support.node_assign(((Node)yyVals[-4+yyTop]), new RescueNode(position, ((Node)yyVals[-2+yyTop]), new RescueBodyNode(position, null, body, null), null));</span>
<span class="fc" id="L2835">    return yyVal;</span>
  }
};
<span class="fc" id="L2838">states[220] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2840">                    support.checkExpression(((Node)yyVals[0+yyTop]));</span>

<span class="fc" id="L2842">                    ISourcePosition pos = ((AssignableNode)yyVals[-2+yyTop]).getPosition();</span>
<span class="fc" id="L2843">                    String asgnOp = ((String)yyVals[-1+yyTop]);</span>
<span class="fc bfc" id="L2844" title="All 2 branches covered.">                    if (asgnOp.equals(&quot;||&quot;)) {</span>
<span class="fc" id="L2845">                        ((AssignableNode)yyVals[-2+yyTop]).setValueNode(((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L2846">                        yyVal = new OpAsgnOrNode(pos, support.gettable2(((AssignableNode)yyVals[-2+yyTop])), ((AssignableNode)yyVals[-2+yyTop]));</span>
<span class="fc bfc" id="L2847" title="All 2 branches covered.">                    } else if (asgnOp.equals(&quot;&amp;&amp;&quot;)) {</span>
<span class="fc" id="L2848">                        ((AssignableNode)yyVals[-2+yyTop]).setValueNode(((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L2849">                        yyVal = new OpAsgnAndNode(pos, support.gettable2(((AssignableNode)yyVals[-2+yyTop])), ((AssignableNode)yyVals[-2+yyTop]));</span>
                    } else {
<span class="fc" id="L2851">                        ((AssignableNode)yyVals[-2+yyTop]).setValueNode(support.getOperatorCallNode(support.gettable2(((AssignableNode)yyVals[-2+yyTop])), asgnOp, ((Node)yyVals[0+yyTop])));</span>
<span class="fc" id="L2852">                        ((AssignableNode)yyVals[-2+yyTop]).setPosition(pos);</span>
<span class="fc" id="L2853">                        yyVal = ((AssignableNode)yyVals[-2+yyTop]);</span>
                    }
<span class="fc" id="L2855">    return yyVal;</span>
  }
};
<span class="fc" id="L2858">states[221] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2860">                    support.checkExpression(((Node)yyVals[-2+yyTop]));</span>
<span class="fc" id="L2861">                    ISourcePosition pos = support.getPosition(((Node)yyVals[0+yyTop]));</span>
<span class="pc bpc" id="L2862" title="1 of 2 branches missed.">                    Node body = ((Node)yyVals[0+yyTop]) == null ? NilImplicitNode.NIL : ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L2863">                    Node rescue = new RescueNode(pos, ((Node)yyVals[-2+yyTop]), new RescueBodyNode(support.getPosition(((Node)yyVals[-2+yyTop])), null, body, null), null);</span>

<span class="fc" id="L2865">                    pos = ((AssignableNode)yyVals[-4+yyTop]).getPosition();</span>
<span class="fc" id="L2866">                    String asgnOp = ((String)yyVals[-3+yyTop]);</span>
<span class="pc bpc" id="L2867" title="1 of 2 branches missed.">                    if (asgnOp.equals(&quot;||&quot;)) {</span>
<span class="nc" id="L2868">                        ((AssignableNode)yyVals[-4+yyTop]).setValueNode(rescue);</span>
<span class="nc" id="L2869">                        yyVal = new OpAsgnOrNode(pos, support.gettable2(((AssignableNode)yyVals[-4+yyTop])), ((AssignableNode)yyVals[-4+yyTop]));</span>
<span class="pc bpc" id="L2870" title="1 of 2 branches missed.">                    } else if (asgnOp.equals(&quot;&amp;&amp;&quot;)) {</span>
<span class="nc" id="L2871">                        ((AssignableNode)yyVals[-4+yyTop]).setValueNode(rescue);</span>
<span class="nc" id="L2872">                        yyVal = new OpAsgnAndNode(pos, support.gettable2(((AssignableNode)yyVals[-4+yyTop])), ((AssignableNode)yyVals[-4+yyTop]));</span>
                    } else {
<span class="fc" id="L2874">                        ((AssignableNode)yyVals[-4+yyTop]).setValueNode(support.getOperatorCallNode(support.gettable2(((AssignableNode)yyVals[-4+yyTop])), asgnOp, rescue));</span>
<span class="fc" id="L2875">                        ((AssignableNode)yyVals[-4+yyTop]).setPosition(pos);</span>
<span class="fc" id="L2876">                        yyVal = ((AssignableNode)yyVals[-4+yyTop]);</span>
                    }
<span class="fc" id="L2878">    return yyVal;</span>
  }
};
<span class="fc" id="L2881">states[222] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
  /* FIXME: arg_concat missing for opt_call_args*/
<span class="fc" id="L2884">                    yyVal = support.new_opElementAsgnNode(((Node)yyVals[-5+yyTop]), ((String)yyVals[-1+yyTop]), ((Node)yyVals[-3+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L2885">    return yyVal;</span>
  }
};
<span class="fc" id="L2888">states[223] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2890">                    yyVal = new OpAsgnNode(support.getPosition(((Node)yyVals[-4+yyTop])), ((Node)yyVals[-4+yyTop]), ((Node)yyVals[0+yyTop]), ((String)yyVals[-2+yyTop]), ((String)yyVals[-1+yyTop]));</span>
<span class="fc" id="L2891">    return yyVal;</span>
  }
};
<span class="fc" id="L2894">states[224] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2896">                    yyVal = new OpAsgnNode(support.getPosition(((Node)yyVals[-4+yyTop])), ((Node)yyVals[-4+yyTop]), ((Node)yyVals[0+yyTop]), ((String)yyVals[-2+yyTop]), ((String)yyVals[-1+yyTop]));</span>
<span class="nc" id="L2897">    return yyVal;</span>
  }
};
<span class="fc" id="L2900">states[225] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2902">                    yyVal = new OpAsgnNode(support.getPosition(((Node)yyVals[-4+yyTop])), ((Node)yyVals[-4+yyTop]), ((Node)yyVals[0+yyTop]), ((String)yyVals[-2+yyTop]), ((String)yyVals[-1+yyTop]));</span>
<span class="nc" id="L2903">    return yyVal;</span>
  }
};
<span class="fc" id="L2906">states[226] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2908">                    support.yyerror(&quot;constant re-assignment&quot;);</span>
<span class="nc" id="L2909">    return yyVal;</span>
  }
};
<span class="fc" id="L2912">states[227] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2914">                    support.yyerror(&quot;constant re-assignment&quot;);</span>
<span class="nc" id="L2915">    return yyVal;</span>
  }
};
<span class="fc" id="L2918">states[228] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L2920">                    support.backrefAssignError(((Node)yyVals[-2+yyTop]));</span>
<span class="nc" id="L2921">    return yyVal;</span>
  }
};
<span class="fc" id="L2924">states[229] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2926">                    support.checkExpression(((Node)yyVals[-2+yyTop]));</span>
<span class="fc" id="L2927">                    support.checkExpression(((Node)yyVals[0+yyTop]));</span>
    
<span class="fc bfc" id="L2929" title="All 4 branches covered.">                    boolean isLiteral = ((Node)yyVals[-2+yyTop]) instanceof FixnumNode &amp;&amp; ((Node)yyVals[0+yyTop]) instanceof FixnumNode;</span>
<span class="fc" id="L2930">                    yyVal = new DotNode(support.getPosition(((Node)yyVals[-2+yyTop])), ((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]), false, isLiteral);</span>
<span class="fc" id="L2931">    return yyVal;</span>
  }
};
<span class="fc" id="L2934">states[230] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2936">                    support.checkExpression(((Node)yyVals[-2+yyTop]));</span>
<span class="fc" id="L2937">                    support.checkExpression(((Node)yyVals[0+yyTop]));</span>

<span class="fc bfc" id="L2939" title="All 4 branches covered.">                    boolean isLiteral = ((Node)yyVals[-2+yyTop]) instanceof FixnumNode &amp;&amp; ((Node)yyVals[0+yyTop]) instanceof FixnumNode;</span>
<span class="fc" id="L2940">                    yyVal = new DotNode(support.getPosition(((Node)yyVals[-2+yyTop])), ((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]), true, isLiteral);</span>
<span class="fc" id="L2941">    return yyVal;</span>
  }
};
<span class="fc" id="L2944">states[231] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2946">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;+&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L2947">    return yyVal;</span>
  }
};
<span class="fc" id="L2950">states[232] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2952">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;-&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L2953">    return yyVal;</span>
  }
};
<span class="fc" id="L2956">states[233] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2958">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;*&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L2959">    return yyVal;</span>
  }
};
<span class="fc" id="L2962">states[234] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2964">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;/&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L2965">    return yyVal;</span>
  }
};
<span class="fc" id="L2968">states[235] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2970">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;%&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L2971">    return yyVal;</span>
  }
};
<span class="fc" id="L2974">states[236] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2976">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;**&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L2977">    return yyVal;</span>
  }
};
<span class="fc" id="L2980">states[237] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2982">                    yyVal = support.getOperatorCallNode(support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;**&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition()), &quot;-@&quot;);</span>
<span class="fc" id="L2983">    return yyVal;</span>
  }
};
<span class="fc" id="L2986">states[238] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2988">                    yyVal = support.getOperatorCallNode(((Node)yyVals[0+yyTop]), &quot;+@&quot;);</span>
<span class="fc" id="L2989">    return yyVal;</span>
  }
};
<span class="fc" id="L2992">states[239] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L2994">                    yyVal = support.getOperatorCallNode(((Node)yyVals[0+yyTop]), &quot;-@&quot;);</span>
<span class="fc" id="L2995">    return yyVal;</span>
  }
};
<span class="fc" id="L2998">states[240] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3000">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;|&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L3001">    return yyVal;</span>
  }
};
<span class="fc" id="L3004">states[241] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3006">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;^&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L3007">    return yyVal;</span>
  }
};
<span class="fc" id="L3010">states[242] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3012">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;&amp;&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L3013">    return yyVal;</span>
  }
};
<span class="fc" id="L3016">states[243] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3018">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;&lt;=&gt;&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L3019">    return yyVal;</span>
  }
};
<span class="fc" id="L3022">states[244] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3024">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;&gt;&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L3025">    return yyVal;</span>
  }
};
<span class="fc" id="L3028">states[245] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3030">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;&gt;=&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L3031">    return yyVal;</span>
  }
};
<span class="fc" id="L3034">states[246] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3036">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;&lt;&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L3037">    return yyVal;</span>
  }
};
<span class="fc" id="L3040">states[247] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3042">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;&lt;=&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L3043">    return yyVal;</span>
  }
};
<span class="fc" id="L3046">states[248] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3048">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;==&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L3049">    return yyVal;</span>
  }
};
<span class="fc" id="L3052">states[249] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3054">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;===&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L3055">    return yyVal;</span>
  }
};
<span class="fc" id="L3058">states[250] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3060">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;!=&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L3061">    return yyVal;</span>
  }
};
<span class="fc" id="L3064">states[251] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3066">                    yyVal = support.getMatchNode(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));</span>
                  /* ENEBO
                        $$ = match_op($1, $3);
                        if (nd_type($1) == NODE_LIT &amp;&amp; TYPE($1-&gt;nd_lit) == T_REGEXP) {
                            $$ = reg_named_capture_assign($1-&gt;nd_lit, $$);
                        }
                  */
<span class="fc" id="L3073">    return yyVal;</span>
  }
};
<span class="fc" id="L3076">states[252] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3078">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;!~&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L3079">    return yyVal;</span>
  }
};
<span class="fc" id="L3082">states[253] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3084">                    yyVal = support.getOperatorCallNode(support.getConditionNode(((Node)yyVals[0+yyTop])), &quot;!&quot;);</span>
<span class="fc" id="L3085">    return yyVal;</span>
  }
};
<span class="fc" id="L3088">states[254] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3090">                    yyVal = support.getOperatorCallNode(((Node)yyVals[0+yyTop]), &quot;~&quot;);</span>
<span class="fc" id="L3091">    return yyVal;</span>
  }
};
<span class="fc" id="L3094">states[255] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3096">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;&lt;&lt;&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L3097">    return yyVal;</span>
  }
};
<span class="fc" id="L3100">states[256] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3102">                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), &quot;&gt;&gt;&quot;, ((Node)yyVals[0+yyTop]), lexer.getPosition());</span>
<span class="fc" id="L3103">    return yyVal;</span>
  }
};
<span class="fc" id="L3106">states[257] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3108">                    yyVal = support.newAndNode(((Node)yyVals[-2+yyTop]).getPosition(), ((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L3109">    return yyVal;</span>
  }
};
<span class="fc" id="L3112">states[258] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3114">                    yyVal = support.newOrNode(((Node)yyVals[-2+yyTop]).getPosition(), ((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L3115">    return yyVal;</span>
  }
};
<span class="fc" id="L3118">states[259] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3120">                    yyVal = support.new_defined(((ISourcePosition)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L3121">    return yyVal;</span>
  }
};
<span class="fc" id="L3124">states[260] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3126">                    yyVal = new IfNode(support.getPosition(((Node)yyVals[-5+yyTop])), support.getConditionNode(((Node)yyVals[-5+yyTop])), ((Node)yyVals[-3+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L3127">    return yyVal;</span>
  }
};
<span class="fc" id="L3130">states[261] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3132">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L3133">    return yyVal;</span>
  }
};
<span class="fc" id="L3136">states[262] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3138">                    support.checkExpression(((Node)yyVals[0+yyTop]));</span>
<span class="pc bpc" id="L3139" title="1 of 2 branches missed.">                    yyVal = ((Node)yyVals[0+yyTop]) != null ? ((Node)yyVals[0+yyTop]) : NilImplicitNode.NIL;</span>
<span class="fc" id="L3140">    return yyVal;</span>
  }
};
<span class="fc" id="L3143">states[264] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3145">                    yyVal = ((Node)yyVals[-1+yyTop]);</span>
<span class="fc" id="L3146">    return yyVal;</span>
  }
};
<span class="fc" id="L3149">states[265] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3151">                    yyVal = support.arg_append(((Node)yyVals[-3+yyTop]), ((HashNode)yyVals[-1+yyTop]));</span>
<span class="fc" id="L3152">    return yyVal;</span>
  }
};
<span class="fc" id="L3155">states[266] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3157">                    yyVal = support.newArrayNode(((HashNode)yyVals[-1+yyTop]).getPosition(), ((HashNode)yyVals[-1+yyTop]));</span>
<span class="fc" id="L3158">    return yyVal;</span>
  }
};
<span class="fc" id="L3161">states[267] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3163">                    yyVal = ((Node)yyVals[-1+yyTop]);</span>
<span class="fc bfc" id="L3164" title="All 2 branches covered.">                    if (yyVal != null) ((Node)yyVal).setPosition(((ISourcePosition)yyVals[-2+yyTop]));</span>
<span class="fc" id="L3165">    return yyVal;</span>
  }
};
<span class="fc" id="L3168">states[272] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3170">                    yyVal = ((Node)yyVals[-1+yyTop]);</span>
<span class="fc" id="L3171">    return yyVal;</span>
  }
};
<span class="fc" id="L3174">states[273] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3176">                    yyVal = support.arg_append(((Node)yyVals[-3+yyTop]), ((HashNode)yyVals[-1+yyTop]));</span>
<span class="fc" id="L3177">    return yyVal;</span>
  }
};
<span class="fc" id="L3180">states[274] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3182">                    yyVal = support.newArrayNode(((HashNode)yyVals[-1+yyTop]).getPosition(), ((HashNode)yyVals[-1+yyTop]));</span>
<span class="fc" id="L3183">    return yyVal;</span>
  }
};
<span class="fc" id="L3186">states[275] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3188">                    yyVal = support.newArrayNode(support.getPosition(((Node)yyVals[0+yyTop])), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L3189">    return yyVal;</span>
  }
};
<span class="fc" id="L3192">states[276] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3194">                    yyVal = support.arg_blk_pass(((Node)yyVals[-1+yyTop]), ((BlockPassNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L3195">    return yyVal;</span>
  }
};
<span class="fc" id="L3198">states[277] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3200">                    yyVal = support.newArrayNode(((HashNode)yyVals[-1+yyTop]).getPosition(), ((HashNode)yyVals[-1+yyTop]));</span>
<span class="fc" id="L3201">                    yyVal = support.arg_blk_pass((Node)yyVal, ((BlockPassNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L3202">    return yyVal;</span>
  }
};
<span class="fc" id="L3205">states[278] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3207">                    yyVal = support.arg_append(((Node)yyVals[-3+yyTop]), ((HashNode)yyVals[-1+yyTop]));</span>
<span class="fc" id="L3208">                    yyVal = support.arg_blk_pass((Node)yyVal, ((BlockPassNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L3209">    return yyVal;</span>
  }
};
<span class="fc" id="L3212">states[279] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3214">    return yyVal;</span>
  }
};
<span class="fc" id="L3217">states[280] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3219">                    yyVal = Long.valueOf(lexer.getCmdArgumentState().begin());</span>
<span class="fc" id="L3220">    return yyVal;</span>
  }
};
<span class="fc" id="L3223">states[281] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3225">                    lexer.getCmdArgumentState().reset(((Long)yyVals[-1+yyTop]).longValue());</span>
<span class="fc" id="L3226">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L3227">    return yyVal;</span>
  }
};
<span class="fc" id="L3230">states[282] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3232">                    yyVal = new BlockPassNode(support.getPosition(((Node)yyVals[0+yyTop])), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L3233">    return yyVal;</span>
  }
};
<span class="fc" id="L3236">states[283] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3238">                    yyVal = ((BlockPassNode)yyVals[0+yyTop]);</span>
<span class="fc" id="L3239">    return yyVal;</span>
  }
};
<span class="fc" id="L3242">states[285] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L3244" title="1 of 2 branches missed.">                    ISourcePosition pos = ((Node)yyVals[0+yyTop]) == null ? lexer.getPosition() : ((Node)yyVals[0+yyTop]).getPosition();</span>
<span class="fc" id="L3245">                    yyVal = support.newArrayNode(pos, ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L3246">    return yyVal;</span>
  }
};
<span class="fc" id="L3249">states[286] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3251">                    yyVal = support.newSplatNode(support.getPosition(((Node)yyVals[0+yyTop])), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L3252">    return yyVal;</span>
  }
};
<span class="fc" id="L3255">states[287] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3257">                    Node node = support.splat_array(((Node)yyVals[-2+yyTop]));</span>

<span class="fc bfc" id="L3259" title="All 2 branches covered.">                    if (node != null) {</span>
<span class="fc" id="L3260">                        yyVal = support.list_append(node, ((Node)yyVals[0+yyTop]));</span>
                    } else {
<span class="fc" id="L3262">                        yyVal = support.arg_append(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));</span>
                    }
<span class="fc" id="L3264">    return yyVal;</span>
  }
};
<span class="fc" id="L3267">states[288] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3269">                    Node node = null;</span>

                    /* FIXME: lose syntactical elements here (and others like this)*/
<span class="fc bfc" id="L3272" title="All 2 branches covered.">                    if (((Node)yyVals[0+yyTop]) instanceof ArrayNode &amp;&amp;</span>
<span class="fc bfc" id="L3273" title="All 2 branches covered.">                        (node = support.splat_array(((Node)yyVals[-3+yyTop]))) != null) {</span>
<span class="fc" id="L3274">                        yyVal = support.list_concat(node, ((Node)yyVals[0+yyTop]));</span>
                    } else {
<span class="fc" id="L3276">                        yyVal = support.arg_concat(support.getPosition(((Node)yyVals[-3+yyTop])), ((Node)yyVals[-3+yyTop]), ((Node)yyVals[0+yyTop]));</span>
                    }
<span class="fc" id="L3278">    return yyVal;</span>
  }
};
<span class="fc" id="L3281">states[289] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3283">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L3284">    return yyVal;</span>
  }
};
<span class="fc" id="L3287">states[290] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3289">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L3290">    return yyVal;</span>
  }
};
<span class="fc" id="L3293">states[291] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3295">                    Node node = support.splat_array(((Node)yyVals[-2+yyTop]));</span>

<span class="fc bfc" id="L3297" title="All 2 branches covered.">                    if (node != null) {</span>
<span class="fc" id="L3298">                        yyVal = support.list_append(node, ((Node)yyVals[0+yyTop]));</span>
                    } else {
<span class="fc" id="L3300">                        yyVal = support.arg_append(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));</span>
                    }
<span class="fc" id="L3302">    return yyVal;</span>
  }
};
<span class="fc" id="L3305">states[292] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3307">                    Node node = null;</span>

<span class="pc bpc" id="L3309" title="1 of 2 branches missed.">                    if (((Node)yyVals[0+yyTop]) instanceof ArrayNode &amp;&amp;</span>
<span class="nc bnc" id="L3310" title="All 2 branches missed.">                        (node = support.splat_array(((Node)yyVals[-3+yyTop]))) != null) {</span>
<span class="nc" id="L3311">                        yyVal = support.list_concat(node, ((Node)yyVals[0+yyTop]));</span>
                    } else {
<span class="fc" id="L3313">                        yyVal = support.arg_concat(((Node)yyVals[-3+yyTop]).getPosition(), ((Node)yyVals[-3+yyTop]), ((Node)yyVals[0+yyTop]));</span>
                    }
<span class="fc" id="L3315">    return yyVal;</span>
  }
};
<span class="fc" id="L3318">states[293] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3320">                     yyVal = support.newSplatNode(support.getPosition(((Node)yyVals[0+yyTop])), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L3321">    return yyVal;</span>
  }
};
<span class="fc" id="L3324">states[300] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3326">                     yyVal = ((ListNode)yyVals[0+yyTop]); /* FIXME: Why complaining without $$ = $1;*/</span>
<span class="fc" id="L3327">    return yyVal;</span>
  }
};
<span class="fc" id="L3330">states[301] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3332">                     yyVal = ((ListNode)yyVals[0+yyTop]); /* FIXME: Why complaining without $$ = $1;*/</span>
<span class="fc" id="L3333">    return yyVal;</span>
  }
};
<span class="fc" id="L3336">states[304] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3338">                    yyVal = support.new_fcall(((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L3339">    return yyVal;</span>
  }
};
<span class="fc" id="L3342">states[305] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L3344" title="1 of 2 branches missed.">                    yyVal = new BeginNode(((ISourcePosition)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop]) == null ? NilImplicitNode.NIL : ((Node)yyVals[-1+yyTop]));</span>
<span class="fc" id="L3345">    return yyVal;</span>
  }
};
<span class="fc" id="L3348">states[306] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L3350">                    lexer.setState(LexState.EXPR_ENDARG);</span>
<span class="nc" id="L3351">    return yyVal;</span>
  }
};
<span class="fc" id="L3354">states[307] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L3356">                    yyVal = null; /*FIXME: Should be implicit nil?*/</span>
<span class="nc" id="L3357">    return yyVal;</span>
  }
};
<span class="fc" id="L3360">states[308] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3362">                    lexer.setState(LexState.EXPR_ENDARG); </span>
<span class="fc" id="L3363">    return yyVal;</span>
  }
};
<span class="fc" id="L3366">states[309] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L3368" title="1 of 2 branches missed.">                    if (Options.PARSER_WARN_GROUPED_EXPRESSIONS.load()) {</span>
<span class="fc" id="L3369">                      support.warning(ID.GROUPED_EXPRESSION, ((ISourcePosition)yyVals[-3+yyTop]), &quot;(...) interpreted as grouped expression&quot;);</span>
                    }
<span class="fc" id="L3371">                    yyVal = ((Node)yyVals[-2+yyTop]);</span>
<span class="fc" id="L3372">    return yyVal;</span>
  }
};
<span class="fc" id="L3375">states[310] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc bfc" id="L3377" title="All 2 branches covered.">                    if (((Node)yyVals[-1+yyTop]) != null) {</span>
                        /* compstmt position includes both parens around it*/
<span class="fc" id="L3379">                        ((ISourcePositionHolder) ((Node)yyVals[-1+yyTop])).setPosition(((ISourcePosition)yyVals[-2+yyTop]));</span>
<span class="fc" id="L3380">                        yyVal = ((Node)yyVals[-1+yyTop]);</span>
                    } else {
<span class="fc" id="L3382">                        yyVal = new NilNode(((ISourcePosition)yyVals[-2+yyTop]));</span>
                    }
<span class="fc" id="L3384">    return yyVal;</span>
  }
};
<span class="fc" id="L3387">states[311] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3389">                    yyVal = support.new_colon2(support.getPosition(((Node)yyVals[-2+yyTop])), ((Node)yyVals[-2+yyTop]), ((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L3390">    return yyVal;</span>
  }
};
<span class="fc" id="L3393">states[312] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3395">                    yyVal = support.new_colon3(lexer.getPosition(), ((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L3396">    return yyVal;</span>
  }
};
<span class="fc" id="L3399">states[313] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3401">                    ISourcePosition position = support.getPosition(((Node)yyVals[-1+yyTop]));</span>
<span class="fc bfc" id="L3402" title="All 2 branches covered.">                    if (((Node)yyVals[-1+yyTop]) == null) {</span>
<span class="fc" id="L3403">                        yyVal = new ZArrayNode(position); /* zero length array */</span>
                    } else {
<span class="fc" id="L3405">                        yyVal = ((Node)yyVals[-1+yyTop]);</span>
                    }
<span class="fc" id="L3407">    return yyVal;</span>
  }
};
<span class="fc" id="L3410">states[314] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3412">                    yyVal = ((HashNode)yyVals[-1+yyTop]);</span>
<span class="fc" id="L3413">    return yyVal;</span>
  }
};
<span class="fc" id="L3416">states[315] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3418">                    yyVal = new ReturnNode(((ISourcePosition)yyVals[0+yyTop]), NilImplicitNode.NIL);</span>
<span class="fc" id="L3419">    return yyVal;</span>
  }
};
<span class="fc" id="L3422">states[316] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3424">                    yyVal = support.new_yield(((ISourcePosition)yyVals[-3+yyTop]), ((Node)yyVals[-1+yyTop]));</span>
<span class="fc" id="L3425">    return yyVal;</span>
  }
};
<span class="fc" id="L3428">states[317] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3430">                    yyVal = new ZYieldNode(((ISourcePosition)yyVals[-2+yyTop]));</span>
<span class="fc" id="L3431">    return yyVal;</span>
  }
};
<span class="fc" id="L3434">states[318] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3436">                    yyVal = new ZYieldNode(((ISourcePosition)yyVals[0+yyTop]));</span>
<span class="fc" id="L3437">    return yyVal;</span>
  }
};
<span class="fc" id="L3440">states[319] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3442">                    yyVal = support.new_defined(((ISourcePosition)yyVals[-4+yyTop]), ((Node)yyVals[-1+yyTop]));</span>
<span class="fc" id="L3443">    return yyVal;</span>
  }
};
<span class="fc" id="L3446">states[320] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3448">                    yyVal = support.getOperatorCallNode(support.getConditionNode(((Node)yyVals[-1+yyTop])), &quot;!&quot;);</span>
<span class="fc" id="L3449">    return yyVal;</span>
  }
};
<span class="fc" id="L3452">states[321] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L3454">                    yyVal = support.getOperatorCallNode(NilImplicitNode.NIL, &quot;!&quot;);</span>
<span class="nc" id="L3455">    return yyVal;</span>
  }
};
<span class="fc" id="L3458">states[322] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3460">                    support.frobnicate_fcall_args(((FCallNode)yyVals[-1+yyTop]), null, ((IterNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L3461">                    yyVal = ((FCallNode)yyVals[-1+yyTop]);                    </span>
<span class="fc" id="L3462">    return yyVal;</span>
  }
};
<span class="fc" id="L3465">states[324] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L3467" title="1 of 2 branches missed.">                    if (((Node)yyVals[-1+yyTop]) != null &amp;&amp; </span>
<span class="fc bfc" id="L3468" title="All 2 branches covered.">                          ((BlockAcceptingNode)yyVals[-1+yyTop]).getIterNode() instanceof BlockPassNode) {</span>
<span class="fc" id="L3469">                        throw new SyntaxException(PID.BLOCK_ARG_AND_BLOCK_GIVEN, ((Node)yyVals[-1+yyTop]).getPosition(), lexer.getCurrentLine(), &quot;Both block arg and actual block given.&quot;);</span>
                    }
<span class="fc" id="L3471">                    yyVal = ((BlockAcceptingNode)yyVals[-1+yyTop]).setIterNode(((IterNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L3472">                    ((Node)yyVal).setPosition(((Node)yyVals[-1+yyTop]).getPosition());</span>
<span class="fc" id="L3473">    return yyVal;</span>
  }
};
<span class="fc" id="L3476">states[325] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3478">                    yyVal = ((LambdaNode)yyVals[0+yyTop]);</span>
<span class="fc" id="L3479">    return yyVal;</span>
  }
};
<span class="fc" id="L3482">states[326] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3484">                    yyVal = new IfNode(((ISourcePosition)yyVals[-5+yyTop]), support.getConditionNode(((Node)yyVals[-4+yyTop])), ((Node)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop]));</span>
<span class="fc" id="L3485">    return yyVal;</span>
  }
};
<span class="fc" id="L3488">states[327] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3490">                    yyVal = new IfNode(((ISourcePosition)yyVals[-5+yyTop]), support.getConditionNode(((Node)yyVals[-4+yyTop])), ((Node)yyVals[-1+yyTop]), ((Node)yyVals[-2+yyTop]));</span>
<span class="fc" id="L3491">    return yyVal;</span>
  }
};
<span class="fc" id="L3494">states[328] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3496">                    lexer.getConditionState().begin();</span>
<span class="fc" id="L3497">    return yyVal;</span>
  }
};
<span class="fc" id="L3500">states[329] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3502">                    lexer.getConditionState().end();</span>
<span class="fc" id="L3503">    return yyVal;</span>
  }
};
<span class="fc" id="L3506">states[330] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc bfc" id="L3508" title="All 2 branches covered.">                    Node body = ((Node)yyVals[-1+yyTop]) == null ? NilImplicitNode.NIL : ((Node)yyVals[-1+yyTop]);</span>
<span class="fc" id="L3509">                    yyVal = new WhileNode(((ISourcePosition)yyVals[-6+yyTop]), support.getConditionNode(((Node)yyVals[-4+yyTop])), body);</span>
<span class="fc" id="L3510">    return yyVal;</span>
  }
};
<span class="fc" id="L3513">states[331] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3515">                  lexer.getConditionState().begin();</span>
<span class="fc" id="L3516">    return yyVal;</span>
  }
};
<span class="fc" id="L3519">states[332] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3521">                  lexer.getConditionState().end();</span>
<span class="fc" id="L3522">    return yyVal;</span>
  }
};
<span class="fc" id="L3525">states[333] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L3527" title="1 of 2 branches missed.">                    Node body = ((Node)yyVals[-1+yyTop]) == null ? NilImplicitNode.NIL : ((Node)yyVals[-1+yyTop]);</span>
<span class="fc" id="L3528">                    yyVal = new UntilNode(((ISourcePosition)yyVals[-6+yyTop]), support.getConditionNode(((Node)yyVals[-4+yyTop])), body);</span>
<span class="fc" id="L3529">    return yyVal;</span>
  }
};
<span class="fc" id="L3532">states[334] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3534">                    yyVal = support.newCaseNode(((ISourcePosition)yyVals[-4+yyTop]), ((Node)yyVals[-3+yyTop]), ((Node)yyVals[-1+yyTop]));</span>
<span class="fc" id="L3535">    return yyVal;</span>
  }
};
<span class="fc" id="L3538">states[335] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3540">                    yyVal = support.newCaseNode(((ISourcePosition)yyVals[-3+yyTop]), null, ((Node)yyVals[-1+yyTop]));</span>
<span class="fc" id="L3541">    return yyVal;</span>
  }
};
<span class="fc" id="L3544">states[336] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3546">                    lexer.getConditionState().begin();</span>
<span class="fc" id="L3547">    return yyVal;</span>
  }
};
<span class="fc" id="L3550">states[337] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3552">                    lexer.getConditionState().end();</span>
<span class="fc" id="L3553">    return yyVal;</span>
  }
};
<span class="fc" id="L3556">states[338] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
                      /* ENEBO: Lots of optz in 1.9 parser here*/
<span class="fc" id="L3559">                    yyVal = new ForNode(((ISourcePosition)yyVals[-8+yyTop]), ((Node)yyVals[-7+yyTop]), ((Node)yyVals[-1+yyTop]), ((Node)yyVals[-4+yyTop]), support.getCurrentScope());</span>
<span class="fc" id="L3560">    return yyVal;</span>
  }
};
<span class="fc" id="L3563">states[339] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L3565" title="2 of 4 branches missed.">                    if (support.isInDef() || support.isInSingle()) {</span>
<span class="nc" id="L3566">                        support.yyerror(&quot;class definition in method body&quot;);</span>
                    }
<span class="fc" id="L3568">                    support.pushLocalScope();</span>
<span class="fc" id="L3569">    return yyVal;</span>
  }
};
<span class="fc" id="L3572">states[340] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc bfc" id="L3574" title="All 2 branches covered.">                    Node body = ((Node)yyVals[-1+yyTop]) == null ? NilImplicitNode.NIL : ((Node)yyVals[-1+yyTop]);</span>

<span class="fc" id="L3576">                    yyVal = new ClassNode(((ISourcePosition)yyVals[-5+yyTop]), ((Colon3Node)yyVals[-4+yyTop]), support.getCurrentScope(), body, ((Node)yyVals[-3+yyTop]));</span>
<span class="fc" id="L3577">                    support.popCurrentScope();</span>
<span class="fc" id="L3578">    return yyVal;</span>
  }
};
<span class="fc" id="L3581">states[341] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3583">                    yyVal = Boolean.valueOf(support.isInDef());</span>
<span class="fc" id="L3584">                    support.setInDef(false);</span>
<span class="fc" id="L3585">    return yyVal;</span>
  }
};
<span class="fc" id="L3588">states[342] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3590">                    yyVal = Integer.valueOf(support.getInSingle());</span>
<span class="fc" id="L3591">                    support.setInSingle(0);</span>
<span class="fc" id="L3592">                    support.pushLocalScope();</span>
<span class="fc" id="L3593">    return yyVal;</span>
  }
};
<span class="fc" id="L3596">states[343] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L3598" title="1 of 2 branches missed.">                    Node body = ((Node)yyVals[-1+yyTop]) == null ? NilImplicitNode.NIL : ((Node)yyVals[-1+yyTop]);</span>

<span class="fc" id="L3600">                    yyVal = new SClassNode(((ISourcePosition)yyVals[-7+yyTop]), ((Node)yyVals[-5+yyTop]), support.getCurrentScope(), body);</span>
<span class="fc" id="L3601">                    support.popCurrentScope();</span>
<span class="fc" id="L3602">                    support.setInDef(((Boolean)yyVals[-4+yyTop]).booleanValue());</span>
<span class="fc" id="L3603">                    support.setInSingle(((Integer)yyVals[-2+yyTop]).intValue());</span>
<span class="fc" id="L3604">    return yyVal;</span>
  }
};
<span class="fc" id="L3607">states[344] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L3609" title="2 of 4 branches missed.">                    if (support.isInDef() || support.isInSingle()) { </span>
<span class="nc" id="L3610">                        support.yyerror(&quot;module definition in method body&quot;);</span>
                    }
<span class="fc" id="L3612">                    support.pushLocalScope();</span>
<span class="fc" id="L3613">    return yyVal;</span>
  }
};
<span class="fc" id="L3616">states[345] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc bfc" id="L3618" title="All 2 branches covered.">                    Node body = ((Node)yyVals[-1+yyTop]) == null ? NilImplicitNode.NIL : ((Node)yyVals[-1+yyTop]);</span>

<span class="fc" id="L3620">                    yyVal = new ModuleNode(((ISourcePosition)yyVals[-4+yyTop]), ((Colon3Node)yyVals[-3+yyTop]), support.getCurrentScope(), body);</span>
<span class="fc" id="L3621">                    support.popCurrentScope();</span>
<span class="fc" id="L3622">    return yyVal;</span>
  }
};
<span class="fc" id="L3625">states[346] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3627">                    support.setInDef(true);</span>
<span class="fc" id="L3628">                    support.pushLocalScope();</span>
<span class="fc" id="L3629">    return yyVal;</span>
  }
};
<span class="fc" id="L3632">states[347] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3634">                    Node body = ((Node)yyVals[-1+yyTop]);</span>
<span class="fc bfc" id="L3635" title="All 2 branches covered.">                    if (body == null) body = NilImplicitNode.NIL;</span>

<span class="fc" id="L3637">                    yyVal = new DefnNode(((ISourcePosition)yyVals[-5+yyTop]), new ArgumentNode(((ISourcePosition)yyVals[-5+yyTop]), ((String)yyVals[-4+yyTop])), ((ArgsNode)yyVals[-2+yyTop]), support.getCurrentScope(), body);</span>
<span class="fc" id="L3638">                    support.popCurrentScope();</span>
<span class="fc" id="L3639">                    support.setInDef(false);</span>
<span class="fc" id="L3640">    return yyVal;</span>
  }
};
<span class="fc" id="L3643">states[348] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3645">                    lexer.setState(LexState.EXPR_FNAME);</span>
<span class="fc" id="L3646">    return yyVal;</span>
  }
};
<span class="fc" id="L3649">states[349] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3651">                    support.setInSingle(support.getInSingle() + 1);</span>
<span class="fc" id="L3652">                    support.pushLocalScope();</span>
<span class="fc" id="L3653">                    lexer.setState(LexState.EXPR_ENDFN); /* force for args */</span>
<span class="fc" id="L3654">    return yyVal;</span>
  }
};
<span class="fc" id="L3657">states[350] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3659">                    Node body = ((Node)yyVals[-1+yyTop]);</span>
<span class="fc bfc" id="L3660" title="All 2 branches covered.">                    if (body == null) body = NilImplicitNode.NIL;</span>

<span class="fc" id="L3662">                    yyVal = new DefsNode(((ISourcePosition)yyVals[-8+yyTop]), ((Node)yyVals[-7+yyTop]), new ArgumentNode(((ISourcePosition)yyVals[-8+yyTop]), ((String)yyVals[-4+yyTop])), ((ArgsNode)yyVals[-2+yyTop]), support.getCurrentScope(), body);</span>
<span class="fc" id="L3663">                    support.popCurrentScope();</span>
<span class="fc" id="L3664">                    support.setInSingle(support.getInSingle() - 1);</span>
<span class="fc" id="L3665">    return yyVal;</span>
  }
};
<span class="fc" id="L3668">states[351] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3670">                    yyVal = new BreakNode(((ISourcePosition)yyVals[0+yyTop]), NilImplicitNode.NIL);</span>
<span class="fc" id="L3671">    return yyVal;</span>
  }
};
<span class="fc" id="L3674">states[352] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3676">                    yyVal = new NextNode(((ISourcePosition)yyVals[0+yyTop]), NilImplicitNode.NIL);</span>
<span class="fc" id="L3677">    return yyVal;</span>
  }
};
<span class="fc" id="L3680">states[353] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3682">                    yyVal = new RedoNode(((ISourcePosition)yyVals[0+yyTop]));</span>
<span class="fc" id="L3683">    return yyVal;</span>
  }
};
<span class="fc" id="L3686">states[354] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3688">                    yyVal = new RetryNode(((ISourcePosition)yyVals[0+yyTop]));</span>
<span class="fc" id="L3689">    return yyVal;</span>
  }
};
<span class="fc" id="L3692">states[355] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3694">                    support.checkExpression(((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L3695">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="pc bpc" id="L3696" title="1 of 2 branches missed.">                    if (yyVal == null) yyVal = NilImplicitNode.NIL;</span>
<span class="fc" id="L3697">    return yyVal;</span>
  }
};
<span class="fc" id="L3700">states[362] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3702">                    yyVal = new IfNode(((ISourcePosition)yyVals[-4+yyTop]), support.getConditionNode(((Node)yyVals[-3+yyTop])), ((Node)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L3703">    return yyVal;</span>
  }
};
<span class="fc" id="L3706">states[364] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3708">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L3709">    return yyVal;</span>
  }
};
<span class="fc" id="L3712">states[366] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3714">    return yyVal;</span>
  }
};
<span class="fc" id="L3717">states[367] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3719">                     yyVal = support.assignableLabelOrIdentifier(((String)yyVals[0+yyTop]), NilImplicitNode.NIL);</span>
<span class="fc" id="L3720">    return yyVal;</span>
  }
};
<span class="fc" id="L3723">states[368] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3725">                    yyVal = ((Node)yyVals[-1+yyTop]);</span>
<span class="fc" id="L3726">    return yyVal;</span>
  }
};
<span class="fc" id="L3729">states[369] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3731">                    yyVal = support.newArrayNode(((Node)yyVals[0+yyTop]).getPosition(), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L3732">    return yyVal;</span>
  }
};
<span class="fc" id="L3735">states[370] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3737">                    yyVal = ((ListNode)yyVals[-2+yyTop]).add(((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L3738">    return yyVal;</span>
  }
};
<span class="fc" id="L3741">states[371] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3743">                    yyVal = new MultipleAsgn19Node(((ListNode)yyVals[0+yyTop]).getPosition(), ((ListNode)yyVals[0+yyTop]), null, null);</span>
<span class="fc" id="L3744">    return yyVal;</span>
  }
};
<span class="fc" id="L3747">states[372] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3749">                    yyVal = new MultipleAsgn19Node(((ListNode)yyVals[-3+yyTop]).getPosition(), ((ListNode)yyVals[-3+yyTop]), support.assignableLabelOrIdentifier(((String)yyVals[0+yyTop]), null), null);</span>
<span class="fc" id="L3750">    return yyVal;</span>
  }
};
<span class="fc" id="L3753">states[373] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3755">                    yyVal = new MultipleAsgn19Node(((ListNode)yyVals[-5+yyTop]).getPosition(), ((ListNode)yyVals[-5+yyTop]), support.assignableLabelOrIdentifier(((String)yyVals[-2+yyTop]), null), ((ListNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L3756">    return yyVal;</span>
  }
};
<span class="fc" id="L3759">states[374] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L3761">                    yyVal = new MultipleAsgn19Node(((ListNode)yyVals[-2+yyTop]).getPosition(), ((ListNode)yyVals[-2+yyTop]), new StarNode(lexer.getPosition()), null);</span>
<span class="nc" id="L3762">    return yyVal;</span>
  }
};
<span class="fc" id="L3765">states[375] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L3767">                    yyVal = new MultipleAsgn19Node(((ListNode)yyVals[-4+yyTop]).getPosition(), ((ListNode)yyVals[-4+yyTop]), new StarNode(lexer.getPosition()), ((ListNode)yyVals[0+yyTop]));</span>
<span class="nc" id="L3768">    return yyVal;</span>
  }
};
<span class="fc" id="L3771">states[376] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3773">                    yyVal = new MultipleAsgn19Node(lexer.getPosition(), null, support.assignableLabelOrIdentifier(((String)yyVals[0+yyTop]), null), null);</span>
<span class="fc" id="L3774">    return yyVal;</span>
  }
};
<span class="fc" id="L3777">states[377] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3779">                    yyVal = new MultipleAsgn19Node(lexer.getPosition(), null, support.assignableLabelOrIdentifier(((String)yyVals[-2+yyTop]), null), ((ListNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L3780">    return yyVal;</span>
  }
};
<span class="fc" id="L3783">states[378] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3785">                    yyVal = new MultipleAsgn19Node(lexer.getPosition(), null, new StarNode(lexer.getPosition()), null);</span>
<span class="fc" id="L3786">    return yyVal;</span>
  }
};
<span class="fc" id="L3789">states[379] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L3791">                    yyVal = new MultipleAsgn19Node(support.getPosition(((ListNode)yyVals[0+yyTop])), null, null, ((ListNode)yyVals[0+yyTop]));</span>
<span class="nc" id="L3792">    return yyVal;</span>
  }
};
<span class="fc" id="L3795">states[380] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3797">                    yyVal = support.new_args_tail(((ListNode)yyVals[-3+yyTop]).getPosition(), ((ListNode)yyVals[-3+yyTop]), ((String)yyVals[-1+yyTop]), ((BlockArgNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L3798">    return yyVal;</span>
  }
};
<span class="fc" id="L3801">states[381] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3803">                    yyVal = support.new_args_tail(((ListNode)yyVals[-1+yyTop]).getPosition(), ((ListNode)yyVals[-1+yyTop]), null, ((BlockArgNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L3804">    return yyVal;</span>
  }
};
<span class="fc" id="L3807">states[382] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3809">                    yyVal = support.new_args_tail(lexer.getPosition(), null, ((String)yyVals[-1+yyTop]), ((BlockArgNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L3810">    return yyVal;</span>
  }
};
<span class="fc" id="L3813">states[383] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3815">                    yyVal = support.new_args_tail(((BlockArgNode)yyVals[0+yyTop]).getPosition(), null, null, ((BlockArgNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L3816">    return yyVal;</span>
  }
};
<span class="fc" id="L3819">states[384] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3821">                    yyVal = ((ArgsTailHolder)yyVals[0+yyTop]);</span>
<span class="fc" id="L3822">    return yyVal;</span>
  }
};
<span class="fc" id="L3825">states[385] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3827">                    yyVal = support.new_args_tail(lexer.getPosition(), null, null, null);</span>
<span class="fc" id="L3828">    return yyVal;</span>
  }
};
<span class="fc" id="L3831">states[386] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L3833">                    yyVal = support.new_args(((ListNode)yyVals[-5+yyTop]).getPosition(), ((ListNode)yyVals[-5+yyTop]), ((ListNode)yyVals[-3+yyTop]), ((RestArgNode)yyVals[-1+yyTop]), null, ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="nc" id="L3834">    return yyVal;</span>
  }
};
<span class="fc" id="L3837">states[387] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3839">                    yyVal = support.new_args(((ListNode)yyVals[-7+yyTop]).getPosition(), ((ListNode)yyVals[-7+yyTop]), ((ListNode)yyVals[-5+yyTop]), ((RestArgNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L3840">    return yyVal;</span>
  }
};
<span class="fc" id="L3843">states[388] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3845">                    yyVal = support.new_args(((ListNode)yyVals[-3+yyTop]).getPosition(), ((ListNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), null, null, ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L3846">    return yyVal;</span>
  }
};
<span class="fc" id="L3849">states[389] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3851">                    yyVal = support.new_args(((ListNode)yyVals[-5+yyTop]).getPosition(), ((ListNode)yyVals[-5+yyTop]), ((ListNode)yyVals[-3+yyTop]), null, ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L3852">    return yyVal;</span>
  }
};
<span class="fc" id="L3855">states[390] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3857">                    yyVal = support.new_args(((ListNode)yyVals[-3+yyTop]).getPosition(), ((ListNode)yyVals[-3+yyTop]), null, ((RestArgNode)yyVals[-1+yyTop]), null, ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L3858">    return yyVal;</span>
  }
};
<span class="fc" id="L3861">states[391] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3863">                    RestArgNode rest = new UnnamedRestArgNode(((ListNode)yyVals[-1+yyTop]).getPosition(), null, support.getCurrentScope().addVariable(&quot;*&quot;));</span>
<span class="fc" id="L3864">                    yyVal = support.new_args(((ListNode)yyVals[-1+yyTop]).getPosition(), ((ListNode)yyVals[-1+yyTop]), null, rest, null, (ArgsTailHolder) null);</span>
<span class="fc" id="L3865">    return yyVal;</span>
  }
};
<span class="fc" id="L3868">states[392] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3870">                    yyVal = support.new_args(((ListNode)yyVals[-5+yyTop]).getPosition(), ((ListNode)yyVals[-5+yyTop]), null, ((RestArgNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L3871">    return yyVal;</span>
  }
};
<span class="fc" id="L3874">states[393] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3876">                    yyVal = support.new_args(((ListNode)yyVals[-1+yyTop]).getPosition(), ((ListNode)yyVals[-1+yyTop]), null, null, null, ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L3877">    return yyVal;</span>
  }
};
<span class="fc" id="L3880">states[394] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3882">                    yyVal = support.new_args(support.getPosition(((ListNode)yyVals[-3+yyTop])), null, ((ListNode)yyVals[-3+yyTop]), ((RestArgNode)yyVals[-1+yyTop]), null, ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L3883">    return yyVal;</span>
  }
};
<span class="fc" id="L3886">states[395] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3888">                    yyVal = support.new_args(support.getPosition(((ListNode)yyVals[-5+yyTop])), null, ((ListNode)yyVals[-5+yyTop]), ((RestArgNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L3889">    return yyVal;</span>
  }
};
<span class="fc" id="L3892">states[396] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3894">                    yyVal = support.new_args(support.getPosition(((ListNode)yyVals[-1+yyTop])), null, ((ListNode)yyVals[-1+yyTop]), null, null, ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L3895">    return yyVal;</span>
  }
};
<span class="fc" id="L3898">states[397] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3900">                    yyVal = support.new_args(((ListNode)yyVals[-3+yyTop]).getPosition(), null, ((ListNode)yyVals[-3+yyTop]), null, ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L3901">    return yyVal;</span>
  }
};
<span class="fc" id="L3904">states[398] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3906">                    yyVal = support.new_args(((RestArgNode)yyVals[-1+yyTop]).getPosition(), null, null, ((RestArgNode)yyVals[-1+yyTop]), null, ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L3907">    return yyVal;</span>
  }
};
<span class="fc" id="L3910">states[399] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3912">                    yyVal = support.new_args(((RestArgNode)yyVals[-3+yyTop]).getPosition(), null, null, ((RestArgNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L3913">    return yyVal;</span>
  }
};
<span class="fc" id="L3916">states[400] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3918">                    yyVal = support.new_args(((ArgsTailHolder)yyVals[0+yyTop]).getPosition(), null, null, null, null, ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L3919">    return yyVal;</span>
  }
};
<span class="fc" id="L3922">states[401] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
    /* was $$ = null;*/
<span class="fc" id="L3925">                    yyVal = support.new_args(lexer.getPosition(), null, null, null, null, (ArgsTailHolder) null);</span>
<span class="fc" id="L3926">    return yyVal;</span>
  }
};
<span class="fc" id="L3929">states[402] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3931">                    lexer.commandStart = true;</span>
<span class="fc" id="L3932">                    yyVal = ((ArgsNode)yyVals[0+yyTop]);</span>
<span class="fc" id="L3933">    return yyVal;</span>
  }
};
<span class="fc" id="L3936">states[403] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3938">                    yyVal = support.new_args(lexer.getPosition(), null, null, null, null, (ArgsTailHolder) null);</span>
<span class="fc" id="L3939">    return yyVal;</span>
  }
};
<span class="fc" id="L3942">states[404] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3944">                    yyVal = support.new_args(lexer.getPosition(), null, null, null, null, (ArgsTailHolder) null);</span>
<span class="fc" id="L3945">    return yyVal;</span>
  }
};
<span class="fc" id="L3948">states[405] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3950">                    yyVal = ((ArgsNode)yyVals[-2+yyTop]);</span>
<span class="fc" id="L3951">    return yyVal;</span>
  }
};
<span class="fc" id="L3954">states[406] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3956">                    yyVal = null;</span>
<span class="fc" id="L3957">    return yyVal;</span>
  }
};
<span class="fc" id="L3960">states[407] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3962">                    yyVal = null;</span>
<span class="fc" id="L3963">    return yyVal;</span>
  }
};
<span class="fc" id="L3966">states[408] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3968">                    yyVal = null;</span>
<span class="fc" id="L3969">    return yyVal;</span>
  }
};
<span class="fc" id="L3972">states[409] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3974">                    yyVal = null;</span>
<span class="fc" id="L3975">    return yyVal;</span>
  }
};
<span class="fc" id="L3978">states[410] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3980">                    support.new_bv(((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L3981">    return yyVal;</span>
  }
};
<span class="fc" id="L3984">states[411] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L3986">                    yyVal = null;</span>
<span class="nc" id="L3987">    return yyVal;</span>
  }
};
<span class="fc" id="L3990">states[412] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L3992">                    support.pushBlockScope();</span>
<span class="fc" id="L3993">                    yyVal = lexer.getLeftParenBegin();</span>
<span class="fc" id="L3994">                    lexer.setLeftParenBegin(lexer.incrementParenNest());</span>
<span class="fc" id="L3995">    return yyVal;</span>
  }
};
<span class="fc" id="L3998">states[413] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4000">                    yyVal = new LambdaNode(((ArgsNode)yyVals[-1+yyTop]).getPosition(), ((ArgsNode)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), support.getCurrentScope());</span>
<span class="fc" id="L4001">                    support.popCurrentScope();</span>
<span class="fc" id="L4002">                    lexer.setLeftParenBegin(((Integer)yyVals[-2+yyTop]));</span>
<span class="fc" id="L4003">    return yyVal;</span>
  }
};
<span class="fc" id="L4006">states[414] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4008">                    yyVal = ((ArgsNode)yyVals[-2+yyTop]);</span>
<span class="fc" id="L4009">    return yyVal;</span>
  }
};
<span class="fc" id="L4012">states[415] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4014">                    yyVal = ((ArgsNode)yyVals[0+yyTop]);</span>
<span class="fc" id="L4015">    return yyVal;</span>
  }
};
<span class="fc" id="L4018">states[416] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4020">                    yyVal = ((Node)yyVals[-1+yyTop]);</span>
<span class="fc" id="L4021">    return yyVal;</span>
  }
};
<span class="fc" id="L4024">states[417] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4026">                    yyVal = ((Node)yyVals[-1+yyTop]);</span>
<span class="fc" id="L4027">    return yyVal;</span>
  }
};
<span class="fc" id="L4030">states[418] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4032">                    support.pushBlockScope();</span>
<span class="fc" id="L4033">    return yyVal;</span>
  }
};
<span class="fc" id="L4036">states[419] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4038">                    yyVal = new IterNode(((ISourcePosition)yyVals[-4+yyTop]), ((ArgsNode)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop]), support.getCurrentScope());</span>
<span class="fc" id="L4039">                    support.popCurrentScope();</span>
<span class="fc" id="L4040">    return yyVal;</span>
  }
};
<span class="fc" id="L4043">states[420] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
                    /* Workaround for JRUBY-2326 (MRI does not enter this production for some reason)*/
<span class="pc bpc" id="L4046" title="1 of 2 branches missed.">                    if (((Node)yyVals[-1+yyTop]) instanceof YieldNode) {</span>
<span class="nc" id="L4047">                        throw new SyntaxException(PID.BLOCK_GIVEN_TO_YIELD, ((Node)yyVals[-1+yyTop]).getPosition(), lexer.getCurrentLine(), &quot;block given to yield&quot;);</span>
                    }
<span class="pc bpc" id="L4049" title="1 of 4 branches missed.">                    if (((Node)yyVals[-1+yyTop]) instanceof BlockAcceptingNode &amp;&amp; ((BlockAcceptingNode)yyVals[-1+yyTop]).getIterNode() instanceof BlockPassNode) {</span>
<span class="nc" id="L4050">                        throw new SyntaxException(PID.BLOCK_ARG_AND_BLOCK_GIVEN, ((Node)yyVals[-1+yyTop]).getPosition(), lexer.getCurrentLine(), &quot;Both block arg and actual block given.&quot;);</span>
                    }
<span class="fc bfc" id="L4052" title="All 2 branches covered.">                    if (((Node)yyVals[-1+yyTop]) instanceof NonLocalControlFlowNode) {</span>
<span class="fc" id="L4053">                        ((BlockAcceptingNode) ((NonLocalControlFlowNode)yyVals[-1+yyTop]).getValueNode()).setIterNode(((IterNode)yyVals[0+yyTop]));</span>
                    } else {
<span class="fc" id="L4055">                        ((BlockAcceptingNode)yyVals[-1+yyTop]).setIterNode(((IterNode)yyVals[0+yyTop]));</span>
                    }
<span class="fc" id="L4057">                    yyVal = ((Node)yyVals[-1+yyTop]);</span>
<span class="fc" id="L4058">                    ((Node)yyVal).setPosition(((Node)yyVals[-1+yyTop]).getPosition());</span>
<span class="fc" id="L4059">    return yyVal;</span>
  }
};
<span class="fc" id="L4062">states[421] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4064">                    yyVal = support.new_call(((Node)yyVals[-3+yyTop]), ((String)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), null);</span>
<span class="nc" id="L4065">    return yyVal;</span>
  }
};
<span class="fc" id="L4068">states[422] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4070">                    yyVal = support.new_call(((Node)yyVals[-4+yyTop]), ((String)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop]), ((IterNode)yyVals[0+yyTop]));</span>
<span class="nc" id="L4071">    return yyVal;</span>
  }
};
<span class="fc" id="L4074">states[423] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4076">                    yyVal = support.new_call(((Node)yyVals[-4+yyTop]), ((String)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop]), ((IterNode)yyVals[0+yyTop]));</span>
<span class="nc" id="L4077">    return yyVal;</span>
  }
};
<span class="fc" id="L4080">states[424] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4082">                    support.frobnicate_fcall_args(((FCallNode)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), null);</span>
<span class="fc" id="L4083">                    yyVal = ((FCallNode)yyVals[-1+yyTop]);</span>
<span class="fc" id="L4084">    return yyVal;</span>
  }
};
<span class="fc" id="L4087">states[425] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4089">                    yyVal = support.new_call(((Node)yyVals[-3+yyTop]), ((String)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), null);</span>
<span class="fc" id="L4090">    return yyVal;</span>
  }
};
<span class="fc" id="L4093">states[426] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4095">                    yyVal = support.new_call(((Node)yyVals[-3+yyTop]), ((String)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), null);</span>
<span class="fc" id="L4096">    return yyVal;</span>
  }
};
<span class="fc" id="L4099">states[427] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4101">                    yyVal = support.new_call(((Node)yyVals[-2+yyTop]), ((String)yyVals[0+yyTop]), null, null);</span>
<span class="fc" id="L4102">    return yyVal;</span>
  }
};
<span class="fc" id="L4105">states[428] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4107">                    yyVal = support.new_call(((Node)yyVals[-2+yyTop]), &quot;call&quot;, ((Node)yyVals[0+yyTop]), null);</span>
<span class="fc" id="L4108">    return yyVal;</span>
  }
};
<span class="fc" id="L4111">states[429] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4113">                    yyVal = support.new_call(((Node)yyVals[-2+yyTop]), &quot;call&quot;, ((Node)yyVals[0+yyTop]), null);</span>
<span class="nc" id="L4114">    return yyVal;</span>
  }
};
<span class="fc" id="L4117">states[430] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4119">                    yyVal = support.new_super(((ISourcePosition)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L4120">    return yyVal;</span>
  }
};
<span class="fc" id="L4123">states[431] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4125">                    yyVal = new ZSuperNode(((ISourcePosition)yyVals[0+yyTop]));</span>
<span class="fc" id="L4126">    return yyVal;</span>
  }
};
<span class="fc" id="L4129">states[432] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc bfc" id="L4131" title="All 2 branches covered.">                    if (((Node)yyVals[-3+yyTop]) instanceof SelfNode) {</span>
<span class="fc" id="L4132">                        yyVal = support.new_fcall(&quot;[]&quot;);</span>
<span class="fc" id="L4133">                        support.frobnicate_fcall_args(((FCallNode)yyVal), ((Node)yyVals[-1+yyTop]), null);</span>
                    } else {
<span class="fc" id="L4135">                        yyVal = support.new_call(((Node)yyVals[-3+yyTop]), &quot;[]&quot;, ((Node)yyVals[-1+yyTop]), null);</span>
                    }
<span class="fc" id="L4137">    return yyVal;</span>
  }
};
<span class="fc" id="L4140">states[433] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4142">                    support.pushBlockScope();</span>
<span class="fc" id="L4143">    return yyVal;</span>
  }
};
<span class="fc" id="L4146">states[434] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4148">                    yyVal = new IterNode(((ISourcePosition)yyVals[-4+yyTop]), ((ArgsNode)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop]), support.getCurrentScope());</span>
<span class="fc" id="L4149">                    support.popCurrentScope();</span>
<span class="fc" id="L4150">    return yyVal;</span>
  }
};
<span class="fc" id="L4153">states[435] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4155">                    support.pushBlockScope();</span>
<span class="fc" id="L4156">    return yyVal;</span>
  }
};
<span class="fc" id="L4159">states[436] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4161">                    yyVal = new IterNode(((ISourcePosition)yyVals[-4+yyTop]), ((ArgsNode)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop]), support.getCurrentScope());</span>
<span class="fc" id="L4162">                    support.popCurrentScope();</span>
<span class="fc" id="L4163">    return yyVal;</span>
  }
};
<span class="fc" id="L4166">states[437] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4168">                    yyVal = support.newWhenNode(((ISourcePosition)yyVals[-4+yyTop]), ((Node)yyVals[-3+yyTop]), ((Node)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L4169">    return yyVal;</span>
  }
};
<span class="fc" id="L4172">states[440] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
                    Node node;
<span class="fc bfc" id="L4175" title="All 2 branches covered.">                    if (((Node)yyVals[-3+yyTop]) != null) {</span>
<span class="fc" id="L4176">                        node = support.appendToBlock(support.node_assign(((Node)yyVals[-3+yyTop]), new GlobalVarNode(((ISourcePosition)yyVals[-5+yyTop]), &quot;$!&quot;)), ((Node)yyVals[-1+yyTop]));</span>
<span class="pc bpc" id="L4177" title="1 of 2 branches missed.">                        if (((Node)yyVals[-1+yyTop]) != null) {</span>
<span class="fc" id="L4178">                            node.setPosition(((ISourcePosition)yyVals[-5+yyTop]));</span>
                        }
                    } else {
<span class="fc" id="L4181">                        node = ((Node)yyVals[-1+yyTop]);</span>
                    }
<span class="fc bfc" id="L4183" title="All 2 branches covered.">                    Node body = node == null ? NilImplicitNode.NIL : node;</span>
<span class="fc" id="L4184">                    yyVal = new RescueBodyNode(((ISourcePosition)yyVals[-5+yyTop]), ((Node)yyVals[-4+yyTop]), body, ((RescueBodyNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L4185">    return yyVal;</span>
  }
};
<span class="fc" id="L4188">states[441] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4190">                    yyVal = null; </span>
<span class="fc" id="L4191">    return yyVal;</span>
  }
};
<span class="fc" id="L4194">states[442] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4196">                    yyVal = support.newArrayNode(((Node)yyVals[0+yyTop]).getPosition(), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L4197">    return yyVal;</span>
  }
};
<span class="fc" id="L4200">states[443] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4202">                    yyVal = support.splat_array(((Node)yyVals[0+yyTop]));</span>
<span class="fc bfc" id="L4203" title="All 2 branches covered.">                    if (yyVal == null) yyVal = ((Node)yyVals[0+yyTop]); /* ArgsCat or ArgsPush*/</span>
<span class="fc" id="L4204">    return yyVal;</span>
  }
};
<span class="fc" id="L4207">states[445] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4209">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L4210">    return yyVal;</span>
  }
};
<span class="fc" id="L4213">states[447] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4215">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L4216">    return yyVal;</span>
  }
};
<span class="fc" id="L4219">states[450] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4221">                    yyVal = new SymbolNode(lexer.getPosition(), new ByteList(((String)yyVals[0+yyTop]).getBytes(), lexer.getEncoding()));</span>
<span class="fc" id="L4222">    return yyVal;</span>
  }
};
<span class="fc" id="L4225">states[452] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L4227" title="1 of 2 branches missed.">                    yyVal = ((Node)yyVals[0+yyTop]) instanceof EvStrNode ? new DStrNode(((Node)yyVals[0+yyTop]).getPosition(), lexer.getEncoding()).add(((Node)yyVals[0+yyTop])) : ((Node)yyVals[0+yyTop]);</span>
                    /*
                    NODE *node = $1;
                    if (!node) {
                        node = NEW_STR(STR_NEW0());
                    } else {
                        node = evstr2dstr(node);
                    }
                    $$ = node;
                    */
<span class="fc" id="L4237">    return yyVal;</span>
  }
};
<span class="fc" id="L4240">states[453] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4242">                    ByteList aChar = ByteList.create(((String)yyVals[0+yyTop]));</span>
<span class="nc" id="L4243">                    aChar.setEncoding(lexer.getEncoding());</span>
<span class="nc" id="L4244">                    yyVal = lexer.createStrNode(lexer.getPosition(), aChar, 0);</span>
<span class="nc" id="L4245">    return yyVal;</span>
  }
};
<span class="fc" id="L4248">states[454] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4250">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L4251">    return yyVal;</span>
  }
};
<span class="fc" id="L4254">states[455] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4256">                    yyVal = support.literal_concat(((Node)yyVals[-1+yyTop]).getPosition(), ((Node)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L4257">    return yyVal;</span>
  }
};
<span class="fc" id="L4260">states[456] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4262">                    yyVal = ((Node)yyVals[-1+yyTop]);</span>
<span class="fc" id="L4263">    return yyVal;</span>
  }
};
<span class="fc" id="L4266">states[457] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4268">                    ISourcePosition position = support.getPosition(((Node)yyVals[-1+yyTop]));</span>

<span class="pc bpc" id="L4270" title="1 of 2 branches missed.">                    if (((Node)yyVals[-1+yyTop]) == null) {</span>
<span class="nc" id="L4271">                        yyVal = new XStrNode(position, null);</span>
<span class="fc bfc" id="L4272" title="All 2 branches covered.">                    } else if (((Node)yyVals[-1+yyTop]) instanceof StrNode) {</span>
<span class="fc" id="L4273">                        yyVal = new XStrNode(position, (ByteList) ((StrNode)yyVals[-1+yyTop]).getValue().clone());</span>
<span class="fc bfc" id="L4274" title="All 2 branches covered.">                    } else if (((Node)yyVals[-1+yyTop]) instanceof DStrNode) {</span>
<span class="fc" id="L4275">                        yyVal = new DXStrNode(position, ((DStrNode)yyVals[-1+yyTop]));</span>

<span class="fc" id="L4277">                        ((Node)yyVal).setPosition(position);</span>
                    } else {
<span class="fc" id="L4279">                        yyVal = new DXStrNode(position).add(((Node)yyVals[-1+yyTop]));</span>
                    }
<span class="fc" id="L4281">    return yyVal;</span>
  }
};
<span class="fc" id="L4284">states[458] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4286">                    yyVal = support.newRegexpNode(support.getPosition(((Node)yyVals[-1+yyTop])), ((Node)yyVals[-1+yyTop]), (RegexpNode) ((RegexpNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L4287">    return yyVal;</span>
  }
};
<span class="fc" id="L4290">states[459] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4292">                    yyVal = new ZArrayNode(lexer.getPosition());</span>
<span class="nc" id="L4293">    return yyVal;</span>
  }
};
<span class="fc" id="L4296">states[460] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4298">                    yyVal = ((ListNode)yyVals[-1+yyTop]);</span>
<span class="fc" id="L4299">    return yyVal;</span>
  }
};
<span class="fc" id="L4302">states[461] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4304">                    yyVal = new ArrayNode(lexer.getPosition());</span>
<span class="fc" id="L4305">    return yyVal;</span>
  }
};
<span class="fc" id="L4308">states[462] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc bfc" id="L4310" title="All 2 branches covered.">                     yyVal = ((ListNode)yyVals[-2+yyTop]).add(((Node)yyVals[-1+yyTop]) instanceof EvStrNode ? new DStrNode(((ListNode)yyVals[-2+yyTop]).getPosition(), lexer.getEncoding()).add(((Node)yyVals[-1+yyTop])) : ((Node)yyVals[-1+yyTop]));</span>
<span class="fc" id="L4311">    return yyVal;</span>
  }
};
<span class="fc" id="L4314">states[464] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4316">                     yyVal = support.literal_concat(support.getPosition(((Node)yyVals[-1+yyTop])), ((Node)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="nc" id="L4317">    return yyVal;</span>
  }
};
<span class="fc" id="L4320">states[465] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4322">                    yyVal = new ArrayNode(lexer.getPosition());</span>
<span class="nc" id="L4323">    return yyVal;</span>
  }
};
<span class="fc" id="L4326">states[466] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4328">                    yyVal = ((ListNode)yyVals[-1+yyTop]);</span>
<span class="fc" id="L4329">    return yyVal;</span>
  }
};
<span class="fc" id="L4332">states[467] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4334">                    yyVal = new ArrayNode(lexer.getPosition());</span>
<span class="fc" id="L4335">    return yyVal;</span>
  }
};
<span class="fc" id="L4338">states[468] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L4340" title="1 of 2 branches missed.">                    yyVal = ((ListNode)yyVals[-2+yyTop]).add(((Node)yyVals[-1+yyTop]) instanceof EvStrNode ? new DSymbolNode(((ListNode)yyVals[-2+yyTop]).getPosition()).add(((Node)yyVals[-1+yyTop])) : support.asSymbol(((ListNode)yyVals[-2+yyTop]).getPosition(), ((Node)yyVals[-1+yyTop])));</span>
<span class="fc" id="L4341">    return yyVal;</span>
  }
};
<span class="fc" id="L4344">states[469] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4346">                     yyVal = new ZArrayNode(lexer.getPosition());</span>
<span class="nc" id="L4347">    return yyVal;</span>
  }
};
<span class="fc" id="L4350">states[470] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4352">                    yyVal = ((ListNode)yyVals[-1+yyTop]);</span>
<span class="fc" id="L4353">    return yyVal;</span>
  }
};
<span class="fc" id="L4356">states[471] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4358">                    yyVal = new ZArrayNode(lexer.getPosition());</span>
<span class="nc" id="L4359">    return yyVal;</span>
  }
};
<span class="fc" id="L4362">states[472] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4364">                    yyVal = ((ListNode)yyVals[-1+yyTop]);</span>
<span class="fc" id="L4365">    return yyVal;</span>
  }
};
<span class="fc" id="L4368">states[473] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4370">                    yyVal = new ArrayNode(lexer.getPosition());</span>
<span class="fc" id="L4371">    return yyVal;</span>
  }
};
<span class="fc" id="L4374">states[474] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4376">                    yyVal = ((ListNode)yyVals[-2+yyTop]).add(((Node)yyVals[-1+yyTop]));</span>
<span class="fc" id="L4377">    return yyVal;</span>
  }
};
<span class="fc" id="L4380">states[475] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4382">                    yyVal = new ArrayNode(lexer.getPosition());</span>
<span class="fc" id="L4383">    return yyVal;</span>
  }
};
<span class="fc" id="L4386">states[476] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4388">                    yyVal = ((ListNode)yyVals[-2+yyTop]).add(support.asSymbol(((ListNode)yyVals[-2+yyTop]).getPosition(), ((Node)yyVals[-1+yyTop])));</span>
<span class="fc" id="L4389">    return yyVal;</span>
  }
};
<span class="fc" id="L4392">states[477] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4394">                    ByteList aChar = ByteList.create(&quot;&quot;);</span>
<span class="fc" id="L4395">                    aChar.setEncoding(lexer.getEncoding());</span>
<span class="fc" id="L4396">                    yyVal = lexer.createStrNode(lexer.getPosition(), aChar, 0);</span>
<span class="fc" id="L4397">    return yyVal;</span>
  }
};
<span class="fc" id="L4400">states[478] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4402">                    yyVal = support.literal_concat(((Node)yyVals[-1+yyTop]).getPosition(), ((Node)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L4403">    return yyVal;</span>
  }
};
<span class="fc" id="L4406">states[479] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4408">                    yyVal = null;</span>
<span class="fc" id="L4409">    return yyVal;</span>
  }
};
<span class="fc" id="L4412">states[480] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4414">                    yyVal = support.literal_concat(support.getPosition(((Node)yyVals[-1+yyTop])), ((Node)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L4415">    return yyVal;</span>
  }
};
<span class="fc" id="L4418">states[481] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4420">                    yyVal = null;</span>
<span class="fc" id="L4421">    return yyVal;</span>
  }
};
<span class="fc" id="L4424">states[482] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
    /* FIXME: mri is different here.*/
<span class="fc" id="L4427">                    yyVal = support.literal_concat(support.getPosition(((Node)yyVals[-1+yyTop])), ((Node)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L4428">    return yyVal;</span>
  }
};
<span class="fc" id="L4431">states[483] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4433">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L4434">    return yyVal;</span>
  }
};
<span class="fc" id="L4437">states[484] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4439">                    yyVal = lexer.getStrTerm();</span>
<span class="fc" id="L4440">                    lexer.setStrTerm(null);</span>
<span class="fc" id="L4441">                    lexer.setState(LexState.EXPR_BEG);</span>
<span class="fc" id="L4442">    return yyVal;</span>
  }
};
<span class="fc" id="L4445">states[485] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4447">                    lexer.setStrTerm(((StrTerm)yyVals[-1+yyTop]));</span>
<span class="fc" id="L4448">                    yyVal = new EvStrNode(support.getPosition(((Node)yyVals[0+yyTop])), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L4449">    return yyVal;</span>
  }
};
<span class="fc" id="L4452">states[486] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4454">                   yyVal = lexer.getStrTerm();</span>
<span class="fc" id="L4455">                   lexer.getConditionState().stop();</span>
<span class="fc" id="L4456">                   lexer.getCmdArgumentState().stop();</span>
<span class="fc" id="L4457">                   lexer.setStrTerm(null);</span>
<span class="fc" id="L4458">                   lexer.setState(LexState.EXPR_BEG);</span>
<span class="fc" id="L4459">    return yyVal;</span>
  }
};
<span class="fc" id="L4462">states[487] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4464">                   lexer.getConditionState().restart();</span>
<span class="fc" id="L4465">                   lexer.getCmdArgumentState().restart();</span>
<span class="fc" id="L4466">                   lexer.setStrTerm(((StrTerm)yyVals[-2+yyTop]));</span>

<span class="fc" id="L4468">                   yyVal = support.newEvStrNode(support.getPosition(((Node)yyVals[-1+yyTop])), ((Node)yyVals[-1+yyTop]));</span>
<span class="fc" id="L4469">    return yyVal;</span>
  }
};
<span class="fc" id="L4472">states[488] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4474">                     yyVal = new GlobalVarNode(lexer.getPosition(), ((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L4475">    return yyVal;</span>
  }
};
<span class="fc" id="L4478">states[489] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4480">                     yyVal = new InstVarNode(lexer.getPosition(), ((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L4481">    return yyVal;</span>
  }
};
<span class="fc" id="L4484">states[490] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4486">                     yyVal = new ClassVarNode(lexer.getPosition(), ((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L4487">    return yyVal;</span>
  }
};
<span class="fc" id="L4490">states[492] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4492">                     lexer.setState(LexState.EXPR_END);</span>
<span class="fc" id="L4493">                     yyVal = ((String)yyVals[0+yyTop]);</span>
<span class="fc" id="L4494">    return yyVal;</span>
  }
};
<span class="fc" id="L4497">states[497] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4499">                     lexer.setState(LexState.EXPR_END);</span>

                     /* DStrNode: :&quot;some text #{some expression}&quot;*/
                     /* StrNode: :&quot;some text&quot;*/
                     /* EvStrNode :&quot;#{some expression}&quot;*/
                     /* Ruby 1.9 allows empty strings as symbols*/
<span class="fc bfc" id="L4505" title="All 2 branches covered.">                     if (((Node)yyVals[-1+yyTop]) == null) {</span>
<span class="fc" id="L4506">                         yyVal = new SymbolNode(lexer.getPosition(), new ByteList(new byte[0], lexer.getEncoding()));</span>
<span class="fc bfc" id="L4507" title="All 2 branches covered.">                     } else if (((Node)yyVals[-1+yyTop]) instanceof DStrNode) {</span>
<span class="fc" id="L4508">                         yyVal = new DSymbolNode(((Node)yyVals[-1+yyTop]).getPosition(), ((DStrNode)yyVals[-1+yyTop]));</span>
<span class="fc bfc" id="L4509" title="All 2 branches covered.">                     } else if (((Node)yyVals[-1+yyTop]) instanceof StrNode) {</span>
<span class="fc" id="L4510">                         yyVal = new SymbolNode(((Node)yyVals[-1+yyTop]).getPosition(), ((StrNode)yyVals[-1+yyTop]).getValue());</span>
                     } else {
<span class="fc" id="L4512">                         yyVal = new DSymbolNode(((Node)yyVals[-1+yyTop]).getPosition());</span>
<span class="fc" id="L4513">                         ((DSymbolNode)yyVal).add(((Node)yyVals[-1+yyTop]));</span>
                     }
<span class="fc" id="L4515">    return yyVal;</span>
  }
};
<span class="fc" id="L4518">states[498] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4520">                    yyVal = ((Node)yyVals[0+yyTop]);  </span>
<span class="fc" id="L4521">    return yyVal;</span>
  }
};
<span class="fc" id="L4524">states[499] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4526">                     yyVal = support.negateNumeric(((Node)yyVals[0+yyTop]).getPosition(), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L4527">    return yyVal;</span>
  }
};
<span class="fc" id="L4530">states[500] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4532">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L4533">    return yyVal;</span>
  }
};
<span class="fc" id="L4536">states[501] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4538">                     yyVal = ((FloatNode)yyVals[0+yyTop]);</span>
<span class="fc" id="L4539">    return yyVal;</span>
  }
};
<span class="fc" id="L4542">states[502] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4544">                     yyVal = ((RationalNode)yyVals[0+yyTop]);</span>
<span class="fc" id="L4545">    return yyVal;</span>
  }
};
<span class="fc" id="L4548">states[503] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4550">                     yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L4551">    return yyVal;</span>
  }
};
<span class="fc" id="L4554">states[504] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4556">                    yyVal = support.declareIdentifier(((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L4557">    return yyVal;</span>
  }
};
<span class="fc" id="L4560">states[505] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4562">                    yyVal = new InstVarNode(lexer.getPosition(), ((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L4563">    return yyVal;</span>
  }
};
<span class="fc" id="L4566">states[506] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4568">                    yyVal = new GlobalVarNode(lexer.getPosition(), ((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L4569">    return yyVal;</span>
  }
};
<span class="fc" id="L4572">states[507] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4574">                    yyVal = new ConstNode(lexer.getPosition(), ((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L4575">    return yyVal;</span>
  }
};
<span class="fc" id="L4578">states[508] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4580">                    yyVal = new ClassVarNode(lexer.getPosition(), ((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L4581">    return yyVal;</span>
  }
};
<span class="fc" id="L4584">states[509] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4586">                    yyVal = new NilNode(lexer.getPosition());</span>
<span class="fc" id="L4587">    return yyVal;</span>
  }
};
<span class="fc" id="L4590">states[510] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4592">                    yyVal = new SelfNode(lexer.getPosition());</span>
<span class="fc" id="L4593">    return yyVal;</span>
  }
};
<span class="fc" id="L4596">states[511] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4598">                    yyVal = new TrueNode(lexer.getPosition());</span>
<span class="fc" id="L4599">    return yyVal;</span>
  }
};
<span class="fc" id="L4602">states[512] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4604">                    yyVal = new FalseNode(lexer.getPosition());</span>
<span class="fc" id="L4605">    return yyVal;</span>
  }
};
<span class="fc" id="L4608">states[513] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4610">                    yyVal = new FileNode(lexer.getPosition(), new ByteList(lexer.getPosition().getFile().getBytes(),</span>
<span class="fc" id="L4611">                    support.getConfiguration().getRuntime().getEncodingService().getLocaleEncoding()));</span>
<span class="fc" id="L4612">    return yyVal;</span>
  }
};
<span class="fc" id="L4615">states[514] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4617">                    yyVal = new FixnumNode(lexer.getPosition(), lexer.tokline.getLine()+1);</span>
<span class="fc" id="L4618">    return yyVal;</span>
  }
};
<span class="fc" id="L4621">states[515] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4623">                    yyVal = new EncodingNode(lexer.getPosition(), lexer.getEncoding());</span>
<span class="fc" id="L4624">    return yyVal;</span>
  }
};
<span class="fc" id="L4627">states[516] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4629">                    yyVal = support.assignableLabelOrIdentifier(((String)yyVals[0+yyTop]), null);</span>
<span class="fc" id="L4630">    return yyVal;</span>
  }
};
<span class="fc" id="L4633">states[517] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4635">                   yyVal = new InstAsgnNode(lexer.getPosition(), ((String)yyVals[0+yyTop]), NilImplicitNode.NIL);</span>
<span class="fc" id="L4636">    return yyVal;</span>
  }
};
<span class="fc" id="L4639">states[518] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4641">                   yyVal = new GlobalAsgnNode(lexer.getPosition(), ((String)yyVals[0+yyTop]), NilImplicitNode.NIL);</span>
<span class="nc" id="L4642">    return yyVal;</span>
  }
};
<span class="fc" id="L4645">states[519] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L4647" title="2 of 4 branches missed.">                    if (support.isInDef() || support.isInSingle()) support.compile_error(&quot;dynamic constant assignment&quot;);</span>

<span class="fc" id="L4649">                    yyVal = new ConstDeclNode(lexer.getPosition(), ((String)yyVals[0+yyTop]), null, NilImplicitNode.NIL);</span>
<span class="fc" id="L4650">    return yyVal;</span>
  }
};
<span class="fc" id="L4653">states[520] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4655">                    yyVal = new ClassVarAsgnNode(lexer.getPosition(), ((String)yyVals[0+yyTop]), NilImplicitNode.NIL);</span>
<span class="fc" id="L4656">    return yyVal;</span>
  }
};
<span class="fc" id="L4659">states[521] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4661">                    support.compile_error(&quot;Can't assign to nil&quot;);</span>
<span class="nc" id="L4662">                    yyVal = null;</span>
<span class="nc" id="L4663">    return yyVal;</span>
  }
};
<span class="fc" id="L4666">states[522] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4668">                    support.compile_error(&quot;Can't change the value of self&quot;);</span>
<span class="nc" id="L4669">                    yyVal = null;</span>
<span class="nc" id="L4670">    return yyVal;</span>
  }
};
<span class="fc" id="L4673">states[523] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4675">                    support.compile_error(&quot;Can't assign to true&quot;);</span>
<span class="nc" id="L4676">                    yyVal = null;</span>
<span class="nc" id="L4677">    return yyVal;</span>
  }
};
<span class="fc" id="L4680">states[524] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4682">                    support.compile_error(&quot;Can't assign to false&quot;);</span>
<span class="nc" id="L4683">                    yyVal = null;</span>
<span class="nc" id="L4684">    return yyVal;</span>
  }
};
<span class="fc" id="L4687">states[525] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4689">                    support.compile_error(&quot;Can't assign to __FILE__&quot;);</span>
<span class="nc" id="L4690">                    yyVal = null;</span>
<span class="nc" id="L4691">    return yyVal;</span>
  }
};
<span class="fc" id="L4694">states[526] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4696">                    support.compile_error(&quot;Can't assign to __LINE__&quot;);</span>
<span class="nc" id="L4697">                    yyVal = null;</span>
<span class="nc" id="L4698">    return yyVal;</span>
  }
};
<span class="fc" id="L4701">states[527] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4703">                    support.compile_error(&quot;Can't assign to __ENCODING__&quot;);</span>
<span class="nc" id="L4704">                    yyVal = null;</span>
<span class="nc" id="L4705">    return yyVal;</span>
  }
};
<span class="fc" id="L4708">states[528] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4710">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L4711">    return yyVal;</span>
  }
};
<span class="fc" id="L4714">states[529] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4716">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L4717">    return yyVal;</span>
  }
};
<span class="fc" id="L4720">states[530] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4722">                    yyVal = null;</span>
<span class="fc" id="L4723">    return yyVal;</span>
  }
};
<span class="fc" id="L4726">states[531] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4728">                   lexer.setState(LexState.EXPR_BEG);</span>
<span class="fc" id="L4729">    return yyVal;</span>
  }
};
<span class="fc" id="L4732">states[532] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4734">                    yyVal = ((Node)yyVals[-1+yyTop]);</span>
<span class="fc" id="L4735">    return yyVal;</span>
  }
};
<span class="fc" id="L4738">states[533] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4740">                   yyVal = null;</span>
<span class="nc" id="L4741">    return yyVal;</span>
  }
};
<span class="fc" id="L4744">states[534] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4746">                    yyVal = ((ArgsNode)yyVals[-1+yyTop]);</span>
<span class="fc" id="L4747">                    lexer.setState(LexState.EXPR_BEG);</span>
<span class="fc" id="L4748">                    lexer.commandStart = true;</span>
<span class="fc" id="L4749">    return yyVal;</span>
  }
};
<span class="fc" id="L4752">states[535] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4754">                    yyVal = ((ArgsNode)yyVals[-1+yyTop]);</span>
<span class="fc" id="L4755">                    lexer.setState(LexState.EXPR_BEG);</span>
<span class="fc" id="L4756">                    lexer.commandStart = true;</span>
<span class="fc" id="L4757">    return yyVal;</span>
  }
};
<span class="fc" id="L4760">states[536] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4762">                    yyVal = support.new_args_tail(((ListNode)yyVals[-3+yyTop]).getPosition(), ((ListNode)yyVals[-3+yyTop]), ((String)yyVals[-1+yyTop]), ((BlockArgNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L4763">    return yyVal;</span>
  }
};
<span class="fc" id="L4766">states[537] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4768">                    yyVal = support.new_args_tail(((ListNode)yyVals[-1+yyTop]).getPosition(), ((ListNode)yyVals[-1+yyTop]), null, ((BlockArgNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L4769">    return yyVal;</span>
  }
};
<span class="fc" id="L4772">states[538] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4774">                    yyVal = support.new_args_tail(lexer.getPosition(), null, ((String)yyVals[-1+yyTop]), ((BlockArgNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L4775">    return yyVal;</span>
  }
};
<span class="fc" id="L4778">states[539] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4780">                    yyVal = support.new_args_tail(((BlockArgNode)yyVals[0+yyTop]).getPosition(), null, null, ((BlockArgNode)yyVals[0+yyTop]));</span>
<span class="fc" id="L4781">    return yyVal;</span>
  }
};
<span class="fc" id="L4784">states[540] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4786">                    yyVal = ((ArgsTailHolder)yyVals[0+yyTop]);</span>
<span class="fc" id="L4787">    return yyVal;</span>
  }
};
<span class="fc" id="L4790">states[541] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4792">                    yyVal = support.new_args_tail(lexer.getPosition(), null, null, null);</span>
<span class="fc" id="L4793">    return yyVal;</span>
  }
};
<span class="fc" id="L4796">states[542] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4798">                    yyVal = support.new_args(((ListNode)yyVals[-5+yyTop]).getPosition(), ((ListNode)yyVals[-5+yyTop]), ((ListNode)yyVals[-3+yyTop]), ((RestArgNode)yyVals[-1+yyTop]), null, ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L4799">    return yyVal;</span>
  }
};
<span class="fc" id="L4802">states[543] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4804">                    yyVal = support.new_args(((ListNode)yyVals[-7+yyTop]).getPosition(), ((ListNode)yyVals[-7+yyTop]), ((ListNode)yyVals[-5+yyTop]), ((RestArgNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L4805">    return yyVal;</span>
  }
};
<span class="fc" id="L4808">states[544] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4810">                    yyVal = support.new_args(((ListNode)yyVals[-3+yyTop]).getPosition(), ((ListNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), null, null, ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L4811">    return yyVal;</span>
  }
};
<span class="fc" id="L4814">states[545] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4816">                    yyVal = support.new_args(((ListNode)yyVals[-5+yyTop]).getPosition(), ((ListNode)yyVals[-5+yyTop]), ((ListNode)yyVals[-3+yyTop]), null, ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L4817">    return yyVal;</span>
  }
};
<span class="fc" id="L4820">states[546] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4822">                    yyVal = support.new_args(((ListNode)yyVals[-3+yyTop]).getPosition(), ((ListNode)yyVals[-3+yyTop]), null, ((RestArgNode)yyVals[-1+yyTop]), null, ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L4823">    return yyVal;</span>
  }
};
<span class="fc" id="L4826">states[547] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4828">                    yyVal = support.new_args(((ListNode)yyVals[-5+yyTop]).getPosition(), ((ListNode)yyVals[-5+yyTop]), null, ((RestArgNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L4829">    return yyVal;</span>
  }
};
<span class="fc" id="L4832">states[548] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4834">                    yyVal = support.new_args(((ListNode)yyVals[-1+yyTop]).getPosition(), ((ListNode)yyVals[-1+yyTop]), null, null, null, ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L4835">    return yyVal;</span>
  }
};
<span class="fc" id="L4838">states[549] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4840">                    yyVal = support.new_args(((ListNode)yyVals[-3+yyTop]).getPosition(), null, ((ListNode)yyVals[-3+yyTop]), ((RestArgNode)yyVals[-1+yyTop]), null, ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L4841">    return yyVal;</span>
  }
};
<span class="fc" id="L4844">states[550] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4846">                    yyVal = support.new_args(((ListNode)yyVals[-5+yyTop]).getPosition(), null, ((ListNode)yyVals[-5+yyTop]), ((RestArgNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="nc" id="L4847">    return yyVal;</span>
  }
};
<span class="fc" id="L4850">states[551] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4852">                    yyVal = support.new_args(((ListNode)yyVals[-1+yyTop]).getPosition(), null, ((ListNode)yyVals[-1+yyTop]), null, null, ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L4853">    return yyVal;</span>
  }
};
<span class="fc" id="L4856">states[552] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4858">                    yyVal = support.new_args(((ListNode)yyVals[-3+yyTop]).getPosition(), null, ((ListNode)yyVals[-3+yyTop]), null, ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L4859">    return yyVal;</span>
  }
};
<span class="fc" id="L4862">states[553] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4864">                    yyVal = support.new_args(((RestArgNode)yyVals[-1+yyTop]).getPosition(), null, null, ((RestArgNode)yyVals[-1+yyTop]), null, ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L4865">    return yyVal;</span>
  }
};
<span class="fc" id="L4868">states[554] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4870">                    yyVal = support.new_args(((RestArgNode)yyVals[-3+yyTop]).getPosition(), null, null, ((RestArgNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L4871">    return yyVal;</span>
  }
};
<span class="fc" id="L4874">states[555] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4876">                    yyVal = support.new_args(((ArgsTailHolder)yyVals[0+yyTop]).getPosition(), null, null, null, null, ((ArgsTailHolder)yyVals[0+yyTop]));</span>
<span class="fc" id="L4877">    return yyVal;</span>
  }
};
<span class="fc" id="L4880">states[556] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4882">                    yyVal = support.new_args(lexer.getPosition(), null, null, null, null, (ArgsTailHolder) null);</span>
<span class="fc" id="L4883">    return yyVal;</span>
  }
};
<span class="fc" id="L4886">states[557] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4888">                    support.yyerror(&quot;formal argument cannot be a constant&quot;);</span>
<span class="nc" id="L4889">    return yyVal;</span>
  }
};
<span class="fc" id="L4892">states[558] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4894">                    support.yyerror(&quot;formal argument cannot be an instance variable&quot;);</span>
<span class="nc" id="L4895">    return yyVal;</span>
  }
};
<span class="fc" id="L4898">states[559] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4900">                    support.yyerror(&quot;formal argument cannot be a global variable&quot;);</span>
<span class="nc" id="L4901">    return yyVal;</span>
  }
};
<span class="fc" id="L4904">states[560] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L4906">                    support.yyerror(&quot;formal argument cannot be a class variable&quot;);</span>
<span class="nc" id="L4907">    return yyVal;</span>
  }
};
<span class="fc" id="L4910">states[562] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4912">                    yyVal = support.formal_argument(((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L4913">    return yyVal;</span>
  }
};
<span class="fc" id="L4916">states[563] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4918">                    yyVal = support.arg_var(((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L4919">    return yyVal;</span>
  }
};
<span class="fc" id="L4922">states[564] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4924">                    yyVal = ((Node)yyVals[-1+yyTop]);</span>
                    /*            {
            ID tid = internal_id();
            arg_var(tid);
            if (dyna_in_block()) {
                $2-&gt;nd_value = NEW_DVAR(tid);
            }
            else {
                $2-&gt;nd_value = NEW_LVAR(tid);
            }
            $$ = NEW_ARGS_AUX(tid, 1);
            $$-&gt;nd_next = $2;*/
<span class="fc" id="L4936">    return yyVal;</span>
  }
};
<span class="fc" id="L4939">states[565] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4941">                    yyVal = new ArrayNode(lexer.getPosition(), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L4942">    return yyVal;</span>
  }
};
<span class="fc" id="L4945">states[566] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4947">                    ((ListNode)yyVals[-2+yyTop]).add(((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L4948">                    yyVal = ((ListNode)yyVals[-2+yyTop]);</span>
<span class="fc" id="L4949">    return yyVal;</span>
  }
};
<span class="fc" id="L4952">states[567] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4954">                    support.arg_var(support.formal_argument(((String)yyVals[0+yyTop])));</span>
<span class="fc" id="L4955">                    yyVal = ((String)yyVals[0+yyTop]);</span>
<span class="fc" id="L4956">    return yyVal;</span>
  }
};
<span class="fc" id="L4959">states[568] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4961">                    yyVal = support.keyword_arg(((Node)yyVals[0+yyTop]).getPosition(), support.assignableLabelOrIdentifier(((String)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop])));</span>
<span class="fc" id="L4962">    return yyVal;</span>
  }
};
<span class="fc" id="L4965">states[569] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4967">                    yyVal = support.keyword_arg(lexer.getPosition(), support.assignableLabelOrIdentifier(((String)yyVals[0+yyTop]), new RequiredKeywordArgumentValueNode()));</span>
<span class="fc" id="L4968">    return yyVal;</span>
  }
};
<span class="fc" id="L4971">states[570] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4973">                    yyVal = support.keyword_arg(support.getPosition(((Node)yyVals[0+yyTop])), support.assignableLabelOrIdentifier(((String)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop])));</span>
<span class="fc" id="L4974">    return yyVal;</span>
  }
};
<span class="fc" id="L4977">states[571] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4979">                    yyVal = support.keyword_arg(lexer.getPosition(), support.assignableLabelOrIdentifier(((String)yyVals[0+yyTop]), new RequiredKeywordArgumentValueNode()));</span>
<span class="fc" id="L4980">    return yyVal;</span>
  }
};
<span class="fc" id="L4983">states[572] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4985">                    yyVal = new ArrayNode(((Node)yyVals[0+yyTop]).getPosition(), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L4986">    return yyVal;</span>
  }
};
<span class="fc" id="L4989">states[573] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4991">                    yyVal = ((ListNode)yyVals[-2+yyTop]).add(((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L4992">    return yyVal;</span>
  }
};
<span class="fc" id="L4995">states[574] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L4997">                    yyVal = new ArrayNode(((Node)yyVals[0+yyTop]).getPosition(), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L4998">    return yyVal;</span>
  }
};
<span class="fc" id="L5001">states[575] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5003">                    yyVal = ((ListNode)yyVals[-2+yyTop]).add(((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L5004">    return yyVal;</span>
  }
};
<span class="fc" id="L5007">states[576] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L5009">                    yyVal = ((String)yyVals[0+yyTop]);</span>
<span class="nc" id="L5010">    return yyVal;</span>
  }
};
<span class="fc" id="L5013">states[577] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5015">                    yyVal = ((String)yyVals[0+yyTop]);</span>
<span class="fc" id="L5016">    return yyVal;</span>
  }
};
<span class="fc" id="L5019">states[578] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5021">                    support.shadowing_lvar(((String)yyVals[0+yyTop]));</span>
<span class="fc" id="L5022">                    yyVal = ((String)yyVals[0+yyTop]);</span>
<span class="fc" id="L5023">    return yyVal;</span>
  }
};
<span class="fc" id="L5026">states[579] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5028">                    yyVal = support.internalId();</span>
<span class="fc" id="L5029">    return yyVal;</span>
  }
};
<span class="fc" id="L5032">states[580] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5034">                    support.arg_var(((String)yyVals[-2+yyTop]));</span>
<span class="fc" id="L5035">                    yyVal = new OptArgNode(support.getPosition(((Node)yyVals[0+yyTop])), support.assignableLabelOrIdentifier(((String)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop])));</span>
<span class="fc" id="L5036">    return yyVal;</span>
  }
};
<span class="fc" id="L5039">states[581] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5041">                    support.arg_var(support.formal_argument(((String)yyVals[-2+yyTop])));</span>
<span class="fc" id="L5042">                    yyVal = new OptArgNode(support.getPosition(((Node)yyVals[0+yyTop])), support.assignableLabelOrIdentifier(((String)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop])));</span>
<span class="fc" id="L5043">    return yyVal;</span>
  }
};
<span class="fc" id="L5046">states[582] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5048">                    yyVal = new BlockNode(((Node)yyVals[0+yyTop]).getPosition()).add(((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L5049">    return yyVal;</span>
  }
};
<span class="fc" id="L5052">states[583] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5054">                    yyVal = support.appendToBlock(((ListNode)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L5055">    return yyVal;</span>
  }
};
<span class="fc" id="L5058">states[584] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5060">                    yyVal = new BlockNode(((Node)yyVals[0+yyTop]).getPosition()).add(((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L5061">    return yyVal;</span>
  }
};
<span class="fc" id="L5064">states[585] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5066">                    yyVal = support.appendToBlock(((ListNode)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L5067">    return yyVal;</span>
  }
};
<span class="fc" id="L5070">states[588] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L5072" title="1 of 2 branches missed.">                    if (!support.is_local_id(((String)yyVals[0+yyTop]))) {</span>
<span class="nc" id="L5073">                        support.yyerror(&quot;rest argument must be local variable&quot;);</span>
                    }
                    
<span class="fc" id="L5076">                    yyVal = new RestArgNode(support.arg_var(support.shadowing_lvar(((String)yyVals[0+yyTop]))));</span>
<span class="fc" id="L5077">    return yyVal;</span>
  }
};
<span class="fc" id="L5080">states[589] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5082">                    yyVal = new UnnamedRestArgNode(lexer.getPosition(), &quot;&quot;, support.getCurrentScope().addVariable(&quot;*&quot;));</span>
<span class="fc" id="L5083">    return yyVal;</span>
  }
};
<span class="fc" id="L5086">states[592] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="pc bpc" id="L5088" title="1 of 2 branches missed.">                    if (!support.is_local_id(((String)yyVals[0+yyTop]))) {</span>
<span class="nc" id="L5089">                        support.yyerror(&quot;block argument must be local variable&quot;);</span>
                    }
                    
<span class="fc" id="L5092">                    yyVal = new BlockArgNode(support.arg_var(support.shadowing_lvar(((String)yyVals[0+yyTop]))));</span>
<span class="fc" id="L5093">    return yyVal;</span>
  }
};
<span class="fc" id="L5096">states[593] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5098">                    yyVal = ((BlockArgNode)yyVals[0+yyTop]);</span>
<span class="fc" id="L5099">    return yyVal;</span>
  }
};
<span class="fc" id="L5102">states[594] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5104">                    yyVal = null;</span>
<span class="fc" id="L5105">    return yyVal;</span>
  }
};
<span class="fc" id="L5108">states[595] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc bfc" id="L5110" title="All 2 branches covered.">                    if (!(((Node)yyVals[0+yyTop]) instanceof SelfNode)) {</span>
<span class="fc" id="L5111">                        support.checkExpression(((Node)yyVals[0+yyTop]));</span>
                    }
<span class="fc" id="L5113">                    yyVal = ((Node)yyVals[0+yyTop]);</span>
<span class="fc" id="L5114">    return yyVal;</span>
  }
};
<span class="fc" id="L5117">states[596] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc" id="L5119">                    lexer.setState(LexState.EXPR_BEG);</span>
<span class="nc" id="L5120">    return yyVal;</span>
  }
};
<span class="fc" id="L5123">states[597] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="nc bnc" id="L5125" title="All 2 branches missed.">                    if (((Node)yyVals[-1+yyTop]) == null) {</span>
<span class="nc" id="L5126">                        support.yyerror(&quot;can't define single method for ().&quot;);</span>
<span class="nc bnc" id="L5127" title="All 2 branches missed.">                    } else if (((Node)yyVals[-1+yyTop]) instanceof ILiteralNode) {</span>
<span class="nc" id="L5128">                        support.yyerror(&quot;can't define single method for literals.&quot;);</span>
                    }
<span class="nc" id="L5130">                    support.checkExpression(((Node)yyVals[-1+yyTop]));</span>
<span class="nc" id="L5131">                    yyVal = ((Node)yyVals[-1+yyTop]);</span>
<span class="nc" id="L5132">    return yyVal;</span>
  }
};
<span class="fc" id="L5135">states[598] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5137">                    yyVal = new HashNode(lexer.getPosition());</span>
<span class="fc" id="L5138">    return yyVal;</span>
  }
};
<span class="fc" id="L5141">states[599] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5143">                    yyVal = ((HashNode)yyVals[-1+yyTop]);</span>
<span class="fc" id="L5144">    return yyVal;</span>
  }
};
<span class="fc" id="L5147">states[600] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5149">                    yyVal = new HashNode(lexer.getPosition(), ((KeyValuePair)yyVals[0+yyTop]));</span>
<span class="fc" id="L5150">    return yyVal;</span>
  }
};
<span class="fc" id="L5153">states[601] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5155">                    yyVal = ((HashNode)yyVals[-2+yyTop]).add(((KeyValuePair)yyVals[0+yyTop]));</span>
<span class="fc" id="L5156">    return yyVal;</span>
  }
};
<span class="fc" id="L5159">states[602] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5161">                    yyVal = new KeyValuePair&lt;Node,Node&gt;(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L5162">    return yyVal;</span>
  }
};
<span class="fc" id="L5165">states[603] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5167">                    SymbolNode label = new SymbolNode(support.getPosition(((Node)yyVals[0+yyTop])), new ByteList(((String)yyVals[-1+yyTop]).getBytes(), lexer.getEncoding()));</span>
<span class="fc" id="L5168">                    yyVal = new KeyValuePair&lt;Node,Node&gt;(label, ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L5169">    return yyVal;</span>
  }
};
<span class="fc" id="L5172">states[604] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5174">                    yyVal = new KeyValuePair&lt;Node,Node&gt;(null, ((Node)yyVals[0+yyTop]));</span>
<span class="fc" id="L5175">    return yyVal;</span>
  }
};
<span class="fc" id="L5178">states[621] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5180">                    yyVal = ((String)yyVals[0+yyTop]);</span>
<span class="fc" id="L5181">    return yyVal;</span>
  }
};
<span class="fc" id="L5184">states[622] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5186">                    yyVal = ((String)yyVals[0+yyTop]);</span>
<span class="fc" id="L5187">    return yyVal;</span>
  }
};
<span class="fc" id="L5190">states[630] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5192">                      yyVal = null;</span>
<span class="fc" id="L5193">    return yyVal;</span>
  }
};
<span class="fc" id="L5196">states[631] = new ParserState() {</span>
  @Override public Object execute(ParserSupport support, RubyLexer lexer, Object yyVal, Object[] yyVals, int yyTop) {
<span class="fc" id="L5198">                  yyVal = null;</span>
<span class="fc" id="L5199">    return yyVal;</span>
  }
};
<span class="fc" id="L5202">}</span>
					// line 2482 &quot;RubyParser.y&quot;

    /** The parse method use an lexer stream and parse it to an AST node 
     * structure
     */
    public RubyParserResult parse(ParserConfiguration configuration, LexerSource source) throws IOException {
<span class="fc" id="L5209">        support.reset();</span>
<span class="fc" id="L5210">        support.setConfiguration(configuration);</span>
<span class="fc" id="L5211">        support.setResult(new RubyParserResult());</span>
        
<span class="fc" id="L5213">        lexer.reset();</span>
<span class="fc" id="L5214">        lexer.setSource(source);</span>
<span class="fc" id="L5215">        lexer.setEncoding(configuration.getDefaultEncoding());</span>

<span class="pc bpc" id="L5217" title="1 of 2 branches missed.">        yyparse(lexer, configuration.isDebug() ? new YYDebug() : null);</span>
        
<span class="fc" id="L5219">        return support.getResult();</span>
    }
}
					// line 9616 &quot;-&quot;
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>