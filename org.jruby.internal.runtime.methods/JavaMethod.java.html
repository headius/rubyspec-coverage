<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JavaMethod.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby.internal.runtime.methods</a> &gt; <span class="el_source">JavaMethod.java</span></div><h1>JavaMethod.java</h1><pre class="source lang-java linenums">/***** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby.internal.runtime.methods;

import org.jruby.RubyModule;
import org.jruby.parser.StaticScope;
import org.jruby.runtime.Arity;
import org.jruby.runtime.Block;
import org.jruby.runtime.RubyEvent;
import org.jruby.runtime.ThreadContext;
import org.jruby.runtime.Visibility;
import org.jruby.runtime.builtin.IRubyObject;

/**
 */
public abstract class JavaMethod extends DynamicMethod implements Cloneable, MethodArgs2 {
    protected int arityValue;
<span class="pc" id="L41">    protected Arity arity = Arity.OPTIONAL;</span>
    private String javaName;
    private boolean isSingleton;
    protected StaticScope staticScope;
    private String parameterDesc;
    private String[] parameterList;
<span class="pc" id="L47">    private CallConfiguration callerRequirement = CallConfiguration.FrameNoneScopeNone;</span>

<span class="fc" id="L49">    public static final Class[][] METHODS = {</span>
        {JavaMethodZero.class, JavaMethodZeroOrOne.class, JavaMethodZeroOrOneOrTwo.class, JavaMethodZeroOrOneOrTwoOrThree.class},
        {null, JavaMethodOne.class, JavaMethodOneOrTwo.class, JavaMethodOneOrTwoOrThree.class},
        {null, null, JavaMethodTwo.class, JavaMethodTwoOrThree.class},
        {null, null, null, JavaMethodThree.class},
    };

<span class="fc" id="L56">    public static final Class[][] REST_METHODS = {</span>
        {JavaMethodZeroOrN.class, JavaMethodZeroOrOneOrN.class, JavaMethodZeroOrOneOrTwoOrN.class, JavaMethodZeroOrOneOrTwoOrThreeOrN.class},
        {null, JavaMethodOneOrN.class, JavaMethodOneOrTwoOrN.class, JavaMethodOneOrTwoOrThreeOrN.class},
        {null, null, JavaMethodTwoOrN.class, JavaMethodTwoOrThreeOrN.class},
        {null, null, null, JavaMethodThreeOrN.class},
    };

<span class="fc" id="L63">    public static final Class[][] BLOCK_METHODS = {</span>
        {JavaMethodZeroBlock.class, JavaMethodZeroOrOneBlock.class, JavaMethodZeroOrOneOrTwoBlock.class, JavaMethodZeroOrOneOrTwoOrThreeBlock.class},
        {null, JavaMethodOneBlock.class, JavaMethodOneOrTwoBlock.class, JavaMethodOneOrTwoOrThreeBlock.class},
        {null, null, JavaMethodTwoBlock.class, JavaMethodTwoOrThreeBlock.class},
        {null, null, null, JavaMethodThreeBlock.class},
    };

<span class="fc" id="L70">    public static final Class[][] BLOCK_REST_METHODS = {</span>
        {JavaMethodZeroOrNBlock.class, JavaMethodZeroOrOneOrNBlock.class, JavaMethodZeroOrOneOrTwoOrNBlock.class, JavaMethodZeroOrOneOrTwoOrThreeOrNBlock.class},
        {null, JavaMethodOneOrNBlock.class, JavaMethodOneOrTwoOrNBlock.class, JavaMethodOneOrTwoOrThreeOrNBlock.class},
        {null, null, JavaMethodTwoOrNBlock.class, JavaMethodTwoOrThreeOrNBlock.class},
        {null, null, null, JavaMethodThreeOrNBlock.class},
    };

    
    public JavaMethod(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L79">        this(implementationClass, visibility, CallConfiguration.FrameFullScopeNone);</span>
<span class="fc" id="L80">    }</span>

    public JavaMethod(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="fc" id="L83">        super(implementationClass, visibility, callConfig);</span>
<span class="fc" id="L84">    }</span>
    
    public JavaMethod(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig, String name) {
<span class="fc" id="L87">        super(implementationClass, visibility, callConfig, name);</span>
<span class="fc" id="L88">    }</span>
    
<span class="nc" id="L90">    protected JavaMethod() {}</span>
    
    public void init(RubyModule implementationClass, Arity arity, Visibility visibility, StaticScope staticScope, CallConfiguration callConfig) {
<span class="nc" id="L93">        this.staticScope = staticScope;</span>
<span class="nc" id="L94">        this.arity = arity;</span>
<span class="nc" id="L95">        this.arityValue = arity.getValue();</span>
<span class="nc" id="L96">        super.init(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L97">    }</span>
    
    public DynamicMethod dup() {
        try {
<span class="fc" id="L101">            JavaMethod msm = (JavaMethod)clone();</span>
<span class="fc" id="L102">            return msm;</span>
<span class="nc" id="L103">        } catch (CloneNotSupportedException cnse) {</span>
<span class="nc" id="L104">            return null;</span>
        }
    }

    protected final void preFrameAndScope(ThreadContext context, IRubyObject self, String name, Block block) {
<span class="nc" id="L109">        context.preMethodFrameAndScope(implementationClass, name, self, block, staticScope);</span>
<span class="nc" id="L110">    }</span>

    protected final void preFrameAndDummyScope(ThreadContext context, IRubyObject self, String name, Block block) {
<span class="nc" id="L113">        context.preMethodFrameAndDummyScope(implementationClass, name, self, block, staticScope);</span>
<span class="nc" id="L114">    }</span>

    protected final void preFrameOnly(ThreadContext context, IRubyObject self, String name, Block block) {
<span class="fc" id="L117">        context.preMethodFrameOnly(implementationClass, name, self, block);</span>
<span class="fc" id="L118">    }</span>

    protected final void preScopeOnly(ThreadContext context) {
<span class="nc" id="L121">        context.preMethodScopeOnly(staticScope);</span>
<span class="nc" id="L122">    }</span>

    protected final void preNoFrameDummyScope(ThreadContext context) {
<span class="nc" id="L125">        context.preMethodNoFrameAndDummyScope(staticScope);</span>
<span class="nc" id="L126">    }</span>

    protected final void preBacktraceOnly(ThreadContext context, String name) {
<span class="nc" id="L129">        context.preMethodBacktraceOnly(name);</span>
<span class="nc" id="L130">    }</span>

    protected final void preBacktraceDummyScope(ThreadContext context, String name) {
<span class="nc" id="L133">        context.preMethodBacktraceDummyScope(name, staticScope);</span>
<span class="nc" id="L134">    }</span>

    protected final void preBacktraceAndScope(ThreadContext context, String name) {
<span class="nc" id="L137">        context.preMethodBacktraceAndScope(name, staticScope);</span>
<span class="nc" id="L138">    }</span>

<span class="nc" id="L140">    protected final void preNoop() {}</span>

    protected final static void postFrameAndScope(ThreadContext context) {
<span class="nc" id="L143">        context.postMethodFrameAndScope();</span>
<span class="nc" id="L144">    }</span>

    protected final static void postFrameOnly(ThreadContext context) {
<span class="fc" id="L147">        context.postMethodFrameOnly();</span>
<span class="fc" id="L148">    }</span>

    protected final static void postScopeOnly(ThreadContext context) {
<span class="nc" id="L151">        context.postMethodScopeOnly();</span>
<span class="nc" id="L152">    }</span>

    protected final static void postNoFrameDummyScope(ThreadContext context) {
<span class="nc" id="L155">        context.postMethodScopeOnly();</span>
<span class="nc" id="L156">    }</span>

    protected final static void postBacktraceOnly(ThreadContext context) {
<span class="nc" id="L159">        context.postMethodBacktraceOnly();</span>
<span class="nc" id="L160">    }</span>

    protected final static void postBacktraceDummyScope(ThreadContext context) {
<span class="nc" id="L163">        context.postMethodBacktraceDummyScope();</span>
<span class="nc" id="L164">    }</span>

    protected final static void postBacktraceAndScope(ThreadContext context) {
<span class="nc" id="L167">        context.postMethodBacktraceAndScope();</span>
<span class="nc" id="L168">    }</span>

<span class="nc" id="L170">    protected final static void postNoop(ThreadContext context) {}</span>

    protected final void callTrace(ThreadContext context, boolean enabled, String name) {
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (enabled) context.trace(RubyEvent.C_CALL, name, getImplementationClass());</span>
<span class="nc" id="L174">    }</span>

    protected final void returnTrace(ThreadContext context, boolean enabled, String name) {
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (enabled) context.trace(RubyEvent.C_RETURN, name, getImplementationClass());</span>
<span class="nc" id="L178">    }</span>

    protected final void callTraceCompiled(ThreadContext context, boolean enabled, String name, String file, int line) {
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (enabled) context.trace(RubyEvent.CALL, name, getImplementationClass(), file, line);</span>
<span class="nc" id="L182">    }</span>

    protected final void returnTraceCompiled(ThreadContext context, boolean enabled, String name) {
<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (enabled) context.trace(RubyEvent.RETURN, name, getImplementationClass());</span>
<span class="nc" id="L186">    }</span>
    
    public void setArity(Arity arity) {
<span class="fc" id="L189">        this.arity = arity;</span>
<span class="fc" id="L190">        this.arityValue = arity.getValue();</span>
<span class="fc" id="L191">    }</span>

    @Override
    public Arity getArity() {
<span class="fc" id="L195">        return arity;</span>
    }
    
    public void setJavaName(String javaName) {
<span class="fc" id="L199">        this.javaName = javaName;</span>
<span class="fc" id="L200">    }</span>
    
    public String getJavaName() {
<span class="nc" id="L203">        return javaName;</span>
    }
    
    public void setSingleton(boolean isSingleton) {
<span class="fc" id="L207">        this.isSingleton = isSingleton;</span>
<span class="fc" id="L208">    }</span>
    
    public boolean isSingleton() {
<span class="nc" id="L211">        return isSingleton;</span>
    }
    
    @Override
    public boolean isNative() {
<span class="nc" id="L216">        return true;</span>
    }

    public StaticScope getStaticScope() {
<span class="nc" id="L220">        return staticScope;</span>
    }
    
    public void setParameterDesc(String parameterDesc) {
<span class="fc" id="L224">        this.parameterDesc = parameterDesc;</span>
<span class="fc" id="L225">        this.parameterList = null;</span>
<span class="fc" id="L226">    }</span>
    
    public void setParameterList(String[] parameterList) {
<span class="nc" id="L229">        this.parameterDesc = null;</span>
<span class="nc" id="L230">        this.parameterList = parameterList;</span>
<span class="nc" id="L231">    }</span>

    public String[] getParameterList() {
<span class="fc bfc" id="L234" title="All 2 branches covered.">        if (parameterList == null) {</span>
<span class="pc bpc" id="L235" title="1 of 4 branches missed.">            if (parameterDesc != null &amp;&amp; parameterDesc.length() &gt; 0) {</span>
<span class="fc" id="L236">                parameterList = parameterDesc.split(&quot;;&quot;);</span>
            } else {
<span class="fc" id="L238">                parameterList = new String[0];</span>
            }
        }
        
<span class="fc" id="L242">        return parameterList;</span>
    }

    /**
     * Return a CallConfiguration representing what *callers* to this method must prepare (scope/frame).
     */
    public CallConfiguration getCallerRequirement() {
<span class="fc" id="L249">        return callerRequirement;</span>
    }

    /**
     * Set a CallConfiguration indicating what callers to this method must prepare (scope/frame).
     */
    public void setCallerRequirement(CallConfiguration callerRequirement) {
<span class="fc" id="L256">        this.callerRequirement = callerRequirement;</span>
<span class="fc" id="L257">    }</span>

    protected static IRubyObject raiseArgumentError(JavaMethod method, ThreadContext context, String name, int given, int min, int max) {
<span class="nc" id="L260">        Arity.raiseArgumentError(context.runtime, name, given, min, max);</span>
        // never reached
<span class="nc" id="L262">        return context.runtime.getNil();</span>
    }

    protected static void checkArgumentCount(JavaMethod method, ThreadContext context, String name, IRubyObject[] args, int num) {
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (args.length != num) raiseArgumentError(method, context, name, args.length, num, num);</span>
<span class="nc" id="L267">    }</span>

    // promise to implement N with block
    public static abstract class JavaMethodNBlock extends JavaMethod {
        public JavaMethodNBlock(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L272">            super(implementationClass, visibility);</span>
<span class="fc" id="L273">        }</span>
        public JavaMethodNBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="fc" id="L275">            super(implementationClass, visibility, callConfig);</span>
<span class="fc" id="L276">        }</span>
        public JavaMethodNBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig, String name) {
<span class="fc" id="L278">            super(implementationClass, visibility, callConfig, name);</span>
<span class="fc" id="L279">        }</span>
    }


    // promise to implement zero to N with block
    public static abstract class JavaMethodZeroOrNBlock extends JavaMethodNBlock {
        public JavaMethodZeroOrNBlock(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L286">            super(implementationClass, visibility);</span>
<span class="fc" id="L287">        }</span>
        public JavaMethodZeroOrNBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L289">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L290">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name) {
<span class="fc" id="L294">            return call(context, self, clazz, name, Block.NULL_BLOCK);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, Block block);
    }

    public static abstract class JavaMethodZeroOrOneOrNBlock extends JavaMethodZeroOrNBlock {
        public JavaMethodZeroOrOneOrNBlock(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L303">            super(implementationClass, visibility);</span>
<span class="fc" id="L304">        }</span>
        public JavaMethodZeroOrOneOrNBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L306">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L307">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0) {
<span class="fc" id="L311">            return call(context, self, clazz, name, arg0, Block.NULL_BLOCK);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg, Block block);
    }

    public static abstract class JavaMethodZeroOrOneOrTwoOrNBlock extends JavaMethodZeroOrOneOrNBlock {
        public JavaMethodZeroOrOneOrTwoOrNBlock(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L320">            super(implementationClass, visibility);</span>
<span class="fc" id="L321">        }</span>
        public JavaMethodZeroOrOneOrTwoOrNBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L323">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L324">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L328">            return call(context, self, clazz, name, arg0, arg1, Block.NULL_BLOCK);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, Block block);
    }

    public static abstract class JavaMethodZeroOrOneOrTwoOrThreeOrNBlock extends JavaMethodZeroOrOneOrTwoOrNBlock {
        public JavaMethodZeroOrOneOrTwoOrThreeOrNBlock(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L337">            super(implementationClass, visibility);</span>
<span class="fc" id="L338">        }</span>
        public JavaMethodZeroOrOneOrTwoOrThreeOrNBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L340">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L341">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {
<span class="fc" id="L345">            return call(context, self, clazz, name, arg0, arg1, arg2, Block.NULL_BLOCK);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2, Block block);
    }


    // promise to implement one to N with block
    public static abstract class JavaMethodOneOrNBlock extends JavaMethodNBlock {
        public JavaMethodOneOrNBlock(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L356">            super(implementationClass, visibility);</span>
<span class="fc" id="L357">        }</span>
        public JavaMethodOneOrNBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L359">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L360">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0) {
<span class="fc" id="L364">            return call(context, self, clazz, name, arg0, Block.NULL_BLOCK);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg, Block block);
    }

    public static abstract class JavaMethodOneOrTwoOrNBlock extends JavaMethodOneOrNBlock {
        public JavaMethodOneOrTwoOrNBlock(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L373">            super(implementationClass, visibility);</span>
<span class="fc" id="L374">        }</span>
        public JavaMethodOneOrTwoOrNBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L376">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L377">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L381">            return call(context, self, clazz, name, arg0, arg1, Block.NULL_BLOCK);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, Block block);
    }

    public static abstract class JavaMethodOneOrTwoOrThreeOrNBlock extends JavaMethodOneOrTwoOrNBlock {
        public JavaMethodOneOrTwoOrThreeOrNBlock(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L390">            super(implementationClass, visibility);</span>
<span class="fc" id="L391">        }</span>
        public JavaMethodOneOrTwoOrThreeOrNBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L393">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L394">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {
<span class="fc" id="L398">            return call(context, self, clazz, name, arg0, arg1, arg2, Block.NULL_BLOCK);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2, Block block);
    }


    // promise to implement two to N with block
    public static abstract class JavaMethodTwoOrNBlock extends JavaMethodNBlock {
        public JavaMethodTwoOrNBlock(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L409">            super(implementationClass, visibility);</span>
<span class="fc" id="L410">        }</span>
        public JavaMethodTwoOrNBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L412">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L413">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1) {
<span class="nc" id="L417">            return call(context, self, clazz, name, arg0, arg1, Block.NULL_BLOCK);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, Block block);
    }

    public static abstract class JavaMethodTwoOrThreeOrNBlock extends JavaMethodTwoOrNBlock {
        public JavaMethodTwoOrThreeOrNBlock(RubyModule implementationClass, Visibility visibility) {
<span class="nc" id="L426">            super(implementationClass, visibility);</span>
<span class="nc" id="L427">        }</span>
        public JavaMethodTwoOrThreeOrNBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L429">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L430">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {
<span class="nc" id="L434">            return call(context, self, clazz, name, arg0, arg1, arg2, Block.NULL_BLOCK);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg1, IRubyObject arg2, IRubyObject arg3, Block block);
    }


    // promise to implement three to N with block
    public static abstract class JavaMethodThreeOrNBlock extends JavaMethodNBlock {
        public JavaMethodThreeOrNBlock(RubyModule implementationClass, Visibility visibility) {
<span class="nc" id="L445">            super(implementationClass, visibility);</span>
<span class="nc" id="L446">        }</span>
        public JavaMethodThreeOrNBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L448">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L449">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {
<span class="nc" id="L453">            return call(context, self, clazz, name, arg0, arg1, arg2, Block.NULL_BLOCK);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg1, IRubyObject arg2, IRubyObject arg3, Block block);
    }


    // promise to implement zero to three with block
    public static abstract class JavaMethodZeroBlock extends JavaMethodZeroOrNBlock {
        public JavaMethodZeroBlock(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L464">            super(implementationClass, visibility);</span>
<span class="fc" id="L465">        }</span>
        public JavaMethodZeroBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L467">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L468">        }</span>

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">            if (args.length != 0) return raiseArgumentError(this, context, name, args.length, 0, 0);</span>
<span class="fc" id="L472">            return call(context, self, clazz, name, block);</span>
        }
    }

    public static abstract class JavaMethodZeroOrOneBlock extends JavaMethodZeroOrOneOrNBlock {
        public JavaMethodZeroOrOneBlock(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L478">            super(implementationClass, visibility);</span>
<span class="fc" id="L479">        }</span>
        public JavaMethodZeroOrOneBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L481">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L482">        }</span>

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="pc bpc" id="L485" title="1 of 3 branches missed.">            switch (args.length) {</span>
            case 0:
<span class="fc" id="L487">                return call(context, self, clazz, name, block);</span>
            case 1:
<span class="fc" id="L489">                return call(context, self, clazz, name, args[0], block);</span>
            default:
<span class="nc" id="L491">                return raiseArgumentError(this, context, name, args.length, 0, 1);</span>
            }
        }
    }

    public static abstract class JavaMethodZeroOrOneOrTwoBlock extends JavaMethodZeroOrOneOrTwoOrNBlock {
        public JavaMethodZeroOrOneOrTwoBlock(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L498">            super(implementationClass, visibility);</span>
<span class="fc" id="L499">        }</span>
        public JavaMethodZeroOrOneOrTwoBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L501">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L502">        }</span>

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="pc bpc" id="L505" title="1 of 4 branches missed.">            switch (args.length) {</span>
            case 0:
<span class="fc" id="L507">                return call(context, self, clazz, name, block);</span>
            case 1:
<span class="fc" id="L509">                return call(context, self, clazz, name, args[0], block);</span>
            case 2:
<span class="fc" id="L511">                return call(context, self, clazz, name, args[0], args[1], block);</span>
            default:
<span class="nc" id="L513">                return raiseArgumentError(this, context, name, args.length, 0, 2);</span>
            }
        }
    }

    public static abstract class JavaMethodZeroOrOneOrTwoOrThreeBlock extends JavaMethodZeroOrOneOrTwoOrThreeOrNBlock {
        public JavaMethodZeroOrOneOrTwoOrThreeBlock(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L520">            super(implementationClass, visibility);</span>
<span class="fc" id="L521">        }</span>
        public JavaMethodZeroOrOneOrTwoOrThreeBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L523">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L524">        }</span>

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="pc bpc" id="L527" title="1 of 5 branches missed.">            switch (args.length) {</span>
            case 0:
<span class="fc" id="L529">                return call(context, self, clazz, name, block);</span>
            case 1:
<span class="fc" id="L531">                return call(context, self, clazz, name, args[0], block);</span>
            case 2:
<span class="fc" id="L533">                return call(context, self, clazz, name, args[0], args[1], block);</span>
            case 3:
<span class="fc" id="L535">                return call(context, self, clazz, name, args[0], args[1], args[2], block);</span>
            default:
<span class="nc" id="L537">                return raiseArgumentError(this, context, name, args.length, 0, 3);</span>
            }
        }
    }

    // promise to implement one to three with block
    public static abstract class JavaMethodOneBlock extends JavaMethodOneOrNBlock {
        public JavaMethodOneBlock(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L545">            super(implementationClass, visibility);</span>
<span class="fc" id="L546">        }</span>
        public JavaMethodOneBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L548">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L549">        }</span>

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">            if (args.length != 1) return raiseArgumentError(this, context, name, args.length, 1, 1);</span>
<span class="fc" id="L553">            return call(context, self, clazz, name, args[0], block);</span>
        }

        @Override
        public Arity getArity() {
<span class="fc" id="L558">            return Arity.ONE_ARGUMENT;</span>
        }
    }

    public static abstract class JavaMethodOneOrTwoBlock extends JavaMethodOneOrTwoOrNBlock {
        public JavaMethodOneOrTwoBlock(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L564">            super(implementationClass, visibility);</span>
<span class="fc" id="L565">        }</span>
        public JavaMethodOneOrTwoBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L567">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L568">        }</span>

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="pc bpc" id="L571" title="1 of 3 branches missed.">            switch (args.length) {</span>
            case 1:
<span class="fc" id="L573">                return call(context, self, clazz, name, args[0], block);</span>
            case 2:
<span class="fc" id="L575">                return call(context, self, clazz, name, args[0], args[1], block);</span>
            default:
<span class="nc" id="L577">                return raiseArgumentError(this, context, name, args.length, 1, 2);</span>
            }
        }
    }

    public static abstract class JavaMethodOneOrTwoOrThreeBlock extends JavaMethodOneOrTwoOrThreeOrNBlock {
        public JavaMethodOneOrTwoOrThreeBlock(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L584">            super(implementationClass, visibility);</span>
<span class="fc" id="L585">        }</span>
        public JavaMethodOneOrTwoOrThreeBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L587">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L588">        }</span>

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="pc bpc" id="L591" title="2 of 5 branches missed.">            switch (args.length) {</span>
            case 0:
<span class="nc" id="L593">                throw context.runtime.newArgumentError(0, 1);</span>
<span class="fc" id="L594">            case 1: return call(context, self, clazz, name, args[0], block);</span>
<span class="fc" id="L595">            case 2: return call(context, self, clazz, name, args[0], args[1], block);</span>
<span class="fc" id="L596">            case 3: return call(context, self, clazz, name, args[0], args[1], args[2], block);</span>
<span class="nc" id="L597">            default: return raiseArgumentError(this, context, name, args.length, 3, 3);</span>
            }
        }
    }


    // promise to implement two to three with block
    public static abstract class JavaMethodTwoBlock extends JavaMethodTwoOrNBlock {
        public JavaMethodTwoBlock(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L606">            super(implementationClass, visibility);</span>
<span class="fc" id="L607">        }</span>
        public JavaMethodTwoBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L609">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L610">        }</span>

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="nc bnc" id="L613" title="All 2 branches missed.">            if (args.length != 2) return raiseArgumentError(this, context, name, args.length, 2, 2);</span>
<span class="nc" id="L614">            return call(context, self, clazz, name, args[0], args[1], block);</span>
        }
    }

    public static abstract class JavaMethodTwoOrThreeBlock extends JavaMethodTwoOrThreeOrNBlock {
        public JavaMethodTwoOrThreeBlock(RubyModule implementationClass, Visibility visibility) {
<span class="nc" id="L620">            super(implementationClass, visibility);</span>
<span class="nc" id="L621">        }</span>
        public JavaMethodTwoOrThreeBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L623">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L624">        }</span>

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="nc bnc" id="L627" title="All 3 branches missed.">            switch (args.length) {</span>
            case 2:
<span class="nc" id="L629">                return call(context, self, clazz, name, args[0], args[1], block);</span>
            case 3:
<span class="nc" id="L631">                return call(context, self, clazz, name, args[0], args[1], args[2], block);</span>
            default:
<span class="nc" id="L633">                return raiseArgumentError(this, context, name, args.length, 2, 3);</span>
            }
        }
    }


    // promise to implement three with block
    public static abstract class JavaMethodThreeBlock extends JavaMethodThreeOrNBlock {
        public JavaMethodThreeBlock(RubyModule implementationClass, Visibility visibility) {
<span class="nc" id="L642">            super(implementationClass, visibility);</span>
<span class="nc" id="L643">        }</span>
        public JavaMethodThreeBlock(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L645">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L646">        }</span>

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="nc bnc" id="L649" title="All 2 branches missed.">            if (args.length != 3) return raiseArgumentError(this, context, name, args.length, 3, 3);</span>
<span class="nc" id="L650">            return call(context, self, clazz, name, args[0], args[1], args[2], block);</span>
        }
    }

    // promise to implement N
    public static abstract class JavaMethodN extends JavaMethodNBlock {
        public JavaMethodN(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L657">            super(implementationClass, visibility);</span>
<span class="fc" id="L658">        }</span>
        public JavaMethodN(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L660">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L661">        }</span>
        public JavaMethodN(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig, String name) {
<span class="fc" id="L663">            super(implementationClass, visibility, callConfig, name);</span>
<span class="fc" id="L664">        }</span>

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args);

        // Normally we could leave these to fall back on the superclass, but
        // since it dispatches through the [] version below, which may
        // dispatch through the []+block version, we can save it a couple hops
        // by overriding these here.
        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, Block block) {
<span class="fc" id="L675">            return call(context, self, clazz, name, IRubyObject.NULL_ARRAY);</span>
        }
        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, Block block) {
<span class="fc" id="L679">            return call(context, self, clazz, name, new IRubyObject[] {arg0});</span>
        }
        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="fc" id="L683">            return call(context, self, clazz, name, new IRubyObject[] {arg0, arg1});</span>
        }
        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2, Block block) {
<span class="fc" id="L687">            return call(context, self, clazz, name, new IRubyObject[] {arg0, arg1, arg2});</span>
        }

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="fc" id="L691">            return call(context, self, clazz, name, args);</span>
        }
    }


    // promise to implement zero to N
    public static abstract class JavaMethodZeroOrN extends JavaMethodN {
        public JavaMethodZeroOrN(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L699">            super(implementationClass, visibility);</span>
<span class="fc" id="L700">        }</span>
        public JavaMethodZeroOrN(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L702">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L703">        }</span>
        public JavaMethodZeroOrN(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig, String name) {
<span class="fc" id="L705">            super(implementationClass, visibility, callConfig, name);</span>
<span class="fc" id="L706">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, Block block) {
<span class="fc" id="L710">            return call(context, self, clazz, name);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name);
    }

    public static abstract class JavaMethodZeroOrOneOrN extends JavaMethodZeroOrN {
        public JavaMethodZeroOrOneOrN(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L719">            super(implementationClass, visibility);</span>
<span class="fc" id="L720">        }</span>
        public JavaMethodZeroOrOneOrN(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L722">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L723">        }</span>
        
        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, Block block) {
<span class="fc" id="L727">            return call(context, self, clazz, name, arg0);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg);
    }

    public static abstract class JavaMethodZeroOrOneOrTwoOrN extends JavaMethodZeroOrOneOrN {
        public JavaMethodZeroOrOneOrTwoOrN(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L736">            super(implementationClass, visibility);</span>
<span class="fc" id="L737">        }</span>
        public JavaMethodZeroOrOneOrTwoOrN(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L739">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L740">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="nc" id="L744">            return call(context, self, clazz, name, arg0, arg1);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1);
    }

    public static abstract class JavaMethodZeroOrOneOrTwoOrThreeOrN extends JavaMethodZeroOrOneOrTwoOrN {
        public JavaMethodZeroOrOneOrTwoOrThreeOrN(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L753">            super(implementationClass, visibility);</span>
<span class="fc" id="L754">        }</span>
        public JavaMethodZeroOrOneOrTwoOrThreeOrN(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L756">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L757">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2, Block block) {
<span class="fc" id="L761">            return call(context, self, clazz, name, arg0, arg1, arg2);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2);
    }


    // promise to implement one to N
    public static abstract class JavaMethodOneOrN extends JavaMethodN {
        public JavaMethodOneOrN(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L772">            super(implementationClass, visibility);</span>
<span class="fc" id="L773">        }</span>
        public JavaMethodOneOrN(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L775">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L776">        }</span>
        public JavaMethodOneOrN(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig, String name) {
<span class="fc" id="L778">            super(implementationClass, visibility, callConfig, name);</span>
<span class="fc" id="L779">        }</span>
        
        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, Block block) {
<span class="fc" id="L783">            return call(context, self, clazz, name, arg0);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0);
    }

    public static abstract class JavaMethodOneOrTwoOrN extends JavaMethodOneOrN {
        public JavaMethodOneOrTwoOrN(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L792">            super(implementationClass, visibility);</span>
<span class="fc" id="L793">        }</span>
        public JavaMethodOneOrTwoOrN(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L795">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L796">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="nc" id="L800">            return call(context, self, clazz, name, arg0, arg1);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1);
    }

    public static abstract class JavaMethodOneOrTwoOrThreeOrN extends JavaMethodOneOrTwoOrN {
        public JavaMethodOneOrTwoOrThreeOrN(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L809">            super(implementationClass, visibility);</span>
<span class="fc" id="L810">        }</span>
        public JavaMethodOneOrTwoOrThreeOrN(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L812">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L813">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2, Block block) {
<span class="nc" id="L817">            return call(context, self, clazz, name, arg0, arg1, arg2);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2);
    }


    // promise to implement two to N
    public static abstract class JavaMethodTwoOrN extends JavaMethodN {
        public JavaMethodTwoOrN(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L828">            super(implementationClass, visibility);</span>
<span class="fc" id="L829">        }</span>
        public JavaMethodTwoOrN(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L831">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L832">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="fc" id="L836">            return call(context, self, clazz, name, arg0, arg1);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1);
    }

    public static abstract class JavaMethodTwoOrThreeOrN extends JavaMethodTwoOrN {
        public JavaMethodTwoOrThreeOrN(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L845">            super(implementationClass, visibility);</span>
<span class="fc" id="L846">        }</span>
        public JavaMethodTwoOrThreeOrN(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L848">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L849">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2, Block block) {
<span class="nc" id="L853">            return call(context, self, clazz, name, arg0, arg1, arg2);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2);
    }


    // promise to implement three to N
    public static abstract class JavaMethodThreeOrN extends JavaMethodN {
        public JavaMethodThreeOrN(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L864">            super(implementationClass, visibility);</span>
<span class="fc" id="L865">        }</span>
        public JavaMethodThreeOrN(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L867">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L868">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2, Block block) {
<span class="nc" id="L872">            return call(context, self, clazz, name, arg0, arg1, arg2);</span>
        }

        @Override
        public abstract IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2);
    }


    // promise to implement zero to three
    public static abstract class JavaMethodZero extends JavaMethodZeroOrN {
        public JavaMethodZero(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L883">            super(implementationClass, visibility);</span>
<span class="fc" id="L884">        }</span>
        public JavaMethodZero(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L886">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L887">        }</span>
        public JavaMethodZero(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig, String name) {
<span class="fc" id="L889">            super(implementationClass, visibility, callConfig, name);</span>
<span class="fc" id="L890">        }</span>

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args) {
<span class="pc bpc" id="L893" title="1 of 2 branches missed.">            if (args.length != 0) return raiseArgumentError(this, context, name, args.length, 0, 0);</span>
<span class="fc" id="L894">            return call(context, self, clazz, name);</span>
        }
        @Override
        public Arity getArity() {
<span class="fc" id="L898">            return Arity.NO_ARGUMENTS;</span>
        }
    }

    public static abstract class JavaMethodZeroOrOne extends JavaMethodZeroOrOneOrN {
        public JavaMethodZeroOrOne(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L904">            super(implementationClass, visibility);</span>
<span class="fc" id="L905">        }</span>
        public JavaMethodZeroOrOne(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L907">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L908">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args) {
<span class="pc bpc" id="L912" title="1 of 3 branches missed.">            switch (args.length) {</span>
            case 0:
<span class="fc" id="L914">                return call(context, self, clazz, name);</span>
            case 1:
<span class="fc" id="L916">                return call(context, self, clazz, name, args[0]);</span>
            default:
<span class="nc" id="L918">                return raiseArgumentError(this, context, name, args.length, 0, 1);</span>
            }
        }
    }

    public static abstract class JavaMethodZeroOrOneOrTwo extends JavaMethodZeroOrOneOrTwoOrN {
        public JavaMethodZeroOrOneOrTwo(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L925">            super(implementationClass, visibility);</span>
<span class="fc" id="L926">        }</span>
        public JavaMethodZeroOrOneOrTwo(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L928">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L929">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args) {
<span class="pc bpc" id="L933" title="1 of 4 branches missed.">            switch (args.length) {</span>
            case 0:
<span class="fc" id="L935">                return call(context, self, clazz, name);</span>
            case 1:
<span class="fc" id="L937">                return call(context, self, clazz, name, args[0]);</span>
            case 2:
<span class="fc" id="L939">                return call(context, self, clazz, name, args[0], args[1]);</span>
            default:
<span class="nc" id="L941">                return raiseArgumentError(this, context, name, args.length, 0, 2);</span>
            }
        }
    }

    public static abstract class JavaMethodZeroOrOneOrTwoOrThree extends JavaMethodZeroOrOneOrTwoOrThreeOrN {
        public JavaMethodZeroOrOneOrTwoOrThree(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L948">            super(implementationClass, visibility);</span>
<span class="fc" id="L949">        }</span>
        public JavaMethodZeroOrOneOrTwoOrThree(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L951">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L952">        }</span>

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args) {
<span class="pc bpc" id="L955" title="2 of 5 branches missed.">            switch (args.length) {</span>
            case 0:
<span class="nc" id="L957">                return call(context, self, clazz, name);</span>
            case 1:
<span class="fc" id="L959">                return call(context, self, clazz, name, args[0]);</span>
            case 2:
<span class="fc" id="L961">                return call(context, self, clazz, name, args[0], args[1]);</span>
            case 3:
<span class="fc" id="L963">                return call(context, self, clazz, name, args[0], args[1], args[2]);</span>
            default:
<span class="nc" id="L965">                return raiseArgumentError(this, context, name, args.length, 0, 3);</span>
            }
        }
    }


    // promise to implement one to three
    public static abstract class JavaMethodOne extends JavaMethodOneOrN {
        public JavaMethodOne(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L974">            super(implementationClass, visibility);</span>
<span class="fc" id="L975">        }</span>
        public JavaMethodOne(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L977">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L978">        }</span>
        public JavaMethodOne(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig, String name) {
<span class="fc" id="L980">            super(implementationClass, visibility, callConfig, name);</span>
<span class="fc" id="L981">        }</span>

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args) {
<span class="pc bpc" id="L984" title="1 of 2 branches missed.">            if (args.length != 1) return raiseArgumentError(this, context, name, args.length, 1, 1);</span>
<span class="fc" id="L985">            return call(context, self, clazz, name, args[0]);</span>
        }

        @Override
        public Arity getArity() {
<span class="fc" id="L990">            return Arity.ONE_ARGUMENT;</span>
        }
    }

    public static abstract class JavaMethodOneOrTwo extends JavaMethodOneOrTwoOrN {
        public JavaMethodOneOrTwo(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L996">            super(implementationClass, visibility);</span>
<span class="fc" id="L997">        }</span>
        public JavaMethodOneOrTwo(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L999">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L1000">        }</span>

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args) {
<span class="pc bpc" id="L1003" title="1 of 3 branches missed.">            switch (args.length) {</span>
            case 1:
<span class="fc" id="L1005">                return call(context, self, clazz, name, args[0]);</span>
            case 2:
<span class="fc" id="L1007">                return call(context, self, clazz, name, args[0], args[1]);</span>
            default:
<span class="nc" id="L1009">                return raiseArgumentError(this, context, name, args.length, 1, 2);</span>
            }
        }
    }

    public static abstract class JavaMethodOneOrTwoOrThree extends JavaMethodOneOrTwoOrThreeOrN {
        public JavaMethodOneOrTwoOrThree(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L1016">            super(implementationClass, visibility);</span>
<span class="fc" id="L1017">        }</span>
        public JavaMethodOneOrTwoOrThree(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L1019">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L1020">        }</span>

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args) {
<span class="pc bpc" id="L1023" title="1 of 4 branches missed.">            switch (args.length) {</span>
            case 1:
<span class="fc" id="L1025">                return call(context, self, clazz, name, args[0]);</span>
            case 2:
<span class="fc" id="L1027">                return call(context, self, clazz, name, args[0], args[1]);</span>
            case 3:
<span class="fc" id="L1029">                return call(context, self, clazz, name, args[0], args[1], args[2]);</span>
            default:
<span class="nc" id="L1031">                return raiseArgumentError(this, context, name, args.length, 1, 3);</span>
            }
        }
    }


    // promise to implement two to three
    public static abstract class JavaMethodTwo extends JavaMethodTwoOrN {
        public JavaMethodTwo(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L1040">            super(implementationClass, visibility);</span>
<span class="fc" id="L1041">        }</span>
        public JavaMethodTwo(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L1043">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L1044">        }</span>

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args) {
<span class="pc bpc" id="L1047" title="1 of 2 branches missed.">            if (args.length != 2) return raiseArgumentError(this, context, name, args.length, 2, 2);</span>
<span class="fc" id="L1048">            return call(context, self, clazz, name, args[0], args[1]);</span>
        }

        @Override
        public Arity getArity() {
<span class="nc" id="L1053">            return Arity.TWO_ARGUMENTS;</span>
        }
    }

    public static abstract class JavaMethodTwoOrThree extends JavaMethodTwoOrThreeOrN {
        public JavaMethodTwoOrThree(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L1059">            super(implementationClass, visibility);</span>
<span class="fc" id="L1060">        }</span>
        public JavaMethodTwoOrThree(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L1062">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L1063">        }</span>

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args) {
<span class="pc bpc" id="L1066" title="1 of 3 branches missed.">            switch (args.length) {</span>
            case 2:
<span class="fc" id="L1068">                return call(context, self, clazz, name, args[0], args[1]);</span>
            case 3:
<span class="fc" id="L1070">                return call(context, self, clazz, name, args[0], args[1], args[2]);</span>
            default:
<span class="nc" id="L1072">                return raiseArgumentError(this, context, name, args.length, 2, 3);</span>
            }
        }
    }


    // promise to implement three
    public static abstract class JavaMethodThree extends JavaMethodThreeOrN {
        public JavaMethodThree(RubyModule implementationClass, Visibility visibility) {
<span class="fc" id="L1081">            super(implementationClass, visibility);</span>
<span class="fc" id="L1082">        }</span>
        public JavaMethodThree(RubyModule implementationClass, Visibility visibility, CallConfiguration callConfig) {
<span class="nc" id="L1084">            super(implementationClass, visibility, callConfig);</span>
<span class="nc" id="L1085">        }</span>

        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args) {
<span class="pc bpc" id="L1088" title="1 of 2 branches missed.">            if (args.length != 3) return raiseArgumentError(this, context, name, args.length, 3, 3);</span>
<span class="fc" id="L1089">            return call(context, self, clazz, name, args[0], args[1], args[2]);</span>
        }

        @Override
        public Arity getArity() {
<span class="nc" id="L1094">            return Arity.THREE_ARGUMENTS;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>