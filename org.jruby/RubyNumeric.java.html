<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RubyNumeric.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby</a> &gt; <span class="el_source">RubyNumeric.java</span></div><h1>RubyNumeric.java</h1><pre class="source lang-java linenums">/***** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2001 Alan Moore &lt;alan_moore@gmx.net&gt;
 * Copyright (C) 2001-2004 Jan Arne Petersen &lt;jpetersen@uni-bonn.de&gt;
 * Copyright (C) 2002 Benoit Cerrina &lt;b.cerrina@wanadoo.fr&gt;
 * Copyright (C) 2002-2004 Anders Bengtsson &lt;ndrsbngtssn@yahoo.se&gt;
 * Copyright (C) 2002-2004 Thomas E Enebo &lt;enebo@acm.org&gt;
 * Copyright (C) 2004 Stefan Matthias Aust &lt;sma@3plus4.de&gt;
 * Copyright (C) 2006 Miguel Covarrubias &lt;mlcovarrubias@gmail.com&gt;
 * Copyright (C) 2006 Antti Karanta &lt;Antti.Karanta@napa.fi&gt;
 * 
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby;

import org.jruby.anno.JRubyClass;
import org.jruby.anno.JRubyMethod;
import org.jruby.ast.util.ArgsUtil;
import org.jruby.common.RubyWarnings;
import org.jruby.exceptions.RaiseException;
import org.jruby.javasupport.JavaUtil;
import org.jruby.runtime.Block;
import org.jruby.runtime.ClassIndex;
import org.jruby.runtime.Helpers;
import org.jruby.runtime.ObjectAllocator;
import org.jruby.runtime.ThreadContext;
import org.jruby.runtime.Visibility;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.runtime.invokedynamic.MethodNames;
import org.jruby.util.ByteList;
import org.jruby.util.ConvertBytes;
import org.jruby.util.ConvertDouble;

import java.math.BigInteger;

import static org.jruby.RubyEnumerator.SizeFn;
import static org.jruby.RubyEnumerator.enumeratorizeWithSize;
import static org.jruby.runtime.Helpers.invokedynamic;
import static org.jruby.util.Numeric.f_abs;
import static org.jruby.util.Numeric.f_arg;
import static org.jruby.util.Numeric.f_mul;
import static org.jruby.util.Numeric.f_negative_p;

/**
 * Base class for all numerical types in ruby.
 */
// TODO: Numeric.new works in Ruby and it does here too.  However trying to use
//   that instance in a numeric operation should generate an ArgumentError. Doing
//   this seems so pathological I do not see the need to fix this now.
@JRubyClass(name=&quot;Numeric&quot;, include=&quot;Comparable&quot;)
public class RubyNumeric extends RubyObject {
    
    public static RubyClass createNumericClass(Ruby runtime) {
<span class="fc" id="L75">        RubyClass numeric = runtime.defineClass(&quot;Numeric&quot;, runtime.getObject(), NUMERIC_ALLOCATOR);</span>
<span class="fc" id="L76">        runtime.setNumeric(numeric);</span>

<span class="fc" id="L78">        numeric.setClassIndex(ClassIndex.NUMERIC);</span>
<span class="fc" id="L79">        numeric.setReifiedClass(RubyNumeric.class);</span>

<span class="fc" id="L81">        numeric.kindOf = new RubyModule.JavaClassKindOf(RubyNumeric.class);</span>

<span class="fc" id="L83">        numeric.includeModule(runtime.getComparable());</span>
<span class="fc" id="L84">        numeric.defineAnnotatedMethods(RubyNumeric.class);</span>

<span class="fc" id="L86">        return numeric;</span>
    }

<span class="fc" id="L89">    protected static final ObjectAllocator NUMERIC_ALLOCATOR = new ObjectAllocator() {</span>
        public IRubyObject allocate(Ruby runtime, RubyClass klass) {
<span class="fc" id="L91">            return new RubyNumeric(runtime, klass);</span>
        }
    };

    public static final double DBL_EPSILON=2.2204460492503131e-16;

    private static IRubyObject convertToNum(double val, Ruby runtime) {

<span class="pc bpc" id="L99" title="1 of 4 branches missed.">        if (val &gt;= (double) RubyFixnum.MAX || val &lt; (double) RubyFixnum.MIN) {</span>
<span class="fc" id="L100">            return RubyBignum.newBignum(runtime, val);</span>
        }
<span class="fc" id="L102">        return RubyFixnum.newFixnum(runtime, (long) val);</span>
    }
    
    public RubyNumeric(Ruby runtime, RubyClass metaClass) {
<span class="fc" id="L106">        super(runtime, metaClass);</span>
<span class="fc" id="L107">    }</span>

    public RubyNumeric(RubyClass metaClass) {
<span class="fc" id="L110">        super(metaClass);</span>
<span class="fc" id="L111">    }</span>

    public RubyNumeric(Ruby runtime, RubyClass metaClass, boolean useObjectSpace) {
<span class="nc" id="L114">        super(runtime, metaClass, useObjectSpace);</span>
<span class="nc" id="L115">    }    </span>

    @Deprecated
    public RubyNumeric(Ruby runtime, RubyClass metaClass, boolean useObjectSpace, boolean canBeTainted) {
<span class="nc" id="L119">        super(runtime, metaClass, useObjectSpace, canBeTainted);</span>
<span class="nc" id="L120">    }    </span>
    
    // The implementations of these are all bonus (see TODO above)  I was going
    // to throw an error from these, but it appears to be the wrong place to
    // do it.
    public double getDoubleValue() {
<span class="fc" id="L126">        return 0;</span>
    }

    /**
     * Return the value of this numeric as a 64-bit long. If the value does not
     * fit in 64 bits, it will be truncated.
     */
    public long getLongValue() {
<span class="nc" id="L134">        return 0;</span>
    }

    /**
     * Return the value of this numeric as a 32-bit long. If the value does not
     * fit in 32 bits, it will be truncated.
     */
    public int getIntValue() {
<span class="nc" id="L142">        return 0;</span>
    }

    public BigInteger getBigIntegerValue() {
<span class="nc" id="L146">        return BigInteger.ZERO;</span>
    }
    
    public static RubyNumeric newNumeric(Ruby runtime) {
<span class="nc" id="L150">    	return new RubyNumeric(runtime, runtime.getNumeric());</span>
    }

    /*  ================
     *  Utility Methods
     *  ================ 
     */

    /** rb_num2int, NUM2INT
     * 
     */
    public static int num2int(IRubyObject arg) {
<span class="fc" id="L162">        long num = num2long(arg);</span>

<span class="fc" id="L164">        checkInt(arg, num);</span>
<span class="fc" id="L165">        return (int)num;</span>
    }
    
    /** check_int
     * 
     */
    public static void checkInt(IRubyObject arg, long num){
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        if (num &lt; Integer.MIN_VALUE) {</span>
<span class="nc" id="L173">            tooSmall(arg, num);</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">        } else if (num &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L175">            tooBig(arg, num);</span>
        } else {
<span class="fc" id="L177">            return;</span>
        }
<span class="nc" id="L179">    }</span>
    
    private static void tooSmall(IRubyObject arg, long num) {
<span class="fc" id="L182">        throw arg.getRuntime().newRangeError(&quot;integer &quot; + num + &quot; too small to convert to `int'&quot;);</span>
    }
    
    private static void tooBig(IRubyObject arg, long num) {
<span class="fc" id="L186">        throw arg.getRuntime().newRangeError(&quot;integer &quot; + num + &quot; too big to convert to `int'&quot;);</span>
    }

    /**
     * NUM2CHR
     */
    public static byte num2chr(IRubyObject arg) {
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        if (arg instanceof RubyString) {</span>
<span class="nc" id="L194">            String value = ((RubyString) arg).toString();</span>

<span class="nc bnc" id="L196" title="All 4 branches missed.">            if (value != null &amp;&amp; value.length() &gt; 0) return (byte) value.charAt(0);</span>
        } 

<span class="nc" id="L199">        return (byte) num2int(arg);</span>
    }

    /** rb_num2long and FIX2LONG (numeric.c)
     * 
     */
    public static long num2long(IRubyObject arg) {
<span class="fc bfc" id="L206" title="All 2 branches covered.">        if (arg instanceof RubyFixnum) {</span>
<span class="fc" id="L207">            return ((RubyFixnum) arg).getLongValue();</span>
        } else {
<span class="fc" id="L209">            return other2long(arg);</span>
        }
    }

    private static long other2long(IRubyObject arg) throws RaiseException {
<span class="fc bfc" id="L214" title="All 2 branches covered.">        if (arg.isNil()) {</span>
<span class="fc" id="L215">            throw arg.getRuntime().newTypeError(&quot;no implicit conversion from nil to integer&quot;);</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        } else if (arg instanceof RubyFloat) {</span>
<span class="fc" id="L217">            return float2long((RubyFloat)arg);</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">        } else if (arg instanceof RubyBignum) {</span>
<span class="nc" id="L219">            return RubyBignum.big2long((RubyBignum) arg);</span>
        }
<span class="fc" id="L221">        return arg.convertToInteger().getLongValue();</span>
    }
    
    private static long float2long(RubyFloat flt) {
<span class="fc" id="L225">        double aFloat = flt.getDoubleValue();</span>
<span class="pc bpc" id="L226" title="1 of 4 branches missed.">        if (aFloat &lt;= (double) Long.MAX_VALUE &amp;&amp; aFloat &gt;= (double) Long.MIN_VALUE) {</span>
<span class="fc" id="L227">            return (long) aFloat;</span>
        } else {
            // TODO: number formatting here, MRI uses &quot;%-.10g&quot;, 1.4 API is a must?
<span class="fc" id="L230">            throw flt.getRuntime().newRangeError(&quot;float &quot; + aFloat + &quot; out of range of integer&quot;);</span>
        }
    }

    /** rb_dbl2big + LONG2FIX at once (numeric.c)
     * 
     */
    public static IRubyObject dbl2num(Ruby runtime, double val) {
<span class="fc bfc" id="L238" title="All 2 branches covered.">        if (Double.isInfinite(val)) {</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">            throw runtime.newFloatDomainError(val &lt; 0 ? &quot;-Infinity&quot; : &quot;Infinity&quot;);</span>
        }
<span class="fc bfc" id="L241" title="All 2 branches covered.">        if (Double.isNaN(val)) {</span>
<span class="fc" id="L242">            throw runtime.newFloatDomainError(&quot;NaN&quot;);</span>
        }
<span class="fc" id="L244">        return convertToNum(val, runtime);</span>
    }

    /** rb_num2dbl and NUM2DBL
     * 
     */
    public static double num2dbl(IRubyObject arg) {
<span class="fc bfc" id="L251" title="All 2 branches covered.">        if (arg instanceof RubyFloat) {</span>
<span class="fc" id="L252">            return ((RubyFloat) arg).getDoubleValue();</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">        } else if (arg instanceof RubyString) {</span>
<span class="fc" id="L254">            throw arg.getRuntime().newTypeError(&quot;no implicit conversion to float from string&quot;);</span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        } else if (arg == arg.getRuntime().getNil()) {</span>
<span class="nc" id="L256">            throw arg.getRuntime().newTypeError(&quot;no implicit conversion to float from nil&quot;);</span>
        }
<span class="fc" id="L258">        return RubyKernel.new_float(arg, arg).getDoubleValue();</span>
    }

    /** rb_dbl_cmp (numeric.c)
     * 
     */
    public static IRubyObject dbl_cmp(Ruby runtime, double a, double b) {
<span class="fc bfc" id="L265" title="All 4 branches covered.">        if (Double.isNaN(a) || Double.isNaN(b)) return runtime.getNil();</span>
<span class="fc bfc" id="L266" title="All 4 branches covered.">        return a == b ? RubyFixnum.zero(runtime) : a &gt; b ?</span>
<span class="fc" id="L267">                RubyFixnum.one(runtime) : RubyFixnum.minus_one(runtime);</span>
    }

    public static long fix2long(IRubyObject arg) {
<span class="fc" id="L271">        return ((RubyFixnum) arg).getLongValue();</span>
    }

    public static int fix2int(IRubyObject arg) {
<span class="fc bfc" id="L275" title="All 2 branches covered.">        long num = arg instanceof RubyFixnum ? fix2long(arg) : num2long(arg);</span>
<span class="fc" id="L276">        checkInt(arg, num);</span>
<span class="fc" id="L277">        return (int) num;</span>
    }

    public static int fix2int(RubyFixnum arg) {
<span class="fc" id="L281">        long num = arg.getLongValue();</span>
<span class="fc" id="L282">        checkInt(arg, num);</span>
<span class="fc" id="L283">        return (int) num;</span>
    }

    public static RubyInteger str2inum(Ruby runtime, RubyString str, int base) {
<span class="nc" id="L287">        return str2inum(runtime,str,base,false);</span>
    }

    public static RubyNumeric int2fix(Ruby runtime, long val) {
<span class="fc" id="L291">        return RubyFixnum.newFixnum(runtime,val);</span>
    }

    /** rb_num2fix
     * 
     */
    public static IRubyObject num2fix(IRubyObject val) {
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (val instanceof RubyFixnum) {</span>
<span class="nc" id="L299">            return val;</span>
        }
<span class="nc bnc" id="L301" title="All 2 branches missed.">        if (val instanceof RubyBignum) {</span>
            // any BigInteger is bigger than Fixnum and we don't have FIXABLE
<span class="nc" id="L303">            throw val.getRuntime().newRangeError(&quot;integer &quot; + val + &quot; out of range of fixnum&quot;);</span>
        }
<span class="nc" id="L305">        return RubyFixnum.newFixnum(val.getRuntime(), num2long(val));</span>
    }

    /**
     * Converts a string representation of an integer to the integer value. 
     * Parsing starts at the beginning of the string (after leading and 
     * trailing whitespace have been removed), and stops at the end or at the 
     * first character that can't be part of an integer.  Leading signs are
     * allowed. If &lt;code&gt;base&lt;/code&gt; is zero, strings that begin with '0[xX]',
     * '0[bB]', or '0' (optionally preceded by a sign) will be treated as hex, 
     * binary, or octal numbers, respectively.  If a non-zero base is given, 
     * only the prefix (if any) that is appropriate to that base will be 
     * parsed correctly.  For example, if the base is zero or 16, the string
     * &quot;0xff&quot; will be converted to 256, but if the base is 10, it will come out 
     * as zero, since 'x' is not a valid decimal digit.  If the string fails 
     * to parse as a number, zero is returned.
     * 
     * @param runtime  the ruby runtime
     * @param str   the string to be converted
     * @param base  the expected base of the number (for example, 2, 8, 10, 16),
     *              or 0 if the method should determine the base automatically 
     *              (defaults to 10). Values 0 and 2-36 are permitted. Any other
     *              value will result in an ArgumentError.
     * @param strict if true, enforce the strict criteria for String encoding of
     *               numeric values, as required by Integer('n'), and raise an
     *               exception when those criteria are not met. Otherwise, allow
     *               lax expression of values, as permitted by String#to_i, and
     *               return a value in almost all cases (excepting illegal radix).
     *               TODO: describe the rules/criteria
     * @return  a RubyFixnum or (if necessary) a RubyBignum representing 
     *          the result of the conversion, which will be zero if the 
     *          conversion failed.
     */
    public static RubyInteger str2inum(Ruby runtime, RubyString str, int base, boolean strict) {
<span class="fc" id="L339">        ByteList s = str.getByteList();</span>
<span class="fc" id="L340">        return ConvertBytes.byteListToInum(runtime, s, base, strict);</span>
    }

    public static RubyFloat str2fnum(Ruby runtime, RubyString arg) {
<span class="nc" id="L344">        return str2fnum(runtime,arg,false);</span>
    }

    /**
     * Converts a string representation of a floating-point number to the 
     * numeric value.  Parsing starts at the beginning of the string (after 
     * leading and trailing whitespace have been removed), and stops at the 
     * end or at the first character that can't be part of a number.  If 
     * the string fails to parse as a number, 0.0 is returned.
     * 
     * @param runtime  the ruby runtime
     * @param arg   the string to be converted
     * @param strict if true, enforce the strict criteria for String encoding of
     *               numeric values, as required by Float('n'), and raise an
     *               exception when those criteria are not met. Otherwise, allow
     *               lax expression of values, as permitted by String#to_f, and
     *               return a value in all cases.
     *               TODO: describe the rules/criteria
     * @return  a RubyFloat representing the result of the conversion, which
     *          will be 0.0 if the conversion failed.
     */
    public static RubyFloat str2fnum(Ruby runtime, RubyString arg, boolean strict) {
<span class="nc" id="L366">        return str2fnumCommon(runtime, arg, strict, biteListCaller18);</span>
    }
    
    public static RubyFloat str2fnum19(Ruby runtime, RubyString arg, boolean strict) {
<span class="fc" id="L370">        return str2fnumCommon(runtime, arg, strict, biteListCaller19);</span>
    }

    private static RubyFloat str2fnumCommon(Ruby runtime, RubyString arg, boolean strict, ByteListCaller caller) {
<span class="fc" id="L374">        final double ZERO = 0.0;</span>
        try {
<span class="fc" id="L376">            return new RubyFloat(runtime, caller.yield(arg, strict));</span>
<span class="fc" id="L377">        } catch (NumberFormatException e) {</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">            if (strict) {</span>
<span class="fc" id="L379">                throw runtime.newArgumentError(&quot;invalid value for Float(): &quot;</span>
<span class="fc" id="L380">                        + arg.callMethod(runtime.getCurrentContext(), &quot;inspect&quot;).toString());</span>
            }
<span class="nc" id="L382">            return new RubyFloat(runtime,ZERO);</span>
        }
    }

    private static interface ByteListCaller {
        public double yield(RubyString arg, boolean strict);
    }

<span class="fc" id="L390">    private static class ByteListCaller18 implements ByteListCaller {</span>
        public double yield(RubyString arg, boolean strict) {
<span class="nc" id="L392">            return ConvertDouble.byteListToDouble(arg.getByteList(),strict);</span>
        }
    }
<span class="fc" id="L395">    private static final ByteListCaller18 biteListCaller18 = new ByteListCaller18();</span>

<span class="fc" id="L397">    private static class ByteListCaller19 implements ByteListCaller {</span>
        public double yield(RubyString arg, boolean strict) {
<span class="fc" id="L399">            return ConvertDouble.byteListToDouble19(arg.getByteList(),strict);</span>
        }
    }
<span class="fc" id="L402">    private static final ByteListCaller19 biteListCaller19 = new ByteListCaller19();</span>

    
    /** Numeric methods. (num_*)
     *
     */
    
    protected IRubyObject[] getCoerced(ThreadContext context, IRubyObject other, boolean error) {
        IRubyObject result;
        
<span class="nc" id="L412">        IRubyObject savedError = context.runtime.getGlobalVariables().get(&quot;$!&quot;);</span>
        try {
<span class="nc" id="L414">            result = other.callMethod(context, &quot;coerce&quot;, this);</span>
<span class="nc" id="L415">        } catch (RaiseException e) {</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">            if (error) {</span>
<span class="nc" id="L417">                throw getRuntime().newTypeError(</span>
<span class="nc" id="L418">                        other.getMetaClass().getName() + &quot; can't be coerced into &quot; + getMetaClass().getName());</span>
            } else {
<span class="nc" id="L420">                context.runtime.getGlobalVariables().set(&quot;$!&quot;, savedError);</span>
            }
             
<span class="nc" id="L423">            return null;</span>
<span class="nc" id="L424">        }</span>
        
<span class="nc bnc" id="L426" title="All 4 branches missed.">        if (!(result instanceof RubyArray) || ((RubyArray)result).getLength() != 2) {</span>
<span class="nc" id="L427">            throw getRuntime().newTypeError(&quot;coerce must return [x, y]&quot;);</span>
        }
        
<span class="nc" id="L430">        return ((RubyArray)result).toJavaArray();</span>
    }

    protected IRubyObject callCoerced(ThreadContext context, String method, IRubyObject other, boolean err) {
<span class="nc" id="L434">        IRubyObject[] args = getCoerced(context, other, err);</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">        if(args == null) {</span>
<span class="nc" id="L436">            return getRuntime().getNil();</span>
        }
<span class="nc" id="L438">        return args[0].callMethod(context, method, args[1]);</span>
    }

    public IRubyObject callCoerced(ThreadContext context, String method, IRubyObject other) {
<span class="nc" id="L442">        IRubyObject[] args = getCoerced(context, other, false);</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">        if(args == null) {</span>
<span class="nc" id="L444">            return getRuntime().getNil();</span>
        }
<span class="nc" id="L446">        return args[0].callMethod(context, method, args[1]);</span>
    }
    
    // beneath are rewritten coercions that reflect MRI logic, the aboves are used only by RubyBigDecimal

    /** coerce_body
     *
     */
    protected final IRubyObject coerceBody(ThreadContext context, IRubyObject other) {
<span class="fc" id="L455">        return other.callMethod(context, &quot;coerce&quot;, this);</span>
    }

    /** do_coerce
     * 
     */
    protected final RubyArray doCoerce(ThreadContext context, IRubyObject other, boolean err) {
        IRubyObject result;

<span class="fc" id="L464">        IRubyObject savedError = context.runtime.getGlobalVariables().get(&quot;$!&quot;);</span>
        try {
<span class="fc" id="L466">            result = coerceBody(context, other);</span>
<span class="fc" id="L467">        } catch (RaiseException e) {</span>
<span class="fc" id="L468">            RubyWarnings warnings = context.runtime.getWarnings();</span>
<span class="fc" id="L469">            warnings.warn(&quot;Numerical comparison operators will no more rescue exceptions of #coerce&quot;);</span>
<span class="fc" id="L470">            warnings.warn(&quot;in the next release. Return nil in #coerce if the coercion is impossible.&quot;);</span>
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">            if (err) {</span>
<span class="nc" id="L472">                coerceFailed(context, other);</span>
            } else {
<span class="fc" id="L474">                context.runtime.getGlobalVariables().set(&quot;$!&quot;, savedError);</span>
            }
<span class="fc" id="L476">            return null;</span>
<span class="fc" id="L477">        }</span>
    
<span class="pc bpc" id="L479" title="1 of 4 branches missed.">        if (!(result instanceof RubyArray) || ((RubyArray) result).getLength() != 2) {</span>
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">            if (err) {</span>
<span class="nc" id="L481">                throw context.runtime.newTypeError(&quot;coerce must return [x, y]&quot;);</span>
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">            } else if (!result.isNil()) {</span>
<span class="nc" id="L483">                RubyWarnings warnings = context.runtime.getWarnings();</span>
<span class="nc" id="L484">                warnings.warn(&quot;Bad return value for #coerce, called by numerical comparison operators.&quot;);</span>
<span class="nc" id="L485">                warnings.warn(&quot;#coerce must return [x, y]. The next release will raise an error for this.&quot;);</span>
            }
<span class="fc" id="L487">            return null;</span>
        }
<span class="fc" id="L489">        return (RubyArray) result;</span>
    }

    /** coerce_failed
     *
     */
    protected final void coerceFailed(ThreadContext context, IRubyObject other) {
<span class="fc" id="L496">        throw context.runtime.newTypeError(String.format(&quot;%s can't be coerced into %s&quot;,</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">                (other.isSpecialConst() ? other.inspect() : other.getMetaClass().getName()), getMetaClass()));</span>
    }

    /** rb_num_coerce_bin
     *  coercion taking two arguments
     */
    protected final IRubyObject coerceBin(ThreadContext context, String method, IRubyObject other) {
<span class="fc" id="L504">        RubyArray ary = doCoerce(context, other, true);</span>
<span class="fc" id="L505">        return (ary.eltInternal(0)).callMethod(context, method, ary.eltInternal(1));</span>
    }
    
    /** rb_num_coerce_cmp
     *  coercion used for comparisons
     */
    protected final IRubyObject coerceCmp(ThreadContext context, String method, IRubyObject other) {
<span class="fc" id="L512">        RubyArray ary = doCoerce(context, other, false);</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">        if (ary == null) {</span>
<span class="fc" id="L514">            return context.runtime.getNil(); // MRI does it!</span>
        } 
<span class="fc" id="L516">        return (ary.eltInternal(0)).callMethod(context, method, ary.eltInternal(1));</span>
    }
        
    /** rb_num_coerce_relop
     *  coercion used for relative operators
     */
    protected final IRubyObject coerceRelOp(ThreadContext context, String method, IRubyObject other) {
<span class="fc" id="L523">        RubyArray ary = doCoerce(context, other, false);</span>
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">        if (ary == null) {</span>
<span class="nc" id="L525">            return RubyComparable.cmperr(this, other);</span>
        }

<span class="fc" id="L528">        return unwrapCoerced(context, method, other, ary);</span>
    }

    private IRubyObject unwrapCoerced(ThreadContext context, String method, IRubyObject other, RubyArray ary) {
<span class="fc" id="L532">        IRubyObject result = (ary.eltInternal(0)).callMethod(context, method, ary.eltInternal(1));</span>
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">        if (result.isNil()) {</span>
<span class="nc" id="L534">            return RubyComparable.cmperr(this, other);</span>
        }
<span class="fc" id="L536">        return result;</span>
    }
        
    public RubyNumeric asNumeric() {
<span class="nc" id="L540">        return this;</span>
    }

    /*  ================
     *  Instance Methods
     *  ================ 
     */

    /** num_sadded
     *
     */
    @JRubyMethod(name = &quot;singleton_method_added&quot;)
    public IRubyObject sadded(IRubyObject name) {
<span class="fc" id="L553">        throw getRuntime().newTypeError(&quot;can't define singleton method &quot; + name + &quot; for &quot; + getType().getName());</span>
    } 
        
    /** num_init_copy
     *
     */
    @Override
    @JRubyMethod(name = &quot;initialize_copy&quot;, visibility = Visibility.PRIVATE)
    public IRubyObject initialize_copy(IRubyObject arg) {
<span class="fc" id="L562">        throw getRuntime().newTypeError(&quot;can't copy &quot; + getType().getName());</span>
    }
    
    /** num_coerce
     *
     */
    @JRubyMethod(name = &quot;coerce&quot;)
    public IRubyObject coerce(IRubyObject other) {
<span class="fc bfc" id="L570" title="All 2 branches covered.">        if (getMetaClass() == other.getMetaClass()) return getRuntime().newArray(other, this);</span>

<span class="fc" id="L572">        IRubyObject cdr = RubyKernel.new_float(this, this);</span>
<span class="fc" id="L573">        IRubyObject car = RubyKernel.new_float(this, other);</span>

<span class="fc" id="L575">        return getRuntime().newArray(car, cdr);</span>
    }

    /** num_uplus
     *
     */
    @JRubyMethod(name = &quot;+@&quot;)
    public IRubyObject op_uplus() {
<span class="fc" id="L583">        return this;</span>
    }

    /** num_imaginary
     *
     */
    @JRubyMethod(name = &quot;i&quot;)
    public IRubyObject num_imaginary(ThreadContext context) {
<span class="fc" id="L591">        return RubyComplex.newComplexRaw(context.runtime, RubyFixnum.zero(context.runtime), this);</span>
    }

    /** num_uminus
     *
     */
    @JRubyMethod(name = &quot;-@&quot;)
    public IRubyObject op_uminus(ThreadContext context) {
<span class="fc" id="L599">        RubyArray ary = RubyFixnum.zero(context.runtime).doCoerce(context, this, true);</span>
<span class="fc" id="L600">        return ary.eltInternal(0).callMethod(context, &quot;-&quot;, ary.eltInternal(1));</span>
    }
    
    /** num_cmp
     *
     */
    @JRubyMethod(name = &quot;&lt;=&gt;&quot;)
    public IRubyObject op_cmp(IRubyObject other) {
<span class="fc bfc" id="L608" title="All 2 branches covered.">        if (this == other) { // won't hurt fixnums</span>
<span class="fc" id="L609">            return RubyFixnum.zero(getRuntime());</span>
        }
<span class="fc" id="L611">        return getRuntime().getNil();</span>
    }

    /** num_eql
     *
     */
    @JRubyMethod(name = &quot;eql?&quot;)
    public IRubyObject eql_p(ThreadContext context, IRubyObject other) {
<span class="fc bfc" id="L619" title="All 2 branches covered.">        if (getClass() != other.getClass()) return getRuntime().getFalse();</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">        return equalInternal(context, this, other) ? getRuntime().getTrue() : getRuntime().getFalse();</span>
    }

    /** num_quo (1.8)
     * quo and fdiv in 1.8 just invokes &quot;/&quot;
     */
    public IRubyObject quo(ThreadContext context, IRubyObject other) {
<span class="nc" id="L627">        return callMethod(context, &quot;/&quot;, other);</span>
    }
    
    /** num_quo (1.9)
    *
    */
    @JRubyMethod(name = &quot;quo&quot;)
    public IRubyObject quo_19(ThreadContext context, IRubyObject other) {
<span class="fc" id="L635">        return RubyRational.numericQuo(context, this, other);</span>
    }

    /** num_div
     * 
     */
    public IRubyObject div(ThreadContext context, IRubyObject other) {
<span class="fc" id="L642">        return div19(context, other);</span>
    }

    /** num_div
     *
     */
    @JRubyMethod(name = &quot;div&quot;)
    public IRubyObject div19(ThreadContext context, IRubyObject other) {
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">        if (other instanceof RubyNumeric) {</span>
<span class="fc" id="L651">            RubyNumeric numeric = (RubyNumeric) other;</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">            if (numeric.zero_p(context).isTrue()) {</span>
<span class="fc" id="L653">                throw context.runtime.newZeroDivisionError();</span>
            }
        }
<span class="fc" id="L656">        return callMethod(context, &quot;/&quot;, other).callMethod(context, &quot;floor&quot;);</span>
    }

    /** num_divmod
     * 
     */
    public IRubyObject divmod(ThreadContext context, IRubyObject other) {
<span class="nc" id="L663">        return divmod19(context, other);</span>
    }

    /** num_divmod
     *
     */
    @JRubyMethod(name = &quot;divmod&quot;)
    public IRubyObject divmod19(ThreadContext context, IRubyObject other) {
<span class="fc" id="L671">        return RubyArray.newArray(getRuntime(), div(context, other), modulo19(context, other));</span>
    }
    
    /** num_fdiv (1.9) */
    @JRubyMethod(name = &quot;fdiv&quot;)
    public IRubyObject fdiv(ThreadContext context, IRubyObject other) {
<span class="fc" id="L677">        return Helpers.invoke(context, this.convertToFloat(), &quot;/&quot;, other);</span>
    }

    /** num_modulo
     *
     */
    public IRubyObject modulo(ThreadContext context, IRubyObject other) {
<span class="nc" id="L684">        return modulo19(context, other);</span>
    }

    /** num_modulo
     *
     */
    @JRubyMethod(name = &quot;modulo&quot;)
    public IRubyObject modulo19(ThreadContext context, IRubyObject other) {
<span class="fc" id="L692">        return callMethod(context, &quot;-&quot;, other.callMethod(context, &quot;*&quot;, callMethod(context, &quot;div&quot;, other)));</span>
    }

    /** num_remainder
     *
     */
    @JRubyMethod(name = &quot;remainder&quot;)
    public IRubyObject remainder(ThreadContext context, IRubyObject dividend) {
<span class="fc" id="L700">        IRubyObject z = callMethod(context, &quot;%&quot;, dividend);</span>
<span class="fc" id="L701">        IRubyObject x = this;</span>
<span class="fc" id="L702">        RubyFixnum zero = RubyFixnum.zero(getRuntime());</span>

<span class="fc bfc" id="L704" title="All 2 branches covered.">        if (!equalInternal(context, z, zero) &amp;&amp;</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">                ((x.callMethod(context, &quot;&lt;&quot;, zero).isTrue() &amp;&amp;</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">                dividend.callMethod(context, &quot;&gt;&quot;, zero).isTrue()) ||</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">                (x.callMethod(context, &quot;&gt;&quot;, zero).isTrue() &amp;&amp;</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">                dividend.callMethod(context, &quot;&lt;&quot;, zero).isTrue()))) {</span>
<span class="fc" id="L709">            return z.callMethod(context, &quot;-&quot;, dividend);</span>
        } else {
<span class="fc" id="L711">            return z;</span>
        }
    }

    /** num_abs
     *
     */
    @JRubyMethod(name = &quot;abs&quot;)
    public IRubyObject abs(ThreadContext context) {
<span class="fc bfc" id="L720" title="All 2 branches covered.">        if (callMethod(context, &quot;&lt;&quot;, RubyFixnum.zero(getRuntime())).isTrue()) {</span>
<span class="fc" id="L721">            return callMethod(context, &quot;-@&quot;);</span>
        }
<span class="fc" id="L723">        return this;</span>
    }

    /** num_abs/1.9
     * 
     */
    @JRubyMethod(name = &quot;magnitude&quot;)
    public IRubyObject magnitude(ThreadContext context) {
<span class="fc" id="L731">        return abs(context);</span>
    }

    /** num_to_int
     * 
     */
    @JRubyMethod(name = &quot;to_int&quot;)
    public IRubyObject to_int(ThreadContext context) {
<span class="fc" id="L739">        return Helpers.invoke(context, this, &quot;to_i&quot;);</span>
    }

    /** num_real_p
    *
    */
    @JRubyMethod(name = &quot;real?&quot;)
    public IRubyObject scalar_p() {
<span class="fc" id="L747">        return getRuntime().getTrue();</span>
    }

    /** num_int_p
     *
     */
    @JRubyMethod(name = &quot;integer?&quot;)
    public IRubyObject integer_p() {
<span class="fc" id="L755">        return getRuntime().getFalse();</span>
    }
    
    /** num_zero_p
     *
     */
    @JRubyMethod(name = &quot;zero?&quot;)
    public IRubyObject zero_p(ThreadContext context) {
<span class="fc bfc" id="L763" title="All 2 branches covered.">        return equalInternal(context, this, RubyFixnum.zero(getRuntime())) ? getRuntime().getTrue() : getRuntime().getFalse();</span>
    }
    
    /** num_nonzero_p
     *
     */
    @JRubyMethod(name = &quot;nonzero?&quot;)
    public IRubyObject nonzero_p(ThreadContext context) {
<span class="fc bfc" id="L771" title="All 2 branches covered.">        if (callMethod(context, &quot;zero?&quot;).isTrue()) {</span>
<span class="fc" id="L772">            return getRuntime().getNil();</span>
        }
<span class="fc" id="L774">        return this;</span>
    }

    /** num_floor
     *
     */
    @JRubyMethod(name = &quot;floor&quot;)
    public IRubyObject floor() {
<span class="fc" id="L782">        return convertToFloat().floor();</span>
    }
        
    /** num_ceil
     *
     */
    @JRubyMethod(name = &quot;ceil&quot;)
    public IRubyObject ceil() {
<span class="fc" id="L790">        return convertToFloat().ceil();</span>
    }

    /** num_round
     *
     */
    @JRubyMethod(name = &quot;round&quot;)
    public IRubyObject round() {
<span class="fc" id="L798">        return convertToFloat().round();</span>
    }

    /** num_truncate
     *
     */
    @JRubyMethod(name = &quot;truncate&quot;)
    public IRubyObject truncate() {
<span class="fc" id="L806">        return convertToFloat().truncate();</span>
    }

    // TODO: Fold kwargs into the @JRubyMethod decorator
<span class="fc" id="L810">    static final String[] validStepArgs = new String[] {&quot;to&quot;, &quot;by&quot;};</span>

    /**
     * num_step
     */
    @JRubyMethod(optional = 2)
    public IRubyObject step(ThreadContext context, IRubyObject[] args, Block block) {
<span class="fc bfc" id="L817" title="All 2 branches covered.">        if (!block.isGiven()) {</span>
<span class="fc" id="L818">            return enumeratorizeWithSize(context, this, &quot;step&quot;, args, stepSizeFn(context, this, args));</span>
        }

<span class="fc" id="L821">        IRubyObject[] scannedArgs = scanStepArgs(context, args);</span>
<span class="fc" id="L822">        return stepCommon(context, scannedArgs[0], scannedArgs[1], block);</span>
    }

    /** num_step_scan_args
     *
     */

    private IRubyObject[] scanStepArgs(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L830">        IRubyObject to = context.runtime.getNil();</span>
<span class="fc" id="L831">        IRubyObject step = context.runtime.newFixnum(1);</span>

<span class="pc bpc" id="L833" title="1 of 2 branches missed.">        if (args.length &gt;= 1) to = args[0];</span>
<span class="fc bfc" id="L834" title="All 2 branches covered.">        if (args.length &gt;= 2) step = args[1];</span>

        // TODO: Fold kwargs into the @JRubyMethod decorator
<span class="fc" id="L837">        IRubyObject[] kwargs = ArgsUtil.extractKeywordArgs(context, args, validStepArgs);</span>

<span class="pc bpc" id="L839" title="1 of 2 branches missed.">        if (kwargs != null) {</span>
<span class="nc" id="L840">            to = kwargs[0];</span>
<span class="nc" id="L841">            step = kwargs[1];</span>

<span class="nc bnc" id="L843" title="All 4 branches missed.">            if(!to.isNil() &amp;&amp; args.length &gt; 1) {</span>
<span class="nc" id="L844">                throw context.runtime.newArgumentError(&quot;to is given twice&quot;);</span>
            }
<span class="nc bnc" id="L846" title="All 4 branches missed.">            if(!step.isNil() &amp;&amp; args.length &gt; 2) {</span>
<span class="nc" id="L847">                throw context.runtime.newArgumentError(&quot;step is given twice&quot;);</span>
            }
        } else {
<span class="fc bfc" id="L850" title="All 2 branches covered.">            if (RubyBasicObject.equalInternal(context, step, RubyFixnum.zero(context.runtime))) {</span>
<span class="fc" id="L851">                throw context.runtime.newArgumentError(&quot;step can't be 0&quot;);</span>
            }
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">            if (step.isNil()) {</span>
<span class="nc" id="L854">                throw context.runtime.newTypeError(&quot;step must be numeric&quot;);</span>
            }
        }

<span class="pc bpc" id="L858" title="1 of 2 branches missed.">        if (step.isNil()) {</span>
<span class="nc" id="L859">            step = RubyFixnum.one(context.runtime);</span>
        }

<span class="pc bpc" id="L862" title="1 of 2 branches missed.">        if (to.isNil()) {</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">            if ( f_negative_p(context, step) ) {</span>
<span class="nc" id="L864">                to = RubyFloat.newFloat(context.runtime, Double.NEGATIVE_INFINITY);</span>
            } else {
<span class="nc" id="L866">                to = RubyFloat.newFloat(context.runtime, Double.POSITIVE_INFINITY);</span>
            }
        }

<span class="fc" id="L870">        return new IRubyObject[] {to, step};</span>
    }

    private IRubyObject stepCommon(ThreadContext context, IRubyObject to, IRubyObject step, Block block) {
<span class="fc" id="L874">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L875" title="All 6 branches covered.">        if (this instanceof RubyFixnum &amp;&amp; to instanceof RubyFixnum &amp;&amp; step instanceof RubyFixnum) {</span>
<span class="fc" id="L876">            fixnumStep(context, runtime, ((RubyFixnum)this).getLongValue(),</span>
<span class="fc" id="L877">                                         ((RubyFixnum)to).getLongValue(),</span>
<span class="fc" id="L878">                                         ((RubyFixnum)step).getLongValue(),</span>
                                          block);
<span class="fc bfc" id="L880" title="All 6 branches covered.">        } else if (this instanceof RubyFloat || to instanceof RubyFloat || step instanceof RubyFloat) {</span>
<span class="fc" id="L881">            floatStep19(context, runtime, this, to, step, false, block);</span>
        } else {
<span class="fc" id="L883">            duckStep(context, runtime, this, to, step, block);</span>
        }
<span class="fc" id="L885">        return this;</span>
    }

    private static void fixnumStep(ThreadContext context, Ruby runtime, long from, long to, long step, Block block) {
        // We must avoid integer overflows in &quot;i += step&quot;.
<span class="fc bfc" id="L890" title="All 2 branches covered.">        if (step &gt;= 0) {</span>
<span class="fc" id="L891">            long tov = Long.MAX_VALUE - step;</span>
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">            if (to &lt; tov) tov = to;</span>
            long i;
<span class="fc bfc" id="L894" title="All 2 branches covered.">            for (i = from; i &lt;= tov; i += step) {</span>
<span class="fc" id="L895">                block.yield(context, RubyFixnum.newFixnum(runtime, i));</span>
            }
<span class="pc bpc" id="L897" title="1 of 2 branches missed.">            if (i &lt;= to) {</span>
<span class="nc" id="L898">                block.yield(context, RubyFixnum.newFixnum(runtime, i));</span>
            }
<span class="fc" id="L900">        } else {</span>
<span class="fc" id="L901">            long tov = Long.MIN_VALUE - step;</span>
<span class="pc bpc" id="L902" title="1 of 2 branches missed.">            if (to &gt; tov) tov = to;</span>
            long i;
<span class="fc bfc" id="L904" title="All 2 branches covered.">            for (i = from; i &gt;= tov; i += step) {</span>
<span class="fc" id="L905">                block.yield(context, RubyFixnum.newFixnum(runtime, i));</span>
            }
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">            if (i &gt;= to) {</span>
<span class="nc" id="L908">                block.yield(context, RubyFixnum.newFixnum(runtime, i));</span>
            }
        }
<span class="fc" id="L911">    }</span>

    protected static void floatStep(ThreadContext context, Ruby runtime, IRubyObject from, IRubyObject to, IRubyObject step, Block block) { 
<span class="nc" id="L914">        double beg = num2dbl(from);</span>
<span class="nc" id="L915">        double end = num2dbl(to);</span>
<span class="nc" id="L916">        double unit = num2dbl(step);</span>

<span class="nc" id="L918">        double n = (end - beg)/unit;</span>
<span class="nc" id="L919">        double err = (Math.abs(beg) + Math.abs(end) + Math.abs(end - beg)) / Math.abs(unit) * DBL_EPSILON;</span>

<span class="nc bnc" id="L921" title="All 2 branches missed.">        if (err &gt; 0.5) err = 0.5;            </span>
<span class="nc" id="L922">        n = Math.floor(n + err) + 1;</span>

<span class="nc bnc" id="L924" title="All 2 branches missed.">        for (long i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L925">            block.yield(context, RubyFloat.newFloat(runtime, i * unit + beg));</span>
        }
<span class="nc" id="L927">    }</span>

    static void floatStep19(ThreadContext context, Ruby runtime, IRubyObject from, IRubyObject to, IRubyObject step, boolean excl, Block block) { 
<span class="fc" id="L930">        double beg = num2dbl(from);</span>
<span class="fc" id="L931">        double end = num2dbl(to);</span>
<span class="fc" id="L932">        double unit = num2dbl(step);</span>

<span class="fc" id="L934">        double n = floatStepSize(beg, end, unit, excl);</span>

<span class="fc bfc" id="L936" title="All 2 branches covered.">        if (Double.isInfinite(unit)) {</span>
<span class="fc bfc" id="L937" title="All 2 branches covered.">            if (n != 0) block.yield(context, from);</span>
<span class="pc bpc" id="L938" title="1 of 2 branches missed.">        } else if (unit == 0) {</span>
            while(true) {
<span class="nc" id="L940">                block.yield(context, from);</span>
            }
        } else {
<span class="fc bfc" id="L943" title="All 2 branches covered.">            for (long i = 0; i &lt; n; i++){</span>
<span class="fc" id="L944">                double d = i * unit + beg;</span>
<span class="pc bpc" id="L945" title="2 of 6 branches missed.">                if (unit &gt;= 0 ? end &lt; d : d &lt; end) {</span>
<span class="nc" id="L946">                    d = end;</span>
                }
<span class="fc" id="L948">                block.yield(context, RubyFloat.newFloat(runtime, d));</span>
            }
        }
<span class="fc" id="L951">    }</span>

    private static void duckStep(ThreadContext context, Ruby runtime, IRubyObject from, IRubyObject to, IRubyObject step, Block block) {
<span class="fc" id="L954">        IRubyObject i = from;</span>

<span class="fc bfc" id="L956" title="All 2 branches covered.">        String cmpString = step.callMethod(context, &quot;&gt;&quot;, RubyFixnum.newFixnum(context.runtime, 0)).isTrue() ? &quot;&gt;&quot; : &quot;&lt;&quot;;</span>
<span class="pc bpc" id="L957" title="1 of 2 branches missed.">        if(step.callMethod(context, &quot;==&quot;, RubyFixnum.newFixnum(context.runtime, 0)).isTrue())</span>
<span class="nc" id="L958">            cmpString = &quot;==&quot;;</span>

        while (true) {
<span class="fc bfc" id="L961" title="All 2 branches covered.">            if (i.callMethod(context, cmpString, to).isTrue()) break;</span>
<span class="fc" id="L962">            block.yield(context, i);</span>
<span class="fc" id="L963">            i = i.callMethod(context, &quot;+&quot;, step);</span>
        }
<span class="fc" id="L965">    }</span>

    public static RubyNumeric intervalStepSize(ThreadContext context, IRubyObject from, IRubyObject to, IRubyObject step, boolean excludeLast) {
<span class="fc" id="L968">        Ruby runtime = context.runtime;</span>

<span class="pc bpc" id="L970" title="1 of 6 branches missed.">        if (from instanceof RubyFixnum &amp;&amp; to instanceof RubyFixnum &amp;&amp; step instanceof RubyFixnum) {</span>
<span class="fc" id="L971">            long diff = ((RubyFixnum) step).getLongValue();</span>
<span class="pc bpc" id="L972" title="1 of 2 branches missed.">            if (diff == 0) {</span>
<span class="nc" id="L973">                return RubyFloat.newFloat(runtime, Double.POSITIVE_INFINITY);</span>
            }

<span class="fc" id="L976">            long delta = ((RubyFixnum) to).getLongValue() - ((RubyFixnum) from).getLongValue();</span>
<span class="pc bpc" id="L977" title="1 of 2 branches missed.">            if (diff &lt; 0) {</span>
<span class="nc" id="L978">                diff = -diff;</span>
<span class="nc" id="L979">                delta = -delta;</span>
            }
<span class="fc bfc" id="L981" title="All 2 branches covered.">            if (excludeLast) {</span>
<span class="fc" id="L982">                delta--;</span>
            }
<span class="fc bfc" id="L984" title="All 2 branches covered.">            if (delta &lt; 0) {</span>
<span class="fc" id="L985">                return runtime.newFixnum(0);</span>
            }

<span class="fc" id="L988">            long result = delta / diff;</span>
<span class="pc bpc" id="L989" title="1 of 2 branches missed.">            return new RubyFixnum(runtime, result &gt;= 0 ? result + 1 : 0);</span>
<span class="pc bpc" id="L990" title="3 of 6 branches missed.">        } else if (from instanceof RubyFloat || to instanceof RubyFloat || step instanceof RubyFloat) {</span>
<span class="fc" id="L991">            double n = floatStepSize(from.convertToFloat().getDoubleValue(), to.convertToFloat().getDoubleValue(), step.convertToFloat().getDoubleValue(), excludeLast);</span>

<span class="fc bfc" id="L993" title="All 2 branches covered.">            if (Double.isInfinite(n)) {</span>
<span class="fc" id="L994">                return runtime.newFloat(n);</span>
            } else {
<span class="fc" id="L996">                return runtime.newFloat(n).convertToInteger();</span>
            }
        } else {
<span class="nc" id="L999">            String cmpString = &quot;&gt;&quot;;</span>
<span class="nc" id="L1000">            RubyFixnum zero = RubyFixnum.zero(runtime);</span>
<span class="nc" id="L1001">            IRubyObject comparison = zero.coerceCmp(context, &quot;&lt;=&gt;&quot;, step);</span>

<span class="nc bnc" id="L1003" title="All 3 branches missed.">            switch (RubyComparable.cmpint(context, comparison, step, zero)) {</span>
                case 0:
<span class="nc" id="L1005">                    return RubyFloat.newFloat(runtime, Float.POSITIVE_INFINITY);</span>
                case 1:
<span class="nc" id="L1007">                    cmpString = &quot;&lt;&quot;;</span>
                    break;
            }

<span class="nc bnc" id="L1011" title="All 2 branches missed.">            if (from.callMethod(context, cmpString, to).isTrue()) {</span>
<span class="nc" id="L1012">                return RubyFixnum.zero(runtime);</span>
            }

<span class="nc" id="L1015">            IRubyObject diff = to.callMethod(context, &quot;-&quot;, from);</span>
<span class="nc" id="L1016">            IRubyObject result = diff.callMethod(context, &quot;div&quot;, step);</span>
<span class="nc bnc" id="L1017" title="All 4 branches missed.">            if (!excludeLast || from.callMethod(context, &quot;+&quot;, result.callMethod(context, &quot;*&quot;, step)).callMethod(context, cmpString, to).isTrue()) {</span>
<span class="nc" id="L1018">                result = result.callMethod(context, &quot;+&quot;, RubyFixnum.newFixnum(runtime, 1));</span>
            }
<span class="nc" id="L1020">            return (RubyNumeric) result;</span>
        }
    }

    private SizeFn stepSizeFn(final ThreadContext context, final IRubyObject from, final IRubyObject[] args) {
<span class="fc" id="L1025">        return new SizeFn() {</span>
            @Override
            public IRubyObject size(IRubyObject[] args) {
<span class="nc" id="L1028">                IRubyObject[] scannedArgs = scanStepArgs(context, args);</span>
<span class="nc" id="L1029">                return intervalStepSize(context, from, scannedArgs[0], scannedArgs[1], false);</span>
            }
        };
    }

    /**
     * Returns the number of unit-sized steps between the given beg and end.
     *
     * NOTE: the returned value is either Double.POSITIVE_INFINITY, or a rounded value appropriate to be cast to a long
     */
    public static double floatStepSize(double beg, double end, double unit, boolean excludeLast) {
<span class="fc" id="L1040">        double n = (end - beg)/unit;</span>
<span class="fc" id="L1041">        double err = (Math.abs(beg) + Math.abs(end) + Math.abs(end - beg)) / Math.abs(unit) * DBL_EPSILON;</span>

<span class="fc bfc" id="L1043" title="All 2 branches covered.">        if (Double.isInfinite(unit)) {</span>
<span class="fc bfc" id="L1044" title="All 2 branches covered.">            if (unit &gt; 0) {</span>
<span class="pc bpc" id="L1045" title="1 of 2 branches missed.">                return beg &lt;= end ? 1 : 0;</span>
            } else {
<span class="pc bpc" id="L1047" title="1 of 2 branches missed.">                return end &lt;= beg ? 1 : 0;</span>
            }
        }

<span class="pc bpc" id="L1051" title="1 of 2 branches missed.">        if (unit == 0) {</span>
<span class="nc" id="L1052">            return Float.POSITIVE_INFINITY;</span>
        }

<span class="fc bfc" id="L1055" title="All 2 branches covered.">        if (err &gt; 0.5) err = 0.5;</span>
<span class="fc bfc" id="L1056" title="All 2 branches covered.">        if (excludeLast) {</span>
<span class="pc bpc" id="L1057" title="1 of 2 branches missed.">            if (n &lt;= 0) {</span>
<span class="nc" id="L1058">                return 0;</span>
            }
<span class="pc bpc" id="L1060" title="1 of 2 branches missed.">            if (n &lt; 1) {</span>
<span class="nc" id="L1061">                n = 0;</span>
            } else {
<span class="fc" id="L1063">                n = Math.floor(n - err);</span>
            }
        } else {
<span class="fc bfc" id="L1066" title="All 2 branches covered.">            if (n &lt; 0) {</span>
<span class="fc" id="L1067">                return 0;</span>
            }
<span class="fc" id="L1069">            n = Math.floor(n + err);</span>
        }
<span class="fc" id="L1071">        return n + 1;</span>
    }

    /** num_equal, doesn't override RubyObject.op_equal
     *
     */
    protected final IRubyObject op_num_equal(ThreadContext context, IRubyObject other) {
        // it won't hurt fixnums
<span class="pc bpc" id="L1079" title="1 of 2 branches missed.">        if (this == other)  return getRuntime().getTrue();</span>

<span class="fc" id="L1081">        return invokedynamic(context, other, MethodNames.OP_EQUAL, this);</span>
    }

    /** num_numerator
     * 
     */
    @JRubyMethod(name = &quot;numerator&quot;)
    public IRubyObject numerator(ThreadContext context) {
<span class="fc" id="L1089">        return RubyRational.newRationalConvert(context, this).callMethod(context, &quot;numerator&quot;);</span>
    }
    
    /** num_denominator
     * 
     */
    @JRubyMethod(name = &quot;denominator&quot;)
    public IRubyObject denominator(ThreadContext context) {
<span class="fc" id="L1097">        return RubyRational.newRationalConvert(context, this).callMethod(context, &quot;denominator&quot;);</span>
    }

    /** numeric_to_c
     * 
     */
    @JRubyMethod(name = &quot;to_c&quot;)
    public IRubyObject to_c(ThreadContext context) {
<span class="fc" id="L1105">        return RubyComplex.newComplexCanonicalize(context, this);</span>
    }

    /** numeric_real
     * 
     */
    @JRubyMethod(name = &quot;real&quot;)
    public IRubyObject real(ThreadContext context) {
<span class="fc" id="L1113">        return this;</span>
    }

    /** numeric_image
     * 
     */
    @JRubyMethod(name = {&quot;imaginary&quot;, &quot;imag&quot;})
    public IRubyObject image(ThreadContext context) {
<span class="fc" id="L1121">        return RubyFixnum.zero(context.runtime);</span>
    }

    /** numeric_abs2
     * 
     */
    @JRubyMethod(name = &quot;abs2&quot;)
    public IRubyObject abs2(ThreadContext context) {
<span class="fc" id="L1129">        return f_mul(context, this, this);</span>
    }

    /** numeric_arg
     * 
     */
    @JRubyMethod(name = {&quot;arg&quot;, &quot;angle&quot;, &quot;phase&quot;})
    public IRubyObject arg(ThreadContext context) {
<span class="fc" id="L1137">        double value = this.getDoubleValue();</span>
<span class="fc bfc" id="L1138" title="All 2 branches covered.">        if (Double.isNaN(value)) {</span>
<span class="fc" id="L1139">            return this;</span>
        }
<span class="fc bfc" id="L1141" title="All 6 branches covered.">        if (f_negative_p(context, this) || (value == 0.0 &amp;&amp; 1/value == Double.NEGATIVE_INFINITY)) {</span>
            // negative or -0.0
<span class="fc" id="L1143">            return context.runtime.getMath().getConstant(&quot;PI&quot;);</span>
        }
<span class="fc" id="L1145">        return RubyFixnum.zero(context.runtime);</span>
    }    

    /** numeric_rect
     * 
     */
    @JRubyMethod(name = {&quot;rectangular&quot;, &quot;rect&quot;})
    public IRubyObject rect(ThreadContext context) {
<span class="fc" id="L1153">        return context.runtime.newArray(this, RubyFixnum.zero(context.runtime));</span>
    }    

    /** numeric_polar
     * 
     */
    @JRubyMethod(name = &quot;polar&quot;)
    public IRubyObject polar(ThreadContext context) {
<span class="fc" id="L1161">        return context.runtime.newArray(f_abs(context, this), f_arg(context, this));</span>
    }    

    /** numeric_real
     * 
     */
    @JRubyMethod(name = {&quot;conjugate&quot;, &quot;conj&quot;})
    public IRubyObject conjugate(ThreadContext context) {
<span class="fc" id="L1169">        return this;</span>
    }

    @Override
    public Object toJava(Class target) {
<span class="fc" id="L1174">        return JavaUtil.getNumericConverter(target).coerce(this, target);</span>
    }

    public static class InvalidIntegerException extends NumberFormatException {
        private static final long serialVersionUID = 55019452543252148L;
        
        public InvalidIntegerException() {
<span class="nc" id="L1181">            super();</span>
<span class="nc" id="L1182">        }</span>
        public InvalidIntegerException(String message) {
<span class="nc" id="L1184">            super(message);</span>
<span class="nc" id="L1185">        }</span>
        @Override
        public Throwable fillInStackTrace() {
<span class="nc" id="L1188">            return this;</span>
        }
    }
    
    public static class NumberTooLargeException extends NumberFormatException {
        private static final long serialVersionUID = -1835120694982699449L;
        public NumberTooLargeException() {
<span class="nc" id="L1195">            super();</span>
<span class="nc" id="L1196">        }</span>
        public NumberTooLargeException(String message) {
<span class="nc" id="L1198">            super(message);</span>
<span class="nc" id="L1199">        }</span>
        @Override
        public Throwable fillInStackTrace() {
<span class="nc" id="L1202">            return this;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>