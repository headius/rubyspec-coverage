<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RubyMath.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby</a> &gt; <span class="el_source">RubyMath.java</span></div><h1>RubyMath.java</h1><pre class="source lang-java linenums">/***** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2001 Chad Fowler &lt;chadfowler@chadfowler.com&gt;
 * Copyright (C) 2001-2002 Jan Arne Petersen &lt;jpetersen@uni-bonn.de&gt;
 * Copyright (C) 2002 Benoit Cerrina &lt;b.cerrina@wanadoo.fr&gt;
 * Copyright (C) 2002-2004 Thomas E Enebo &lt;enebo@acm.org&gt;
 * Copyright (C) 2004 Stefan Matthias Aust &lt;sma@3plus4.de&gt;
 * 
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby;

import org.jruby.anno.JRubyMethod;
import org.jruby.anno.JRubyModule;
import org.jruby.runtime.ThreadContext;
import org.jruby.runtime.Visibility;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.util.TypeConverter;

@JRubyModule(name=&quot;Math&quot;)
<span class="nc" id="L42">public class RubyMath {</span>
    /** Create the Math module and add it to the Ruby runtime.
     * 
     */
    public static RubyModule createMathModule(Ruby runtime) {
<span class="fc" id="L47">        RubyModule result = runtime.defineModule(&quot;Math&quot;);</span>
<span class="fc" id="L48">        runtime.setMath(result);</span>
        
<span class="fc" id="L50">        result.defineConstant(&quot;E&quot;, RubyFloat.newFloat(runtime, Math.E));</span>
<span class="fc" id="L51">        result.defineConstant(&quot;PI&quot;, RubyFloat.newFloat(runtime, Math.PI));</span>
        
<span class="fc" id="L53">        result.defineAnnotatedMethods(RubyMath.class);</span>

<span class="fc" id="L55">        return result;</span>
    }
    
    
    private static void domainCheck(IRubyObject recv, double value, String msg) {
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">        if (Double.isNaN(value)) {</span>
<span class="nc" id="L61">            throw recv.getRuntime().newErrnoEDOMError(msg);</span>
        }
<span class="fc" id="L63">    }</span>

    private static void domainCheck19(IRubyObject recv, double value, String msg) {
<span class="fc bfc" id="L66" title="All 2 branches covered.">        if (Double.isNaN(value)) {</span>
<span class="fc" id="L67">            throw recv.getRuntime().newMathDomainError(msg);</span>
        }
<span class="fc" id="L69">    }</span>

    public static double chebylevSerie(double x, double coef[]) {
        double  b0, b1, b2, twox;
        int i;
<span class="fc" id="L74">        b1 = 0.0;</span>
<span class="fc" id="L75">        b0 = 0.0;</span>
<span class="fc" id="L76">        b2 = 0.0;</span>
<span class="fc" id="L77">        twox = 2.0 * x;</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">        for (i = coef.length-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L79">            b2 = b1;</span>
<span class="fc" id="L80">            b1 = b0;</span>
<span class="fc" id="L81">            b0 = twox * b1 - b2 + coef[i];</span>
        }
<span class="fc" id="L83">        return 0.5*(b0 - b2);</span>
    }
    
    public static double sign(double x, double y) {
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">        double abs = ((x &lt; 0) ? -x : x);</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">        return (y &lt; 0.0) ? -abs : abs;</span>
    }
    
    private static RubyFloat needFloat(IRubyObject x) {
<span class="fc bfc" id="L92" title="All 2 branches covered.">        if (x instanceof RubyFloat) {</span>
<span class="fc" id="L93">            return (RubyFloat)x;</span>
        }

<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        if (!x.getRuntime().getNumeric().isInstance(x)) {</span>
<span class="nc" id="L97">            TypeConverter.handleUncoercibleObject(true, x, x.getRuntime().getFloat());</span>
        }

<span class="fc" id="L100">        return (RubyFloat) TypeConverter.convertToType19(x, x.getRuntime().getFloat(), &quot;to_f&quot;, true);</span>
    }

    public static RubyFloat atan2(ThreadContext context, IRubyObject recv, IRubyObject x, IRubyObject y) {
<span class="fc" id="L104">        return atan219(context, recv, x, y);</span>
    }

    @JRubyMethod(name = &quot;atan2&quot;, required = 2, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat atan219(ThreadContext context, IRubyObject recv, IRubyObject x, IRubyObject y) {
<span class="fc" id="L109">        double valuea = needFloat(x).getDoubleValue();</span>
<span class="fc" id="L110">        double valueb = needFloat(y).getDoubleValue();</span>
        
<span class="fc" id="L112">        return RubyFloat.newFloat(context.runtime, Math.atan2(valuea, valueb));</span>
    }

    public static RubyFloat cos(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L116">        return cos19(context, recv, x);</span>
    }

    @JRubyMethod(name = &quot;cos&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat cos19(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L121">        return RubyFloat.newFloat(context.runtime, Math.cos(needFloat(x).getDoubleValue()));</span>
    }

    public static RubyFloat sin(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L125">        return sin19(context, recv, x);</span>
    }

    @JRubyMethod(name = &quot;sin&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat sin19(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L130">        return RubyFloat.newFloat(context.runtime, Math.sin(needFloat(x).getDoubleValue()));</span>
    }

    public static RubyFloat tan(ThreadContext context, IRubyObject recv,  IRubyObject x) {
<span class="nc" id="L134">        return tan19(context, recv, x);</span>
    }

    @JRubyMethod(name = &quot;tan&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat tan19(ThreadContext context, IRubyObject recv,  IRubyObject x) {
<span class="fc" id="L139">        return RubyFloat.newFloat(context.runtime, Math.tan(needFloat(x).getDoubleValue()));</span>
    }
    
    public static RubyFloat asin(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="nc" id="L143">        return asin19(context, recv, x);</span>
    }

    @JRubyMethod(name = &quot;asin&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat asin19(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L148">        double value = needFloat(x).getDoubleValue();</span>

<span class="pc bpc" id="L150" title="2 of 4 branches missed.">        if (value &lt; -1.0 || value &gt; 1.0) throw context.runtime.newMathDomainError(&quot;asin&quot;);</span>

<span class="fc" id="L152">        return RubyFloat.newFloat(context.runtime, Math.asin(value));</span>
    }

    public static RubyFloat acos(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="nc" id="L156">        return acos19(context, recv, x);</span>
    }

    @JRubyMethod(name = &quot;acos&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat acos19(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L161">        double value = needFloat(x).getDoubleValue();</span>

<span class="pc bpc" id="L163" title="2 of 4 branches missed.">        if (value &lt; -1.0 || value &gt; 1.0) throw context.runtime.newMathDomainError(&quot;acos&quot;);</span>

<span class="fc" id="L165">        return RubyFloat.newFloat(context.runtime, Math.acos(value));</span>
    }
    
    public static RubyFloat atan(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="nc" id="L169">        return atan19(context, recv, x);</span>
    }

    @JRubyMethod(name = &quot;atan&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat atan19(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L174">        return RubyFloat.newFloat(context.runtime, Math.atan(needFloat(x).getDoubleValue()));</span>
    }

    public static RubyFloat cosh(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="nc" id="L178">        return cosh19(context, recv, x);</span>
    }    

    @JRubyMethod(name = &quot;cosh&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat cosh19(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L183">        double value = needFloat(x).getDoubleValue();</span>
        
<span class="fc" id="L185">        return RubyFloat.newFloat(context.runtime, (Math.exp(value) + Math.exp(-value)) / 2.0);</span>
    }    

    public static RubyFloat sinh(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="nc" id="L189">        return sinh19(context, recv, x);</span>
    }

    @JRubyMethod(name = &quot;sinh&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat sinh19(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L194">        double value = needFloat(x).getDoubleValue();</span>
        
<span class="fc" id="L196">        return RubyFloat.newFloat(context.runtime, (Math.exp(value) - Math.exp(-value)) / 2.0);</span>
    }
    
    public static RubyFloat tanh(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="nc" id="L200">        return tanh19(context, recv, x);</span>
    }          

    @JRubyMethod(name = &quot;tanh&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat tanh19(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L205">        return RubyFloat.newFloat(context.runtime, Math.tanh(needFloat(x).getDoubleValue()));</span>
    }          
    
    public static RubyFloat acosh(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="nc" id="L209">        return acosh19(context, recv, x);</span>
    }

    @JRubyMethod(name = &quot;acosh&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat acosh19(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L214">        double value = needFloat(x).getDoubleValue();</span>
        double result;
        
<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (Double.isNaN(value)) {</span>
<span class="fc" id="L218">            result = Double.NaN;</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">        } else if (value &lt; 1) {</span>
<span class="nc" id="L220">            throw context.runtime.newMathDomainError(&quot;acosh&quot;);</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        } else if (value &lt; 94906265.62) {</span>
<span class="fc" id="L222">            result = Math.log(value + Math.sqrt(value * value - 1.0));</span>
        } else{
<span class="nc" id="L224">            result = 0.69314718055994530941723212145818 + Math.log(value);</span>
        }
        
<span class="fc" id="L227">        return RubyFloat.newFloat(context.runtime,result);</span>
    }
    
<span class="fc" id="L230">    public static final double[] ASINH_COEF = {</span>
        -.12820039911738186343372127359268e+0,
        -.58811761189951767565211757138362e-1,
        .47274654322124815640725249756029e-2,
        -.49383631626536172101360174790273e-3,
        .58506207058557412287494835259321e-4,
        -.74669983289313681354755069217188e-5,
        .10011693583558199265966192015812e-5,
        -.13903543858708333608616472258886e-6,
        .19823169483172793547317360237148e-7,
        -.28847468417848843612747272800317e-8,
        .42672965467159937953457514995907e-9,
        -.63976084654366357868752632309681e-10,
        .96991686089064704147878293131179e-11,
        -.14844276972043770830246658365696e-11,
        .22903737939027447988040184378983e-12,
        -.35588395132732645159978942651310e-13,
        .55639694080056789953374539088554e-14,
        -.87462509599624678045666593520162e-15,
        .13815248844526692155868802298129e-15,
        -.21916688282900363984955142264149e-16,
        .34904658524827565638313923706880e-17
    };      
    
    public static RubyFloat asinh(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="nc" id="L255">        return asinh19(context, recv, x);</span>
    }

    @JRubyMethod(name = &quot;asinh&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat asinh19(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L260">        double value = needFloat(x).getDoubleValue();</span>
<span class="fc" id="L261">        double  y = Math.abs(value);</span>
        double result;
        
<span class="fc bfc" id="L264" title="All 2 branches covered.">        if (Double.isNaN(value)) {</span>
<span class="fc" id="L265">            result = Double.NaN;</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">        } else if (y &lt;= 1.05367e-08) {</span>
<span class="fc" id="L267">            result = value;</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">        } else if (y &lt;= 1.0) {          </span>
<span class="fc" id="L269">            result = value * (1.0 + chebylevSerie(2.0 * value * value - 1.0, ASINH_COEF));</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        } else if (y &lt; 94906265.62) {</span>
<span class="fc" id="L271">            result = Math.log(value + Math.sqrt(value * value + 1.0));</span>
        } else {    
<span class="nc" id="L273">            result = 0.69314718055994530941723212145818 + Math.log(y);</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">            if (value &lt; 0) result *= -1;</span>
        }

<span class="fc" id="L277">        return RubyFloat.newFloat(context.runtime, result);        </span>
    }
    
<span class="fc" id="L280">    public static final double[] ATANH_COEF = {</span>
        .9439510239319549230842892218633e-1,
        .4919843705578615947200034576668e-1,
        .2102593522455432763479327331752e-2,
        .1073554449776116584640731045276e-3,
        .5978267249293031478642787517872e-5,
        .3505062030889134845966834886200e-6,
        .2126374343765340350896219314431e-7,
        .1321694535715527192129801723055e-8,
        .8365875501178070364623604052959e-10,
        .5370503749311002163881434587772e-11,
        .3486659470157107922971245784290e-12,
        .2284549509603433015524024119722e-13,
        .1508407105944793044874229067558e-14,
        .1002418816804109126136995722837e-15,
        .6698674738165069539715526882986e-17,
        .4497954546494931083083327624533e-18
    };    

    public static RubyFloat atanh(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="nc" id="L300">        return atanh_19(context, recv, x);</span>
    }

    @JRubyMethod(name = &quot;atanh&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat atanh_19(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L305">        double value = needFloat(x).getDoubleValue();</span>

<span class="fc bfc" id="L307" title="All 4 branches covered.">        if (value &lt; -1.0 || value &gt; 1.0) throw context.runtime.newMathDomainError(&quot;atanh&quot;);</span>

<span class="fc" id="L309">        return RubyFloat.newFloat(context.runtime, atanh_common(recv, x));</span>
    }

    private static double atanh_common(IRubyObject recv, IRubyObject x) {
<span class="fc" id="L313">        double value = ((RubyFloat)RubyKernel.new_float(recv,x)).getDoubleValue();</span>
<span class="fc" id="L314">        double  y = Math.abs(value);</span>
        double  result;

<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        if (Double.isNaN(value)) {</span>
<span class="nc" id="L318">            result = Double.NaN;</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">        } else if (y &lt; 1.82501e-08) {</span>
<span class="fc" id="L320">            result = value;</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        } else if (y &lt;= 0.5) {</span>
<span class="fc" id="L322">            result = value * (1.0 + chebylevSerie(8.0 * value * value - 1.0, ATANH_COEF));</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        } else if (y &lt; 1.0) {</span>
<span class="nc" id="L324">            result = 0.5 * Math.log((1.0 + value) / (1.0 - value));</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">        } else if (y == 1.0) {</span>
<span class="nc" id="L326">            result = value * Double.POSITIVE_INFINITY;</span>
        } else {
<span class="nc" id="L328">            result = Double.NaN;</span>
        }

<span class="fc" id="L331">        return result;</span>

    }
    
    public static RubyFloat exp(ThreadContext context, IRubyObject recv, IRubyObject exponent) {
<span class="fc" id="L336">        return exp19(context, recv, exponent);</span>
    }

    @JRubyMethod(name = &quot;exp&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat exp19(ThreadContext context, IRubyObject recv, IRubyObject exponent) {
<span class="fc" id="L341">        return RubyFloat.newFloat(context.runtime, Math.exp(needFloat(exponent).getDoubleValue()));</span>
    }

    private static RubyFloat log_common19(IRubyObject recv, double value, double base, String msg) {
<span class="pc bpc" id="L345" title="1 of 4 branches missed.">        if (value &lt; 0 || base &lt; 0) throw recv.getRuntime().newMathDomainError(msg);</span>

<span class="fc" id="L347">        return RubyFloat.newFloat(recv.getRuntime(), Math.log(value)/Math.log(base));</span>
    }

    /** Returns the natural logarithm of x.
     * 
     */
    @JRubyMethod(name = &quot;log&quot;, required = 1, optional = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat log_19(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="fc" id="L355">        double value = needFloat(args[0]).getDoubleValue();</span>
<span class="fc" id="L356">        double base = Math.E;</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">        if (args.length == 2) {</span>
<span class="fc" id="L358">            base = needFloat(args[1]).getDoubleValue();</span>
        }
<span class="fc" id="L360">        return log_common19(recv, value, base, &quot;log&quot;);</span>
    }

    /** Returns the base 10 logarithm of x.
     * 
     */
    public static RubyFloat log10(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="nc" id="L367">        return log10_19(context, recv, x);</span>
    }

    @JRubyMethod(name = &quot;log10&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat log10_19(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L372">        return log_common19(recv, needFloat(x).getDoubleValue(), 10, &quot;log10&quot;);</span>
    }

    /** Returns the base 2 logarithm of x.
     *
     */
    public static RubyFloat log2(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="nc" id="L379">        return log2_19(context, recv, x);</span>
    }

    @JRubyMethod(name = &quot;log2&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat log2_19(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L384">        return log_common19(recv, needFloat(x).getDoubleValue(), 2, &quot;log2&quot;);</span>
    }

    public static RubyFloat sqrt(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="nc" id="L388">        return sqrt19(context, recv, x);</span>
    }

    @JRubyMethod(name = &quot;sqrt&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat sqrt19(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L393">        double value = needFloat(x).getDoubleValue();</span>
        double result;

<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        if (value &lt; 0) {</span>
<span class="nc" id="L397">            throw context.runtime.newMathDomainError(&quot;sqrt&quot;);</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        } else if (value == 0.0) {</span>
<span class="nc" id="L399">            result = 0.0;</span>
        } else {
<span class="fc" id="L401">            result = Math.sqrt(value);</span>
        }

<span class="fc" id="L404">        return RubyFloat.newFloat(context.runtime, result);</span>
    }
    
    @JRubyMethod(name = &quot;cbrt&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat cbrt(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L409">        double result = Math.cbrt(needFloat(x).getDoubleValue());</span>

<span class="fc" id="L411">        domainCheck(recv, result, &quot;cbrt&quot;);</span>
        
<span class="fc" id="L413">        return RubyFloat.newFloat(context.runtime, result);</span>
    }

    public static RubyFloat hypot(ThreadContext context, IRubyObject recv, IRubyObject x, IRubyObject y) {
<span class="fc" id="L417">        return hypot19(context, recv, x, y);</span>
    }    

    @JRubyMethod(name = &quot;hypot&quot;, required = 2, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat hypot19(ThreadContext context, IRubyObject recv, IRubyObject x, IRubyObject y) {
<span class="fc" id="L422">        double valuea = needFloat(x).getDoubleValue(); </span>
<span class="fc" id="L423">        double valueb = needFloat(y).getDoubleValue();</span>
        double result;
        
<span class="fc bfc" id="L426" title="All 2 branches covered.">        if (Math.abs(valuea) &gt; Math.abs(valueb)) {</span>
<span class="fc" id="L427">            result = valueb / valuea;</span>
<span class="fc" id="L428">            result = Math.abs(valuea) * Math.sqrt(1 + result * result);</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">        } else if (valueb != 0) {</span>
<span class="fc" id="L430">            result = valuea / valueb;</span>
<span class="fc" id="L431">            result = Math.abs(valueb) * Math.sqrt(1 + result * result);</span>
<span class="pc bpc" id="L432" title="1 of 4 branches missed.">        } else if (Double.isNaN(valuea) || Double.isNaN(valueb)) {</span>
<span class="fc" id="L433">            result = Double.NaN;</span>
        } else {
<span class="fc" id="L435">            result = 0;</span>
        }
        
<span class="fc" id="L438">        return RubyFloat.newFloat(context.runtime,result);</span>
    }    
    
    
    /*
     * x = mantissa * 2 ** exponent
     *
     * Where mantissa is in the range of [.5, 1)
     *
     */
    public static RubyArray frexp(ThreadContext context, IRubyObject recv, IRubyObject other) {
<span class="nc" id="L449">        return frexp19(context, recv, other);</span>
    }

    @JRubyMethod(name = &quot;frexp&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyArray frexp19(ThreadContext context, IRubyObject recv, IRubyObject other) {
<span class="fc" id="L454">        double mantissa = needFloat(other).getDoubleValue();</span>
<span class="fc" id="L455">        short sign = 1;</span>
<span class="fc" id="L456">        long exponent = 0;</span>

<span class="pc bpc" id="L458" title="2 of 4 branches missed.">        if (!Double.isInfinite(mantissa) &amp;&amp; mantissa != 0.0) {</span>
            // Make mantissa same sign so we only have one code path.
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">            if (mantissa &lt; 0) {</span>
<span class="nc" id="L461">                mantissa = -mantissa;</span>
<span class="nc" id="L462">                sign = -1;</span>
            }

            // Increase value to hit lower range.
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">            for (; mantissa &lt; 0.5; mantissa *= 2.0, exponent -=1) { }</span>

            // Decrease value to hit upper range.  
<span class="fc bfc" id="L469" title="All 2 branches covered.">            for (; mantissa &gt;= 1.0; mantissa *= 0.5, exponent +=1) { }</span>
        }
	 
<span class="fc" id="L472">        return RubyArray.newArray(context.runtime, </span>
<span class="fc" id="L473">                                 RubyFloat.newFloat(context.runtime, sign * mantissa),</span>
<span class="fc" id="L474">                                 RubyNumeric.int2fix(context.runtime, exponent));</span>
    }

    /*
     * r = x * 2 ** y
     */
    public static RubyFloat ldexp(ThreadContext context, IRubyObject recv, IRubyObject mantissa, IRubyObject exponent) {
<span class="nc" id="L481">        return ldexp19(context, recv, mantissa, exponent);</span>
    }

    @JRubyMethod(name = &quot;ldexp&quot;, required = 2, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat ldexp19(ThreadContext context, IRubyObject recv, IRubyObject mantissa, IRubyObject exponent) {
<span class="fc" id="L486">        return RubyFloat.newFloat(context.runtime, </span>
<span class="fc" id="L487">                needFloat(mantissa).getDoubleValue() * Math.pow(2.0, RubyNumeric.num2int(exponent)));</span>
    }

<span class="fc" id="L490">    public static final double[] ERFC_COEF = {</span>
         -.490461212346918080399845440334e-1,
         -.142261205103713642378247418996e0,
         .100355821875997955757546767129e-1,
         -.576876469976748476508270255092e-3,
         .274199312521960610344221607915e-4,
         -.110431755073445076041353812959e-5,
         .384887554203450369499613114982e-7,
         -.118085825338754669696317518016e-8,
         .323342158260509096464029309534e-10,
         -.799101594700454875816073747086e-12,
         .179907251139614556119672454866e-13,
         -.371863548781869263823168282095e-15,
         .710359900371425297116899083947e-17,
         -.126124551191552258324954248533e-18
    };
    
    public static RubyFloat erf(IRubyObject recv, IRubyObject x) {
<span class="nc" id="L508">        return erf19(null, recv, x);</span>
    }

    @JRubyMethod(name = &quot;erf&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat erf19(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L513">        double value = needFloat(x).getDoubleValue();</span>

        double  result;
<span class="fc" id="L516">        double  y = Math.abs(value);</span>

<span class="fc bfc" id="L518" title="All 2 branches covered.">        if (y &lt;= 1.49012e-08) {</span>
<span class="fc" id="L519">            result = 2 * value / 1.77245385090551602729816748334;</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">        } else if (y &lt;= 1) {</span>
<span class="fc" id="L521">            result = value * (1 + chebylevSerie(2 * value * value - 1, ERFC_COEF));</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">        } else if (y &lt; 6.013687357) {</span>
<span class="fc" id="L523">            result = sign(1 - erfc(context, recv, RubyFloat.newFloat(context.runtime,y)).getDoubleValue(), value);</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">        } else if (Double.isNaN(y)) {</span>
<span class="fc" id="L525">            result = Double.NaN;</span>
        } else {
<span class="fc" id="L527">            result = sign(1, value);</span>
        }
        
<span class="fc" id="L530">        return RubyFloat.newFloat(context.runtime,result);</span>
    }

<span class="fc" id="L533">    public static final double[] ERFC2_COEF = {</span>
         -.69601346602309501127391508262e-1,
         -.411013393626208934898221208467e-1,
         .391449586668962688156114370524e-2,
         -.490639565054897916128093545077e-3,
         .715747900137703638076089414183e-4,
         -.115307163413123283380823284791e-4,
         .199467059020199763505231486771e-5,
         -.364266647159922287393611843071e-6,
         .694437261000501258993127721463e-7,
         -.137122090210436601953460514121e-7,
         .278838966100713713196386034809e-8,
         -.581416472433116155186479105032e-9,
         .123892049175275318118016881795e-9,
         -.269063914530674343239042493789e-10,
         .594261435084791098244470968384e-11,
         -.133238673575811957928775442057e-11,
         .30280468061771320171736972433e-12,
         -.696664881494103258879586758895e-13,
         .162085454105392296981289322763e-13,
         -.380993446525049199987691305773e-14,
         .904048781597883114936897101298e-15,
         -.2164006195089607347809812047e-15,
         .522210223399585498460798024417e-16,
         -.126972960236455533637241552778e-16,
         .310914550427619758383622741295e-17,
         -.766376292032038552400956671481e-18,
         .190081925136274520253692973329e-18
    };

<span class="fc" id="L563">    public static final double[] ERFCC_COEF = {</span>
         .715179310202924774503697709496e-1,
         -.265324343376067157558893386681e-1,
         .171115397792085588332699194606e-2,
         -.163751663458517884163746404749e-3,
         .198712935005520364995974806758e-4,
         -.284371241276655508750175183152e-5,
         .460616130896313036969379968464e-6,
         -.822775302587920842057766536366e-7,
         .159214187277090112989358340826e-7,
         -.329507136225284321486631665072e-8,
         .72234397604005554658126115389e-9,
         -.166485581339872959344695966886e-9,
         .401039258823766482077671768814e-10,
         -.100481621442573113272170176283e-10,
         .260827591330033380859341009439e-11,
         -.699111056040402486557697812476e-12,
         .192949233326170708624205749803e-12,
         -.547013118875433106490125085271e-13,
         .158966330976269744839084032762e-13,
         -.47268939801975548392036958429e-14,
         .14358733767849847867287399784e-14,
         -.444951056181735839417250062829e-15,
         .140481088476823343737305537466e-15,
         -.451381838776421089625963281623e-16,
         .147452154104513307787018713262e-16,
         -.489262140694577615436841552532e-17,
         .164761214141064673895301522827e-17,
         -.562681717632940809299928521323e-18,
         .194744338223207851429197867821e-18
    };
        
    public static RubyFloat erfc(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L596">        return erfc19(context, recv, x);</span>
    }

    @JRubyMethod(name = &quot;erfc&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat erfc19(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L601">        double value = needFloat(x).getDoubleValue();</span>
        double  result;
<span class="fc" id="L603">        double  y = Math.abs(value);</span>

<span class="fc bfc" id="L605" title="All 2 branches covered.">        if (value &lt;= -6.013687357) {</span>
<span class="fc" id="L606">            result = 2;</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">        } else if (y &lt; 1.49012e-08) {</span>
<span class="fc" id="L608">            result = 1 - 2 * value / 1.77245385090551602729816748334;</span>
        } else {
<span class="fc" id="L610">            double ysq = y*y;</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">            if (y &lt; 1) {</span>
<span class="fc" id="L612">                result = 1 - value * (1 + chebylevSerie(2 * ysq - 1, ERFC_COEF));</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">            } else if (y &lt;= 4.0) {</span>
<span class="fc" id="L614">                result = Math.exp(-ysq)/y*(0.5+chebylevSerie((8.0 / ysq - 5.0) / 3.0, ERFC2_COEF));</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">                if (value &lt; 0) result = 2.0 - result;</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">                if (value &lt; 0) result = 2.0 - result;</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">                if (value &lt; 0) result = 2.0 - result;</span>
            } else {
<span class="fc" id="L619">                result = Math.exp(-ysq) / y * (0.5 + chebylevSerie(8.0 / ysq - 1, ERFCC_COEF));</span>
<span class="pc bpc" id="L620" title="1 of 2 branches missed.">                if (value &lt; 0) result = 2.0 - result;</span>
            }
        }
<span class="fc" id="L623">        return RubyFloat.newFloat(context.runtime,result);        </span>
    }

<span class="fc" id="L626">    private static final double FACTORIAL[] = {</span>
        /*  0! */ 1.0,
        /*  1! */ 1.0,
        /*  2! */ 2.0,
        /*  3! */ 6.0,
        /*  4! */ 24.0,
        /*  5! */ 120.0,
        /*  6! */ 720.0,
        /*  7! */ 5040.0,
        /*  8! */ 40320.0,
        /*  9! */ 362880.0,
        /* 10! */ 3628800.0,
        /* 11! */ 39916800.0,
        /* 12! */ 479001600.0,
        /* 13! */ 6227020800.0,
        /* 14! */ 87178291200.0,
        /* 15! */ 1307674368000.0,
        /* 16! */ 20922789888000.0,
        /* 17! */ 355687428096000.0,
        /* 18! */ 6402373705728000.0,
        /* 19! */ 121645100408832000.0,
        /* 20! */ 2432902008176640000.0,
        /* 21! */ 51090942171709440000.0,
        /* 22! */ 1124000727777607680000.0
    };

<span class="fc" id="L652">    private static final double NEMES_GAMMA_COEFF[] = {</span>
        1.00000000000000000000000000000000000,
        0                                    ,
        0.08333333333333333333333333333333333,
        0                                    ,
        0.00069444444444444444444444444444444,
        0                                    ,
        0.00065861992945326278659611992945326,
        0                                    ,
       -0.00053287817827748383303938859494415,
        0                                    ,
        0.00079278588700608376534302460228386,
        0                                    ,
       -0.00184758189322033028400606295961969,
        0                                    ,
        0.00625067824784941846328836824623616,
        0                                    ,
       -0.02901710246301150993444701506844402,
        0                                    ,
        0.17718457242491308890302832366796470,
        0                                    ,
       -1.37747681703993534399676348903067470
    };


    /**
     * Based on Gerg&amp;#337; Nemes's Gamma Function approximation formula, we compute
     * approximate value of Gamma function of x.
     * @param recv Math module
     * @param x a real number
     * @return &amp;Gamma;(x) for real number x
     * @see &lt;a href=&quot;http://www.ebyte.it/library/downloads/2008_MTH_Nemes_GammaApproximationUpdate.pdf&quot;&gt;
     * New asymptotic expansion for the &amp;Gamma;(x) function&lt;/a&gt;
     */

    @JRubyMethod(name = &quot;gamma&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyFloat gamma(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L689">        double value = ((RubyFloat) RubyKernel.new_float(recv, x)).getDoubleValue();</span>
<span class="fc" id="L690">        double result = nemes_gamma(value);</span>
        /* note nemes_gamma can return Double.POSITIVE_INFINITY or Double.NEGATIVE_INFINITY
         * when value is an integer less than 1.
         * We treat 0 as a special case to avoid Domain error.
         */
<span class="fc bfc" id="L695" title="All 2 branches covered.">        if (Double.isInfinite(result)) {</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">            if (value &lt; 0) {</span>
<span class="fc" id="L697">                result = Double.NaN;</span>
            } else {
<span class="fc bfc" id="L699" title="All 4 branches covered.">                if (value == 0 &amp;&amp; 1 / value &lt; 0) {</span>
<span class="fc" id="L700">                    result = Double.NEGATIVE_INFINITY;</span>
                } else {
<span class="fc" id="L702">                    result = Double.POSITIVE_INFINITY;</span>
                }
            }
        }

<span class="fc bfc" id="L707" title="All 2 branches covered.">        if (Double.isNaN(value)) {</span>
<span class="fc" id="L708">            return RubyFloat.newFloat(context.runtime, Double.NaN);</span>
        }

<span class="fc" id="L711">        domainCheck19(recv, result, &quot;gamma&quot;);</span>
<span class="fc" id="L712">        return RubyFloat.newFloat(context.runtime, result);</span>

    }

    /**
     * Based on Gerg&amp;#337; Nemes's Gamma Function approximation formula, we compute
     * Log Gamma function for real number x.
     * @param recv Math module
     * @param x a real number
     * @return 2-element array [ln(&amp;Gamma;(x)), sgn] for real number x,
     *  where sgn is the sign of &amp;Gamma;(x) when exponentiated
     * @see #gamma(org.jruby.runtime.builtin.IRubyObject, org.jruby.runtime.builtin.IRubyObject)
     */

    @JRubyMethod(name = &quot;lgamma&quot;, required = 1, module = true, visibility = Visibility.PRIVATE)
    public static RubyArray lgamma(ThreadContext context, IRubyObject recv, IRubyObject x) {
<span class="fc" id="L728">        double value      = RubyKernel.new_float(recv, x).getDoubleValue();</span>
        // JRUBY-4653: Could this error checking done more elegantly?
<span class="fc bfc" id="L730" title="All 4 branches covered.">        if (value &lt; 0 &amp;&amp; Double.isInfinite(value)) throw context.runtime.newMathDomainError(&quot;lgamma&quot;);</span>

<span class="fc" id="L732">        NemesLogGamma l = new NemesLogGamma(value);</span>

<span class="fc" id="L734">        return RubyArray.newArray(context.runtime, </span>
<span class="fc" id="L735">                RubyFloat.newFloat(context.runtime, l.value), RubyInteger.int2fix(context.runtime, (int) l.sign));</span>
    }

    public static double nemes_gamma(double x) {
<span class="fc" id="L739">        double int_part = (int) x;</span>

<span class="fc bfc" id="L741" title="All 6 branches covered.">        if ((x - int_part) == 0.0 &amp;&amp; 0 &lt; int_part &amp;&amp; int_part &lt;= FACTORIAL.length) {</span>
<span class="fc" id="L742">            return FACTORIAL[(int) int_part - 1];</span>
        }
<span class="fc" id="L744">        NemesLogGamma l = new NemesLogGamma(x);</span>
<span class="fc" id="L745">        return l.sign * Math.exp(l.value);</span>
    }

    /**
     * Inner class to help with &amp;Gamma; functions
     */
<span class="nc" id="L751">    public static class NemesLogGamma {</span>
        public double value;
<span class="fc" id="L753">        public double sign = 1;</span>

<span class="fc" id="L755">        public NemesLogGamma(double x) {</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">            if (Double.isInfinite(x)) {</span>
<span class="fc" id="L757">                value = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L758">                return;</span>
            }

<span class="fc bfc" id="L761" title="All 2 branches covered.">            if (Double.isNaN(x)) {</span>
<span class="fc" id="L762">                value = Double.NaN;</span>
<span class="fc" id="L763">                return;</span>
            }

<span class="fc" id="L766">            double int_part = (int) x;</span>
<span class="fc bfc" id="L767" title="All 6 branches covered.">            sign = (int_part % 2 == 0 &amp;&amp; (x - int_part) != 0.0 &amp;&amp; (x &lt; 0)) ? -1 : 1;</span>
<span class="fc bfc" id="L768" title="All 6 branches covered.">            if ((x - int_part) == 0.0 &amp;&amp; 0 &lt; int_part &amp;&amp; int_part &lt;= FACTORIAL.length) {</span>
<span class="fc" id="L769">                value = Math.log(FACTORIAL[(int) int_part - 1]);</span>
            }
<span class="fc bfc" id="L771" title="All 2 branches covered.">            else if (x &lt; 10) {</span>
<span class="fc" id="L772">                double rising_factorial = 1;</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">                for (int i = 0; i &lt; (int) Math.abs(x) - int_part + 10; i++) {</span>
<span class="fc" id="L774">                    rising_factorial *= (x + i);</span>
                }
<span class="fc" id="L776">                NemesLogGamma l = new NemesLogGamma(x + (int) Math.abs(x) - int_part + 10);</span>
<span class="fc" id="L777">                value = l.value - Math.log(Math.abs(rising_factorial));</span>
<span class="fc" id="L778">            } else {</span>
<span class="fc" id="L779">                double temp = 0.0;</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">                for (int i = 0; i &lt; NEMES_GAMMA_COEFF.length; i++) {</span>
<span class="fc" id="L781">                    temp += NEMES_GAMMA_COEFF[i] * 1.0 / Math.pow(x, i);</span>
                }

<span class="fc" id="L784">                value = x * (Math.log(x) - 1 + Math.log(temp)) +</span>
<span class="fc" id="L785">                        (Math.log(2) + Math.log(Math.PI) - Math.log(x)) / 2.0;</span>
            }
<span class="fc" id="L787">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>