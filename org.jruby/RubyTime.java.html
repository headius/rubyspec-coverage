<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RubyTime.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby</a> &gt; <span class="el_source">RubyTime.java</span></div><h1>RubyTime.java</h1><pre class="source lang-java linenums">/***** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2001 Chad Fowler &lt;chadfowler@chadfowler.com&gt;
 * Copyright (C) 2001-2004 Jan Arne Petersen &lt;jpetersen@uni-bonn.de&gt;
 * Copyright (C) 2002 Benoit Cerrina &lt;b.cerrina@wanadoo.fr&gt;
 * Copyright (C) 2002-2004 Anders Bengtsson &lt;ndrsbngtssn@yahoo.se&gt;
 * Copyright (C) 2004 Joey Gibson &lt;joey@joeygibson.com&gt;
 * Copyright (C) 2004 Charles O Nutter &lt;headius@headius.com&gt;
 * Copyright (C) 2004 Stefan Matthias Aust &lt;sma@3plus4.de&gt;
 * Copyright (C) 2006 Thomas E Enebo &lt;enebo@acm.org&gt;
 * Copyright (C) 2006 Ola Bini &lt;ola.bini@ki.se&gt;
 * Copyright (C) 2006 Miguel Covarrubias &lt;mlcovarrubias@gmail.com&gt;
 * Copyright (C) 2009 Joseph LaFata &lt;joe@quibb.org&gt;
 * 
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby;

import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jcodings.specific.USASCIIEncoding;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.joda.time.IllegalFieldValueException;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.tz.FixedDateTimeZone;
import org.jruby.anno.JRubyClass;
import org.jruby.anno.JRubyMethod;
import org.jruby.exceptions.RaiseException;
import org.jruby.runtime.Block;
import org.jruby.runtime.ClassIndex;
import org.jruby.runtime.ObjectAllocator;
import org.jruby.runtime.ThreadContext;
import org.jruby.runtime.Visibility;
import static org.jruby.runtime.Visibility.PRIVATE;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.util.ByteList;
import org.jruby.util.RubyDateFormatter;
import org.jruby.runtime.Helpers;

import static org.jruby.RubyComparable.invcmp;
import static org.jruby.runtime.Helpers.invokedynamic;
import static org.jruby.runtime.invokedynamic.MethodNames.OP_CMP;

/** The Time class.
 * 
 * @author chadfowler, jpetersen
 */
@JRubyClass(name=&quot;Time&quot;, include=&quot;Comparable&quot;)
public class RubyTime extends RubyObject {
    public static final String UTC = &quot;UTC&quot;;
    private DateTime dt;
    private long nsec;
    
<span class="fc" id="L84">    private final static DateTimeFormatter ONE_DAY_CTIME_FORMATTER = DateTimeFormat.forPattern(&quot;EEE MMM  d HH:mm:ss yyyy&quot;).withLocale(Locale.ENGLISH);</span>
<span class="fc" id="L85">    private final static DateTimeFormatter TWO_DAY_CTIME_FORMATTER = DateTimeFormat.forPattern(&quot;EEE MMM dd HH:mm:ss yyyy&quot;).withLocale(Locale.ENGLISH);</span>

<span class="fc" id="L87">    private final static DateTimeFormatter TO_S_FORMATTER = DateTimeFormat.forPattern(&quot;EEE MMM dd HH:mm:ss Z yyyy&quot;).withLocale(Locale.ENGLISH);</span>
<span class="fc" id="L88">    private final static DateTimeFormatter TO_S_UTC_FORMATTER = DateTimeFormat.forPattern(&quot;EEE MMM dd HH:mm:ss 'UTC' yyyy&quot;).withLocale(Locale.ENGLISH);</span>

<span class="fc" id="L90">    private final static DateTimeFormatter TO_S_FORMATTER_19 = DateTimeFormat.forPattern(&quot;yyyy-MM-dd HH:mm:ss Z&quot;).withLocale(Locale.ENGLISH);</span>
<span class="fc" id="L91">    private final static DateTimeFormatter TO_S_UTC_FORMATTER_19 = DateTimeFormat.forPattern(&quot;yyyy-MM-dd HH:mm:ss 'UTC'&quot;).withLocale(Locale.ENGLISH);</span>
    // There are two different popular TZ formats: legacy (AST+3:00:00, GMT-3), and
    // newer one (US/Pacific, America/Los_Angeles). This pattern is to detect
    // the legacy TZ format in order to convert it to the newer format
    // understood by Java API.
<span class="fc" id="L96">    private static final Pattern TZ_PATTERN</span>
<span class="fc" id="L97">            = Pattern.compile(&quot;([^-\\+\\d]+)?([\\+-]?)(\\d+)(?::(\\d+))?(?::(\\d+))?&quot;);</span>
    
<span class="fc" id="L99">    private static final Pattern TIME_OFFSET_PATTERN</span>
<span class="fc" id="L100">            = Pattern.compile(&quot;([\\+-])(\\d\\d):(\\d\\d)(?::(\\d\\d))?&quot;);</span>

<span class="fc" id="L102">    private static final ByteList TZ_STRING = ByteList.create(&quot;TZ&quot;);</span>
    
<span class="fc" id="L104">    private boolean isTzRelative = false; // true if and only if #new is called with a numeric offset (e.g., &quot;+03:00&quot;)</span>
    
    /* JRUBY-3560
     * joda-time disallows use of three-letter time zone IDs.
     * Since MRI accepts these values, we need to translate them.
     */
<span class="fc" id="L110">    private static final Map&lt;String, String&gt; LONG_TZNAME = Helpers.map(</span>
        &quot;MET&quot;, &quot;CET&quot;, // JRUBY-2759
        &quot;ROC&quot;, &quot;Asia/Taipei&quot;, // Republic of China
        &quot;WET&quot;, &quot;Europe/Lisbon&quot; // Western European Time
    );
    
    /* Some TZ values need to be overriden for Time#zone
     */
<span class="fc" id="L118">    private static final Map&lt;String, String&gt; SHORT_STD_TZNAME = Helpers.map(</span>
        &quot;Etc/UCT&quot;, &quot;UCT&quot;,
        &quot;MET&quot;, &quot;MET&quot;, // needs to be overriden
        &quot;UCT&quot;, &quot;UCT&quot;
    );

<span class="fc" id="L124">    private static final Map&lt;String, String&gt; SHORT_DL_TZNAME = Helpers.map(</span>
        &quot;Etc/UCT&quot;, &quot;UCT&quot;,
        &quot;MET&quot;, &quot;MEST&quot;, // needs to be overriden
        &quot;UCT&quot;, &quot;UCT&quot;
    );
    
    private void setIsTzRelative(boolean tzRelative) {
<span class="fc" id="L131">        isTzRelative = tzRelative;</span>
<span class="fc" id="L132">    }</span>

    @Override
    public ClassIndex getNativeClassIndex() {
<span class="nc" id="L136">        return ClassIndex.TIME;</span>
    }
    
    private static IRubyObject getEnvTimeZone(Ruby runtime) {
<span class="fc" id="L140">        RubyString tzVar = runtime.newString(TZ_STRING);</span>
<span class="fc" id="L141">        return runtime.getENV().op_aref(runtime.getCurrentContext(), tzVar);</span>
    }

    public static DateTimeZone getLocalTimeZone(Ruby runtime) {
<span class="fc" id="L145">        IRubyObject tz = getEnvTimeZone(runtime);</span>

<span class="pc bpc" id="L147" title="1 of 4 branches missed.">        if (tz == null || ! (tz instanceof RubyString)) {</span>
<span class="fc" id="L148">            return DateTimeZone.getDefault();</span>
        } else {
<span class="fc" id="L150">            return getTimeZoneFromTZString(runtime, tz.toString());</span>
        }
    }

    public static DateTimeZone getTimeZoneFromTZString(Ruby runtime, String zone) {
<span class="fc" id="L155">        DateTimeZone cachedZone = runtime.getTimezoneCache().get(zone);</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">        if (cachedZone != null) {</span>
<span class="fc" id="L157">            return cachedZone;</span>
        } else {
<span class="fc" id="L159">            DateTimeZone dtz = parseTZString(runtime, zone);</span>
<span class="fc" id="L160">            runtime.getTimezoneCache().put(zone, dtz);</span>
<span class="fc" id="L161">            return dtz;</span>
        }
    }

    private static DateTimeZone parseTZString(Ruby runtime, String zone) {
<span class="fc" id="L166">        String upZone = zone.toUpperCase();</span>

<span class="fc" id="L168">        Matcher tzMatcher = TZ_PATTERN.matcher(zone);</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (tzMatcher.matches()) {</span>
<span class="fc" id="L170">            String zoneName = tzMatcher.group(1);</span>
<span class="fc" id="L171">            String sign = tzMatcher.group(2);</span>
<span class="fc" id="L172">            String hours = tzMatcher.group(3);</span>
<span class="fc" id="L173">            String minutes = tzMatcher.group(4);</span>
<span class="fc" id="L174">            String seconds= tzMatcher.group(5);</span>

<span class="pc bpc" id="L176" title="1 of 2 branches missed.">            if (zoneName == null) {</span>
<span class="nc" id="L177">                zoneName = &quot;&quot;;</span>
            }

            // Sign is reversed in legacy TZ notation
<span class="fc" id="L181">            return getTimeZoneFromHHMM(runtime, zoneName, sign.equals(&quot;-&quot;), hours, minutes, seconds);</span>
        } else {
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">            if (LONG_TZNAME.containsKey(upZone)) {</span>
<span class="nc" id="L184">                zone = LONG_TZNAME.get(upZone);</span>
<span class="pc bpc" id="L185" title="1 of 4 branches missed.">            } else if (upZone.equals(&quot;UTC&quot;) || upZone.equals(&quot;GMT&quot;)) {</span>
                // MRI behavior: With TZ equal to &quot;GMT&quot; or &quot;UTC&quot;, Time.now
                // is *NOT* considered as a proper GMT/UTC time:
                //   ENV['TZ']=&quot;GMT&quot;; Time.now.gmt? #=&gt; false
                //   ENV['TZ']=&quot;UTC&quot;; Time.now.utc? #=&gt; false
                // Hence, we need to adjust for that.
<span class="fc" id="L191">                zone = &quot;Etc/&quot; + upZone;</span>
            }

            try {
<span class="fc" id="L195">                return DateTimeZone.forID(zone);</span>
<span class="nc" id="L196">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L197">                runtime.getWarnings().warn(&quot;Unrecognized time zone: &quot;+zone);</span>
<span class="nc" id="L198">                return DateTimeZone.UTC;</span>
            }
        }
    }

    public static DateTimeZone getTimeZoneFromString(Ruby runtime, String zone) {
<span class="nc" id="L204">        DateTimeZone cachedZone = runtime.getTimezoneCache().get(zone);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (cachedZone != null) {</span>
<span class="nc" id="L206">            return cachedZone;</span>
        } else {
<span class="nc" id="L208">            DateTimeZone dtz = parseZoneString(runtime, zone);</span>
<span class="nc" id="L209">            runtime.getTimezoneCache().put(zone, dtz);</span>
<span class="nc" id="L210">            return dtz;</span>
        }
    }

    private static DateTimeZone parseZoneString(Ruby runtime, String zone) {
        // TODO: handle possible differences with TZ format
<span class="nc" id="L216">        return parseTZString(runtime, zone);</span>
    }

    public static DateTimeZone getTimeZoneFromUtcOffset(Ruby runtime, IRubyObject utcOffset) {
<span class="fc" id="L220">        String strOffset = utcOffset.toString();</span>

<span class="fc" id="L222">        DateTimeZone cachedZone = runtime.getTimezoneCache().get(strOffset);</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">        if (cachedZone != null) return cachedZone;</span>

        DateTimeZone dtz;
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">        if(utcOffset instanceof RubyString) {</span>
<span class="fc" id="L227">            Matcher offsetMatcher = TIME_OFFSET_PATTERN.matcher(strOffset);</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">            if (!offsetMatcher.matches()) {</span>
<span class="fc" id="L229">                throw runtime.newArgumentError(&quot;\&quot;+HH:MM\&quot; or \&quot;-HH:MM\&quot; expected for utc_offset&quot;);</span>
            }
<span class="fc" id="L231">            String sign = offsetMatcher.group(1);</span>
<span class="fc" id="L232">            String hours = offsetMatcher.group(2);</span>
<span class="fc" id="L233">            String minutes = offsetMatcher.group(3);</span>
<span class="fc" id="L234">            String seconds = offsetMatcher.group(4);</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">            dtz = getTimeZoneFromHHMM(runtime, &quot;&quot;, !sign.equals(&quot;-&quot;), hours, minutes, seconds);</span>
<span class="fc" id="L236">        } else {</span>
<span class="nc" id="L237">            IRubyObject numericOffset = numExact(runtime, utcOffset);</span>
<span class="nc" id="L238">            int newOffset = (int)Math.round(numericOffset.convertToFloat().getDoubleValue() * 1000);</span>
<span class="nc" id="L239">            dtz = getTimeZoneWithOffset(runtime, &quot;&quot;, newOffset);</span>
        }

<span class="fc" id="L242">        runtime.getTimezoneCache().put(strOffset, dtz);</span>
<span class="fc" id="L243">        return dtz;</span>
    }

    /* time.c num_exact
     */
    private static IRubyObject numExact(Ruby runtime, IRubyObject v) {
        IRubyObject tmp;
<span class="nc bnc" id="L250" title="All 4 branches missed.">        switch(v.getMetaClass().getRealClass().getClassIndex()) {</span>
            case FIXNUM:
            case BIGNUM:
<span class="nc" id="L253">                return v;</span>
            case RATIONAL:
<span class="nc" id="L255">                break;</span>
            case STRING:
            case NIL:
<span class="nc" id="L258">                exactTypeError(runtime, v);</span>
            default:
<span class="nc" id="L260">                tmp = v.callMethod(runtime.getCurrentContext(), &quot;to_r&quot;);</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">                if(!tmp.eql(UNDEF)) {</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">                    if(v.respondsTo(&quot;to_str&quot;)) {</span>
<span class="nc" id="L263">                        exactTypeError(runtime, v);</span>
                    }
<span class="nc" id="L265">                    v = tmp;</span>
<span class="nc" id="L266">                    break;</span>
                }

<span class="nc" id="L269">                tmp = v.callMethod(runtime.getCurrentContext(), &quot;to_int&quot;);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">                if(!tmp.isNil()) {</span>
<span class="nc" id="L271">                    v = tmp;</span>
<span class="nc" id="L272">                    break;</span>
                }
<span class="nc" id="L274">                exactTypeError(runtime, v);</span>
        }

<span class="nc bnc" id="L277" title="All 3 branches missed.">        switch(v.getMetaClass().getRealClass().getClassIndex()) {</span>
            case FIXNUM:
            case BIGNUM:
<span class="nc" id="L280">                return v;</span>
            case RATIONAL:
<span class="nc" id="L282">                RubyRational r = (RubyRational)v;</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">                if(r.denominator(runtime.getCurrentContext()) == RubyFixnum.newFixnum(runtime, 1)) {</span>
<span class="nc" id="L284">                    return r.numerator(runtime.getCurrentContext());</span>
                }
                break;
            default:
<span class="nc" id="L288">                exactTypeError(runtime, v);</span>
        }

<span class="nc" id="L291">        return v;</span>
    }

    private static void exactTypeError(Ruby runtime, IRubyObject received) {
<span class="nc" id="L295">        throw runtime.newTypeError(</span>
<span class="nc" id="L296">                String.format(&quot;Can't convert %s into an exact number&quot;, received.getMetaClass().getRealClass()));</span>
    }

    private static DateTimeZone getTimeZoneFromHHMM(Ruby runtime, String name, boolean positive, String hours, String minutes, String seconds) {
<span class="fc" id="L300">        int h = Integer.parseInt(hours);</span>
<span class="fc" id="L301">        int m = 0;</span>
<span class="fc" id="L302">        int s = 0;</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">        if (minutes != null) {</span>
<span class="fc" id="L304">            m = Integer.parseInt(minutes);</span>
        }

<span class="fc bfc" id="L307" title="All 2 branches covered.">        if (seconds != null) {</span>
<span class="fc" id="L308">            s = Integer.parseInt(seconds);</span>
        }

<span class="pc bpc" id="L311" title="1 of 4 branches missed.">        if (h &gt; 23 || m &gt; 59) {</span>
<span class="fc" id="L312">            throw runtime.newArgumentError(&quot;utc_offset out of range&quot;);</span>
        }

<span class="fc bfc" id="L315" title="All 2 branches covered.">        int offset = (positive ? +1 : -1) * ((h * 3600) + m * 60 + s)  * 1000;</span>
<span class="fc" id="L316">        return timeZoneWithOffset(name, offset);</span>
    }

    public static DateTimeZone getTimeZone(Ruby runtime, long seconds) {
<span class="fc bfc" id="L320" title="All 4 branches covered.">        if (seconds &gt;= 60*60*24 || seconds &lt;= -60*60*24) {</span>
<span class="fc" id="L321">            throw runtime.newArgumentError(&quot;utc_offset out of range&quot;);</span>
        }
<span class="fc" id="L323">        return getTimeZoneWithOffset(runtime, &quot;&quot;, (int) (seconds * 1000));</span>
    }

    public static DateTimeZone getTimeZoneWithOffset(Ruby runtime, String zoneName, int offset) {
        // validate_zone_name
<span class="fc" id="L328">        zoneName = zoneName.trim();</span>

<span class="fc" id="L330">        String zone = zoneName + offset;</span>

<span class="fc" id="L332">        DateTimeZone cachedZone = runtime.getTimezoneCache().get(zone);</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (cachedZone != null) {</span>
<span class="fc" id="L334">            return cachedZone;</span>
        } else {
<span class="fc" id="L336">            DateTimeZone dtz = timeZoneWithOffset(zoneName, offset);</span>
<span class="fc" id="L337">            runtime.getTimezoneCache().put(zone, dtz);</span>
<span class="fc" id="L338">            return dtz;</span>
        }
    }

    private static DateTimeZone timeZoneWithOffset(String zoneName, int offset) {
<span class="fc bfc" id="L343" title="All 2 branches covered.">        if (zoneName.isEmpty()) {</span>
<span class="fc" id="L344">            return DateTimeZone.forOffsetMillis(offset);</span>
        } else {
<span class="fc" id="L346">            return new FixedDateTimeZone(zoneName, null, offset, offset);</span>
        }
    }

    public RubyTime(Ruby runtime, RubyClass rubyClass) {
<span class="fc" id="L351">        super(runtime, rubyClass);</span>
<span class="fc" id="L352">    }</span>
    
    public RubyTime(Ruby runtime, RubyClass rubyClass, DateTime dt) {
<span class="fc" id="L355">        super(runtime, rubyClass);</span>
<span class="fc" id="L356">        this.dt = dt;</span>
<span class="fc" id="L357">    }</span>

<span class="fc" id="L359">    private static ObjectAllocator TIME_ALLOCATOR = new ObjectAllocator() {</span>
        @Override
        public IRubyObject allocate(Ruby runtime, RubyClass klass) {
<span class="fc" id="L362">            DateTimeZone dtz = getLocalTimeZone(runtime);</span>
<span class="fc" id="L363">            DateTime dt = new DateTime(dtz);</span>
<span class="fc" id="L364">            RubyTime rt =  new RubyTime(runtime, klass, dt);</span>
<span class="fc" id="L365">            rt.setNSec(0);</span>

<span class="fc" id="L367">            return rt;</span>
        }
    };

    public static RubyClass createTimeClass(Ruby runtime) {
<span class="fc" id="L372">        RubyClass timeClass = runtime.defineClass(&quot;Time&quot;, runtime.getObject(), TIME_ALLOCATOR);</span>

<span class="fc" id="L374">        timeClass.setClassIndex(ClassIndex.TIME);</span>
<span class="fc" id="L375">        timeClass.setReifiedClass(RubyTime.class);</span>
        
<span class="fc" id="L377">        runtime.setTime(timeClass);</span>
        
<span class="fc" id="L379">        timeClass.includeModule(runtime.getComparable());</span>
        
<span class="fc" id="L381">        timeClass.defineAnnotatedMethods(RubyTime.class);</span>
        
<span class="fc" id="L383">        return timeClass;</span>
    }
    
    public void setNSec(long nsec) {
<span class="fc" id="L387">        this.nsec = nsec;</span>
<span class="fc" id="L388">    }</span>

    public long getNSec() {
<span class="fc" id="L391">        return nsec;</span>
    }

    public void setUSec(long usec) {
<span class="fc" id="L395">        this.nsec = 1000 * usec;</span>
<span class="fc" id="L396">    }</span>
    
    public long getUSec() {
<span class="fc" id="L399">        return nsec / 1000;</span>
    }
    
    public void updateCal(DateTime dt) {
<span class="nc" id="L403">        this.dt = dt;</span>
<span class="nc" id="L404">    }</span>
    
    protected long getTimeInMillis() {
<span class="fc" id="L407">        return dt.getMillis();</span>
    }
    
    public static RubyTime newTime(Ruby runtime, long milliseconds) {
<span class="fc" id="L411">        return newTime(runtime, new DateTime(milliseconds));</span>
    }
    
    public static RubyTime newTime(Ruby runtime, DateTime dt) {
<span class="fc" id="L415">        return new RubyTime(runtime, runtime.getTime(), dt);</span>
    }
    
    public static RubyTime newTime(Ruby runtime, DateTime dt, long nsec) {
<span class="fc" id="L419">        RubyTime t = new RubyTime(runtime, runtime.getTime(), dt);</span>
<span class="fc" id="L420">        t.setNSec(nsec);</span>
<span class="fc" id="L421">        return t;</span>
    }
    
    @Override
    public Class&lt;?&gt; getJavaClass() {
<span class="nc" id="L426">        return Date.class;</span>
    }

    @JRubyMethod(required = 1, visibility = Visibility.PRIVATE)
    @Override
    public IRubyObject initialize_copy(IRubyObject original) {
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">        if (!(original instanceof RubyTime)) {</span>
<span class="nc" id="L433">            throw getRuntime().newTypeError(&quot;Expecting an instance of class Time&quot;);</span>
        }
        
<span class="fc" id="L436">        RubyTime originalTime = (RubyTime) original;</span>
        
        // We can just use dt, since it is immutable
<span class="fc" id="L439">        dt = originalTime.dt;</span>
<span class="fc" id="L440">        nsec = originalTime.nsec;</span>
        
<span class="fc" id="L442">        return this;</span>
    }

    @JRubyMethod
    public RubyTime succ() {
<span class="fc" id="L447">        return newTime(getRuntime(),dt.plusSeconds(1));</span>
    }

    @JRubyMethod(name = {&quot;gmtime&quot;, &quot;utc&quot;})
    public RubyTime gmtime() {
<span class="fc" id="L452">        dt = dt.withZone(DateTimeZone.UTC);</span>
<span class="fc" id="L453">        return this;</span>
    }

    public RubyTime localtime() {
<span class="fc" id="L457">        return localtime19(getRuntime().getCurrentContext(), NULL_ARRAY);</span>
    }
    
    @JRubyMethod(name = &quot;localtime&quot;, optional = 1)
    public RubyTime localtime19(ThreadContext context, IRubyObject[] args) {
        DateTimeZone newDtz;
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">        if (args.length == 0) {</span>
<span class="fc" id="L464">            newDtz = getLocalTimeZone(context.runtime);</span>
        } else {
<span class="nc" id="L466">            newDtz = getTimeZoneFromUtcOffset(context.runtime, args[0]);</span>
        }
<span class="fc" id="L468">        dt = dt.withZone(newDtz);</span>
<span class="fc" id="L469">        return this;</span>
    }
    
    @JRubyMethod(name = {&quot;gmt?&quot;, &quot;utc?&quot;, &quot;gmtime?&quot;})
    public RubyBoolean gmt() {
<span class="fc" id="L474">        return getRuntime().newBoolean(dt.getZone().getID().equals(&quot;UTC&quot;));</span>
    }
    
    @JRubyMethod(name = {&quot;getgm&quot;, &quot;getutc&quot;})
    public RubyTime getgm() {
<span class="fc" id="L479">        return newTime(getRuntime(), dt.withZone(DateTimeZone.UTC), nsec);</span>
    }

    public RubyTime getlocal() {
<span class="nc" id="L483">        return getlocal19(getRuntime().getCurrentContext(), NULL_ARRAY);</span>
    }

    @JRubyMethod(name = &quot;getlocal&quot;, optional = 1)
    public RubyTime getlocal19(ThreadContext context, IRubyObject[] args) {
<span class="pc bpc" id="L488" title="1 of 4 branches missed.">        if (args.length == 0 || args[0].isNil()) {</span>
<span class="fc" id="L489">            return newTime(getRuntime(), dt.withZone(getLocalTimeZone(getRuntime())), nsec);</span>
        } else {
<span class="fc" id="L491">            DateTimeZone dtz = getTimeZoneFromUtcOffset(context.runtime, args[0]);</span>
<span class="fc" id="L492">            return newTime(getRuntime(), dt.withZone(dtz), nsec);</span>
        }
    }

    @JRubyMethod(required = 1)
    public RubyString strftime(IRubyObject format) {
<span class="fc" id="L498">        final RubyDateFormatter rdf = getRuntime().getCurrentContext().getRubyDateFormatter();</span>
<span class="fc" id="L499">        return rdf.compileAndFormat(format.convertToString(), false, dt, nsec, null);</span>
    }

    @JRubyMethod(name = &quot;==&quot;, required = 1)
    @Override
    public IRubyObject op_equal(ThreadContext context, IRubyObject other) {
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">        if (other.isNil()) {</span>
<span class="nc" id="L506">            return RubyBoolean.newBoolean(getRuntime(), false);</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">        } else if (other instanceof RubyTime) {</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">            return getRuntime().newBoolean(cmp((RubyTime) other) == 0);</span>
        }

<span class="fc" id="L511">        return RubyComparable.op_equal19(context, this, other);</span>
    }
    
    @JRubyMethod(name = &quot;&gt;=&quot;, required = 1)
    public IRubyObject op_ge(ThreadContext context, IRubyObject other) {
<span class="nc bnc" id="L516" title="All 2 branches missed.">        if (other instanceof RubyTime) {</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">            return getRuntime().newBoolean(cmp((RubyTime) other) &gt;= 0);</span>
        }
        
<span class="nc" id="L520">        return RubyComparable.op_ge(context, this, other);</span>
    }
    
    @JRubyMethod(name = &quot;&gt;&quot;, required = 1)
    public IRubyObject op_gt(ThreadContext context, IRubyObject other) {
<span class="nc bnc" id="L525" title="All 2 branches missed.">        if (other instanceof RubyTime) {</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">            return getRuntime().newBoolean(cmp((RubyTime) other) &gt; 0);</span>
        }
        
<span class="nc" id="L529">        return RubyComparable.op_gt(context, this, other);</span>
    }
    
    @JRubyMethod(name = &quot;&lt;=&quot;, required = 1)
    public IRubyObject op_le(ThreadContext context, IRubyObject other) {
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">        if (other instanceof RubyTime) {</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">            return getRuntime().newBoolean(cmp((RubyTime) other) &lt;= 0);</span>
        }
        
<span class="nc" id="L538">        return RubyComparable.op_le(context, this, other);</span>
    }
    
    @JRubyMethod(name = &quot;&lt;&quot;, required = 1)
    public IRubyObject op_lt(ThreadContext context, IRubyObject other) {
<span class="nc bnc" id="L543" title="All 2 branches missed.">        if (other instanceof RubyTime) {</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">            return getRuntime().newBoolean(cmp((RubyTime) other) &lt; 0);</span>
        }
        
<span class="nc" id="L547">        return RubyComparable.op_lt(context, this, other);</span>
    }
    
    private int cmp(RubyTime other) {
<span class="fc" id="L551">        Ruby runtime = getRuntime();</span>

<span class="fc" id="L553">        long millis = getTimeInMillis();</span>
<span class="fc" id="L554">		long millis_other = other.getTimeInMillis();</span>
        // ignore &lt; usec on 1.8
<span class="fc" id="L556">        long nanosec = this.nsec;</span>
<span class="fc" id="L557">        long nsec_other = other.nsec;</span>

<span class="fc bfc" id="L559" title="All 6 branches covered.">		if (millis &gt; millis_other || (millis == millis_other &amp;&amp; nanosec &gt; nsec_other)) {</span>
<span class="fc" id="L560">		    return 1;</span>
<span class="pc bpc" id="L561" title="1 of 6 branches missed.">		} else if (millis &lt; millis_other || (millis == millis_other &amp;&amp; nanosec &lt; nsec_other)) {</span>
<span class="fc" id="L562">		    return -1;</span>
		}

<span class="fc" id="L565">        return 0;</span>
    }

    public IRubyObject op_plus(IRubyObject other) {
<span class="nc" id="L569">        return op_plus19(getRuntime().getCurrentContext(), other);</span>
    }

    @JRubyMethod(name = &quot;+&quot;, required = 1)
    public IRubyObject op_plus19(ThreadContext context, IRubyObject other) {
<span class="fc" id="L574">        checkOpCoercion(context, other);</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">        if (other instanceof RubyTime) {</span>
<span class="fc" id="L576">            throw getRuntime().newTypeError(&quot;time + time ?&quot;);</span>
        }
<span class="fc" id="L578">        other = other.callMethod(context, &quot;to_r&quot;);</span>

<span class="fc" id="L580">        long adjustNanos = (long)(RubyNumeric.num2dbl(other) * 1000000000);</span>
<span class="fc" id="L581">        return opPlusNanos(adjustNanos);</span>
    }

    private IRubyObject opPlusNanos(long adjustNanos) {
<span class="fc" id="L585">        long currentMillis = getTimeInMillis();</span>
        
<span class="fc" id="L587">        long adjustMillis = adjustNanos/1000000;</span>
<span class="fc" id="L588">        long adjustNanosLeft = adjustNanos - (adjustMillis*1000000);</span>
        
<span class="fc" id="L590">        long newMillisPart = currentMillis + adjustMillis;</span>
<span class="fc" id="L591">        long newNanosPart = nsec + adjustNanosLeft;</span>

<span class="pc bpc" id="L593" title="1 of 2 branches missed.">        if (newNanosPart &gt;= 1000000) {</span>
<span class="nc" id="L594">            newNanosPart -= 1000000;</span>
<span class="nc" id="L595">            newMillisPart++;</span>
        }

<span class="fc" id="L598">        RubyTime newTime = new RubyTime(getRuntime(), getMetaClass());</span>
<span class="fc" id="L599">        newTime.dt = new DateTime(newMillisPart).withZone(dt.getZone());</span>
<span class="fc" id="L600">        newTime.setNSec(newNanosPart);</span>

<span class="fc" id="L602">        return newTime;</span>
    }

    private void checkOpCoercion(ThreadContext context, IRubyObject other) {
<span class="fc bfc" id="L606" title="All 2 branches covered.">        if (other instanceof RubyString) {</span>
<span class="fc" id="L607">            throw context.runtime.newTypeError(&quot;no implicit conversion to rational from string&quot;);</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">        } else if (other.isNil()) {</span>
<span class="fc" id="L609">            throw context.runtime.newTypeError(&quot;no implicit conversion to rational from nil&quot;);</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">        } else if (!other.respondsTo(&quot;to_r&quot;)){</span>
<span class="fc" id="L611">            throw context.runtime.newTypeError(&quot;can't convert &quot; + other.getMetaClass().getBaseName() + &quot; into Rational&quot;);</span>
        }
<span class="fc" id="L613">    }</span>

    private IRubyObject opMinus(RubyTime other) {
<span class="fc" id="L616">        long timeInMillis = (getTimeInMillis() - other.getTimeInMillis());</span>
<span class="fc" id="L617">        double timeInSeconds = timeInMillis/1000.0 + (getNSec() - other.getNSec())/1000000000.0;</span>
        
<span class="fc" id="L619">        return RubyFloat.newFloat(getRuntime(), timeInSeconds); // float number of seconds</span>
    }

    public IRubyObject op_minus(IRubyObject other) {
<span class="nc" id="L623">        return op_minus19(getRuntime().getCurrentContext(), other);</span>
    }

    @JRubyMethod(name = &quot;-&quot;, required = 1)
    public IRubyObject op_minus19(ThreadContext context, IRubyObject other) {
<span class="fc" id="L628">        checkOpCoercion(context, other);</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">        if (other instanceof RubyTime) return opMinus((RubyTime) other);</span>
<span class="fc" id="L630">        return opMinusCommon(other.callMethod(context, &quot;to_r&quot;));</span>
    }

    private IRubyObject opMinusCommon(IRubyObject other) {
<span class="fc" id="L634">        long adjustmentInNanos = (long)(RubyNumeric.num2dbl(other)*1000000000);</span>
<span class="fc" id="L635">        long adjustmentInMillis = adjustmentInNanos/1000000;</span>
<span class="fc" id="L636">        long adjustmentInNanosLeft = adjustmentInNanos%1000000;</span>
        
<span class="fc" id="L638">        long time = getTimeInMillis() - adjustmentInMillis;</span>
        
        long nano;
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">        if (nsec &lt; adjustmentInNanosLeft) {</span>
<span class="nc" id="L642">            time--;</span>
<span class="nc" id="L643">            nano = 1000000 - (adjustmentInNanosLeft - nsec);</span>
        } else {
<span class="fc" id="L645">            nano = nsec - adjustmentInNanosLeft;</span>
        }

<span class="fc" id="L648">        RubyTime newTime = new RubyTime(getRuntime(), getMetaClass());</span>
<span class="fc" id="L649">        newTime.dt = new DateTime(time).withZone(dt.getZone());</span>
<span class="fc" id="L650">        newTime.setNSec(nano);</span>

<span class="fc" id="L652">        return newTime;</span>
    }

    @JRubyMethod(name = &quot;===&quot;, required = 1)
    @Override
    public IRubyObject op_eqq(ThreadContext context, IRubyObject other) {
<span class="nc bnc" id="L658" title="All 2 branches missed.">        if (other instanceof RubyTime) {</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">            return context.runtime.newBoolean(RubyNumeric.fix2int(invokedynamic(context, this, OP_CMP, other)) == 0);</span>
        }

<span class="nc" id="L662">        return context.getRuntime().getFalse();</span>
    }

    @JRubyMethod(name = &quot;&lt;=&gt;&quot;, required = 1)
    @Override
    public IRubyObject op_cmp(ThreadContext context, IRubyObject other) {
<span class="fc bfc" id="L668" title="All 2 branches covered.">        if (other instanceof RubyTime) {</span>
<span class="fc" id="L669">            return context.runtime.newFixnum(cmp((RubyTime) other));</span>
        }
        
<span class="fc" id="L672">        return invcmp(context, this, other);</span>
    }

    @JRubyMethod(name = &quot;eql?&quot;, required = 1)
    @Override
    public IRubyObject eql_p(IRubyObject other) {
<span class="fc bfc" id="L678" title="All 2 branches covered.">        if (other instanceof RubyTime) {</span>
<span class="fc" id="L679">            RubyTime otherTime = (RubyTime)other; </span>
<span class="fc bfc" id="L680" title="All 4 branches covered.">            return (nsec == otherTime.nsec &amp;&amp; getTimeInMillis() == otherTime.getTimeInMillis()) ? getRuntime().getTrue() : getRuntime().getFalse();</span>
        }
<span class="fc" id="L682">        return getRuntime().getFalse();</span>
    }

    @JRubyMethod(name = {&quot;asctime&quot;, &quot;ctime&quot;})
    public RubyString asctime() {
        DateTimeFormatter simpleDateFormat;

<span class="fc bfc" id="L689" title="All 2 branches covered.">        if (dt.getDayOfMonth() &lt; 10) {</span>
<span class="fc" id="L690">            simpleDateFormat = ONE_DAY_CTIME_FORMATTER;</span>
        } else {
<span class="fc" id="L692">            simpleDateFormat = TWO_DAY_CTIME_FORMATTER;</span>
        }
<span class="fc" id="L694">        String result = simpleDateFormat.print(dt);</span>
<span class="fc" id="L695">        return RubyString.newString(getRuntime(), result, USASCIIEncoding.INSTANCE);</span>
    }

    @Override
    public IRubyObject to_s() {
<span class="fc" id="L700">        return to_s19();</span>
    }

    @JRubyMethod(name = {&quot;to_s&quot;, &quot;inspect&quot;})
    public IRubyObject to_s19() {
<span class="fc" id="L705">        return inspectCommon(TO_S_FORMATTER_19, TO_S_UTC_FORMATTER_19);</span>
    }

    private IRubyObject inspectCommon(DateTimeFormatter formatter, DateTimeFormatter utcFormatter) {
        DateTimeFormatter simpleDateFormat;
<span class="fc bfc" id="L710" title="All 2 branches covered.">        if (dt.getZone() == DateTimeZone.UTC) {</span>
<span class="fc" id="L711">            simpleDateFormat = utcFormatter;</span>
        } else {
<span class="fc" id="L713">            simpleDateFormat = formatter;</span>
        }

<span class="fc" id="L716">        String result = simpleDateFormat.print(dt);</span>

<span class="pc bpc" id="L718" title="1 of 2 branches missed.">        if (isTzRelative) {</span>
            // display format needs to invert the UTC offset if this object was
            // created with a specific offset in the 7-arg form of #new
<span class="nc" id="L721">            DateTimeZone dtz = dt.getZone();</span>
<span class="nc" id="L722">            int offset = dtz.toTimeZone().getOffset(dt.getMillis());</span>
<span class="nc" id="L723">            DateTimeZone invertedDTZ = DateTimeZone.forOffsetMillis(offset);</span>
<span class="nc" id="L724">            DateTime invertedDT = dt.withZone(invertedDTZ);</span>
<span class="nc" id="L725">            result = simpleDateFormat.print(invertedDT);</span>
        }

<span class="fc" id="L728">        return RubyString.newString(getRuntime(), result, USASCIIEncoding.INSTANCE);</span>
    }

    @JRubyMethod
    @Override
    public RubyArray to_a() {
<span class="fc" id="L734">        return getRuntime().newArrayNoCopy(new IRubyObject[] { sec(), min(), hour(), mday(), month(), </span>
<span class="fc" id="L735">                year(), wday(), yday(), isdst(), zone() });</span>
    }

    @JRubyMethod
    public RubyFloat to_f() {
<span class="fc" id="L740">        long millis = getTimeInMillis();</span>
<span class="fc" id="L741">        long nanos = nsec;</span>
<span class="fc" id="L742">        double secs = 0;</span>
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">        if (millis != 0) secs += (millis / 1000.0);</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">        if (nanos != 0) secs += (nanos / 1000000000.0);</span>
<span class="fc" id="L745">        return RubyFloat.newFloat(getRuntime(), secs);</span>
    }

    @JRubyMethod(name = {&quot;to_i&quot;, &quot;tv_sec&quot;})
    public RubyInteger to_i() {
<span class="fc" id="L750">        return getRuntime().newFixnum(getTimeInMillis() / 1000);</span>
    }

    @JRubyMethod(name = {&quot;nsec&quot;, &quot;tv_nsec&quot;})
    public RubyInteger nsec() {
<span class="fc" id="L755">        return getRuntime().newFixnum((getTimeInMillis() % 1000) * 1000000 + nsec);</span>
    }

    @JRubyMethod
    public IRubyObject to_r(ThreadContext context) {
<span class="nc" id="L760">        IRubyObject rational = to_f().to_r(context);</span>
<span class="nc" id="L761">        return rational;</span>
    }

    @JRubyMethod(name = {&quot;usec&quot;, &quot;tv_usec&quot;})
    public RubyInteger usec() {
<span class="fc" id="L766">        return getRuntime().newFixnum(dt.getMillisOfSecond() * 1000 + getUSec());</span>
    }

    public void setMicroseconds(long mic) {
<span class="nc" id="L770">        long millis = getTimeInMillis() % 1000;</span>
<span class="nc" id="L771">        long withoutMillis = getTimeInMillis() - millis;</span>
<span class="nc" id="L772">        withoutMillis += (mic / 1000);</span>
<span class="nc" id="L773">        dt = dt.withMillis(withoutMillis);</span>
<span class="nc" id="L774">        nsec = (mic % 1000) * 1000;</span>
<span class="nc" id="L775">    }</span>
    
    public long microseconds() {
<span class="fc" id="L778">    	return getTimeInMillis() % 1000 * 1000 + getUSec();</span>
    }

    @JRubyMethod
    public RubyInteger sec() {
<span class="fc" id="L783">        return getRuntime().newFixnum(dt.getSecondOfMinute());</span>
    }

    @JRubyMethod
    public RubyInteger min() {
<span class="fc" id="L788">        return getRuntime().newFixnum(dt.getMinuteOfHour());</span>
    }

    @JRubyMethod
    public RubyInteger hour() {
<span class="fc" id="L793">        return getRuntime().newFixnum(dt.getHourOfDay());</span>
    }

    @JRubyMethod(name = {&quot;mday&quot;, &quot;day&quot;})
    public RubyInteger mday() {
<span class="fc" id="L798">        return getRuntime().newFixnum(dt.getDayOfMonth());</span>
    }

    @JRubyMethod(name = {&quot;month&quot;, &quot;mon&quot;})
    public RubyInteger month() {
<span class="fc" id="L803">        return getRuntime().newFixnum(dt.getMonthOfYear());</span>
    }

    @JRubyMethod
    public RubyInteger year() {
<span class="fc" id="L808">        return getRuntime().newFixnum(dt.getYear());</span>
    }

    @JRubyMethod
    public RubyInteger wday() {
<span class="fc" id="L813">        return getRuntime().newFixnum((dt.getDayOfWeek()%7));</span>
    }

    @JRubyMethod
    public RubyInteger yday() {
<span class="fc" id="L818">        return getRuntime().newFixnum(dt.getDayOfYear());</span>
    }

    @JRubyMethod
    public IRubyObject subsec() {
<span class="fc" id="L823">        Ruby runtime = getRuntime();</span>
<span class="fc" id="L824">        long nanosec = dt.getMillisOfSecond() * 1000000 + this.nsec;</span>

<span class="fc bfc" id="L826" title="All 2 branches covered.">        if (nanosec % 1000000000 == 0) return RubyFixnum.zero(runtime);</span>

<span class="fc" id="L828">        return runtime.newRationalReduced(</span>
                nanosec, 1000000000);
    }

    @JRubyMethod(name = {&quot;gmt_offset&quot;, &quot;gmtoff&quot;, &quot;utc_offset&quot;})
    public RubyInteger gmt_offset() {
<span class="fc" id="L834">        int offset = dt.getZone().getOffset(dt.getMillis());</span>
<span class="fc" id="L835">        return getRuntime().newFixnum(offset/1000);</span>
    }

    @JRubyMethod(name = {&quot;isdst&quot;, &quot;dst?&quot;})
    public RubyBoolean isdst() {
<span class="fc bfc" id="L840" title="All 2 branches covered.">        return getRuntime().newBoolean(!dt.getZone().isStandardOffset(dt.getMillis()));</span>
    }

    @JRubyMethod
    public IRubyObject zone() {
<span class="fc" id="L845">        Ruby runtime = getRuntime();</span>
<span class="fc bfc" id="L846" title="All 2 branches covered.">        if (isTzRelative) return runtime.getNil();</span>
        
<span class="fc" id="L848">        String envTZ = getEnvTimeZone(runtime).toString();</span>
        // see declaration of SHORT_TZNAME
<span class="pc bpc" id="L850" title="3 of 4 branches missed.">        if (SHORT_STD_TZNAME.containsKey(envTZ) &amp;&amp; ! dt.getZone().toTimeZone().inDaylightTime(dt.toDate())) {</span>
<span class="nc" id="L851">            return runtime.newString(SHORT_STD_TZNAME.get(envTZ));</span>
        }
        
<span class="pc bpc" id="L854" title="3 of 4 branches missed.">        if (SHORT_DL_TZNAME.containsKey(envTZ) &amp;&amp; dt.getZone().toTimeZone().inDaylightTime(dt.toDate())) {</span>
<span class="nc" id="L855">            return runtime.newString(SHORT_DL_TZNAME.get(envTZ));</span>
        }
        
<span class="fc" id="L858">        String zone = dt.getZone().getShortName(dt.getMillis());</span>
        
<span class="fc" id="L860">        Matcher offsetMatcher = TIME_OFFSET_PATTERN.matcher(zone);</span>
        
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">        if (offsetMatcher.matches()) {</span>
<span class="nc" id="L863">            boolean minus_p = offsetMatcher.group(1).toString().equals(&quot;-&quot;);</span>
<span class="nc" id="L864">            int hourOffset  = Integer.valueOf(offsetMatcher.group(2));</span>
                        
<span class="nc bnc" id="L866" title="All 2 branches missed.">            if (zone.equals(&quot;+00:00&quot;)) {</span>
<span class="nc" id="L867">                zone = &quot;GMT&quot;;</span>
            } else {
                // try non-localized time zone name
<span class="nc" id="L870">                zone = dt.getZone().getNameKey(dt.getMillis());</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">                if (zone == null) {</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">                    char sign = minus_p ? '+' : '-';</span>
<span class="nc" id="L873">                    zone = &quot;GMT&quot; + sign + hourOffset;</span>
                }
            }
        }
        
<span class="fc" id="L878">        return runtime.newString(zone);</span>
    }

    public void setDateTime(DateTime dt) {
<span class="fc" id="L882">        this.dt = dt;</span>
<span class="fc" id="L883">    }</span>

    public DateTime getDateTime() {
<span class="nc" id="L886">        return this.dt;</span>
    }

    public Date getJavaDate() {
<span class="nc" id="L890">        return this.dt.toDate();</span>
    }

    @JRubyMethod
    @Override
    public RubyFixnum hash() {
    	// modified to match how hash is calculated in 1.8.2
<span class="fc" id="L897">        return getRuntime().newFixnum((int)(((dt.getMillis() / 1000) ^ microseconds()) &lt;&lt; 1) &gt;&gt; 1);</span>
    }    

    @JRubyMethod(name = &quot;_dump&quot;, optional = 1)
    public RubyString dump(IRubyObject[] args, Block unusedBlock) {
<span class="fc" id="L902">        RubyString str = (RubyString) mdump();</span>
<span class="fc" id="L903">        str.syncVariables(this);</span>
<span class="fc" id="L904">        return str;</span>
    }    

    public RubyObject mdump() {
<span class="fc" id="L908">        Ruby runtime = getRuntime();</span>
<span class="fc" id="L909">        RubyTime obj = this;</span>
<span class="fc" id="L910">        DateTime dateTime = obj.dt.toDateTime(DateTimeZone.UTC);</span>
<span class="fc" id="L911">        byte dumpValue[] = new byte[8];</span>
<span class="fc" id="L912">        long nanos = this.nsec;</span>
<span class="fc" id="L913">        long usec = this.nsec / 1000;</span>
<span class="fc" id="L914">        long nanosec = this.nsec % 1000;</span>
        
<span class="fc" id="L916">        int pe = </span>
            0x1                                 &lt;&lt; 31 |
<span class="fc bfc" id="L918" title="All 2 branches covered.">            ((obj.gmt().isTrue())? 0x1 : 0x0)   &lt;&lt; 30 |</span>
<span class="fc" id="L919">            (dateTime.getYear()-1900)           &lt;&lt; 14 |</span>
<span class="fc" id="L920">            (dateTime.getMonthOfYear()-1)       &lt;&lt; 10 |</span>
<span class="fc" id="L921">            dateTime.getDayOfMonth()            &lt;&lt; 5  |</span>
<span class="fc" id="L922">            dateTime.getHourOfDay();</span>
<span class="fc" id="L923">        int se =</span>
<span class="fc" id="L924">            dateTime.getMinuteOfHour()          &lt;&lt; 26 |</span>
<span class="fc" id="L925">            dateTime.getSecondOfMinute()        &lt;&lt; 20 |</span>
<span class="fc" id="L926">            (dateTime.getMillisOfSecond() * 1000 + (int)usec); // dump usec, not msec</span>

<span class="fc bfc" id="L928" title="All 2 branches covered.">        for(int i = 0; i &lt; 4; i++) {</span>
<span class="fc" id="L929">            dumpValue[i] = (byte)(pe &amp; 0xFF);</span>
<span class="fc" id="L930">            pe &gt;&gt;&gt;= 8;</span>
        }
<span class="fc bfc" id="L932" title="All 2 branches covered.">        for(int i = 4; i &lt; 8 ;i++) {</span>
<span class="fc" id="L933">            dumpValue[i] = (byte)(se &amp; 0xFF);</span>
<span class="fc" id="L934">            se &gt;&gt;&gt;= 8;</span>
        }

<span class="fc" id="L937">        RubyString string = RubyString.newString(obj.getRuntime(), new ByteList(dumpValue));</span>

        // 1.9 includes more nsecs
<span class="fc" id="L940">        copyInstanceVariablesInto(string);</span>

        // nanos in numerator/denominator form
<span class="pc bpc" id="L943" title="1 of 2 branches missed.">        if (nanosec != 0) {</span>
<span class="nc" id="L944">            string.setInternalVariable(&quot;nano_num&quot;, runtime.newFixnum(nanosec));</span>
<span class="nc" id="L945">            string.setInternalVariable(&quot;nano_den&quot;, runtime.newFixnum(1));</span>
        }

        // submicro for 1.9.1 compat
<span class="fc" id="L949">        byte[] submicro = new byte[2];</span>
<span class="fc" id="L950">        int len = 2;</span>
<span class="fc" id="L951">        submicro[1] = (byte)((nanosec % 10) &lt;&lt; 4);</span>
<span class="fc" id="L952">        nanosec /= 10;</span>
<span class="fc" id="L953">        submicro[0] = (byte)(nanosec % 10);</span>
<span class="fc" id="L954">        nanosec /= 10;</span>
<span class="fc" id="L955">        submicro[0] |= (byte)((nanosec % 10) &lt;&lt; 4);</span>
<span class="pc bpc" id="L956" title="1 of 2 branches missed.">        if (submicro[1] == 0) len = 1;</span>
<span class="fc" id="L957">        string.setInternalVariable(&quot;submicro&quot;, RubyString.newString(runtime, submicro, 0, len));</span>

        // time zone
<span class="fc bfc" id="L960" title="All 2 branches covered.">        if (dt.getZone() != DateTimeZone.UTC) {</span>
<span class="fc" id="L961">            long offset = dt.getZone().getOffset(dt.getMillis());</span>
<span class="fc" id="L962">            string.setInternalVariable(&quot;offset&quot;, runtime.newFixnum(offset / 1000));</span>

<span class="fc" id="L964">            String zone = dt.getZone().getShortName(dt.getMillis());</span>
<span class="pc bpc" id="L965" title="1 of 2 branches missed.">            if (!TIME_OFFSET_PATTERN.matcher(zone).matches()) {</span>
<span class="fc" id="L966">                string.setInternalVariable(&quot;zone&quot;, runtime.newString(zone));</span>
            }
        }

<span class="fc" id="L970">        return string;</span>
    }

    @JRubyMethod(visibility = PRIVATE)
    public IRubyObject initialize(Block block) {
<span class="fc" id="L975">        return this;</span>
    }
    
    @JRubyMethod(optional = 1)
    public RubyTime round(ThreadContext context, IRubyObject[] args) {
<span class="fc bfc" id="L980" title="All 2 branches covered.">        int ndigits = args.length == 0 ? 0 : RubyNumeric.num2int(args[0]);</span>
        // There are only 1_000_000_000 nanoseconds in 1 second,
        // so there is no need to keep more than 9 digits
<span class="pc bpc" id="L983" title="1 of 2 branches missed.">        if (ndigits &gt; 9) {</span>
<span class="nc" id="L984">            ndigits = 9;</span>
<span class="pc bpc" id="L985" title="1 of 2 branches missed.">        } else if (ndigits &lt; 0) {</span>
<span class="nc" id="L986">            throw context.getRuntime().newArgumentError(&quot;negative ndigits given&quot;);</span>
        }

<span class="fc" id="L989">        int _nsec = this.dt.getMillisOfSecond() * 1000000 + (int) (this.nsec);</span>
<span class="fc" id="L990">        int pow = (int) Math.pow(10, 9 - ndigits);</span>
<span class="fc" id="L991">        int rounded = ((_nsec + pow/2) / pow) * pow;</span>
<span class="fc" id="L992">        DateTime _dt = this.dt.withMillisOfSecond(0).plusMillis(rounded / 1000000);</span>
<span class="fc" id="L993">        return newTime(context.runtime, _dt, rounded % 1000000);</span>
    }

   /* Time class methods */
    
    public static IRubyObject s_new(IRubyObject recv, IRubyObject[] args, Block block) {
<span class="nc" id="L999">        Ruby runtime = recv.getRuntime();</span>
<span class="nc" id="L1000">        RubyTime time = new RubyTime(runtime, (RubyClass) recv, new DateTime(getLocalTimeZone(runtime)));</span>
<span class="nc" id="L1001">        time.callInit(args,block);</span>
<span class="nc" id="L1002">        return time;</span>
    }

    /**
     * @deprecated Use {@link #newInstance(ThreadContext, IRubyObject)}
     */
    @Deprecated
    public static IRubyObject newInstance(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="nc" id="L1010">        return newInstance(context, recv);</span>
    }

    @JRubyMethod(name = &quot;now&quot;, meta = true)
    public static IRubyObject newInstance(ThreadContext context, IRubyObject recv) {
<span class="fc" id="L1015">        IRubyObject obj = ((RubyClass) recv).allocate();</span>
<span class="fc" id="L1016">        obj.getMetaClass().getBaseCallSite(RubyClass.CS_IDX_INITIALIZE).call(context, recv, obj);</span>
<span class="fc" id="L1017">        return obj;</span>
    }

    @JRubyMethod(meta = true)
    public static IRubyObject at(ThreadContext context, IRubyObject recv, IRubyObject arg) {
<span class="fc" id="L1022">        Ruby runtime = context.runtime;</span>
        final RubyTime time;

<span class="fc bfc" id="L1025" title="All 2 branches covered.">        if (arg instanceof RubyTime) {</span>
<span class="fc" id="L1026">            RubyTime other = (RubyTime) arg;</span>
<span class="fc" id="L1027">            time = new RubyTime(runtime, (RubyClass) recv, other.dt);</span>
<span class="fc" id="L1028">            time.setNSec(other.getNSec());</span>
<span class="fc" id="L1029">        } else {</span>
<span class="fc" id="L1030">            time = new RubyTime(runtime, (RubyClass) recv,</span>
<span class="fc" id="L1031">                    new DateTime(0L, getLocalTimeZone(runtime)));</span>

<span class="fc" id="L1033">            long seconds = RubyNumeric.num2long(arg);</span>
<span class="fc" id="L1034">            long millisecs = 0;</span>
<span class="fc" id="L1035">            long nanosecs = 0;</span>

            // In the case of two arguments, MRI will discard the portion of
            // the first argument after a decimal point (i.e., &quot;floor&quot;).
            // However in the case of a single argument, any portion after
            // the decimal point is honored.
<span class="fc bfc" id="L1041" title="All 4 branches covered.">            if (arg instanceof RubyFloat || arg instanceof RubyRational) {</span>
<span class="fc" id="L1042">                double dbl = RubyNumeric.num2dbl(arg);</span>
                long nano;

<span class="fc" id="L1045">                nano = Math.round((dbl - seconds) * 1000000000);</span>

<span class="pc bpc" id="L1047" title="3 of 4 branches missed.">                if (dbl &lt; 0 &amp;&amp; nano != 0) {</span>
<span class="nc" id="L1048">                    nano += 1000000000;</span>
                }
<span class="fc" id="L1050">                millisecs = nano / 1000000;</span>
<span class="fc" id="L1051">                nanosecs = nano % 1000000;</span>
            }
<span class="fc" id="L1053">            time.setNSec(nanosecs);</span>
	    try {
<span class="fc" id="L1055">		time.dt = time.dt.withMillis(seconds * 1000 + millisecs);</span>
	    }
	    // joda-time 2.5 can throw this exception - seen locally
<span class="nc" id="L1058">	    catch(ArithmeticException e1) {</span>
<span class="nc" id="L1059">		throw runtime.newRangeError(e1.getMessage());</span>
	    }
	    // joda-time 2.5 can throw this exception - seen on travis
<span class="nc" id="L1062">	    catch(IllegalFieldValueException e2) {</span>
<span class="nc" id="L1063">		throw runtime.newRangeError(e2.getMessage());</span>
<span class="fc" id="L1064">	    }</span>
        }

<span class="fc" id="L1067">        time.getMetaClass().getBaseCallSite(RubyClass.CS_IDX_INITIALIZE).call(context, recv, time);</span>

<span class="fc" id="L1069">        return time;</span>
    }

    @JRubyMethod(meta = true)
    public static IRubyObject at(ThreadContext context, IRubyObject recv, IRubyObject arg1, IRubyObject arg2) {
<span class="fc" id="L1074">        Ruby runtime = context.runtime;</span>

<span class="fc" id="L1076">        RubyTime time = new RubyTime(runtime, (RubyClass) recv, new DateTime(0L, getLocalTimeZone(runtime)));</span>
        long millisecs;
<span class="fc" id="L1078">        long nanosecs = 0;</span>

<span class="pc bpc" id="L1080" title="2 of 4 branches missed.">        if (arg1 instanceof RubyFloat || arg1 instanceof RubyRational) {</span>
<span class="nc" id="L1081">            double dbl = RubyNumeric.num2dbl(arg1);</span>
<span class="nc" id="L1082">            millisecs = (long) (dbl * 1000);</span>
<span class="nc" id="L1083">            nanosecs = ((long) (dbl * 1000000000)) % 1000000;</span>
<span class="nc" id="L1084">        } else {</span>
<span class="fc" id="L1085">            millisecs = RubyNumeric.num2long(arg1) * 1000;</span>
        }

<span class="fc bfc" id="L1088" title="All 4 branches covered.">        if (arg2 instanceof RubyFloat || arg2 instanceof RubyRational) {</span>
<span class="fc" id="L1089">            double micros = RubyNumeric.num2dbl(arg2);</span>
<span class="fc" id="L1090">            double nanos = micros * 1000;</span>
<span class="fc" id="L1091">            millisecs += (long) (nanos / 1000000);</span>
<span class="fc" id="L1092">            nanosecs += (long) (nanos % 1000000);</span>
<span class="fc" id="L1093">        } else {</span>
<span class="fc" id="L1094">            long micros = RubyNumeric.num2long(arg2);</span>
<span class="fc" id="L1095">            long nanos = micros * 1000;</span>
<span class="fc" id="L1096">            millisecs += nanos / 1000000;</span>
<span class="fc" id="L1097">            nanosecs += nanos % 1000000;</span>
        }

<span class="fc" id="L1100">        long nanosecOverflow = (nanosecs / 1000000);</span>

<span class="fc" id="L1102">        time.setNSec(nanosecs % 1000000);</span>
<span class="fc" id="L1103">        time.dt = time.dt.withMillis(millisecs + nanosecOverflow);</span>

<span class="fc" id="L1105">        time.getMetaClass().getBaseCallSite(RubyClass.CS_IDX_INITIALIZE).call(context, recv, time);</span>

<span class="fc" id="L1107">        return time;</span>
    }

    @JRubyMethod(name = {&quot;local&quot;, &quot;mktime&quot;}, required = 1, optional = 9, meta = true)
    public static RubyTime new_local(IRubyObject recv, IRubyObject[] args) {
<span class="fc" id="L1112">        return createTime(recv, args, false, false);</span>
    }

    @JRubyMethod(name = &quot;new&quot;, optional = 7, meta = true)
    public static IRubyObject new19(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="fc bfc" id="L1117" title="All 2 branches covered.">        if (args.length == 0) return newInstance(context, recv);</span>

<span class="fc bfc" id="L1119" title="All 2 branches covered.">        if (args.length == 7) {</span>
<span class="fc" id="L1120">          Ruby runtime = context.getRuntime();</span>

          // 7th argument can be the symbol :dst instead of an offset, so needs to be special cased
<span class="fc" id="L1123">          final RubySymbol dstSymbol = RubySymbol.newSymbol(runtime, &quot;dst&quot;);</span>
<span class="fc" id="L1124">          boolean receivedDstSymbolAsArgument = (args[6].op_equal(context, dstSymbol)).isTrue();</span>

<span class="fc" id="L1126">          final RubyBoolean isDst = RubyBoolean.newBoolean(runtime, receivedDstSymbolAsArgument);</span>

          // Convert the 7-argument form of Time.new into the 10-argument form of Time.local:
<span class="fc" id="L1129">          args = new IRubyObject[] { args[5],          // seconds</span>
                                     args[4],          // minutes
                                     args[3],          // hours
                                     args[2],          // day
                                     args[1],          // month
                                     args[0],          // year
<span class="fc" id="L1135">                                     runtime.getNil(), // weekday</span>
<span class="fc" id="L1136">                                     runtime.getNil(), // day of year</span>
                                     isDst,            // is DST?
                                     args[6] };        // UTC offset
        }
<span class="fc" id="L1140">        return createTime(recv, args, false, true);</span>
    }

    @JRubyMethod(name = {&quot;utc&quot;, &quot;gm&quot;}, required = 1, optional = 9, meta = true)
    public static RubyTime new_utc(IRubyObject recv, IRubyObject[] args) {
<span class="fc" id="L1145">        return createTime(recv, args, true, false);</span>
    }

    @JRubyMethod(name = &quot;_load&quot;, meta = true)
    public static RubyTime load(IRubyObject recv, IRubyObject from, Block block) {
<span class="fc" id="L1150">        return s_mload(recv, (RubyTime)(((RubyClass)recv).allocate()), from);</span>
    }

    @Override
    public Object toJava(Class target) {
<span class="nc bnc" id="L1155" title="All 2 branches missed.">        if (target.equals(Date.class)) {</span>
<span class="nc" id="L1156">            return getJavaDate();</span>
<span class="nc bnc" id="L1157" title="All 2 branches missed.">        } else if (target.equals(Calendar.class)) {</span>
<span class="nc" id="L1158">            Calendar cal = GregorianCalendar.getInstance();</span>
<span class="nc" id="L1159">            cal.setTime(getJavaDate());</span>
<span class="nc" id="L1160">            return cal;</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">        } else if (target.equals(DateTime.class)) {</span>
<span class="nc" id="L1162">            return this.dt;</span>
<span class="nc bnc" id="L1163" title="All 2 branches missed.">        } else if (target.equals(java.sql.Date.class)) {</span>
<span class="nc" id="L1164">            return new java.sql.Date(dt.getMillis());</span>
<span class="nc bnc" id="L1165" title="All 2 branches missed.">        } else if (target.equals(java.sql.Time.class)) {</span>
<span class="nc" id="L1166">            return new java.sql.Time(dt.getMillis());</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">        } else if (target.equals(java.sql.Timestamp.class)) {</span>
<span class="nc" id="L1168">            return new java.sql.Timestamp(dt.getMillis());</span>
<span class="nc bnc" id="L1169" title="All 2 branches missed.">        } else if (target.isAssignableFrom(Date.class)) {</span>
<span class="nc" id="L1170">            return getJavaDate();</span>
        } else {
<span class="nc" id="L1172">            return super.toJava(target);</span>
        }
    }
    
    protected static RubyTime s_mload(IRubyObject recv, RubyTime time, IRubyObject from) {
<span class="fc" id="L1177">        Ruby runtime = recv.getRuntime();</span>

<span class="fc" id="L1179">        DateTime dt = new DateTime(DateTimeZone.UTC);</span>

        byte[] fromAsBytes;
<span class="fc" id="L1182">        fromAsBytes = from.convertToString().getBytes();</span>
<span class="pc bpc" id="L1183" title="1 of 2 branches missed.">        if(fromAsBytes.length != 8) {</span>
<span class="nc" id="L1184">            throw runtime.newTypeError(&quot;marshaled time format differ&quot;);</span>
        }
<span class="fc" id="L1186">        int p=0;</span>
<span class="fc" id="L1187">        int s=0;</span>
<span class="fc bfc" id="L1188" title="All 2 branches covered.">        for (int i = 0; i &lt; 4; i++) {</span>
<span class="fc" id="L1189">            p |= ((int)fromAsBytes[i] &amp; 0xFF) &lt;&lt; (8 * i);</span>
        }
<span class="fc bfc" id="L1191" title="All 2 branches covered.">        for (int i = 4; i &lt; 8; i++) {</span>
<span class="fc" id="L1192">            s |= ((int)fromAsBytes[i] &amp; 0xFF) &lt;&lt; (8 * (i - 4));</span>
        }
<span class="fc" id="L1194">        boolean utc = false;</span>
<span class="fc bfc" id="L1195" title="All 2 branches covered.">        if ((p &amp; (1&lt;&lt;31)) == 0) {</span>
<span class="fc" id="L1196">            dt = dt.withMillis(p * 1000L);</span>
<span class="fc" id="L1197">            time.setUSec((s &amp; 0xFFFFF) % 1000);</span>
        } else {
<span class="fc" id="L1199">            p &amp;= ~(1&lt;&lt;31);</span>
<span class="fc bfc" id="L1200" title="All 2 branches covered.">            utc = ((p &gt;&gt;&gt; 30 &amp; 0x1) == 0x1);</span>
<span class="fc" id="L1201">            dt = dt.withYear(((p &gt;&gt;&gt; 14) &amp; 0xFFFF) + 1900);</span>
<span class="fc" id="L1202">            dt = dt.withMonthOfYear(((p &gt;&gt;&gt; 10) &amp; 0xF) + 1);</span>
<span class="fc" id="L1203">            dt = dt.withDayOfMonth(((p &gt;&gt;&gt; 5)  &amp; 0x1F));</span>
<span class="fc" id="L1204">            dt = dt.withHourOfDay((p &amp; 0x1F));</span>
<span class="fc" id="L1205">            dt = dt.withMinuteOfHour(((s &gt;&gt;&gt; 26) &amp; 0x3F));</span>
<span class="fc" id="L1206">            dt = dt.withSecondOfMinute(((s &gt;&gt;&gt; 20) &amp; 0x3F));</span>
            // marsaling dumps usec, not msec
<span class="fc" id="L1208">            dt = dt.withMillisOfSecond((s &amp; 0xFFFFF) / 1000);</span>
<span class="fc" id="L1209">            time.setUSec((s &amp; 0xFFFFF) % 1000);</span>
        }
<span class="fc" id="L1211">        time.setDateTime(dt);</span>
<span class="fc bfc" id="L1212" title="All 2 branches covered.">        if (!utc) time.localtime();</span>

<span class="fc" id="L1214">        from.getInstanceVariables().copyInstanceVariablesInto(time);</span>

        // pull out nanos, offset, zone
<span class="fc" id="L1217">        IRubyObject nano_num = (IRubyObject) from.getInternalVariables().getInternalVariable(&quot;nano_num&quot;);</span>
<span class="fc" id="L1218">        IRubyObject nano_den = (IRubyObject) from.getInternalVariables().getInternalVariable(&quot;nano_den&quot;);</span>
<span class="fc" id="L1219">        IRubyObject offsetVar = (IRubyObject) from.getInternalVariables().getInternalVariable(&quot;offset&quot;);</span>
<span class="fc" id="L1220">        IRubyObject zoneVar = (IRubyObject) from.getInternalVariables().getInternalVariable(&quot;zone&quot;);</span>

<span class="pc bpc" id="L1222" title="3 of 4 branches missed.">        if (nano_num != null &amp;&amp; nano_den != null) {</span>
<span class="nc" id="L1223">            long nanos = nano_num.convertToInteger().getLongValue() / nano_den.convertToInteger().getLongValue();</span>
<span class="nc" id="L1224">            time.nsec += nanos;</span>
        }

<span class="fc" id="L1227">        int offset = 0;</span>
<span class="pc bpc" id="L1228" title="1 of 4 branches missed.">        if (offsetVar != null &amp;&amp; offsetVar.respondsTo(&quot;to_int&quot;)) {</span>
            try {
<span class="fc" id="L1230">                offset = offsetVar.convertToInteger().getIntValue() * 1000;</span>
<span class="nc" id="L1231">            } catch (RaiseException typeError) {</span>
<span class="fc" id="L1232">            }</span>
        }

<span class="fc" id="L1235">        String zone = &quot;&quot;;</span>
<span class="pc bpc" id="L1236" title="1 of 4 branches missed.">        if (zoneVar != null &amp;&amp; zoneVar.respondsTo(&quot;to_str&quot;)) {</span>
            try {
<span class="fc" id="L1238">                zone = zoneVar.convertToString().toString();</span>
<span class="nc" id="L1239">            } catch (RaiseException typeError) {</span>
<span class="fc" id="L1240">            }</span>
        }

<span class="fc" id="L1243">        time.dt = dt.withZone(getTimeZoneWithOffset(runtime, zone, offset));</span>
<span class="fc" id="L1244">        return time;</span>
    }

<span class="fc" id="L1247">    private static final String[] MONTHS = {&quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;,</span>
                                            &quot;jul&quot;, &quot;aug&quot;, &quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;};

<span class="fc" id="L1250">    private static final Map&lt;String, Integer&gt; MONTHS_MAP = new HashMap&lt;String, Integer&gt;();</span>
    static {
<span class="fc bfc" id="L1252" title="All 2 branches covered.">        for (int i = 0; i &lt; MONTHS.length; i++) {</span>
<span class="fc" id="L1253">            MONTHS_MAP.put(MONTHS[i], i + 1);</span>
        }
<span class="fc" id="L1255">    }</span>

    private static final int ARG_SIZE = 7;

    private static RubyTime createTime(IRubyObject recv, IRubyObject[] args, boolean gmt, boolean utcOffset) {
<span class="fc" id="L1260">        Ruby runtime = recv.getRuntime();</span>
<span class="fc" id="L1261">        int len = ARG_SIZE;</span>
<span class="fc" id="L1262">        boolean isDst = false;</span>
<span class="fc" id="L1263">        boolean setTzRelative = false; </span>
<span class="fc" id="L1264">        long nanos = 0;</span>

        DateTimeZone dtz;
<span class="fc bfc" id="L1267" title="All 2 branches covered.">        if (gmt) {</span>
<span class="fc" id="L1268">            dtz = DateTimeZone.UTC;</span>
<span class="fc bfc" id="L1269" title="All 4 branches covered.">        } else if (args.length == 10 &amp;&amp; args[9] instanceof RubyString) {</span>
<span class="pc bpc" id="L1270" title="1 of 2 branches missed.">            if (utcOffset) {</span>
<span class="fc" id="L1271">                dtz = getTimeZoneFromUtcOffset(runtime, args[9]);</span>
<span class="fc" id="L1272">                setTzRelative = true;</span>
            } else {
<span class="nc" id="L1274">                dtz = getTimeZoneFromString(runtime, args[9].toString());</span>
            }
<span class="fc bfc" id="L1276" title="All 4 branches covered.">        } else if (args.length == 10 &amp;&amp; args[9].respondsTo(&quot;to_int&quot;)) {</span>
<span class="fc" id="L1277">            IRubyObject offsetInt = args[9].callMethod(runtime.getCurrentContext(), &quot;to_int&quot;);</span>
<span class="fc" id="L1278">            dtz = getTimeZone(runtime, ((RubyNumeric) offsetInt).getLongValue());</span>
<span class="fc" id="L1279">        } else {</span>
<span class="fc" id="L1280">            dtz = getLocalTimeZone(runtime);</span>
        }
 
<span class="fc bfc" id="L1283" title="All 2 branches covered.">        if (args.length == 10) {</span>
<span class="fc bfc" id="L1284" title="All 2 branches covered.">            if (args[8] instanceof RubyBoolean) isDst = args[8].isTrue();</span>

<span class="fc" id="L1286">            args = new IRubyObject[] { args[5], args[4], args[3], args[2], args[1], args[0], runtime.getNil() };</span>
        } else {
            // MRI accepts additional wday argument which appears to be ignored.
<span class="fc" id="L1289">            len = args.length;</span>

<span class="fc bfc" id="L1291" title="All 2 branches covered.">            if (len &lt; ARG_SIZE) {</span>
<span class="fc" id="L1292">                IRubyObject[] newArgs = new IRubyObject[ARG_SIZE];</span>
<span class="fc" id="L1293">                System.arraycopy(args, 0, newArgs, 0, args.length);</span>
<span class="fc bfc" id="L1294" title="All 2 branches covered.">                for (int i = len; i &lt; ARG_SIZE; i++) {</span>
<span class="fc" id="L1295">                    newArgs[i] = runtime.getNil();</span>
                }
<span class="fc" id="L1297">                args = newArgs;</span>
<span class="fc" id="L1298">                len = ARG_SIZE;</span>
            }
        }

<span class="fc bfc" id="L1302" title="All 2 branches covered.">        if (args[0] instanceof RubyString) {</span>
<span class="fc" id="L1303">            args[0] = RubyNumeric.str2inum(runtime, (RubyString) args[0], 10, false);</span>
        }

<span class="fc" id="L1306">        int year = (int) RubyNumeric.num2long(args[0]);</span>
<span class="fc" id="L1307">        int month = 1;</span>

<span class="pc bpc" id="L1309" title="1 of 2 branches missed.">        if (len &gt; 1) {</span>
<span class="fc bfc" id="L1310" title="All 2 branches covered.">            if (!args[1].isNil()) {</span>
<span class="fc" id="L1311">                IRubyObject tmp = args[1].checkStringType();</span>
<span class="fc bfc" id="L1312" title="All 2 branches covered.">                if (!tmp.isNil()) {</span>
<span class="fc" id="L1313">                    String monthString = tmp.toString().toLowerCase();</span>
<span class="fc" id="L1314">                    Integer monthInt = MONTHS_MAP.get(monthString);</span>

<span class="fc bfc" id="L1316" title="All 2 branches covered.">                    if (monthInt != null) {</span>
<span class="fc" id="L1317">                        month = monthInt;</span>
                    } else {
                        try {
<span class="fc" id="L1320">                            month = Integer.parseInt(monthString);</span>
<span class="nc" id="L1321">                        } catch (NumberFormatException nfExcptn) {</span>
<span class="nc" id="L1322">                            throw runtime.newArgumentError(&quot;Argument out of range.&quot;);</span>
<span class="fc" id="L1323">                        }</span>
                    }
<span class="fc" id="L1325">                } else {</span>
<span class="fc" id="L1326">                    month = (int) RubyNumeric.num2long(args[1]);</span>
                }
            }
<span class="fc bfc" id="L1329" title="All 4 branches covered.">            if (1 &gt; month || month &gt; 12) {</span>
<span class="fc" id="L1330">                throw runtime.newArgumentError(&quot;Argument out of range: for month: &quot; + month);</span>
            }
        }

<span class="fc" id="L1334">        int[] int_args = { 1, 0, 0, 0, 0, 0 };</span>

<span class="fc bfc" id="L1336" title="All 2 branches covered.">        for (int i = 0; int_args.length &gt;= i + 2; i++) {</span>
<span class="fc bfc" id="L1337" title="All 2 branches covered.">            if (!args[i + 2].isNil()) {</span>
<span class="fc bfc" id="L1338" title="All 2 branches covered.">                if (!(args[i + 2] instanceof RubyNumeric)) {</span>
<span class="fc bfc" id="L1339" title="All 2 branches covered.">                    if (args[i + 2].respondsTo(&quot;to_int&quot;)) {</span>
<span class="fc" id="L1340">                        args[i + 2] = args[i + 2].callMethod(</span>
<span class="fc" id="L1341">                                runtime.getCurrentContext(), &quot;to_int&quot;);</span>
                    } else {
<span class="fc" id="L1343">                        args[i + 2] = args[i + 2].callMethod(</span>
<span class="fc" id="L1344">                                runtime.getCurrentContext(), &quot;to_i&quot;);</span>
                    }
                }

<span class="fc" id="L1348">                int_args[i] = RubyNumeric.num2int(args[i + 2]);</span>
            }
        }

        // Validate the times
        // Complying with MRI behavior makes it a little bit complicated. Logic copied from:
        // https://github.com/ruby/ruby/blob/trunk/time.c#L2609
<span class="pc bpc" id="L1355" title="9 of 22 branches missed.">        if (   (int_args[0] &lt; 1 || int_args[0] &gt; 31)</span>
            || (int_args[1] &lt; 0 || int_args[1] &gt; 24)
            || (int_args[1] == 24 &amp;&amp; (int_args[2] &gt; 0 || int_args[3] &gt; 0))
            || (int_args[2] &lt; 0 || int_args[2] &gt; 59)
            || (int_args[3] &lt; 0 || int_args[3] &gt; 60)) {
<span class="fc" id="L1360">            throw runtime.newArgumentError(&quot;argument out of range.&quot;);</span>
        }

        DateTime dt;
        // set up with min values and then add to allow rolling over
        try {
<span class="fc" id="L1366">            dt = new DateTime(year, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);</span>

<span class="fc" id="L1368">            dt = dt.plusMonths(month - 1)</span>
<span class="fc" id="L1369">                    .plusDays(int_args[0] - 1)</span>
<span class="fc" id="L1370">                    .plusHours(int_args[1])</span>
<span class="fc" id="L1371">                    .plusMinutes(int_args[2])</span>
<span class="fc" id="L1372">                    .plusSeconds(int_args[3]);</span>

            // 1.9 will observe fractional seconds *if* not given usec
<span class="fc bfc" id="L1375" title="All 2 branches covered.">            if (!args[5].isNil()</span>
<span class="fc bfc" id="L1376" title="All 2 branches covered.">                    &amp;&amp; args[6].isNil()) {</span>
<span class="fc" id="L1377">                double secs = RubyFloat.num2dbl(args[5]);</span>
<span class="fc" id="L1378">                int int_millis = (int) (secs * 1000) % 1000;</span>
<span class="fc" id="L1379">                dt = dt.plusMillis(int_millis);</span>
<span class="fc" id="L1380">                nanos = ((long) (secs * 1000000000) % 1000000);</span>
            }

<span class="fc" id="L1383">            dt = dt.withZoneRetainFields(dtz);</span>

            // If we're at a DST boundary, we need to choose the correct side of the boundary
<span class="pc bpc" id="L1386" title="1 of 2 branches missed.">            if (isDst) {</span>
<span class="nc" id="L1387">                final DateTime beforeDstBoundary = dt.withEarlierOffsetAtOverlap();</span>
<span class="nc" id="L1388">                final DateTime afterDstBoundary = dt.withLaterOffsetAtOverlap();</span>

<span class="nc" id="L1390">                final int offsetBeforeBoundary = dtz.getOffset(beforeDstBoundary);</span>
<span class="nc" id="L1391">                final int offsetAfterBoundary = dtz.getOffset(afterDstBoundary);</span>

                // If the time is during DST, we need to pick the time with the highest offset
<span class="nc bnc" id="L1394" title="All 2 branches missed.">                dt = offsetBeforeBoundary &gt; offsetAfterBoundary ? beforeDstBoundary : afterDstBoundary;</span>
            }
<span class="nc" id="L1396">        } catch (org.joda.time.IllegalFieldValueException e) {</span>
<span class="nc" id="L1397">            throw runtime.newArgumentError(&quot;time out of range&quot;);</span>
<span class="fc" id="L1398">        }</span>

<span class="fc" id="L1400">        RubyTime time = new RubyTime(runtime, (RubyClass) recv, dt);</span>
        // Ignores usec if 8 args (for compatibility with parsedate) or if not supplied.
<span class="pc bpc" id="L1402" title="1 of 4 branches missed.">        if (args.length != 8 &amp;&amp; !args[6].isNil()) {</span>
<span class="fc bfc" id="L1403" title="All 4 branches covered.">            boolean fractionalUSecGiven = args[6] instanceof RubyFloat || args[6] instanceof RubyRational;</span>

<span class="fc bfc" id="L1405" title="All 2 branches covered.">            if (fractionalUSecGiven) {</span>
<span class="fc" id="L1406">                double micros = RubyNumeric.num2dbl(args[6]);</span>
<span class="fc" id="L1407">                time.dt = dt.withMillis(dt.getMillis() + (long) (micros / 1000));</span>
<span class="fc" id="L1408">                nanos = ((long) (micros * 1000) % 1000000);</span>
<span class="fc" id="L1409">            } else {</span>
<span class="fc" id="L1410">                int usec = int_args[4] % 1000;</span>
<span class="fc" id="L1411">                int msec = int_args[4] / 1000;</span>

<span class="pc bpc" id="L1413" title="1 of 2 branches missed.">                if (int_args[4] &lt; 0) {</span>
<span class="nc" id="L1414">                    msec -= 1;</span>
<span class="nc" id="L1415">                    usec += 1000;</span>
                }
<span class="fc" id="L1417">                time.dt = dt.withMillis(dt.getMillis() + msec);</span>
<span class="fc" id="L1418">                time.setUSec(usec);</span>
            }
        }

<span class="fc bfc" id="L1422" title="All 2 branches covered.">        if (nanos != 0)</span>
<span class="fc" id="L1423">            time.setNSec(nanos);</span>

<span class="fc" id="L1425">        time.callInit(IRubyObject.NULL_ARRAY, Block.NULL_BLOCK);</span>
<span class="fc" id="L1426">        time.setIsTzRelative(setTzRelative);</span>
<span class="fc" id="L1427">        return time;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>