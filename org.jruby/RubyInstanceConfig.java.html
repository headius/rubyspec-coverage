<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RubyInstanceConfig.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby</a> &gt; <span class="el_source">RubyInstanceConfig.java</span></div><h1>RubyInstanceConfig.java</h1><pre class="source lang-java linenums">/***** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2007-2011 Nick Sieger &lt;nicksieger@gmail.com&gt;
 * Copyright (C) 2009 Joseph LaFata &lt;joe@quibb.org&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby;

import jnr.posix.util.Platform;
import org.jruby.embed.util.SystemPropertyCatcher;
import org.jruby.exceptions.MainExitException;
import org.jruby.runtime.Constants;
import org.jruby.runtime.backtrace.TraceType;
import org.jruby.runtime.load.LoadService;
import org.jruby.runtime.profile.builtin.ProfileOutput;
import org.jruby.util.InputStreamMarkCursor;
import org.jruby.util.JRubyFile;
import org.jruby.util.KCode;
import org.jruby.util.NormalizedFile;
import org.jruby.util.SafePropertyAccessor;
import org.jruby.util.cli.ArgumentProcessor;
import org.jruby.util.cli.Options;
import org.jruby.util.cli.OutputStrings;
import org.objectweb.asm.Opcodes;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.math.BigDecimal;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.regex.Pattern;

/**
 * A structure used to configure new JRuby instances. All publicly-tweakable
 * aspects of Ruby can be modified here, including those settable by command-
 * line options, those available through JVM properties, and those suitable for
 * embedding.
 */
public class RubyInstanceConfig {
<span class="fc" id="L80">    public RubyInstanceConfig() {</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">        currentDirectory = Ruby.isSecurityRestricted() ? &quot;/&quot; : JRubyFile.getFileProperty(&quot;user.dir&quot;);</span>

<span class="pc bpc" id="L83" title="1 of 2 branches missed.">        if (Ruby.isSecurityRestricted()) {</span>
<span class="nc" id="L84">            compileMode = CompileMode.OFF;</span>
<span class="nc" id="L85">            jitLogging = false;</span>
<span class="nc" id="L86">            jitDumping = false;</span>
<span class="nc" id="L87">            jitLoggingVerbose = false;</span>
<span class="nc" id="L88">            jitLogEvery = 0;</span>
<span class="nc" id="L89">            jitThreshold = -1;</span>
<span class="nc" id="L90">            jitMax = 0;</span>
<span class="nc" id="L91">            jitMaxSize = -1;</span>
<span class="nc" id="L92">            managementEnabled = false;</span>
        } else {
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">            if (COMPILE_EXCLUDE != null) {</span>
<span class="fc" id="L95">                String[] elements = COMPILE_EXCLUDE.split(&quot;,&quot;);</span>
<span class="fc" id="L96">                excludedMethods.addAll(Arrays.asList(elements));</span>
            }

<span class="fc" id="L99">            managementEnabled = Options.MANAGEMENT_ENABLED.load();</span>
<span class="fc" id="L100">            runRubyInProcess = Options.LAUNCH_INPROC.load();</span>
<span class="fc" id="L101">            compileMode = Options.COMPILE_MODE.load();</span>

<span class="fc" id="L103">            jitLogging = Options.JIT_LOGGING.load();</span>
<span class="fc" id="L104">            jitDumping = Options.JIT_DUMPING.load();</span>
<span class="fc" id="L105">            jitLoggingVerbose = Options.JIT_LOGGING_VERBOSE.load();</span>
<span class="fc" id="L106">            jitLogEvery = Options.JIT_LOGEVERY.load();</span>
<span class="fc" id="L107">            jitThreshold = Options.JIT_THRESHOLD.load();</span>
<span class="fc" id="L108">            jitMax = Options.JIT_MAX.load();</span>
<span class="fc" id="L109">            jitMaxSize = Options.JIT_MAXSIZE.load();</span>
        }

<span class="fc" id="L112">        threadDumpSignal = Options.THREAD_DUMP_SIGNAL.load();</span>

        try {
<span class="fc" id="L115">            environment = System.getenv();</span>
<span class="nc" id="L116">        } catch (SecurityException se) {</span>
<span class="nc" id="L117">            environment = new HashMap();</span>
<span class="fc" id="L118">        }</span>
<span class="fc" id="L119">    }</span>

<span class="nc" id="L121">    public RubyInstanceConfig(RubyInstanceConfig parentConfig) {</span>
<span class="nc" id="L122">        currentDirectory = parentConfig.getCurrentDirectory();</span>
<span class="nc" id="L123">        compileMode = parentConfig.getCompileMode();</span>
<span class="nc" id="L124">        jitLogging = parentConfig.jitLogging;</span>
<span class="nc" id="L125">        jitDumping = parentConfig.jitDumping;</span>
<span class="nc" id="L126">        jitLoggingVerbose = parentConfig.jitLoggingVerbose;</span>
<span class="nc" id="L127">        jitLogEvery = parentConfig.jitLogEvery;</span>
<span class="nc" id="L128">        jitThreshold = parentConfig.jitThreshold;</span>
<span class="nc" id="L129">        jitMax = parentConfig.jitMax;</span>
<span class="nc" id="L130">        jitMaxSize = parentConfig.jitMaxSize;</span>
<span class="nc" id="L131">        managementEnabled = parentConfig.managementEnabled;</span>
<span class="nc" id="L132">        runRubyInProcess = parentConfig.runRubyInProcess;</span>
<span class="nc" id="L133">        excludedMethods = parentConfig.excludedMethods;</span>
<span class="nc" id="L134">        threadDumpSignal = parentConfig.threadDumpSignal;</span>
<span class="nc" id="L135">        updateNativeENVEnabled = parentConfig.updateNativeENVEnabled;</span>

<span class="nc" id="L137">        profilingService = parentConfig.profilingService;</span>
<span class="nc" id="L138">        profilingMode = parentConfig.profilingMode;</span>

        try {
<span class="nc" id="L141">            environment = System.getenv();</span>
<span class="nc" id="L142">        } catch (SecurityException se) {</span>
<span class="nc" id="L143">            environment = new HashMap();</span>
<span class="nc" id="L144">        }</span>
<span class="nc" id="L145">    }</span>

    public RubyInstanceConfig(final InputStream in, final PrintStream out, final PrintStream err) {
<span class="nc" id="L148">        this();</span>
<span class="nc" id="L149">        setInput(in);</span>
<span class="nc" id="L150">        setOutput(out);</span>
<span class="nc" id="L151">        setError(err);</span>
<span class="nc" id="L152">    }</span>

    public LoadService createLoadService(Ruby runtime) {
<span class="fc" id="L155">        return creator.create(runtime);</span>
    }

    public void processArguments(String[] arguments) {
<span class="fc" id="L159">        new ArgumentProcessor(arguments, this).processArguments();</span>
<span class="fc" id="L160">        tryProcessArgumentsWithRubyopts();</span>
<span class="fc" id="L161">    }</span>

    public void tryProcessArgumentsWithRubyopts() {
        try {
            // environment defaults to System.getenv normally
<span class="fc" id="L166">            Object rubyoptObj = environment.get(&quot;RUBYOPT&quot;);</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">            String rubyopt = rubyoptObj == null ? null : rubyoptObj.toString();</span>

<span class="pc bpc" id="L169" title="3 of 4 branches missed.">            if (rubyopt == null || &quot;&quot;.equals(rubyopt)) return;</span>

<span class="nc bnc" id="L171" title="All 2 branches missed.">            if (rubyopt.split(&quot;\\s&quot;).length != 0) {</span>
<span class="nc" id="L172">                String[] rubyoptArgs = rubyopt.split(&quot;\\s+&quot;);</span>
<span class="nc" id="L173">                new ArgumentProcessor(rubyoptArgs, false, true, true, this).processArguments();</span>
            }
<span class="nc" id="L175">        } catch (SecurityException se) {</span>
            // ignore and do nothing
<span class="nc" id="L177">        }</span>
<span class="nc" id="L178">    }</span>

    // This method does not work like previous version in verifying it is
    // a Ruby shebang line.  Looking for ruby before \n is possible to add,
    // but I wanted to keep this short.
    private boolean isShebang(InputStreamMarkCursor cursor) throws IOException {
<span class="fc bfc" id="L184" title="All 2 branches covered.">        if (cursor.read() == '#') {</span>
<span class="fc" id="L185">            int c = cursor.read();</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">            if (c == '!') {</span>
<span class="fc" id="L187">                cursor.endPoint(-2);</span>
<span class="fc" id="L188">                return true;</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">            } else if (c == '\n') {</span>
<span class="nc" id="L190">                cursor.rewind();</span>
            }
<span class="nc" id="L192">        } else {</span>
<span class="fc" id="L193">            cursor.rewind();</span>
        }

<span class="fc" id="L196">        return false;</span>
    }

    private boolean skipToNextLine(InputStreamMarkCursor cursor) throws IOException {
<span class="nc" id="L200">        int c = cursor.read();</span>
        do {
<span class="nc bnc" id="L202" title="All 2 branches missed.">            if (c == '\n') return true;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">        } while ((c = cursor.read()) != -1);</span>

<span class="nc" id="L205">        return false;</span>
    }

    private void eatToShebang(InputStream in) {
<span class="nc" id="L209">        InputStreamMarkCursor cursor = new InputStreamMarkCursor(in, 8192);</span>
        try {
            do {
<span class="nc bnc" id="L212" title="All 2 branches missed.">                if (isShebang(cursor)) break;</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">		    } while (skipToNextLine(cursor));</span>
<span class="nc" id="L214">        } catch (IOException e) {</span>
        } finally {
<span class="nc" id="L216">            try { cursor.finish(); } catch (IOException e) {}</span>
<span class="nc" id="L217">        }</span>
<span class="nc" id="L218">    }</span>

    /**
     * The intent here is to gather up any options that might have
     * been specified in the shebang line and return them so they can
     * be merged into the ones specified on the command-line.  This is
     * kind of a hopeless task because it's impossible to figure out
     * where the command invocation stops and the parameters start.
     * We try to work with the common scenarios where /usr/bin/env is
     * used to invoke the JRuby shell script, and skip any parameters
     * it might have.  Then we look for the interpreter invocation and
     * assume that the binary will have the word &quot;ruby&quot; in the name.
     * This is error prone but should cover more cases than the
     * previous code.
     */
    public String[] parseShebangOptions(InputStream in) {
<span class="fc" id="L234">        BufferedReader reader = null;</span>
<span class="fc" id="L235">        String[] result = new String[0];</span>
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">        if (in == null) return result;</span>

<span class="pc bpc" id="L238" title="1 of 2 branches missed.">        if (isXFlag()) eatToShebang(in);</span>

        try {
<span class="fc" id="L241">            InputStreamMarkCursor cursor = new InputStreamMarkCursor(in, 8192);</span>
            try {
<span class="fc bfc" id="L243" title="All 2 branches covered.">                if (!isShebang(cursor)) return result;</span>
            } finally {
<span class="pc" id="L245">                cursor.finish();</span>
<span class="fc" id="L246">            }</span>

<span class="fc" id="L248">            in.mark(8192);</span>
<span class="fc" id="L249">            reader = new BufferedReader(new InputStreamReader(in, &quot;iso-8859-1&quot;), 8192);</span>
<span class="fc" id="L250">            String firstLine = reader.readLine();</span>

<span class="fc" id="L252">            boolean usesEnv = false;</span>
<span class="pc bpc" id="L253" title="3 of 6 branches missed.">            if (firstLine.length() &gt; 2 &amp;&amp; firstLine.charAt(0) == '#' &amp;&amp; firstLine.charAt(1) == '!') {</span>
<span class="fc" id="L254">                String[] options = firstLine.substring(2).split(&quot;\\s+&quot;);</span>
                int i;
<span class="fc bfc" id="L256" title="All 2 branches covered.">                for (i = 0; i &lt; options.length; i++) {</span>
                    // Skip /usr/bin/env if it's first
<span class="pc bpc" id="L258" title="1 of 4 branches missed.">                    if (i == 0 &amp;&amp; options[i].endsWith(&quot;/env&quot;)) {</span>
<span class="fc" id="L259">                        usesEnv = true;</span>
<span class="fc" id="L260">                        continue;</span>
                    }
                    // Skip any assignments if /usr/bin/env is in play
<span class="pc bpc" id="L263" title="2 of 4 branches missed.">                    if (usesEnv &amp;&amp; options[i].indexOf('=') &gt; 0) continue;</span>

                    // Skip any commandline args if /usr/bin/env is in play
<span class="pc bpc" id="L266" title="2 of 4 branches missed.">                    if (usesEnv &amp;&amp; options[i].startsWith(&quot;-&quot;)) continue;</span>

<span class="fc" id="L268">                    String basename = (new File(options[i])).getName();</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">                    if (basename.indexOf(&quot;ruby&quot;) &gt; 0) break;</span>
                }
<span class="fc" id="L271">                setHasShebangLine(true);</span>
<span class="fc" id="L272">                System.arraycopy(options, i, result, 0, options.length - i);</span>
<span class="fc" id="L273">            } else {</span>
                // No shebang line found
<span class="nc" id="L275">                setHasShebangLine(false);</span>
            }
<span class="nc" id="L277">        } catch (Exception ex) {</span>
            // ignore error
        } finally {
<span class="nc" id="L280">            try {</span>
<span class="pc" id="L281">                in.reset();</span>
<span class="pc" id="L282">            } catch (IOException ex) {}</span>
<span class="nc" id="L283">        }</span>
<span class="fc" id="L284">        return result;</span>
    }

<span class="fc" id="L287">    private static final Pattern RUBY_SHEBANG = Pattern.compile(&quot;#!.*ruby.*&quot;);</span>

    protected static boolean isRubyShebangLine(String line) {
<span class="nc" id="L290">        return RUBY_SHEBANG.matcher(line).matches();</span>
    }

    private String calculateJRubyHome() {
<span class="fc" id="L294">        String newJRubyHome = null;</span>

        // try the normal property first
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        if (!Ruby.isSecurityRestricted()) {</span>
<span class="fc" id="L298">            newJRubyHome = SafePropertyAccessor.getProperty(&quot;jruby.home&quot;);</span>
        }

<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        if (newJRubyHome != null) {</span>
            // verify it if it's there
<span class="fc" id="L303">            newJRubyHome = verifyHome(newJRubyHome, error);</span>
        } else {
            try {
<span class="nc" id="L306">                newJRubyHome = SystemPropertyCatcher.findJRubyHome(this);</span>
<span class="nc" id="L307">            } catch (Exception e) {}</span>

<span class="nc bnc" id="L309" title="All 2 branches missed.">            if (newJRubyHome != null) {</span>
                // verify it if it's there
<span class="nc" id="L311">                newJRubyHome = verifyHome(newJRubyHome, error);</span>
            } else {
                // otherwise fall back on system temp location
<span class="nc" id="L314">                newJRubyHome = SafePropertyAccessor.getProperty(&quot;java.io.tmpdir&quot;);</span>
            }
        }

        // RegularFileResource absolutePath will canonicalize resources so that will change c: paths to C:.
        // We will cannonicalize on windows so that jruby.home is also C:.
        // assume all those uri-like pathnames are already in absolute form
<span class="pc bpc" id="L321" title="9 of 10 branches missed.">        if (Platform.IS_WINDOWS &amp;&amp; !newJRubyHome.startsWith(&quot;jar:&quot;) &amp;&amp; !newJRubyHome.startsWith(&quot;file:&quot;) &amp;&amp; !newJRubyHome.startsWith(&quot;classpath:&quot;) &amp;&amp; !newJRubyHome.startsWith(&quot;uri:&quot;)) {</span>
<span class="nc" id="L322">            File file = new File(newJRubyHome);</span>

            try {
<span class="nc" id="L325">                newJRubyHome = file.getCanonicalPath();</span>
<span class="nc" id="L326">            } catch (IOException e) {} // just let newJRubyHome stay the way it is if this fails</span>
        }

<span class="fc" id="L329">        return newJRubyHome;</span>
    }

    // We require the home directory to be absolute
    private static String verifyHome(String home, PrintStream error) {
<span class="pc bpc" id="L334" title="2 of 4 branches missed.">        if (&quot;uri:classloader://META-INF/jruby.home&quot;.equals(home) || &quot;uri:classloader:/META-INF/jruby.home&quot;.equals(home)) {</span>
<span class="nc" id="L335">            return home;</span>
        }
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">        if (home.equals(&quot;.&quot;)) {</span>
<span class="nc" id="L338">            home = SafePropertyAccessor.getProperty(&quot;user.dir&quot;);</span>
        }
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">        else if (home.startsWith(&quot;cp:&quot;)) {</span>
<span class="nc" id="L341">            home = home.substring(3);</span>
        }
<span class="pc bpc" id="L343" title="4 of 6 branches missed.">        if (home.startsWith(&quot;jar:&quot;) || ( home.startsWith(&quot;file:&quot;) &amp;&amp; home.contains(&quot;.jar!/&quot;) ) ||</span>
<span class="pc bpc" id="L344" title="2 of 4 branches missed.">                home.startsWith(&quot;classpath:&quot;) || home.startsWith(&quot;uri:&quot;)) {</span>
<span class="nc" id="L345">            error.println(&quot;Warning: JRuby home with uri like pathes may not have full functionality - use at your own risk&quot;);</span>
        }
        // do not normalize on plain jar like pathes coming from jruby-rack
<span class="pc bpc" id="L348" title="2 of 4 branches missed.">        else if (!home.contains(&quot;.jar!/&quot;) &amp;&amp; !home.startsWith(&quot;uri:&quot;)) {</span>
<span class="fc" id="L349">            NormalizedFile f = new NormalizedFile(home);</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">            if (!f.isAbsolute()) {</span>
<span class="nc" id="L351">                home = f.getAbsolutePath();</span>
            }
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">            if (!f.exists()) {</span>
<span class="nc" id="L354">                error.println(&quot;Warning: JRuby home \&quot;&quot; + f + &quot;\&quot; does not exist, using &quot; + SafePropertyAccessor.getProperty(&quot;java.io.tmpdir&quot;));</span>
<span class="nc" id="L355">                return System.getProperty(&quot;java.io.tmpdir&quot;);</span>
            }
        }
<span class="fc" id="L358">        return home;</span>
    }

    /** Indicates whether the JVM process' native environment will be updated when ENV[...] is set from Ruby. */
    public boolean isUpdateNativeENVEnabled() {
<span class="fc" id="L363">        return updateNativeENVEnabled;</span>
    }

    /** Ensure that the JVM process' native environment will be updated when ENV is modified .*/
    public void setUpdateNativeENVEnabled(boolean updateNativeENVEnabled) {
<span class="nc" id="L368">        this.updateNativeENVEnabled = updateNativeENVEnabled;</span>
<span class="nc" id="L369">    }</span>

    public byte[] inlineScript() {
<span class="fc" id="L372">        return inlineScript.toString().getBytes();</span>
    }

    public InputStream getScriptSource() {
        try {
            // KCode.NONE is used because KCODE does not affect parse in Ruby 1.8
            // if Ruby 2.0 encoding pragmas are implemented, this will need to change
<span class="fc bfc" id="L379" title="All 2 branches covered.">            if (hasInlineScript) {</span>
<span class="fc" id="L380">                return new ByteArrayInputStream(inlineScript());</span>
<span class="pc bpc" id="L381" title="2 of 4 branches missed.">            } else if (isForceStdin() || getScriptFileName() == null) {</span>
                // can't use -v and stdin
<span class="nc bnc" id="L383" title="All 2 branches missed.">                if (isShowVersion()) {</span>
<span class="nc" id="L384">                    return null;</span>
                }
<span class="nc" id="L386">                return getInput();</span>
            } else {
<span class="fc" id="L388">                String script = getScriptFileName();</span>
<span class="fc" id="L389">                InputStream stream = null;</span>
<span class="pc bpc" id="L390" title="3 of 4 branches missed.">                if (script.startsWith(&quot;file:&quot;) &amp;&amp; script.indexOf(&quot;.jar!/&quot;) != -1) {</span>
<span class="nc" id="L391">                    stream = new URL(&quot;jar:&quot; + script).openStream();</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">                } else if (script.startsWith(&quot;classpath:&quot;)) {</span>
<span class="nc" id="L393">                    stream = Ruby.getClassLoader().getResourceAsStream(script.substring(&quot;classpath:&quot;.length()));</span>
                } else {
<span class="fc" id="L395">                    File file = JRubyFile.create(getCurrentDirectory(), getScriptFileName());</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">                    if (isXFlag()) {</span>
                        // search for a shebang line and
                        // return the script between shebang and __END__ or CTRL-Z (0x1A)
<span class="nc" id="L399">                        return findScript(file);</span>
                    }
<span class="fc" id="L401">                    stream = new FileInputStream(file);</span>
                }

<span class="fc" id="L404">                return new BufferedInputStream(stream, 8192);</span>
            }
<span class="nc" id="L406">        } catch (IOException e) {</span>
            // We haven't found any file directly on the file system,
            // now check for files inside the JARs.
<span class="nc" id="L409">            InputStream is = getJarScriptSource(scriptFileName);</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">            if (is != null) {</span>
<span class="nc" id="L411">                return new BufferedInputStream(is, 8129);</span>
            }
<span class="nc" id="L413">            throw new MainExitException(1, &quot;Error opening script file: &quot; + e.getMessage());</span>
        }
    }

    private static InputStream findScript(File file) throws IOException {
<span class="nc" id="L418">        StringBuffer buf = new StringBuffer();</span>
<span class="nc" id="L419">        BufferedReader br = new BufferedReader(new FileReader(file));</span>
<span class="nc" id="L420">        String currentLine = br.readLine();</span>
<span class="nc bnc" id="L421" title="All 4 branches missed.">        while (currentLine != null &amp;&amp; !isRubyShebangLine(currentLine)) {</span>
<span class="nc" id="L422">            currentLine = br.readLine();</span>
        }

<span class="nc" id="L425">        buf.append(currentLine);</span>
<span class="nc" id="L426">        buf.append(&quot;\n&quot;);</span>

        do {
<span class="nc" id="L429">            currentLine = br.readLine();</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">            if (currentLine != null) {</span>
<span class="nc" id="L431">            buf.append(currentLine);</span>
<span class="nc" id="L432">            buf.append(&quot;\n&quot;);</span>
            }
<span class="nc bnc" id="L434" title="All 6 branches missed.">        } while (!(currentLine == null || currentLine.contains(&quot;__END__&quot;) || currentLine.contains(&quot;\026&quot;)));</span>
<span class="nc" id="L435">        return new BufferedInputStream(new ByteArrayInputStream(buf.toString().getBytes()), 8192);</span>
    }

    private static InputStream getJarScriptSource(String scriptFileName) {
<span class="nc bnc" id="L439" title="All 4 branches missed.">        boolean looksLikeJarURL = scriptFileName.startsWith(&quot;file:&quot;) &amp;&amp; scriptFileName.indexOf(&quot;!/&quot;) != -1;</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">        if (!looksLikeJarURL) {</span>
<span class="nc" id="L441">            return null;</span>
        }

<span class="nc" id="L444">        String before = scriptFileName.substring(&quot;file:&quot;.length(), scriptFileName.indexOf(&quot;!/&quot;));</span>
<span class="nc" id="L445">        String after =  scriptFileName.substring(scriptFileName.indexOf(&quot;!/&quot;) + 2);</span>

        try {
<span class="nc" id="L448">            JarFile jFile = new JarFile(before);</span>
<span class="nc" id="L449">            JarEntry entry = jFile.getJarEntry(after);</span>

<span class="nc bnc" id="L451" title="All 4 branches missed.">            if (entry != null &amp;&amp; !entry.isDirectory()) {</span>
<span class="nc" id="L452">                return jFile.getInputStream(entry);</span>
            }
<span class="nc" id="L454">        } catch (IOException ignored) {</span>
<span class="nc" id="L455">        }</span>
<span class="nc" id="L456">        return null;</span>
    }

    public String displayedFileName() {
<span class="fc bfc" id="L460" title="All 2 branches covered.">        if (hasInlineScript) {</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">            if (scriptFileName != null) {</span>
<span class="nc" id="L462">                return scriptFileName;</span>
            } else {
<span class="fc" id="L464">                return &quot;-e&quot;;</span>
            }
<span class="pc bpc" id="L466" title="2 of 4 branches missed.">        } else if (isForceStdin() || getScriptFileName() == null) {</span>
<span class="nc" id="L467">            return &quot;-&quot;;</span>
        } else {
<span class="fc" id="L469">            return getScriptFileName();</span>
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // Static utilities and global state management methods.
    ////////////////////////////////////////////////////////////////////////////

    public static boolean hasLoadedNativeExtensions() {
<span class="nc" id="L478">        return loadedNativeExtensions;</span>
    }

    public static void setLoadedNativeExtensions(boolean loadedNativeExtensions) {
<span class="nc" id="L482">        RubyInstanceConfig.loadedNativeExtensions = loadedNativeExtensions;</span>
<span class="nc" id="L483">    }</span>

    ////////////////////////////////////////////////////////////////////////////
    // Getters and setters for config settings.
    ////////////////////////////////////////////////////////////////////////////

    public LoadServiceCreator getLoadServiceCreator() {
<span class="nc" id="L490">        return creator;</span>
    }

    public void setLoadServiceCreator(LoadServiceCreator creator) {
<span class="nc" id="L494">        this.creator = creator;</span>
<span class="nc" id="L495">    }</span>

    public String getJRubyHome() {
<span class="fc bfc" id="L498" title="All 2 branches covered.">        if (jrubyHome == null) {</span>
<span class="fc" id="L499">            jrubyHome = calculateJRubyHome();</span>
        }
<span class="fc" id="L501">        return jrubyHome;</span>
    }

    public void setJRubyHome(String home) {
<span class="nc" id="L505">        jrubyHome = verifyHome(home, error);</span>
<span class="nc" id="L506">    }</span>

    public CompileMode getCompileMode() {
<span class="fc" id="L509">        return compileMode;</span>
    }

    public void setCompileMode(CompileMode compileMode) {
<span class="nc" id="L513">        this.compileMode = compileMode;</span>
<span class="nc" id="L514">    }</span>

    /**
     * @see Options#JIT_LOGGING
     */
    public boolean isJitLogging() {
<span class="fc" id="L520">        return jitLogging;</span>
    }

    /**
     * @see Options#JIT_DUMPING
     */
    public boolean isJitDumping() {
<span class="nc" id="L527">        return jitDumping;</span>
    }

    /**
     * @see Options#JIT_LOGGING_VERBOSE
     */
    public boolean isJitLoggingVerbose() {
<span class="nc" id="L534">        return jitLoggingVerbose;</span>
    }

    /**
     * @see Options#JIT_LOGEVERY
     */
    public int getJitLogEvery() {
<span class="fc" id="L541">        return jitLogEvery;</span>
    }

    /**
     * @see Options#JIT_LOGEVERY
     */
    public void setJitLogEvery(int jitLogEvery) {
<span class="nc" id="L548">        this.jitLogEvery = jitLogEvery;</span>
<span class="nc" id="L549">    }</span>

    /**
     * @see Options#JIT_THRESHOLD
     */
    public int getJitThreshold() {
<span class="fc" id="L555">        return jitThreshold;</span>
    }

    /**
     * @see Options#JIT_THRESHOLD
     */
    public void setJitThreshold(int jitThreshold) {
<span class="nc" id="L562">        this.jitThreshold = jitThreshold;</span>
<span class="nc" id="L563">    }</span>

    /**
     * @see Options#JIT_MAX
     */
    public int getJitMax() {
<span class="nc" id="L569">        return jitMax;</span>
    }

    /**
     * @see Options#JIT_MAX
     */
    public void setJitMax(int jitMax) {
<span class="nc" id="L576">        this.jitMax = jitMax;</span>
<span class="nc" id="L577">    }</span>

    /**
     * @see Options#JIT_MAXSIZE
     */
    public int getJitMaxSize() {
<span class="nc" id="L583">        return jitMaxSize;</span>
    }

    /**
     * @see Options#JIT_MAXSIZE
     */
    public void setJitMaxSize(int jitMaxSize) {
<span class="nc" id="L590">        this.jitMaxSize = jitMaxSize;</span>
<span class="nc" id="L591">    }</span>

    /**
     * @see Options#LAUNCH_INPROC
     */
    public boolean isRunRubyInProcess() {
<span class="fc" id="L597">        return runRubyInProcess;</span>
    }

    /**
     * @see Options#LAUNCH_INPROC
     */
    public void setRunRubyInProcess(boolean flag) {
<span class="nc" id="L604">        this.runRubyInProcess = flag;</span>
<span class="nc" id="L605">    }</span>

    public void setInput(InputStream newInput) {
<span class="nc" id="L608">        input = newInput;</span>
<span class="nc" id="L609">    }</span>

    public InputStream getInput() {
<span class="fc" id="L612">        return input;</span>
    }

    @Deprecated
    public CompatVersion getCompatVersion() {
<span class="fc" id="L617">        return CompatVersion.RUBY2_1;</span>
    }

    @Deprecated
    public void setCompatVersion(CompatVersion compatVersion) {
<span class="nc" id="L622">    }</span>

    public void setOutput(PrintStream newOutput) {
<span class="nc" id="L625">        output = newOutput;</span>
<span class="nc" id="L626">    }</span>

    public PrintStream getOutput() {
<span class="fc" id="L629">        return output;</span>
    }

    public void setError(PrintStream newError) {
<span class="nc" id="L633">        error = newError;</span>
<span class="nc" id="L634">    }</span>

    public PrintStream getError() {
<span class="fc" id="L637">        return error;</span>
    }

    public void setCurrentDirectory(String newCurrentDirectory) {
<span class="fc" id="L641">        currentDirectory = newCurrentDirectory;</span>
<span class="fc" id="L642">    }</span>

    public String getCurrentDirectory() {
<span class="fc" id="L645">        return currentDirectory;</span>
    }

    public void setProfile(Profile newProfile) {
<span class="nc" id="L649">        profile = newProfile;</span>
<span class="nc" id="L650">    }</span>

    public Profile getProfile() {
<span class="fc" id="L653">        return profile;</span>
    }

    /**
     * @see Options#OBJECTSPACE_ENABLED
     */
    public void setObjectSpaceEnabled(boolean newObjectSpaceEnabled) {
<span class="nc" id="L660">        objectSpaceEnabled = newObjectSpaceEnabled;</span>
<span class="nc" id="L661">    }</span>

    /**
     * @see Options#OBJECTSPACE_ENABLED
     */
    public boolean isObjectSpaceEnabled() {
<span class="fc" id="L667">        return objectSpaceEnabled;</span>
    }

    /**
     * @see Options#SIPHASH_ENABLED
     */
    public void setSiphashEnabled(boolean newSiphashEnabled) {
<span class="nc" id="L674">        siphashEnabled = newSiphashEnabled;</span>
<span class="nc" id="L675">    }</span>

    /**
     * @see Options#SIPHASH_ENABLED
     */
    public boolean isSiphashEnabled() {
<span class="fc" id="L681">        return siphashEnabled;</span>
    }

    public void setEnvironment(Map newEnvironment) {
<span class="nc bnc" id="L685" title="All 2 branches missed.">        if (newEnvironment == null) newEnvironment = new HashMap();</span>
<span class="nc" id="L686">        environment = newEnvironment;</span>
<span class="nc" id="L687">    }</span>

    public Map getEnvironment() {
<span class="fc" id="L690">        return environment;</span>
    }

    public ClassLoader getLoader() {
<span class="fc" id="L694">        return loader;</span>
    }

    public void setLoader(ClassLoader loader) {
<span class="nc" id="L698">        this.loader = loader;</span>
<span class="nc" id="L699">    }</span>

    public String[] getArgv() {
<span class="fc" id="L702">        return argv;</span>
    }

    public void setArgv(String[] argv) {
<span class="fc" id="L706">        this.argv = argv;</span>
<span class="fc" id="L707">    }</span>

    public StringBuffer getInlineScript() {
<span class="fc" id="L710">        return inlineScript;</span>
    }

    public void setHasInlineScript(boolean hasInlineScript) {
<span class="fc" id="L714">        this.hasScriptArgv = true;</span>
<span class="fc" id="L715">        this.hasInlineScript = hasInlineScript;</span>
<span class="fc" id="L716">    }</span>

    public boolean hasInlineScript() {
<span class="nc" id="L719">        return hasInlineScript;</span>
    }

    public Collection&lt;String&gt; getRequiredLibraries() {
<span class="fc" id="L723">        return requiredLibraries;</span>
    }

    public List&lt;String&gt; getLoadPaths() {
<span class="fc" id="L727">        return loadPaths;</span>
    }

    public void setLoadPaths(List&lt;String&gt; loadPaths) {
<span class="nc" id="L731">        this.loadPaths = loadPaths;</span>
<span class="nc" id="L732">    }</span>

    /**
     * @see Options#CLI_HELP
     */
    public void setShouldPrintUsage(boolean shouldPrintUsage) {
<span class="nc" id="L738">        this.shouldPrintUsage = shouldPrintUsage;</span>
<span class="nc" id="L739">    }</span>

    /**
     * @see Options#CLI_HELP
     */
    public boolean getShouldPrintUsage() {
<span class="nc" id="L745">        return shouldPrintUsage;</span>
    }

    /**
     * @see Options#CLI_PROPERTIES
     */
    public void setShouldPrintProperties(boolean shouldPrintProperties) {
<span class="nc" id="L752">        this.shouldPrintProperties = shouldPrintProperties;</span>
<span class="nc" id="L753">    }</span>

    /**
     * @see Options#CLI_PROPERTIES
     */
    public boolean getShouldPrintProperties() {
<span class="nc" id="L759">        return shouldPrintProperties;</span>
    }

    public boolean isInlineScript() {
<span class="fc" id="L763">        return hasInlineScript;</span>
    }

    /**
     * True if we are only using source from stdin and not from a -e or file argument.
     */
    public boolean isForceStdin() {
<span class="fc" id="L770">        return forceStdin;</span>
    }

    /**
     * Set whether we should only look at stdin for source.
     */
    public void setForceStdin(boolean forceStdin) {
<span class="nc" id="L777">        this.forceStdin = forceStdin;</span>
<span class="nc" id="L778">    }</span>

    public void setScriptFileName(String scriptFileName) {
<span class="fc" id="L781">        this.hasScriptArgv = true;</span>
<span class="fc" id="L782">        this.scriptFileName = scriptFileName;</span>
<span class="fc" id="L783">    }</span>

    public String getScriptFileName() {
<span class="fc" id="L786">        return scriptFileName;</span>
    }

    /**
     * @see Options#CLI_ASSUME_LOOP
     */
    public void setAssumeLoop(boolean assumeLoop) {
<span class="fc" id="L793">        this.assumeLoop = assumeLoop;</span>
<span class="fc" id="L794">    }</span>

    /**
     * @see Options#CLI_ASSUME_LOOP
     */
    public boolean isAssumeLoop() {
<span class="fc" id="L800">        return assumeLoop;</span>
    }

    /**
     * @see Options#CLI_ASSUME_PRINT
     */
    public void setAssumePrinting(boolean assumePrinting) {
<span class="fc" id="L807">        this.assumePrinting = assumePrinting;</span>
<span class="fc" id="L808">    }</span>

    /**
     * @see Options#CLI_ASSUME_PRINT
     */
    public boolean isAssumePrinting() {
<span class="fc" id="L814">        return assumePrinting;</span>
    }

    /**
     * @see Options#CLI_PROCESS_LINE_ENDS
     */
    public void setProcessLineEnds(boolean processLineEnds) {
<span class="nc" id="L821">        this.processLineEnds = processLineEnds;</span>
<span class="nc" id="L822">    }</span>

    /**
     * @see Options#CLI_PROCESS_LINE_ENDS
     */
    public boolean isProcessLineEnds() {
<span class="fc" id="L828">        return processLineEnds;</span>
    }

    /**
     * @see Options#CLI_AUTOSPLIT
     */
    public void setSplit(boolean split) {
<span class="fc" id="L835">        this.split = split;</span>
<span class="fc" id="L836">    }</span>

    /**
     * @see Options#CLI_AUTOSPLIT
     */
    public boolean isSplit() {
<span class="fc" id="L842">        return split;</span>
    }

    /**
     * @see Options#CLI_WARNING_LEVEL
     */
    public Verbosity getVerbosity() {
<span class="fc" id="L849">        return verbosity;</span>
    }

    /**
     * @see Options#CLI_WARNING_LEVEL
     */
    public void setVerbosity(Verbosity verbosity) {
<span class="fc" id="L856">        this.verbosity = verbosity;</span>
<span class="fc" id="L857">    }</span>

    /**
     * @see Options#CLI_VERBOSE
     */
    public boolean isVerbose() {
<span class="pc bpc" id="L863" title="1 of 2 branches missed.">        return verbosity == Verbosity.TRUE;</span>
    }

    /**
     * @see Options#CLI_DEBUG
     */
    public boolean isDebug() {
<span class="fc" id="L870">        return debug;</span>
    }

    /**
     * @see Options#CLI_DEBUG
     */
    public void setDebug(boolean debug) {
<span class="fc" id="L877">        this.debug = debug;</span>
<span class="fc" id="L878">    }</span>

    /**
     * @see Options#CLI_PARSER_DEBUG
     */
    public boolean isParserDebug() {
<span class="fc" id="L884">        return parserDebug;</span>
    }

    /**
     * @see Options#CLI_PARSER_DEBUG
     */
    public void setParserDebug(boolean parserDebug) {
<span class="nc" id="L891">        this.parserDebug = parserDebug;</span>
<span class="nc" id="L892">    }</span>

    /**
     * @see Options#CLI_PARSER_DEBUG
     */
    public boolean getParserDebug() {
<span class="nc" id="L898">        return parserDebug;</span>
    }

    /**
     * @see Options#CLI_VERSION
     */
    public void setShowVersion(boolean showVersion) {
<span class="fc" id="L905">        this.showVersion = showVersion;</span>
<span class="fc" id="L906">    }</span>

    /**
     * @see Options#CLI_VERSION
     */
    public boolean isShowVersion() {
<span class="fc" id="L912">        return showVersion;</span>
    }

    /**
     * @see Options#CLI_BYTECODE
     */
    public void setShowBytecode(boolean showBytecode) {
<span class="nc" id="L919">        this.showBytecode = showBytecode;</span>
<span class="nc" id="L920">    }</span>

    /**
     * @see Options#CLI_BYTECODE
     */
    public boolean isShowBytecode() {
<span class="fc" id="L926">        return showBytecode;</span>
    }

    /**
     * @see Options#CLI_COPYRIGHT
     */
    public void setShowCopyright(boolean showCopyright) {
<span class="nc" id="L933">        this.showCopyright = showCopyright;</span>
<span class="nc" id="L934">    }</span>

    /**
     * @see Options#CLI_COPYRIGHT
     */
    public boolean isShowCopyright() {
<span class="fc" id="L940">        return showCopyright;</span>
    }

    public void setShouldRunInterpreter(boolean shouldRunInterpreter) {
<span class="nc" id="L944">        this.shouldRunInterpreter = shouldRunInterpreter;</span>
<span class="nc" id="L945">    }</span>

    public boolean getShouldRunInterpreter() {
<span class="pc bpc" id="L948" title="4 of 6 branches missed.">        return shouldRunInterpreter &amp;&amp; (hasScriptArgv || !showVersion);</span>
    }

    /**
     * @see Options#CLI_CHECK_SYNTAX
     */
    public void setShouldCheckSyntax(boolean shouldSetSyntax) {
<span class="fc" id="L955">        this.shouldCheckSyntax = shouldSetSyntax;</span>
<span class="fc" id="L956">    }</span>

    /**
     * @see Options#CLI_CHECK_SYNTAX
     */
    public boolean getShouldCheckSyntax() {
<span class="fc" id="L962">        return shouldCheckSyntax;</span>
    }

    /**
     * @see Options#CLI_AUTOSPLIT_SEPARATOR
     */
    public void setInputFieldSeparator(String inputFieldSeparator) {
<span class="fc" id="L969">        this.inputFieldSeparator = inputFieldSeparator;</span>
<span class="fc" id="L970">    }</span>

    /**
     * @see Options#CLI_AUTOSPLIT_SEPARATOR
     */
    public String getInputFieldSeparator() {
<span class="fc" id="L976">        return inputFieldSeparator;</span>
    }

    /**
     * @see Options#CLI_KCODE
     */
    public KCode getKCode() {
<span class="fc" id="L983">        return kcode;</span>
    }

    /**
     * @see Options#CLI_KCODE
     */
    public void setKCode(KCode kcode) {
<span class="fc" id="L990">        this.kcode = kcode;</span>
<span class="fc" id="L991">    }</span>

    /**
     * @see Options#CLI_ENCODING_INTERNAL
     */
    public void setInternalEncoding(String internalEncoding) {
<span class="fc" id="L997">        this.internalEncoding = internalEncoding;</span>
<span class="fc" id="L998">    }</span>

    /**
     * @see Options#CLI_ENCODING_INTERNAL
     */
    public String getInternalEncoding() {
<span class="fc" id="L1004">        return internalEncoding;</span>
    }

    /**
     * @see Options#CLI_ENCODING_EXTERNAL
     */
    public void setExternalEncoding(String externalEncoding) {
<span class="fc" id="L1011">        this.externalEncoding = externalEncoding;</span>
<span class="fc" id="L1012">    }</span>

    /**
     * @see Options#CLI_ENCODING_EXTERNAL
     */
    public String getExternalEncoding() {
<span class="fc" id="L1018">        return externalEncoding;</span>
    }

    /**
     * @see Options#CLI_ENCODING_SOURCE
     */
    public void setSourceEncoding(String sourceEncoding) {
<span class="fc" id="L1025">        this.sourceEncoding = sourceEncoding;</span>
<span class="fc" id="L1026">    }</span>

    /**
     * @see Options#CLI_ENCODING_SOURCE
     */
    public String getSourceEncoding() {
<span class="fc" id="L1032">        return sourceEncoding;</span>
    }

    /**
     * @see Options#CLI_RECORD_SEPARATOR
     */
    public void setRecordSeparator(String recordSeparator) {
<span class="nc" id="L1039">        this.recordSeparator = recordSeparator;</span>
<span class="nc" id="L1040">    }</span>

    /**
     * @see Options#CLI_RECORD_SEPARATOR
     */
    public String getRecordSeparator() {
<span class="fc" id="L1046">        return recordSeparator;</span>
    }

    public int getSafeLevel() {
<span class="nc" id="L1050">        return 0;</span>
    }

    /**
     * @see Options#CLI_BACKUP_EXTENSION
     */
    public void setInPlaceBackupExtension(String inPlaceBackupExtension) {
<span class="fc" id="L1057">        this.inPlaceBackupExtension = inPlaceBackupExtension;</span>
<span class="fc" id="L1058">    }</span>

    /**
     * @see Options#CLI_BACKUP_EXTENSION
     */
    public String getInPlaceBackupExtension() {
<span class="fc" id="L1064">        return inPlaceBackupExtension;</span>
    }

    public Map getOptionGlobals() {
<span class="fc" id="L1068">        return optionGlobals;</span>
    }

    public boolean isManagementEnabled() {
<span class="fc" id="L1072">        return managementEnabled;</span>
    }

    public Set getExcludedMethods() {
<span class="fc" id="L1076">        return excludedMethods;</span>
    }

    public boolean isArgvGlobalsOn() {
<span class="fc" id="L1080">        return argvGlobalsOn;</span>
    }

    public void setArgvGlobalsOn(boolean argvGlobalsOn) {
<span class="fc" id="L1084">        this.argvGlobalsOn = argvGlobalsOn;</span>
<span class="fc" id="L1085">    }</span>

    public String getThreadDumpSignal() {
<span class="nc" id="L1088">        return threadDumpSignal;</span>
    }

    public boolean isHardExit() {
<span class="fc" id="L1092">        return hardExit;</span>
    }

    public void setHardExit(boolean hardExit) {
<span class="fc" id="L1096">        this.hardExit = hardExit;</span>
<span class="fc" id="L1097">    }</span>

    /**
     * @see Options#CLI_PROFILING_MODE
     */
    public boolean isProfiling() {
<span class="pc bpc" id="L1103" title="1 of 2 branches missed.">        return profilingMode != ProfilingMode.OFF;</span>
    }

    /**
     * @see Options#CLI_PROFILING_MODE
     */
    public boolean isProfilingEntireRun() {
<span class="pc bpc" id="L1110" title="3 of 4 branches missed.">        return profilingMode != ProfilingMode.OFF &amp;&amp; profilingMode != ProfilingMode.API;</span>
    }

    /**
     * @see Options#CLI_PROFILING_MODE
     */
    public void setProfilingMode(ProfilingMode profilingMode) {
<span class="nc" id="L1117">        this.profilingMode = profilingMode;</span>
<span class="nc" id="L1118">    }</span>

    /**
     * @see Options#CLI_PROFILING_MODE
     */
    public ProfilingMode getProfilingMode() {
<span class="nc" id="L1124">        return profilingMode;</span>
    }

    public void setProfileOutput(ProfileOutput output) {
<span class="nc" id="L1128">        this.profileOutput = output;</span>
<span class="nc" id="L1129">    }</span>

    public ProfileOutput getProfileOutput() {
<span class="nc" id="L1132">        return profileOutput;</span>
    }

    public boolean hasShebangLine() {
<span class="nc" id="L1136">        return hasShebangLine;</span>
    }

    public void setHasShebangLine(boolean hasShebangLine) {
<span class="fc" id="L1140">        this.hasShebangLine = hasShebangLine;</span>
<span class="fc" id="L1141">    }</span>

    /**
     * @see Options#CLI_RUBYGEMS_ENABLE
     */
    public boolean isDisableGems() {
<span class="fc" id="L1147">        return disableGems;</span>
    }

    /**
     * @see Options#CLI_RUBYOPT_ENABLE
     */
    public void setDisableRUBYOPT(boolean dr) {
<span class="nc" id="L1154">        this.disableRUBYOPT = dr;</span>
<span class="nc" id="L1155">    }</span>

    /**
     * @see Options#CLI_RUBYGEMS_ENABLE
     */
    public void setDisableGems(boolean dg) {
<span class="nc" id="L1161">        this.disableGems = dg;</span>
<span class="nc" id="L1162">    }</span>

    /**
     * @see Options#BACKTRACE_STYLE
     */
    public TraceType getTraceType() {
<span class="fc" id="L1168">        return traceType;</span>
    }

    /**
     * @see Options#BACKTRACE_STYLE
     */
    public void setTraceType(TraceType traceType) {
<span class="nc" id="L1175">        this.traceType = traceType;</span>
<span class="nc" id="L1176">    }</span>

    public void setHasScriptArgv(boolean argvRemains) {
<span class="nc" id="L1179">        hasScriptArgv = argvRemains;</span>
<span class="nc" id="L1180">    }</span>

    public boolean getHasScriptArgv() {
<span class="nc" id="L1183">        return hasScriptArgv;</span>
    }

    /**
     * Whether to mask .java lines in the Ruby backtrace, as MRI does for C calls.
     *
     * @see Options#BACKTRACE_MASK
     *
     * @return true if masking; false otherwise
     */
    public boolean getBacktraceMask() {
<span class="fc" id="L1194">        return backtraceMask;</span>
    }

    /**
     * Set whether to mask .java lines in the Ruby backtrace.
     *
     * @see Options#BACKTRACE_MASK
     *
     * @param backtraceMask true to mask; false otherwise
     */
    public void setBacktraceMask(boolean backtraceMask) {
<span class="nc" id="L1205">        this.backtraceMask = backtraceMask;</span>
<span class="nc" id="L1206">    }</span>

    /**
     * Set whether native code is enabled for this config.
     *
     * @see Options#NATIVE_ENABLED
     *
     * @param b new value indicating whether native code is enabled
     */
    public void setNativeEnabled(boolean b) {
<span class="nc" id="L1216">        _nativeEnabled = b;</span>
<span class="nc" id="L1217">    }</span>

    /**
     * Get whether native code is enabled for this config.
     *
     * @see Options#NATIVE_ENABLED
     *
     * @return true if native code is enabled; false otherwise.
     */
    public boolean isNativeEnabled() {
<span class="fc" id="L1227">        return _nativeEnabled;</span>
    }

    /**
     * @see Options#CLI_STRIP_HEADER
     */
    public void setXFlag(boolean xFlag) {
<span class="nc" id="L1234">        this.xFlag = xFlag;</span>
<span class="nc" id="L1235">    }</span>

    /**
     * @see Options#CLI_STRIP_HEADER
     */
    public boolean isXFlag() {
<span class="fc" id="L1241">        return xFlag;</span>
    }

    /**
     * True if colorized backtraces are enabled. False otherwise.
     *
     * @see Options#BACKTRACE_COLOR
     */
    public boolean getBacktraceColor() {
<span class="fc" id="L1250">        return backtraceColor;</span>
    }

    /**
     * Set to true to enable colorized backtraces.
     *
     * @see Options#BACKTRACE_COLOR
     */
    public void setBacktraceColor(boolean backtraceColor) {
<span class="nc" id="L1259">        this.backtraceColor = backtraceColor;</span>
<span class="nc" id="L1260">    }</span>

    /**
     * Whether to use a single global lock for requires.
     *
     * @see Options#GLOBAL_REQUIRE_LOCK
     */
    public boolean isGlobalRequireLock() {
<span class="fc" id="L1268">        return globalRequireLock;</span>
    }

    /**
     * Set whether to use a single global lock for requires.
     *
     * @see Options#GLOBAL_REQUIRE_LOCK
     */
    public void setGlobalRequireLock(boolean globalRequireLock) {
<span class="nc" id="L1277">        this.globalRequireLock = globalRequireLock;</span>
<span class="nc" id="L1278">    }</span>

    /**
     * Set whether the JIT compiler should run in a background thread (Executor-based).
     *
     * @see Options#JIT_BACKGROUND
     *
     * @param jitBackground whether to run the JIT compiler in a background thread
     */
    public void setJitBackground(boolean jitBackground) {
<span class="nc" id="L1288">        this.jitBackground = jitBackground;</span>
<span class="nc" id="L1289">    }</span>

    /**
     * Get whether the JIT compiler will run in a background thread.
     *
     * @see Options#JIT_BACKGROUND
     *
     * @return whether the JIT compiler will run in a background thread
     */
    public boolean getJitBackground() {
<span class="fc" id="L1299">        return jitBackground;</span>
    }

    /**
     * Set whether to load and setup bundler on startup.
     *
     * @see Options#CLI_LOAD_GEMFILE
     */
    public void setLoadGemfile(boolean loadGemfile) {
<span class="nc" id="L1308">        this.loadGemfile = loadGemfile;</span>
<span class="nc" id="L1309">    }</span>

    /**
     * Whether to load and setup bundler on startup.
     *
     * @see Options#CLI_LOAD_GEMFILE
     */
    public boolean getLoadGemfile() {
<span class="fc" id="L1317">        return loadGemfile;</span>
    }

    /**
     * Set the maximum number of methods to consider when profiling.
     *
     * @see Options#PROFILE_MAX_METHODS
     */
    public void setProfileMaxMethods(int profileMaxMethods) {
<span class="nc" id="L1326">        this.profileMaxMethods = profileMaxMethods;</span>
<span class="nc" id="L1327">    }</span>

    /**
     * Get the maximum number of methods to consider when profiling.
     *
     * @see Options#PROFILE_MAX_METHODS
     */
    public int getProfileMaxMethods() {
<span class="nc" id="L1335">        return profileMaxMethods;</span>
    }

    /**
     * Set whether Kernel#gsub should be defined
     */
    public void setKernelGsubDefined(boolean setDefineKernelGsub) {
<span class="fc" id="L1342">        this.kernelGsubDefined = setDefineKernelGsub;</span>
<span class="fc" id="L1343">    }</span>

    /**
     * Get Kernel#gsub is defined or not
     */
    public boolean getKernelGsubDefined() {
<span class="fc" id="L1349">        return kernelGsubDefined;</span>
    }

    /**
     * get whether IPv4 is preferred
     *
     * @see Options#PREFER_IPV4
     */
    public boolean getIPv4Preferred() {
<span class="fc" id="L1358">        return preferIPv4;</span>
    }

    /**
     * get whether uppercase package names will be honored
     */
    public boolean getAllowUppercasePackageNames() {
<span class="nc" id="L1365">        return allowUppercasePackageNames;</span>
    }

    /**
     * set whether uppercase package names will be honored
     */
    public void setAllowUppercasePackageNames(boolean allow) {
<span class="nc" id="L1372">        allowUppercasePackageNames = allow;</span>
<span class="nc" id="L1373">    }</span>

    public String getProfilingService() {
<span class="nc" id="L1376">        return profilingService;</span>
    }

    public void setProfilingService( String service )  {
<span class="nc" id="L1380">        this.profilingService = service;</span>
<span class="nc" id="L1381">    }</span>

    ////////////////////////////////////////////////////////////////////////////
    // Configuration fields.
    ////////////////////////////////////////////////////////////////////////////

    /**
     * Indicates whether the script must be extracted from script source
     */
<span class="pc" id="L1390">    private boolean xFlag = Options.CLI_STRIP_HEADER.load();</span>

    /**
     * Indicates whether the script has a shebang line or not
     */
    private boolean hasShebangLine;
<span class="pc" id="L1396">    private InputStream input          = System.in;</span>
<span class="pc" id="L1397">    private PrintStream output         = System.out;</span>
<span class="pc" id="L1398">    private PrintStream error          = System.err;</span>
<span class="pc" id="L1399">    private Profile profile            = Profile.DEFAULT;</span>
<span class="pc" id="L1400">    private boolean objectSpaceEnabled = Options.OBJECTSPACE_ENABLED.load();</span>
<span class="pc" id="L1401">    private boolean siphashEnabled     = Options.SIPHASH_ENABLED.load();</span>

<span class="pc" id="L1403">    private CompileMode compileMode = CompileMode.OFF;</span>
<span class="pc" id="L1404">    private boolean runRubyInProcess   = true;</span>
    private String currentDirectory;

    /** Environment variables; defaults to System.getenv() in constructor */
    private Map environment;
<span class="pc" id="L1409">    private String[] argv = {};</span>

    private final boolean jitLogging;
    private final boolean jitDumping;
    private final boolean jitLoggingVerbose;
    private int jitLogEvery;
    private int jitThreshold;
    private int jitMax;
    private int jitMaxSize;

<span class="pc" id="L1419">    private String internalEncoding = Options.CLI_ENCODING_INTERNAL.load();</span>
<span class="pc" id="L1420">    private String externalEncoding = Options.CLI_ENCODING_EXTERNAL.load();</span>
<span class="pc" id="L1421">    private String sourceEncoding = Options.CLI_ENCODING_SOURCE.load();</span>

<span class="pc" id="L1423">    private ProfilingMode profilingMode = Options.CLI_PROFILING_MODE.load();</span>
<span class="pc" id="L1424">    private ProfileOutput profileOutput = new ProfileOutput(System.err);</span>
    private String profilingService;

<span class="pc" id="L1427">    private ClassLoader thisLoader = RubyInstanceConfig.class.getClassLoader();</span>
    // thisLoader can be null for example when jruby comes from the boot-classLoader
<span class="pc bpc" id="L1429" title="3 of 4 branches missed.">    private ClassLoader loader = thisLoader == null ? Thread.currentThread().getContextClassLoader() : thisLoader;</span>

    // from CommandlineParser
<span class="pc" id="L1432">    private List&lt;String&gt; loadPaths = new ArrayList&lt;String&gt;();</span>
<span class="pc" id="L1433">    private Set&lt;String&gt; excludedMethods = new HashSet&lt;String&gt;();</span>
<span class="pc" id="L1434">    private StringBuffer inlineScript = new StringBuffer();</span>
<span class="pc" id="L1435">    private boolean hasInlineScript = false;</span>
<span class="pc" id="L1436">    private String scriptFileName = null;</span>
<span class="pc" id="L1437">    private Collection&lt;String&gt; requiredLibraries = new LinkedHashSet&lt;String&gt;();</span>
<span class="pc" id="L1438">    private boolean argvGlobalsOn = false;</span>
<span class="pc" id="L1439">    private boolean assumeLoop = Options.CLI_ASSUME_LOOP.load();</span>
<span class="pc" id="L1440">    private boolean assumePrinting = Options.CLI_ASSUME_PRINT.load();</span>
<span class="pc" id="L1441">    private Map optionGlobals = new HashMap();</span>
<span class="pc" id="L1442">    private boolean processLineEnds = Options.CLI_PROCESS_LINE_ENDS.load();</span>
<span class="pc" id="L1443">    private boolean split = Options.CLI_AUTOSPLIT.load();</span>
<span class="pc" id="L1444">    private Verbosity verbosity = Options.CLI_WARNING_LEVEL.load();</span>
<span class="pc" id="L1445">    private boolean debug = Options.CLI_DEBUG.load();</span>
<span class="pc" id="L1446">    private boolean showVersion = Options.CLI_VERSION.load();</span>
<span class="pc" id="L1447">    private boolean showBytecode = Options.CLI_BYTECODE.load();</span>
<span class="pc" id="L1448">    private boolean showCopyright = Options.CLI_COPYRIGHT.load();</span>
<span class="pc" id="L1449">    private boolean shouldRunInterpreter = true;</span>
<span class="pc" id="L1450">    private boolean shouldPrintUsage = Options.CLI_HELP.load();</span>
<span class="pc" id="L1451">    private boolean shouldPrintProperties=Options.CLI_PROPERTIES.load();</span>
<span class="pc" id="L1452">    private boolean dumpConfig=false;</span>
<span class="pc" id="L1453">    private KCode kcode = Options.CLI_KCODE.load();</span>
<span class="pc" id="L1454">    private String recordSeparator = Options.CLI_RECORD_SEPARATOR.load();</span>
<span class="pc" id="L1455">    private boolean shouldCheckSyntax = Options.CLI_CHECK_SYNTAX.load();</span>
<span class="pc" id="L1456">    private String inputFieldSeparator = Options.CLI_AUTOSPLIT_SEPARATOR.load();</span>
<span class="pc" id="L1457">    private boolean managementEnabled = false;</span>
<span class="pc" id="L1458">    private String inPlaceBackupExtension = Options.CLI_BACKUP_EXTENSION.load();</span>
<span class="pc" id="L1459">    private boolean parserDebug = false;</span>
<span class="pc" id="L1460">    private String threadDumpSignal = null;</span>
<span class="pc" id="L1461">    private boolean hardExit = false;</span>
<span class="pc bpc" id="L1462" title="3 of 4 branches missed.">    private boolean disableGems = !Options.CLI_RUBYGEMS_ENABLE.load();</span>
<span class="pc bpc" id="L1463" title="3 of 4 branches missed.">    private boolean disableRUBYOPT = !Options.CLI_RUBYOPT_ENABLE.load();</span>
<span class="pc" id="L1464">    private boolean updateNativeENVEnabled = true;</span>
    private boolean kernelGsubDefined;
<span class="pc" id="L1466">    private boolean hasScriptArgv = false;</span>
<span class="pc" id="L1467">    private boolean preferIPv4 = Options.PREFER_IPV4.load();</span>

    private String jrubyHome;

    /**
     * Whether native code is enabled for this configuration.
     */
<span class="pc" id="L1474">    private boolean _nativeEnabled = NATIVE_ENABLED;</span>

<span class="pc" id="L1476">    private TraceType traceType =</span>
<span class="pc" id="L1477">            TraceType.traceTypeFor(Options.BACKTRACE_STYLE.load());</span>

<span class="pc" id="L1479">    private boolean backtraceMask = Options.BACKTRACE_MASK.load();</span>

<span class="pc" id="L1481">    private boolean backtraceColor = Options.BACKTRACE_COLOR.load();</span>

<span class="pc" id="L1483">    private LoadServiceCreator creator = LoadServiceCreator.DEFAULT;</span>

<span class="pc" id="L1485">    private boolean globalRequireLock = Options.GLOBAL_REQUIRE_LOCK.load();</span>

<span class="pc" id="L1487">    private boolean jitBackground = Options.JIT_BACKGROUND.load();</span>

<span class="pc" id="L1489">    private boolean loadGemfile = Options.CLI_LOAD_GEMFILE.load();</span>

<span class="pc" id="L1491">    private int profileMaxMethods = Options.PROFILE_MAX_METHODS.load();</span>

<span class="pc" id="L1493">    private boolean allowUppercasePackageNames = Options.JI_UPPER_CASE_PACKAGE_NAME_ALLOWED.load();</span>

<span class="pc" id="L1495">    private boolean forceStdin = false;</span>

    ////////////////////////////////////////////////////////////////////////////
    // Support classes, etc.
    ////////////////////////////////////////////////////////////////////////////

<span class="pc" id="L1501">    public enum Verbosity { NIL, FALSE, TRUE }</span>

    public static interface LoadServiceCreator {
        LoadService create(Ruby runtime);

<span class="fc" id="L1506">        LoadServiceCreator DEFAULT = new LoadServiceCreator() {</span>
                public LoadService create(Ruby runtime) {
<span class="fc" id="L1508">                    return new LoadService(runtime);</span>
                }
            };
    }

<span class="pc" id="L1513">    public enum ProfilingMode {</span>
<span class="fc" id="L1514">		OFF, API, FLAT, GRAPH, HTML, JSON, SERVICE</span>
	}

<span class="pc" id="L1517">    public enum CompileMode {</span>
<span class="fc" id="L1518">        JIT, FORCE, OFF, TRUFFLE;</span>

        public boolean shouldPrecompileCLI() {
<span class="pc bpc" id="L1521" title="3 of 4 branches missed.">            return this == JIT || this == FORCE;</span>
        }

        public boolean shouldJIT() {
<span class="pc bpc" id="L1525" title="3 of 4 branches missed.">            return this == JIT || this == FORCE;</span>
        }

        public boolean shouldPrecompileAll() {
<span class="pc bpc" id="L1529" title="1 of 2 branches missed.">            return this == FORCE;</span>
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // Static configuration fields, used as defaults for new JRuby instances.
    ////////////////////////////////////////////////////////////////////////////

    // NOTE: These BigDecimal fields must be initialized before calls to initGlobalJavaVersion

    /** A BigDecimal representing 1.5, for Java spec version matching */
<span class="fc" id="L1540">    private static final BigDecimal BIGDECIMAL_1_5 = new BigDecimal(&quot;1.5&quot;);</span>
    /** A BigDecimal representing 1.6, for Java spec version matching */
<span class="fc" id="L1542">    private static final BigDecimal BIGDECIMAL_1_6 = new BigDecimal(&quot;1.6&quot;);</span>
    /** A BigDecimal representing 1.7, for Java spec version matching */
<span class="fc" id="L1544">    private static final BigDecimal BIGDECIMAL_1_7 = new BigDecimal(&quot;1.7&quot;);</span>

    /**
     * The version to use for generated classes. Set to current JVM version by default
     */
<span class="fc" id="L1549">    public static final int JAVA_VERSION = initGlobalJavaVersion();</span>

    /**
     * The number of lines at which a method, class, or block body is split into
     * chained methods (to dodge 64k method-size limit in JVM).
     */
<span class="fc" id="L1555">    public static final int CHAINED_COMPILE_LINE_COUNT = Options.COMPILE_CHAINSIZE.load();</span>

    /**
     * Enable compiler peephole optimizations.
     *
     * Set with the &lt;tt&gt;jruby.compile.peephole&lt;/tt&gt; system property.
     */
<span class="fc" id="L1562">    public static final boolean PEEPHOLE_OPTZ = Options.COMPILE_PEEPHOLE.load();</span>

    /**
     * Enable compiler &quot;noguards&quot; optimizations.
     *
     * Set with the &lt;tt&gt;jruby.compile.noguards&lt;/tt&gt; system property.
     */
<span class="fc" id="L1569">    public static boolean NOGUARDS_COMPILE_ENABLED = Options.COMPILE_NOGUARDS.load();</span>

    /**
     * Enable compiler &quot;fastest&quot; set of optimizations.
     *
     * Set with the &lt;tt&gt;jruby.compile.fastest&lt;/tt&gt; system property.
     */
<span class="fc" id="L1576">    public static boolean FASTEST_COMPILE_ENABLED = Options.COMPILE_FASTEST.load();</span>

    /**
     * Enable fast operator compiler optimizations.
     *
     * Set with the &lt;tt&gt;jruby.compile.fastops&lt;/tt&gt; system property.
     */
<span class="pc bpc" id="L1583" title="1 of 2 branches missed.">    public static boolean FASTOPS_COMPILE_ENABLED</span>
<span class="pc bpc" id="L1584" title="1 of 2 branches missed.">            = FASTEST_COMPILE_ENABLED || Options.COMPILE_FASTOPS.load();</span>

    /**
     * Enable &quot;threadless&quot; compile.
     *
     * Set with the &lt;tt&gt;jruby.compile.threadless&lt;/tt&gt; system property.
     */
<span class="pc bpc" id="L1591" title="1 of 2 branches missed.">    public static boolean THREADLESS_COMPILE_ENABLED</span>
<span class="pc bpc" id="L1592" title="1 of 2 branches missed.">            = FASTEST_COMPILE_ENABLED || Options.COMPILE_THREADLESS.load();</span>

    /**
     * Enable &quot;fast send&quot; compiler optimizations.
     *
     * Set with the &lt;tt&gt;jruby.compile.fastsend&lt;/tt&gt; system property.
     */
<span class="pc bpc" id="L1599" title="1 of 2 branches missed.">    public static boolean FASTSEND_COMPILE_ENABLED</span>
<span class="pc bpc" id="L1600" title="1 of 2 branches missed.">            = FASTEST_COMPILE_ENABLED || Options.COMPILE_FASTSEND.load();</span>

    /**
     * Enable lazy handles optimizations.
     *
     * Set with the &lt;tt&gt;jruby.compile.lazyHandles&lt;/tt&gt; system property.
     */
<span class="fc" id="L1607">    public static boolean LAZYHANDLES_COMPILE = Options.COMPILE_LAZYHANDLES.load();</span>

    /**
     * Enable fast multiple assignment optimization.
     *
     * Set with the &lt;tt&gt;jruby.compile.fastMasgn&lt;/tt&gt; system property.
     */
<span class="fc" id="L1614">    public static boolean FAST_MULTIPLE_ASSIGNMENT = Options.COMPILE_FASTMASGN.load();</span>

    /**
     * Enable a thread pool. Each Ruby thread will be mapped onto a thread from this pool.
     *
     * Set with the &lt;tt&gt;jruby.thread.pool.enabled&lt;/tt&gt; system property.
     */
    public static final boolean POOLING_ENABLED = false;

    /**
     * Maximum thread pool size (integer, default Integer.MAX_VALUE).
     *
     * Set with the &lt;tt&gt;jruby.thread.pool.max&lt;/tt&gt; system property.
     */
<span class="fc" id="L1628">    public static final int POOL_MAX = Options.THREADPOOL_MAX.load();</span>
    /**
     * Minimum thread pool size (integer, default 0).
     *
     * Set with the &lt;tt&gt;jruby.thread.pool.min&lt;/tt&gt; system property.
     */
<span class="fc" id="L1634">    public static final int POOL_MIN = Options.THREADPOOL_MIN.load();</span>
    /**
     * Thread pool time-to-live in seconds.
     *
     * Set with the &lt;tt&gt;jruby.thread.pool.max&lt;/tt&gt; system property.
     */
<span class="fc" id="L1640">    public static final int POOL_TTL = Options.THREADPOOL_TTL.load();</span>
    /**
     * Fiber thread pool time-to-live in seconds.
     *
     * Set with the &lt;tt&gt;jruby.fiber.thread.pool.max&lt;/tt&gt; system property.
     */
<span class="fc" id="L1646">    public static final int FIBER_POOL_TTL = Options.FIBER_THREADPOOL_TTL.load();</span>

    /**
     * Enable use of the native Java version of the 'net/protocol' library.
     *
     * Set with the &lt;tt&gt;jruby.thread.pool.max&lt;/tt&gt; system property.
     */
<span class="fc" id="L1653">    public static final boolean NATIVE_NET_PROTOCOL = Options.NATIVE_NET_PROTOCOL.load();</span>

    /**
     * Enable tracing of method calls.
     *
     * Set with the &lt;tt&gt;jruby.debug.fullTrace&lt;/tt&gt; system property.
     */
<span class="fc" id="L1660">    public static boolean FULL_TRACE_ENABLED = Options.DEBUG_FULLTRACE.load();</span>

    /**
     * Comma-separated list of methods to exclude from JIT compilation.
     * Specify as &quot;Module&quot;, &quot;Module#method&quot; or &quot;method&quot;.
     *
     * Set with the &lt;tt&gt;jruby.jit.exclude&lt;/tt&gt; system property.
     */
<span class="fc" id="L1668">    public static final String COMPILE_EXCLUDE = Options.JIT_EXCLUDE.load();</span>

    /**
     * Indicates the global default for whether native code is enabled. Default
     * is true. This value is used to default new runtime configurations.
     *
     * Set with the &lt;tt&gt;jruby.native.enabled&lt;/tt&gt; system property.
     */
<span class="fc" id="L1676">    public static final boolean NATIVE_ENABLED = Options.NATIVE_ENABLED.load();</span>

    @Deprecated
    public final static boolean CEXT_ENABLED = false;

    /**
     * Whether to reify (pre-compile and generate) a Java class per Ruby class.
     *
     * Set with the &lt;tt&gt;jruby.reify.classes&lt;/tt&gt; system property.
     */
<span class="fc" id="L1686">    public static final boolean REIFY_RUBY_CLASSES = Options.REIFY_CLASSES.load();</span>

    /**
     * Log errors that occur during reification.
     *
     * Set with the &lt;tt&gt;jruby.reify.logErrors&lt;/tt&gt; system property.
     */
<span class="fc" id="L1693">    public static final boolean REIFY_LOG_ERRORS = Options.REIFY_LOGERRORS.load();</span>

    /**
     * Whether to use a custom-generated handle for Java methods instead of
     * reflection.
     *
     * Set with the &lt;tt&gt;jruby.java.handles&lt;/tt&gt; system property.
     */
<span class="fc" id="L1701">    public static final boolean USE_GENERATED_HANDLES = Options.JAVA_HANDLES.load();</span>

    /**
     * Turn on debugging of the load service (requires and loads).
     *
     * Set with the &lt;tt&gt;jruby.debug.loadService&lt;/tt&gt; system property.
     */
<span class="fc" id="L1708">    public static final boolean DEBUG_LOAD_SERVICE = Options.DEBUG_LOADSERVICE.load();</span>

    /**
     * Turn on timings of the load service (requires and loads).
     *
     * Set with the &lt;tt&gt;jruby.debug.loadService.timing&lt;/tt&gt; system property.
     */
<span class="fc" id="L1715">    public static final boolean DEBUG_LOAD_TIMINGS = Options.DEBUG_LOADSERVICE_TIMING.load();</span>

    /**
     * Turn on debugging of subprocess launching.
     *
     * Set with the &lt;tt&gt;jruby.debug.launch&lt;/tt&gt; system property.
     */
<span class="fc" id="L1722">    public static final boolean DEBUG_LAUNCHING = Options.DEBUG_LAUNCH.load();</span>

    /**
     * Turn on debugging of script resolution with &quot;-S&quot;.
     *
     * Set with the &lt;tt&gt;jruby.debug.scriptResolution&lt;/tt&gt; system property.
     */
<span class="fc" id="L1729">    public static final boolean DEBUG_SCRIPT_RESOLUTION = Options.DEBUG_SCRIPTRESOLUTION.load();</span>

<span class="fc" id="L1731">    public static final boolean DEBUG_PARSER = Options.DEBUG_PARSER.load();</span>

<span class="fc" id="L1733">    public static final boolean JUMPS_HAVE_BACKTRACE = Options.JUMP_BACKTRACE.load();</span>

<span class="fc" id="L1735">    public static final boolean JIT_CACHE_ENABLED = Options.JIT_CACHE.load();</span>

<span class="fc" id="L1737">    public static final String JIT_CODE_CACHE = Options.JIT_CODECACHE.load();</span>

<span class="fc" id="L1739">    public static final boolean REFLECTED_HANDLES = Options.REFLECTED_HANDLES.load();</span>

<span class="fc" id="L1741">    public static final boolean NO_UNWRAP_PROCESS_STREAMS = Options.PROCESS_NOUNWRAP.load();</span>

<span class="fc" id="L1743">    public static final boolean INTERFACES_USE_PROXY = Options.INTERFACES_USEPROXY.load();</span>

<span class="fc" id="L1745">    public static final boolean JIT_LOADING_DEBUG = Options.JIT_DEBUG.load();</span>

<span class="fc" id="L1747">    public static final boolean CAN_SET_ACCESSIBLE = Options.JI_SETACCESSIBLE.load();</span>

    // properties for logging exceptions, backtraces, and caller invocations
<span class="fc" id="L1750">    public static final boolean LOG_EXCEPTIONS = Options.LOG_EXCEPTIONS.load();</span>
<span class="fc" id="L1751">    public static final boolean LOG_BACKTRACES = Options.LOG_BACKTRACES.load();</span>
<span class="fc" id="L1752">    public static final boolean LOG_CALLERS = Options.LOG_CALLERS.load();</span>
<span class="fc" id="L1753">    public static final boolean LOG_WARNINGS = Options.LOG_WARNINGS.load();</span>

<span class="fc" id="L1755">    public static final boolean ERRNO_BACKTRACE = Options.ERRNO_BACKTRACE.load();</span>
<span class="fc" id="L1756">    public static final boolean STOPITERATION_BACKTRACE = Options.STOPITERATION_BACKTRACE.load();</span>

<span class="fc" id="L1758">    public static boolean IR_DEBUG = Options.IR_DEBUG.load();</span>
<span class="fc" id="L1759">    public static boolean IR_PROFILE = Options.IR_PROFILE.load();</span>
<span class="fc" id="L1760">    public static boolean IR_COMPILER_DEBUG = Options.IR_COMPILER_DEBUG.load();</span>
<span class="fc" id="L1761">    public static boolean IR_WRITING = Options.IR_WRITING.load();</span>
<span class="fc" id="L1762">    public static boolean IR_READING = Options.IR_READING.load();</span>
<span class="fc" id="L1763">    public static boolean IR_READING_DEBUG = Options.IR_READING_DEBUG.load();</span>
<span class="fc" id="L1764">    public static boolean IR_WRITING_DEBUG = Options.IR_WRITING_DEBUG.load();</span>
<span class="fc" id="L1765">    public static boolean IR_VISUALIZER = Options.IR_VISUALIZER.load();</span>
<span class="fc" id="L1766">    public static boolean IR_UNBOXING = Options.IR_UNBOXING.load();</span>
<span class="fc" id="L1767">    public static String IR_COMPILER_PASSES = Options.IR_COMPILER_PASSES.load();</span>
<span class="fc" id="L1768">    public static String IR_JIT_PASSES = Options.IR_JIT_PASSES.load();</span>
<span class="fc" id="L1769">    public static String IR_INLINE_COMPILER_PASSES = Options.IR_INLINE_COMPILER_PASSES.load();</span>

<span class="pc" id="L1771">    private TruffleHooksStub truffleHooks = null;</span>

<span class="fc" id="L1773">    public static final boolean COROUTINE_FIBERS = Options.FIBER_COROUTINES.load();</span>

    /**
     * Whether to calculate consistent hashes across JVM instances, or to ensure
     * un-predicatable hash values using SecureRandom.
     *
     * Set with the &lt;tt&gt;jruby.consistent.hashing.enabled&lt;/tt&gt; system property.
     */
<span class="fc" id="L1781">    public static final boolean CONSISTENT_HASHING_ENABLED = Options.CONSISTENT_HASHING.load();</span>

<span class="fc" id="L1783">    private static volatile boolean loadedNativeExtensions = false;</span>

    ////////////////////////////////////////////////////////////////////////////
    // Static initializers
    ////////////////////////////////////////////////////////////////////////////

    private static int initGlobalJavaVersion() {
<span class="fc" id="L1790">        String specVersion = Options.BYTECODE_VERSION.load();</span>

        // stack map calculation is failing for some compilation scenarios, so
        // forcing both 1.5 and 1.6 to use 1.5 bytecode for the moment.
<span class="pc bpc" id="L1794" title="1 of 2 branches missed.">        if (specVersion.equals(&quot;1.5&quot;)) {// || specVersion.equals(&quot;1.6&quot;)) {</span>
<span class="nc" id="L1795">           return Opcodes.V1_5;</span>
<span class="pc bpc" id="L1796" title="1 of 2 branches missed.">        } else if (specVersion.equals(&quot;1.6&quot;)) {</span>
<span class="nc" id="L1797">            return Opcodes.V1_6;</span>
<span class="pc bpc" id="L1798" title="2 of 4 branches missed.">        } else if (specVersion.equals(&quot;1.7&quot;) || specVersion.equals(&quot;1.8&quot;)) {</span>
<span class="fc" id="L1799">            return Opcodes.V1_7;</span>
        } else {
<span class="nc" id="L1801">            System.err.println(&quot;unsupported Java version \&quot;&quot; + specVersion + &quot;\&quot;, defaulting to 1.5&quot;);</span>
<span class="nc" id="L1802">            return Opcodes.V1_5;</span>
        }
    }
    public void setTruffleHooks(TruffleHooksStub truffleHooks) {
<span class="nc" id="L1806">        this.truffleHooks = truffleHooks;</span>
<span class="nc" id="L1807">    }</span>

    public TruffleHooksStub getTruffleHooks() {
<span class="nc" id="L1810">        return truffleHooks;</span>
    }

    @Deprecated
    public void setSafeLevel(int safeLevel) {
<span class="nc" id="L1815">    }</span>

    @Deprecated
    public String getInPlaceBackupExtention() {
<span class="nc" id="L1819">        return inPlaceBackupExtension;</span>
    }

    @Deprecated
    public String getBasicUsageHelp() {
<span class="nc" id="L1824">        return OutputStrings.getBasicUsageHelp();</span>
    }

    @Deprecated
    public String getExtendedHelp() {
<span class="nc" id="L1829">        return OutputStrings.getExtendedHelp();</span>
    }

    @Deprecated
    public String getPropertyHelp() {
<span class="nc" id="L1834">        return OutputStrings.getPropertyHelp();</span>
    }

    @Deprecated
    public String getVersionString() {
<span class="nc" id="L1839">        return OutputStrings.getVersionString();</span>
    }

    @Deprecated
    public String getCopyrightString() {
<span class="nc" id="L1844">        return OutputStrings.getCopyrightString();</span>
    }

    @Deprecated
    public Collection&lt;String&gt; requiredLibraries() {
<span class="nc" id="L1849">        return requiredLibraries;</span>
    }

    @Deprecated
    public List&lt;String&gt; loadPaths() {
<span class="nc" id="L1854">        return loadPaths;</span>
    }

    @Deprecated
    public boolean shouldPrintUsage() {
<span class="nc" id="L1859">        return shouldPrintUsage;</span>
    }

    @Deprecated
    public boolean shouldPrintProperties() {
<span class="nc" id="L1864">        return shouldPrintProperties;</span>
    }

    @Deprecated
    public Boolean getVerbose() {
<span class="nc" id="L1869">        return isVerbose();</span>
    }

    @Deprecated
    public boolean shouldRunInterpreter() {
<span class="nc" id="L1874">        return isShouldRunInterpreter();</span>
    }

    @Deprecated
    public boolean isShouldRunInterpreter() {
<span class="nc" id="L1879">        return shouldRunInterpreter;</span>
    }

    @Deprecated
    public boolean isxFlag() {
<span class="nc" id="L1884">        return xFlag;</span>
    }

    /**
     * The max count of active methods eligible for JIT-compilation.
     */
    @Deprecated
    public static final int JIT_MAX_METHODS_LIMIT = Constants.JIT_MAX_METHODS_LIMIT;

    /**
     * The max size of JIT-compiled methods (full class size) allowed.
     */
    @Deprecated
    public static final int JIT_MAX_SIZE_LIMIT = Constants.JIT_MAX_SIZE_LIMIT;

    /**
     * The JIT threshold to the specified method invocation count.
     */
    @Deprecated
    public static final int JIT_THRESHOLD = Constants.JIT_THRESHOLD;

    /**
     * Default size for chained compilation.
     */
    @Deprecated
    public static final int CHAINED_COMPILE_LINE_COUNT_DEFAULT = Constants.CHAINED_COMPILE_LINE_COUNT_DEFAULT;

    @Deprecated
<span class="fc" id="L1912">    public static final boolean nativeEnabled = NATIVE_ENABLED;</span>

    @Deprecated
    public boolean isSamplingEnabled() {
<span class="nc" id="L1916">        return false;</span>
    }

    @Deprecated
    public void setBenchmarking(boolean benchmarking) {
<span class="nc" id="L1921">    }</span>

    @Deprecated
    public boolean isBenchmarking() {
<span class="nc" id="L1925">        return false;</span>
    }

    @Deprecated
    public void setCextEnabled(boolean b) {
<span class="nc" id="L1930">    }</span>

    @Deprecated
    public boolean isCextEnabled() {
<span class="nc" id="L1934">        return false;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>