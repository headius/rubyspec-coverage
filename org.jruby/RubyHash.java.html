<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RubyHash.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby</a> &gt; <span class="el_source">RubyHash.java</span></div><h1>RubyHash.java</h1><pre class="source lang-java linenums">/***** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2001 Chad Fowler &lt;chadfowler@chadfowler.com&gt;
 * Copyright (C) 2001 Alan Moore &lt;alan_moore@gmx.net&gt;
 * Copyright (C) 2001-2002 Benoit Cerrina &lt;b.cerrina@wanadoo.fr&gt;
 * Copyright (C) 2001-2004 Jan Arne Petersen &lt;jpetersen@uni-bonn.de&gt;
 * Copyright (C) 2002-2004 Anders Bengtsson &lt;ndrsbngtssn@yahoo.se&gt;
 * Copyright (C) 2004-2006 Thomas E Enebo &lt;enebo@acm.org&gt;
 * Copyright (C) 2004 Stefan Matthias Aust &lt;sma@3plus4.de&gt;
 * Copyright (C) 2005 Charles O Nutter &lt;headius@headius.com&gt;
 * Copyright (C) 2006 Ola Bini &lt;Ola.Bini@ki.se&gt;
 * Copyright (C) 2006 Tim Azzopardi &lt;tim@tigerfive.com&gt;
 * Copyright (C) 2006 Miguel Covarrubias &lt;mlcovarrubias@gmail.com&gt;
 * Copyright (C) 2007 MenTaLguY &lt;mental@rydia.net&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby;

import static org.jruby.RubyEnumerator.enumeratorize;

import org.jcodings.specific.USASCIIEncoding;
import org.jruby.anno.JRubyClass;
import org.jruby.anno.JRubyMethod;
import org.jruby.common.IRubyWarnings.ID;
import org.jruby.exceptions.RaiseException;
import org.jruby.javasupport.JavaUtil;
import org.jruby.runtime.Arity;
import org.jruby.runtime.Block;
import org.jruby.runtime.ClassIndex;
import org.jruby.runtime.Helpers;
import org.jruby.runtime.ObjectAllocator;
import org.jruby.runtime.ThreadContext;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.runtime.invokedynamic.MethodNames;
import org.jruby.runtime.marshal.MarshalStream;
import org.jruby.runtime.marshal.UnmarshalStream;
import org.jruby.util.RecursiveComparator;
import org.jruby.util.TypeConverter;

import java.io.IOException;
import java.util.AbstractCollection;
import java.util.AbstractSet;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;

import static org.jruby.RubyEnumerator.enumeratorizeWithSize;
import static org.jruby.runtime.Helpers.invokedynamic;
import static org.jruby.runtime.Visibility.PRIVATE;
import static org.jruby.runtime.invokedynamic.MethodNames.DEFAULT;
import static org.jruby.runtime.invokedynamic.MethodNames.HASH;
import static org.jruby.RubyEnumerator.SizeFn;

// Design overview:
//
// RubyHash is implemented as hash table with a singly-linked list of
// RubyHash.RubyHashEntry objects for each bucket.  RubyHashEntry objects
// are also kept in a doubly-linked list which reflects their insertion
// order and is used for iteration.  For simplicity, this latter list is
// circular; a dummy RubyHashEntry, RubyHash.head, is used to mark the
// ends of the list.
//
// When an entry is removed from the table, it is also removed from the
// doubly-linked list.  However, while the reference to the previous
// RubyHashEntry is cleared (to mark the entry as dead), the reference
// to the next RubyHashEntry is preserved so that iterators are not
// invalidated: any iterator with a reference to a dead entry can climb
// back up into the list of live entries by chasing next references until
// it finds a live entry (or head).
//
// Ordinarily, this scheme would require O(N) time to clear a hash (since
// each RubyHashEntry would need to be visited and unlinked from the
// iteration list), but RubyHash also maintains a generation count.  Every
// time the hash is cleared, the doubly-linked list is simply discarded and
// the generation count incremented.  Iterators check to see whether the
// generation count has changed; if it has, they reset themselves back to
// the new start of the list.
//
// This design means that iterators are never invalidated by changes to the
// hashtable, and they do not need to modify the structure during their
// lifecycle.
//

/** Implementation of the Hash class.
 *
 *  Concurrency: no synchronization is required among readers, but
 *  all users must synchronize externally with writers.
 *
 */
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">@JRubyClass(name = &quot;Hash&quot;, include=&quot;Enumerable&quot;)</span>
public class RubyHash extends RubyObject implements Map {
    public static final int DEFAULT_INSPECT_STR_SIZE = 20;

    public static RubyClass createHashClass(Ruby runtime) {
<span class="fc" id="L120">        RubyClass hashc = runtime.defineClass(&quot;Hash&quot;, runtime.getObject(), HASH_ALLOCATOR);</span>
<span class="fc" id="L121">        runtime.setHash(hashc);</span>

<span class="fc" id="L123">        hashc.setClassIndex(ClassIndex.HASH);</span>
<span class="fc" id="L124">        hashc.setReifiedClass(RubyHash.class);</span>
        
<span class="fc" id="L126">        hashc.kindOf = new RubyModule.JavaClassKindOf(RubyHash.class);</span>

<span class="fc" id="L128">        hashc.includeModule(runtime.getEnumerable());</span>

<span class="fc" id="L130">        hashc.defineAnnotatedMethods(RubyHash.class);</span>

<span class="fc" id="L132">        return hashc;</span>
    }

<span class="fc" id="L135">    private final static ObjectAllocator HASH_ALLOCATOR = new ObjectAllocator() {</span>
        @Override
        public IRubyObject allocate(Ruby runtime, RubyClass klass) {
<span class="fc" id="L138">            return new RubyHash(runtime, klass);</span>
        }
    };

    @Override
    public ClassIndex getNativeClassIndex() {
<span class="fc" id="L144">        return ClassIndex.HASH;</span>
    }

    /** rb_hash_s_create
     *
     */
    @JRubyMethod(name = &quot;[]&quot;, rest = true, meta = true)
    public static IRubyObject create(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="fc" id="L152">        RubyClass klass = (RubyClass) recv;</span>
<span class="fc" id="L153">        Ruby runtime = context.runtime;</span>
        RubyHash hash;

<span class="fc bfc" id="L156" title="All 2 branches covered.">        if (args.length == 1) {</span>
<span class="fc" id="L157">            IRubyObject tmp = TypeConverter.convertToTypeWithCheck(</span>
<span class="fc" id="L158">                    args[0], runtime.getHash(), &quot;to_hash&quot;);</span>

<span class="fc bfc" id="L160" title="All 2 branches covered.">            if (!tmp.isNil()) {</span>
<span class="fc" id="L161">                RubyHash otherHash = (RubyHash) tmp;</span>
<span class="fc" id="L162">                return new RubyHash(runtime, klass, otherHash);</span>
            }

<span class="fc" id="L165">            tmp = TypeConverter.convertToTypeWithCheck(args[0], runtime.getArray(), &quot;to_ary&quot;);</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">            if (!tmp.isNil()) {</span>
<span class="fc" id="L167">                hash = (RubyHash)klass.allocate();</span>
<span class="fc" id="L168">                RubyArray arr = (RubyArray)tmp;</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">                for(int i = 0, j = arr.getLength(); i&lt;j; i++) {</span>
<span class="fc" id="L170">                    IRubyObject v = TypeConverter.convertToTypeWithCheck(arr.entry(i), runtime.getArray(), &quot;to_ary&quot;);</span>
                    IRubyObject key;
<span class="fc" id="L172">                    IRubyObject val = runtime.getNil();</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">                    if(v.isNil()) {</span>
<span class="fc" id="L174">                        continue;</span>
                    }
<span class="pc bpc" id="L176" title="1 of 3 branches missed.">                    switch(((RubyArray)v).getLength()) {</span>
                    case 2:
<span class="fc" id="L178">                        val = ((RubyArray)v).entry(1);</span>
                    case 1:
<span class="fc" id="L180">                        key = ((RubyArray)v).entry(0);</span>
<span class="fc" id="L181">                        hash.fastASet(key, val);</span>
                    }
                }
<span class="fc" id="L184">                return hash;</span>
            }
        }

<span class="fc bfc" id="L188" title="All 2 branches covered.">        if ((args.length &amp; 1) != 0) {</span>
<span class="fc" id="L189">            throw runtime.newArgumentError(&quot;odd number of arguments for Hash&quot;);</span>
        }

<span class="fc" id="L192">        hash = (RubyHash)klass.allocate();</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">        for (int i=0; i &lt; args.length; i+=2) hash.op_aset(context, args[i], args[i+1]);</span>

<span class="fc" id="L195">        return hash;</span>
    }

    @JRubyMethod(name = &quot;try_convert&quot;, meta = true)
    public static IRubyObject try_convert(ThreadContext context, IRubyObject recv, IRubyObject args) {
<span class="fc" id="L200">        return TypeConverter.convertToTypeWithCheck(args, context.runtime.getHash(), &quot;to_hash&quot;);</span>
    }

    /** rb_hash_new
     *
     */
    public static final RubyHash newHash(Ruby runtime) {
<span class="fc" id="L207">        return new RubyHash(runtime);</span>
    }

    /** rb_hash_new
     *
     */
    public static final RubyHash newSmallHash(Ruby runtime) {
<span class="fc" id="L214">        return new RubyHash(runtime, 1);</span>
    }

    /** rb_hash_new
     *
     */
    public static final RubyHash newHash(Ruby runtime, Map valueMap, IRubyObject defaultValue) {
<span class="nc bnc" id="L221" title="All 4 branches missed.">        assert defaultValue != null;</span>

<span class="nc" id="L223">        return new RubyHash(runtime, valueMap, defaultValue);</span>
    }

    private RubyHashEntry[] table;
<span class="fc" id="L227">    protected int size = 0;</span>
    private int threshold;

    private static final int PROCDEFAULT_HASH_F = 1 &lt;&lt; 10;

    private IRubyObject ifNone;

    private RubyHash(Ruby runtime, RubyClass klass, RubyHash other) {
<span class="fc" id="L235">        super(runtime, klass);</span>
<span class="fc" id="L236">        this.ifNone = runtime.getNil();</span>
<span class="fc" id="L237">        threshold = INITIAL_THRESHOLD;</span>
<span class="fc" id="L238">        table = other.internalCopyTable(head);</span>
<span class="fc" id="L239">        size = other.size;</span>
<span class="fc" id="L240">    }</span>

    public RubyHash(Ruby runtime, RubyClass klass) {
<span class="fc" id="L243">        super(runtime, klass);</span>
<span class="fc" id="L244">        this.ifNone = runtime.getNil();</span>
<span class="fc" id="L245">        allocFirst();</span>
<span class="fc" id="L246">    }</span>

    public RubyHash(Ruby runtime, int buckets) {
<span class="fc" id="L249">        this(runtime, runtime.getNil(), buckets);</span>
<span class="fc" id="L250">    }</span>

    public RubyHash(Ruby runtime) {
<span class="fc" id="L253">        this(runtime, runtime.getNil());</span>
<span class="fc" id="L254">    }</span>

    public RubyHash(Ruby runtime, IRubyObject defaultValue) {
<span class="fc" id="L257">        super(runtime, runtime.getHash());</span>
<span class="fc" id="L258">        this.ifNone = defaultValue;</span>
<span class="fc" id="L259">        allocFirst();</span>
<span class="fc" id="L260">    }</span>

    public RubyHash(Ruby runtime, IRubyObject defaultValue, int buckets) {
<span class="fc" id="L263">        super(runtime, runtime.getHash());</span>
<span class="fc" id="L264">        this.ifNone = defaultValue;</span>
<span class="fc" id="L265">        allocFirst(buckets);</span>
<span class="fc" id="L266">    }</span>

    /*
     *  Constructor for internal usage (mainly for Array#|, Array#&amp;, Array#- and Array#uniq)
     *  it doesn't initialize ifNone field
     */
    RubyHash(Ruby runtime, boolean objectSpace) {
<span class="fc" id="L273">        super(runtime, runtime.getHash(), objectSpace);</span>
<span class="fc" id="L274">        allocFirst();</span>
<span class="fc" id="L275">    }</span>

    // TODO should this be deprecated ? (to be efficient, internals should deal with RubyHash directly)
    public RubyHash(Ruby runtime, Map valueMap, IRubyObject defaultValue) {
<span class="fc" id="L279">        super(runtime, runtime.getHash());</span>
<span class="fc" id="L280">        this.ifNone = defaultValue;</span>
<span class="fc" id="L281">        allocFirst();</span>

<span class="fc bfc" id="L283" title="All 2 branches covered.">        for (Iterator iter = valueMap.entrySet().iterator();iter.hasNext();) {</span>
<span class="fc" id="L284">            Map.Entry e = (Map.Entry)iter.next();</span>
<span class="fc" id="L285">            internalPut((IRubyObject)e.getKey(), (IRubyObject)e.getValue());</span>
<span class="fc" id="L286">        }</span>
<span class="fc" id="L287">    }</span>

    private final void allocFirst() {
<span class="fc" id="L290">        threshold = INITIAL_THRESHOLD;</span>
<span class="fc" id="L291">        table = new RubyHashEntry[MRI_HASH_RESIZE ? MRI_INITIAL_CAPACITY : JAVASOFT_INITIAL_CAPACITY];</span>
<span class="fc" id="L292">    }</span>

    private final void allocFirst(int buckets) {
<span class="fc" id="L295">        threshold = INITIAL_THRESHOLD;</span>
<span class="fc" id="L296">        table = new RubyHashEntry[buckets];</span>
<span class="fc" id="L297">    }</span>

    private final void alloc() {
<span class="fc" id="L300">        generation++;</span>
<span class="fc" id="L301">        head.prevAdded = head.nextAdded = head;</span>
<span class="fc" id="L302">        allocFirst();</span>
<span class="fc" id="L303">    }</span>

    private final void alloc(int buckets) {
<span class="nc" id="L306">        generation++;</span>
<span class="nc" id="L307">        head.prevAdded = head.nextAdded = head;</span>
<span class="nc" id="L308">        allocFirst(buckets);</span>
<span class="nc" id="L309">    }</span>

    /* ============================
     * Here are hash internals
     * (This could be extracted to a separate class but it's not too large though)
     * ============================
     */

<span class="fc" id="L317">    public static final int MRI_PRIMES[] = {</span>
        8 + 3, 16 + 3, 32 + 5, 64 + 3, 128 + 3, 256 + 27, 512 + 9, 1024 + 9, 2048 + 5, 4096 + 3,
        8192 + 27, 16384 + 43, 32768 + 3, 65536 + 45, 131072 + 29, 262144 + 3, 524288 + 21, 1048576 + 7,
        2097152 + 17, 4194304 + 15, 8388608 + 9, 16777216 + 43, 33554432 + 35, 67108864 + 15,
        134217728 + 29, 268435456 + 3, 536870912 + 11, 1073741824 + 85, 0
    };

    private static final int JAVASOFT_INITIAL_CAPACITY = 8; // 16 ?
<span class="fc" id="L325">    private static final int MRI_INITIAL_CAPACITY = MRI_PRIMES[0];</span>

    private static final int INITIAL_THRESHOLD = JAVASOFT_INITIAL_CAPACITY - (JAVASOFT_INITIAL_CAPACITY &gt;&gt; 2);
    private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

<span class="fc" id="L330">    public static final RubyHashEntry NO_ENTRY = new RubyHashEntry();</span>
<span class="fc" id="L331">    private int generation = 0; // generation count for O(1) clears</span>
<span class="fc" id="L332">    private final RubyHashEntry head = new RubyHashEntry();</span>

<span class="fc" id="L334">    { head.prevAdded = head.nextAdded = head; }</span>

    public static final class RubyHashEntry implements Map.Entry {
        private IRubyObject key;
        private IRubyObject value;
        private RubyHashEntry next;
        private RubyHashEntry prevAdded;
        private RubyHashEntry nextAdded;
        private int hash;

<span class="fc" id="L344">        RubyHashEntry() {</span>
<span class="fc" id="L345">            key = NEVER;</span>
<span class="fc" id="L346">        }</span>

<span class="fc" id="L348">        public RubyHashEntry(int h, IRubyObject k, IRubyObject v, RubyHashEntry e, RubyHashEntry head) {</span>
<span class="fc" id="L349">            key = k; value = v; next = e; hash = h;</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">            if (head != null) {</span>
<span class="fc" id="L351">                prevAdded = head.prevAdded;</span>
<span class="fc" id="L352">                nextAdded = head;</span>
<span class="fc" id="L353">                nextAdded.prevAdded = this;</span>
<span class="fc" id="L354">                prevAdded.nextAdded = this;</span>
            }
<span class="fc" id="L356">        }</span>

        public void detach() {
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">            if (prevAdded != null) {</span>
<span class="fc" id="L360">                prevAdded.nextAdded = nextAdded;</span>
<span class="fc" id="L361">                nextAdded.prevAdded = prevAdded;</span>
<span class="fc" id="L362">                prevAdded = null;</span>
            }
<span class="fc" id="L364">        }</span>

        public boolean isLive() {
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">            return prevAdded != null;</span>
        }

        @Override
        public Object getKey() {
<span class="fc" id="L372">            return key;</span>
        }
        public Object getJavaifiedKey(){
<span class="nc" id="L375">            return key.toJava(Object.class);</span>
        }

        @Override
        public Object getValue() {
<span class="fc" id="L380">            return value;</span>
        }
        public Object getJavaifiedValue() {
<span class="nc" id="L383">            return value.toJava(Object.class);</span>
        }

        @Override
        public Object setValue(Object value) {
<span class="nc" id="L388">            IRubyObject oldValue = this.value;</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">            if (value instanceof IRubyObject) {</span>
<span class="nc" id="L390">                this.value = (IRubyObject)value;</span>
            } else {
<span class="nc" id="L392">                throw new UnsupportedOperationException(&quot;directEntrySet() doesn't support setValue for non IRubyObject instance entries, convert them manually or use entrySet() instead&quot;);</span>
            }
<span class="nc" id="L394">            return oldValue;</span>
        }

        @Override
        public boolean equals(Object other){
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">            if(!(other instanceof RubyHashEntry)) return false;</span>
<span class="fc" id="L400">            RubyHashEntry otherEntry = (RubyHashEntry)other;</span>
            
<span class="pc bpc" id="L402" title="4 of 6 branches missed.">            return (key == otherEntry.key || key.eql(otherEntry.key)) &amp;&amp;</span>
<span class="pc bnc" id="L403" title="All 2 branches missed.">                    (value == otherEntry.value || value.equals(otherEntry.value));</span>
        }

        @Override
        public int hashCode(){
<span class="nc" id="L408">            return key.hashCode() ^ value.hashCode();</span>
        }
    }

    private static int JavaSoftHashValue(int h) {
<span class="nc" id="L413">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span>
<span class="nc" id="L414">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span>
    }

    private static int JavaSoftBucketIndex(final int h, final int length) {
<span class="nc" id="L418">        return h &amp; (length - 1);</span>
    }

    private static int MRIHashValue(int h) {
<span class="fc" id="L422">        return h &amp; HASH_SIGN_BIT_MASK;</span>
    }

    private static final int HASH_SIGN_BIT_MASK = ~(1 &lt;&lt; 31);
    private static int MRIBucketIndex(final int h, final int length) {
<span class="fc" id="L427">        return ((h &amp; HASH_SIGN_BIT_MASK) % length);</span>
    }

    private final synchronized void resize(int newCapacity) {
<span class="fc" id="L431">        final RubyHashEntry[] oldTable = table;</span>
<span class="fc" id="L432">        final RubyHashEntry[] newTable = new RubyHashEntry[newCapacity];</span>
        
<span class="fc bfc" id="L434" title="All 2 branches covered.">        for (int j = 0; j &lt; oldTable.length; j++) {</span>
<span class="fc" id="L435">            RubyHashEntry entry = oldTable[j];</span>
<span class="fc" id="L436">            oldTable[j] = null;</span>
            
<span class="fc bfc" id="L438" title="All 2 branches covered.">            while (entry != null) {</span>
<span class="fc" id="L439">                RubyHashEntry next = entry.next;</span>
<span class="fc" id="L440">                int i = bucketIndex(entry.hash, newCapacity);</span>
<span class="fc" id="L441">                entry.next = newTable[i];</span>
<span class="fc" id="L442">                newTable[i] = entry;</span>
<span class="fc" id="L443">                entry = next;</span>
<span class="fc" id="L444">            }</span>
        }
        
<span class="fc" id="L447">        table = newTable;</span>
<span class="fc" id="L448">    }</span>

    private final void JavaSoftCheckResize() {
<span class="nc bnc" id="L451" title="All 2 branches missed.">        if (overThreshold()) {</span>
<span class="nc" id="L452">            RubyHashEntry[] tbl = table;</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">            if (tbl.length == MAXIMUM_CAPACITY) {</span>
<span class="nc" id="L454">                threshold = Integer.MAX_VALUE;</span>
<span class="nc" id="L455">                return;</span>
            }
<span class="nc" id="L457">            resizeAndAdjustThreshold(table);</span>
        }
<span class="nc" id="L459">    }</span>
    
    private boolean overThreshold() {
<span class="nc bnc" id="L462" title="All 2 branches missed.">        return size &gt; threshold;</span>
    }
    
    private void resizeAndAdjustThreshold(RubyHashEntry[] oldTable) {
<span class="nc" id="L466">        int newCapacity = oldTable.length &lt;&lt; 1;</span>
<span class="nc" id="L467">        resize(newCapacity);</span>
<span class="nc" id="L468">        threshold = newCapacity - (newCapacity &gt;&gt; 2);</span>
<span class="nc" id="L469">    }</span>

    private static final int MIN_CAPA = 8;
    private static final int ST_DEFAULT_MAX_DENSITY = 5;
    private final void MRICheckResize() {
<span class="fc bfc" id="L474" title="All 2 branches covered.">        if (size / table.length &gt; ST_DEFAULT_MAX_DENSITY) {</span>
<span class="fc" id="L475">            int forSize = table.length + 1; // size + 1;</span>
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">            for (int i=0, newCapacity = MIN_CAPA; i &lt; MRI_PRIMES.length; i++, newCapacity &lt;&lt;= 1) {</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">                if (newCapacity &gt; forSize) {</span>
<span class="fc" id="L478">                    resize(MRI_PRIMES[i]);</span>
<span class="fc" id="L479">                    return;</span>
                }
            }
<span class="nc" id="L482">            return; // suboptimal for large hashes (&gt; 1073741824 + 85 entries) not very likely to happen</span>
        }
<span class="fc" id="L484">    }</span>
    // ------------------------------
    private static final boolean MRI_HASH = true;
    private static final boolean MRI_HASH_RESIZE = true;

    protected static int hashValue(final int h) {
<span class="fc" id="L490">        return MRI_HASH ? MRIHashValue(h) : JavaSoftHashValue(h);</span>
    }

    private static int bucketIndex(final int h, final int length) {
<span class="fc" id="L494">        return MRI_HASH ? MRIBucketIndex(h, length) : JavaSoftBucketIndex(h, length);</span>
    }

    private void checkResize() {
<span class="fc" id="L498">        if (MRI_HASH_RESIZE) MRICheckResize(); else JavaSoftCheckResize();</span>
<span class="fc" id="L499">    }</span>

    private void checkIterating() {
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">        if (iteratorCount &gt; 0) {</span>
<span class="nc" id="L503">            throw getRuntime().newRuntimeError(&quot;can't add a new key into hash during iteration&quot;);</span>
        }
<span class="fc" id="L505">    }</span>
    // ------------------------------
<span class="fc" id="L507">    public static long collisions = 0;</span>

    // put implementation

    private final void internalPut(final IRubyObject key, final IRubyObject value) {
<span class="fc" id="L512">        internalPut(key, value, true);</span>
<span class="fc" id="L513">    }</span>

    private final void internalPutSmall(final IRubyObject key, final IRubyObject value) {
<span class="nc" id="L516">        internalPutSmall(key, value, true);</span>
<span class="nc" id="L517">    }</span>

    protected void internalPut(final IRubyObject key, final IRubyObject value, final boolean checkForExisting) {
<span class="fc" id="L520">        checkResize();</span>

<span class="fc" id="L522">        internalPutSmall(key, value, checkForExisting);</span>
<span class="fc" id="L523">    }</span>

    protected void internalPutSmall(final IRubyObject key, final IRubyObject value, final boolean checkForExisting) {
<span class="fc" id="L526">        final int hash = hashValue(key.hashCode());</span>
<span class="fc" id="L527">        final int i = bucketIndex(hash, table.length);</span>

        // if (table[i] != null) collisions++;

<span class="fc bfc" id="L531" title="All 2 branches covered.">        if (checkForExisting) {</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">            for (RubyHashEntry entry = table[i]; entry != null; entry = entry.next) {</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">                if (internalKeyExist(entry, hash, key)) {</span>
<span class="fc" id="L534">                    entry.value = value;</span>
<span class="fc" id="L535">                    return;</span>
                }
            }
        }

<span class="fc" id="L540">        checkIterating();</span>

<span class="fc" id="L542">        table[i] = new RubyHashEntry(hash, key, value, table[i], head);</span>
<span class="fc" id="L543">        size++;</span>
<span class="fc" id="L544">    }</span>

    // get implementation

    protected IRubyObject internalGet(IRubyObject key) { // specialized for value
<span class="fc" id="L549">        return internalGetEntry(key).value;</span>
    }

    protected RubyHashEntry internalGetEntry(IRubyObject key) {
<span class="fc bfc" id="L553" title="All 2 branches covered.">        if (size == 0) return NO_ENTRY;</span>

<span class="fc" id="L555">        final int hash = hashValue(key.hashCode());</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">        for (RubyHashEntry entry = table[bucketIndex(hash, table.length)]; entry != null; entry = entry.next) {</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">            if (internalKeyExist(entry, hash, key)) {</span>
<span class="fc" id="L558">                return entry;</span>
            }
        }
<span class="fc" id="L561">        return NO_ENTRY;</span>
    }

    private boolean internalKeyExist(RubyHashEntry entry, int hash, IRubyObject key) {
<span class="fc bfc" id="L565" title="All 2 branches covered.">        return (entry.hash == hash</span>
<span class="fc bfc" id="L566" title="All 6 branches covered.">            &amp;&amp; (entry.key == key || (!isComparedByIdentity() &amp;&amp; key.eql(entry.key))));</span>
    }

    // delete implementation


    protected RubyHashEntry internalDelete(final IRubyObject key) {
<span class="fc bfc" id="L573" title="All 2 branches covered.">        if (size == 0) return NO_ENTRY;</span>

<span class="fc" id="L575">        return internalDelete(hashValue(key.hashCode()), MATCH_KEY, key);</span>
    }

    protected RubyHashEntry internalDeleteEntry(final RubyHashEntry entry) {
        // n.b. we need to recompute the hash in case the key object was modified
<span class="fc" id="L580">        return internalDelete(hashValue(entry.key.hashCode()), MATCH_ENTRY, entry);</span>
    }

    private final RubyHashEntry internalDelete(final int hash, final EntryMatchType matchType, final Object obj) {
<span class="fc" id="L584">        final int i = bucketIndex(hash, table.length);</span>

<span class="fc" id="L586">        RubyHashEntry entry = table[i];</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">        if (entry != null) {</span>
<span class="fc" id="L588">            RubyHashEntry prior = null;</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">            for (; entry != null; prior = entry, entry = entry.next) {</span>
<span class="fc bfc" id="L590" title="All 4 branches covered.">                if (entry.hash == hash &amp;&amp; matchType.matches(entry, obj)) {</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">                    if (prior != null) {</span>
<span class="fc" id="L592">                        prior.next = entry.next;</span>
                    } else {
<span class="fc" id="L594">                        table[i] = entry.next;</span>
                    }
<span class="fc" id="L596">                    entry.detach();</span>
<span class="fc" id="L597">                    size--;</span>
<span class="fc" id="L598">                    return entry;</span>
                }
            }
        }

<span class="fc" id="L603">        return NO_ENTRY;</span>
    }

<span class="fc" id="L606">    private static abstract class EntryMatchType {</span>
        public abstract boolean matches(final RubyHashEntry entry, final Object obj);
    }

<span class="fc" id="L610">    private static final EntryMatchType MATCH_KEY = new EntryMatchType() {</span>
        @Override
        public boolean matches(final RubyHashEntry entry, final Object obj) {
<span class="fc" id="L613">            final IRubyObject key = entry.key;</span>
<span class="fc bfc" id="L614" title="All 4 branches covered.">            return obj == key || (((IRubyObject)obj).eql(key));</span>
        }
    };

<span class="fc" id="L618">    private static final EntryMatchType MATCH_ENTRY = new EntryMatchType() {</span>
        @Override
        public boolean matches(final RubyHashEntry entry, final Object obj) {
<span class="fc" id="L621">            return entry.equals(obj);</span>
        }
    };

    private final RubyHashEntry[] internalCopyTable(RubyHashEntry destHead) {
<span class="fc" id="L626">         RubyHashEntry[]newTable = new RubyHashEntry[table.length];</span>

<span class="fc bfc" id="L628" title="All 2 branches covered.">         for (RubyHashEntry entry = head.nextAdded; entry != head; entry = entry.nextAdded) {</span>
<span class="fc" id="L629">             int i = bucketIndex(entry.hash, table.length);</span>
<span class="fc" id="L630">             newTable[i] = new RubyHashEntry(entry.hash, entry.key, entry.value, newTable[i], destHead);</span>
         }
<span class="fc" id="L632">         return newTable;</span>
    }

<span class="fc" id="L635">    public static abstract class Visitor {</span>
        public abstract void visit(IRubyObject key, IRubyObject value);
    }

    public void visitAll(Visitor visitor) {
        // use -1 to disable concurrency checks
<span class="fc" id="L641">        visitLimited(visitor, -1);</span>
<span class="fc" id="L642">    }</span>

    private void visitLimited(Visitor visitor, long size) {
<span class="fc" id="L645">        int startGeneration = generation;</span>
<span class="fc" id="L646">        long count = size;</span>
        // visit not more than size entries
<span class="pc bpc" id="L648" title="1 of 4 branches missed.">        for (RubyHashEntry entry = head.nextAdded; entry != head &amp;&amp; count != 0; entry = entry.nextAdded) {</span>
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">            if (startGeneration != generation) {</span>
<span class="nc" id="L650">                startGeneration = generation;</span>
<span class="nc" id="L651">                entry = head.nextAdded;</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">                if (entry == head) break;</span>
            }
<span class="pc bpc" id="L654" title="2 of 4 branches missed.">            if (entry != null &amp;&amp; entry.isLive()) {</span>
<span class="fc" id="L655">                visitor.visit(entry.key, entry.value);</span>
<span class="fc" id="L656">                count--;</span>
            }
        }
        // it does not handle all concurrent modification cases,
        // but at least provides correct marshal as we have exactly size entries visited (count == 0)
        // or if count &lt; 0 - skipped concurrent modification checks
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">        if (count &gt; 0) throw concurrentModification();</span>
<span class="fc" id="L663">    }</span>

    /* ============================
     * End of hash internals
     * ============================
     */

    /*  ================
     *  Instance Methods
     *  ================
     */

    /** rb_hash_initialize
     *
     */
    @JRubyMethod(optional = 1, visibility = PRIVATE)
    public IRubyObject initialize(IRubyObject[] args, final Block block) {
<span class="fc" id="L680">        modify();</span>

<span class="fc bfc" id="L682" title="All 2 branches covered.">        if (block.isGiven()) {</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">            if (args.length &gt; 0) throw getRuntime().newArgumentError(&quot;wrong number of arguments&quot;);</span>
<span class="fc" id="L684">            ifNone = getRuntime().newProc(Block.Type.PROC, block);</span>
<span class="fc" id="L685">            flags |= PROCDEFAULT_HASH_F;</span>
        } else {
<span class="fc" id="L687">            Arity.checkArgumentCount(getRuntime(), args, 0, 1);</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">            if (args.length == 1) ifNone = args[0];</span>
        }
<span class="fc" id="L690">        return this;</span>
    }

    /** rb_hash_default
     *
     */
    @Deprecated
    public IRubyObject default_value_get(ThreadContext context, IRubyObject[] args) {
<span class="nc bnc" id="L698" title="All 3 branches missed.">        switch (args.length) {</span>
<span class="nc" id="L699">            case 0: return default_value_get(context);</span>
<span class="nc" id="L700">            case 1: return default_value_get(context, args[0]);</span>
            default:
<span class="nc" id="L702">                throw context.runtime.newArgumentError(args.length, 1);</span>
        }
    }
    @JRubyMethod(name = &quot;default&quot;)
    public IRubyObject default_value_get(ThreadContext context) {
<span class="fc bfc" id="L707" title="All 2 branches covered.">        if ((flags &amp; PROCDEFAULT_HASH_F) != 0) {</span>
<span class="fc" id="L708">            return getRuntime().getNil();</span>
        }
<span class="fc" id="L710">        return ifNone;</span>
    }
    @JRubyMethod(name = &quot;default&quot;)
    public IRubyObject default_value_get(ThreadContext context, IRubyObject arg) {
<span class="fc bfc" id="L714" title="All 2 branches covered.">        if ((flags &amp; PROCDEFAULT_HASH_F) != 0) {</span>
<span class="fc" id="L715">            return Helpers.invoke(context, ifNone, &quot;call&quot;, this, arg);</span>
        }
<span class="fc" id="L717">        return ifNone;</span>
    }

    /** rb_hash_set_default
     *
     */
    @JRubyMethod(name = &quot;default=&quot;, required = 1)
    public IRubyObject default_value_set(final IRubyObject defaultValue) {
<span class="fc" id="L725">        modify();</span>

<span class="fc" id="L727">        ifNone = defaultValue;</span>
<span class="fc" id="L728">        flags &amp;= ~PROCDEFAULT_HASH_F;</span>

<span class="fc" id="L730">        return ifNone;</span>
    }

    /** rb_hash_default_proc
     *
     */
    @JRubyMethod
    public IRubyObject default_proc() {
<span class="fc bfc" id="L738" title="All 2 branches covered.">        return (flags &amp; PROCDEFAULT_HASH_F) != 0 ? ifNone : getRuntime().getNil();</span>
    }

    /** default_proc_arity_check
     *
     */
    private void checkDefaultProcArity(IRubyObject proc) {
<span class="fc" id="L745">        int n = ((RubyProc)proc).getBlock().arity().getValue();</span>

<span class="pc bpc" id="L747" title="3 of 8 branches missed.">        if(((RubyProc)proc).getBlock().type == Block.Type.LAMBDA &amp;&amp; n != 2 &amp;&amp; (n &gt;= 0 || n &lt; -3)) {</span>
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">            if(n &lt; 0) n = -n-1;</span>
<span class="fc" id="L749">            throw getRuntime().newTypeError(&quot;default_proc takes two arguments (2 for &quot; + n + &quot;)&quot;);</span>
        }
<span class="fc" id="L751">    }</span>

    /** rb_hash_set_default_proc
     *
     */
    public IRubyObject set_default_proc(IRubyObject proc) {
<span class="nc" id="L757">        return set_default_proc20(proc);</span>
    }
    
    @JRubyMethod(name = &quot;default_proc=&quot;)
    public IRubyObject set_default_proc20(IRubyObject proc) {
<span class="fc" id="L762">        modify();</span>
        
<span class="fc bfc" id="L764" title="All 2 branches covered.">        if (proc.isNil()) {</span>
<span class="fc" id="L765">            ifNone = proc;</span>
<span class="fc" id="L766">            return proc;</span>
        }

<span class="fc" id="L769">        IRubyObject b = TypeConverter.convertToType(proc, getRuntime().getProc(), &quot;to_proc&quot;);</span>
<span class="pc bpc" id="L770" title="2 of 4 branches missed.">        if(b.isNil() || !(b instanceof RubyProc)) {</span>
<span class="nc" id="L771">            throw getRuntime().newTypeError(&quot;wrong default_proc type &quot; + proc.getMetaClass() + &quot; (expected Proc)&quot;);</span>
        }
<span class="fc" id="L773">        proc = b;</span>
<span class="fc" id="L774">        checkDefaultProcArity(proc);</span>
<span class="fc" id="L775">        ifNone = proc;</span>
<span class="fc" id="L776">        flags |= PROCDEFAULT_HASH_F;</span>
<span class="fc" id="L777">        return proc;</span>
    }

    /** rb_hash_modify
     *
     */
    public void modify() {
<span class="fc" id="L784">    	testFrozen(&quot;Hash&quot;);</span>
<span class="fc" id="L785">    }</span>

    /** inspect_hash
     *
     */
    private IRubyObject inspectHash(final ThreadContext context) {
<span class="nc" id="L791">        final RubyString str = RubyString.newStringLight(context.runtime, DEFAULT_INSPECT_STR_SIZE);</span>
<span class="nc" id="L792">        str.cat((byte)'{');</span>
<span class="nc" id="L793">        final boolean[] firstEntry = new boolean[1];</span>

<span class="nc" id="L795">        firstEntry[0] = true;</span>
<span class="nc" id="L796">        visitAll(new Visitor() {</span>
            @Override
            public void visit(IRubyObject key, IRubyObject value) {
<span class="nc bnc" id="L799" title="All 2 branches missed.">                if (!firstEntry[0]) str.cat((byte)',').cat((byte)' ');</span>

<span class="nc" id="L801">                str.cat(inspect(context, key)).cat((byte)'=').cat((byte)'&gt;').cat(inspect(context, value));</span>
                
<span class="nc" id="L803">                firstEntry[0] = false;</span>
<span class="nc" id="L804">            }</span>
        });
<span class="nc" id="L806">        str.cat((byte)'}');</span>
<span class="nc" id="L807">        return str;</span>
    }
    
    private IRubyObject inspectHash19(final ThreadContext context) {
<span class="fc" id="L811">        final RubyString str = RubyString.newStringLight(context.runtime, DEFAULT_INSPECT_STR_SIZE, USASCIIEncoding.INSTANCE);</span>
<span class="fc" id="L812">        str.cat((byte)'{');</span>
<span class="fc" id="L813">        final boolean[] firstEntry = new boolean[1];</span>

<span class="fc" id="L815">        firstEntry[0] = true;</span>
<span class="fc" id="L816">        visitAll(new Visitor() {</span>
            @Override
            public void visit(IRubyObject key, IRubyObject value) {
<span class="fc bfc" id="L819" title="All 2 branches covered.">                if (!firstEntry[0]) str.cat((byte)',').cat((byte)' ');</span>

<span class="fc" id="L821">                str.cat19(inspect(context, key)).cat((byte)'=').cat((byte)'&gt;').cat19(inspect(context, value));</span>
                
<span class="fc" id="L823">                firstEntry[0] = false;</span>
<span class="fc" id="L824">            }</span>
        });
<span class="fc" id="L826">        str.cat((byte)'}');</span>
<span class="fc" id="L827">        return str;</span>
    }    

    /** rb_hash_inspect
     *
     */
    public IRubyObject inspect(ThreadContext context) {
<span class="nc" id="L834">        return inspect19(context);</span>
    }

    @JRubyMethod(name = &quot;inspect&quot;)
    public IRubyObject inspect19(ThreadContext context) {
<span class="pc bpc" id="L839" title="1 of 2 branches missed.">        if (size == 0) return RubyString.newUSASCIIString(context.runtime, &quot;{}&quot;);</span>
<span class="fc bfc" id="L840" title="All 2 branches covered.">        if (getRuntime().isInspecting(this)) return RubyString.newUSASCIIString(context.runtime, &quot;{...}&quot;);</span>

        try {
<span class="fc" id="L843">            getRuntime().registerInspecting(this);</span>
<span class="fc" id="L844">            return inspectHash19(context);</span>
        } finally {
<span class="pc" id="L846">            getRuntime().unregisterInspecting(this);</span>
        }
    }

    /** rb_hash_size
     *
     */
    @JRubyMethod(name = {&quot;size&quot;, &quot;length&quot;})
    public RubyFixnum rb_size() {
<span class="fc" id="L855">        return getRuntime().newFixnum(size);</span>
    }

    private SizeFn enumSizeFn() {
<span class="fc" id="L859">        final RubyHash self = this;</span>
<span class="fc" id="L860">        return new RubyEnumerator.SizeFn() {</span>
            @Override
            public IRubyObject size(IRubyObject[] args) {
<span class="nc" id="L863">                return self.rb_size();</span>
            }
        };
    }

    /** rb_hash_empty_p
     *
     */
    @JRubyMethod(name = &quot;empty?&quot;)
    public RubyBoolean empty_p() {
<span class="fc bfc" id="L873" title="All 2 branches covered.">        return size == 0 ? getRuntime().getTrue() : getRuntime().getFalse();</span>
    }

    /** rb_hash_to_a
     *
     */
    @JRubyMethod(name = &quot;to_a&quot;)
    @Override
    public RubyArray to_a() {
<span class="fc" id="L882">        final Ruby runtime = getRuntime();</span>
        try {
<span class="fc" id="L884">            final RubyArray result = RubyArray.newArray(runtime, size);</span>

<span class="fc" id="L886">            visitAll(new Visitor() {</span>
                @Override
                public void visit(IRubyObject key, IRubyObject value) {
<span class="fc" id="L889">                    result.append(RubyArray.newArray(runtime, key, value));</span>
<span class="fc" id="L890">                }</span>
            });

<span class="fc" id="L893">            result.setTaint(isTaint());</span>
<span class="fc" id="L894">            return result;</span>
<span class="nc" id="L895">        } catch (NegativeArraySizeException nase) {</span>
<span class="nc" id="L896">            throw concurrentModification();</span>
        }
    }

    /** rb_hash_to_s &amp; to_s_hash
     *
     */
    public IRubyObject to_s(ThreadContext context) {
<span class="nc" id="L904">        return to_s19(context);</span>
    }

    @JRubyMethod(name = &quot;to_s&quot;)
    public IRubyObject to_s19(ThreadContext context) {
<span class="fc" id="L909">        return inspect19(context);</span>
    }

    /** rb_hash_rehash
     *
     */
    @JRubyMethod(name = &quot;rehash&quot;)
    public RubyHash rehash() {
<span class="pc bpc" id="L917" title="1 of 2 branches missed.">        if (iteratorCount &gt; 0) {</span>
<span class="nc" id="L918">            throw getRuntime().newRuntimeError(&quot;rehash during iteration&quot;);</span>
        }

<span class="fc" id="L921">        modify();</span>
<span class="fc" id="L922">        final RubyHashEntry[] oldTable = table;</span>
<span class="fc" id="L923">        final RubyHashEntry[] newTable = new RubyHashEntry[oldTable.length];</span>
<span class="fc bfc" id="L924" title="All 2 branches covered.">        for (int j = 0; j &lt; oldTable.length; j++) {</span>
<span class="fc" id="L925">            RubyHashEntry entry = oldTable[j];</span>
<span class="fc" id="L926">            oldTable[j] = null;</span>
<span class="fc bfc" id="L927" title="All 2 branches covered.">            while (entry != null) {</span>
<span class="fc" id="L928">                RubyHashEntry next = entry.next;</span>
<span class="fc" id="L929">                entry.hash = hashValue(entry.key.hashCode()); // update the hash value</span>
<span class="fc" id="L930">                int i = bucketIndex(entry.hash, newTable.length);</span>
<span class="fc" id="L931">                entry.next = newTable[i];</span>
<span class="fc" id="L932">                newTable[i] = entry;</span>
<span class="fc" id="L933">                entry = next;</span>
<span class="fc" id="L934">            }</span>
        }
<span class="fc" id="L936">        table = newTable;</span>
<span class="fc" id="L937">        return this;</span>
    }

    /** rb_hash_to_hash
     *
     */
    @JRubyMethod(name = &quot;to_hash&quot;)
    public RubyHash to_hash() {
<span class="fc" id="L945">        return this;</span>
    }
    
    @JRubyMethod
    public RubyHash to_h(ThreadContext context) {
<span class="fc bfc" id="L950" title="All 2 branches covered.">        return getType() == getRuntime().getHash() ? this : newHash(getRuntime()).replace(context, this);</span>
    }

    @Override
    public RubyHash convertToHash() {
<span class="fc" id="L955">        return this;</span>
    }

    public final void fastASet(IRubyObject key, IRubyObject value) {
<span class="fc" id="L959">        internalPut(key, value);</span>
<span class="fc" id="L960">    }</span>

    public final void fastASetSmall(IRubyObject key, IRubyObject value) {
<span class="nc" id="L963">        internalPutSmall(key, value);</span>
<span class="nc" id="L964">    }</span>
    
    public final void fastASetCheckString(Ruby runtime, IRubyObject key, IRubyObject value) {
<span class="fc bfc" id="L967" title="All 4 branches covered.">      if (key instanceof RubyString &amp;&amp; !isComparedByIdentity()) {</span>
<span class="fc" id="L968">          op_asetForString(runtime, (RubyString) key, value);</span>
      } else {
<span class="fc" id="L970">          internalPut(key, value);</span>
      }
<span class="fc" id="L972">    }</span>

    public final void fastASetSmallCheckString(Ruby runtime, IRubyObject key, IRubyObject value) {
<span class="nc bnc" id="L975" title="All 2 branches missed.">        if (key instanceof RubyString) {</span>
<span class="nc" id="L976">            op_asetSmallForString(runtime, (RubyString) key, value);</span>
        } else {
<span class="nc" id="L978">            internalPutSmall(key, value);</span>
        }
<span class="nc" id="L980">    }</span>

    public final void fastASet(Ruby runtime, IRubyObject key, IRubyObject value, boolean prepareString) {
<span class="pc bpc" id="L983" title="1 of 2 branches missed.">        if (prepareString) {</span>
<span class="fc" id="L984">            fastASetCheckString(runtime, key, value);</span>
        } else {
<span class="nc" id="L986">            fastASet(key, value);</span>
        }
<span class="fc" id="L988">    }</span>

    public final void fastASetSmall(Ruby runtime, IRubyObject key, IRubyObject value, boolean prepareString) {
<span class="nc bnc" id="L991" title="All 2 branches missed.">        if (prepareString) {</span>
<span class="nc" id="L992">            fastASetSmallCheckString(runtime, key, value);</span>
        } else {
<span class="nc" id="L994">            fastASetSmall(key, value);</span>
        }
<span class="nc" id="L996">    }</span>

    /** rb_hash_aset
     *
     */
    @JRubyMethod(name = {&quot;[]=&quot;, &quot;store&quot;})
    public IRubyObject op_aset(ThreadContext context, IRubyObject key, IRubyObject value) {
<span class="fc" id="L1003">        modify();</span>

<span class="fc" id="L1005">        fastASetCheckString(context.runtime, key, value);</span>
<span class="fc" id="L1006">        return value;</span>
    }


    protected void op_asetForString(Ruby runtime, RubyString key, IRubyObject value) {
<span class="fc" id="L1011">        final RubyHashEntry entry = internalGetEntry(key);</span>
<span class="fc bfc" id="L1012" title="All 2 branches covered.">        if (entry != NO_ENTRY) {</span>
<span class="fc" id="L1013">            entry.value = value;</span>
        } else {
<span class="fc" id="L1015">            checkIterating();</span>
<span class="fc bfc" id="L1016" title="All 2 branches covered.">            if (!key.isFrozen()) {</span>
<span class="pc bpc" id="L1017" title="1 of 2 branches missed.">                if (isComparedByIdentity()) {</span>
                    // when comparing by identity, we don't want to be too eager about deduping
<span class="nc" id="L1019">                    key = key.strDup(runtime, key.getMetaClass().getRealClass());</span>
<span class="nc" id="L1020">                    key.setFrozen(true);</span>
                } else {
<span class="fc" id="L1022">                    key = runtime.freezeAndDedupString(key);</span>
                }
            }
<span class="fc" id="L1025">            internalPut(key, value, false);</span>
        }
<span class="fc" id="L1027">    }</span>

    protected void op_asetSmallForString(Ruby runtime, RubyString key, IRubyObject value) {
<span class="nc" id="L1030">        final RubyHashEntry entry = internalGetEntry(key);</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">        if (entry != NO_ENTRY) {</span>
<span class="nc" id="L1032">            entry.value = value;</span>
        } else {
<span class="nc" id="L1034">            checkIterating();</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">            if (isComparedByIdentity()) {</span>
                // when comparing by identity, we don't want to be too eager about deduping
<span class="nc" id="L1037">                key = key.strDup(runtime, key.getMetaClass().getRealClass());</span>
<span class="nc" id="L1038">                key.setFrozen(true);</span>
            } else {
<span class="nc" id="L1040">                key = runtime.freezeAndDedupString(key);</span>
            }
<span class="nc" id="L1042">            internalPutSmall(key, value, false);</span>
        }
<span class="nc" id="L1044">    }</span>

    public final IRubyObject fastARef(IRubyObject key) { // retuns null when not found to avoid unnecessary getRuntime().getNil() call
<span class="fc" id="L1047">        return internalGet(key);</span>
    }

    public RubyBoolean compare(final ThreadContext context, final MethodNames method, IRubyObject other) {

<span class="fc" id="L1052">        Ruby runtime = context.runtime;</span>

<span class="fc bfc" id="L1054" title="All 2 branches covered.">        if (!(other instanceof RubyHash)) {</span>
<span class="fc bfc" id="L1055" title="All 2 branches covered.">            if (!other.respondsTo(&quot;to_hash&quot;)) {</span>
<span class="fc" id="L1056">                return runtime.getFalse();</span>
            } else {
<span class="fc" id="L1058">                return Helpers.rbEqual(context, other, this);</span>
            }
        }

<span class="fc" id="L1062">        final RubyHash otherHash = (RubyHash) other;</span>

<span class="fc bfc" id="L1064" title="All 2 branches covered.">        if (this.size != otherHash.size) {</span>
<span class="fc" id="L1065">            return runtime.getFalse();</span>
        }

        try {
<span class="fc" id="L1069">            visitAll(new Visitor() {</span>
                @Override
                public void visit(IRubyObject key, IRubyObject value) {
<span class="fc" id="L1072">                    IRubyObject value2 = otherHash.fastARef(key);</span>

<span class="fc bfc" id="L1074" title="All 2 branches covered.">                    if (value2 == null) {</span>
                        // other hash does not contain key
<span class="fc" id="L1076">                        throw MISMATCH;</span>
                    }

<span class="fc bfc" id="L1079" title="All 2 branches covered.">                    if (!(method == MethodNames.OP_EQUAL ?</span>
<span class="fc" id="L1080">                            Helpers.rbEqual(context, value, value2) :</span>
<span class="fc bfc" id="L1081" title="All 2 branches covered.">                            Helpers.rbEql(context, value, value2)).isTrue()) {</span>
<span class="fc" id="L1082">                        throw MISMATCH;</span>
                    }
<span class="fc" id="L1084">                }</span>
            });
<span class="fc" id="L1086">        } catch (Mismatch e) {</span>
<span class="fc" id="L1087">            return runtime.getFalse();</span>
<span class="fc" id="L1088">        }</span>
        
<span class="fc" id="L1090">        return runtime.getTrue();</span>
    }

    /** rb_hash_equal
     * 
     */
    @JRubyMethod(name = &quot;==&quot;)
    @Override
    public IRubyObject op_equal(final ThreadContext context, IRubyObject other) {
<span class="fc" id="L1099">        return RecursiveComparator.compare(context, MethodNames.OP_EQUAL, this, other);</span>
    }

    /** rb_hash_eql
     * 
     */
    @JRubyMethod(name = &quot;eql?&quot;)
    public IRubyObject op_eql19(final ThreadContext context, IRubyObject other) {
<span class="fc" id="L1107">        return RecursiveComparator.compare(context, MethodNames.EQL, this, other);</span>
    }

    /** rb_hash_aref
     *
     */
    @JRubyMethod(name = &quot;[]&quot;, required = 1)
    public IRubyObject op_aref(ThreadContext context, IRubyObject key) {
        IRubyObject value;
<span class="fc bfc" id="L1116" title="All 2 branches covered.">        return ((value = internalGet(key)) == null) ? invokedynamic(context, this, DEFAULT, key) : value;</span>
    }

    /** rb_hash_hash
     * 
     */
    // FIXME: 
    @Override
    public RubyFixnum hash() {
<span class="nc" id="L1125">        final Ruby runtime = getRuntime();</span>
<span class="nc" id="L1126">        final ThreadContext context = runtime.getCurrentContext();</span>
<span class="nc bnc" id="L1127" title="All 4 branches missed.">        if (size == 0 || runtime.isInspecting(this)) return RubyFixnum.zero(runtime);</span>
<span class="nc" id="L1128">        final long hash[] = new long[]{size};</span>
        try {
<span class="nc" id="L1130">            runtime.registerInspecting(this);</span>
<span class="nc" id="L1131">            visitAll(new Visitor() {</span>
                public void visit(IRubyObject key, IRubyObject value) {
<span class="nc" id="L1133">                    hash[0] ^= invokedynamic(context, key, HASH).convertToInteger().getLongValue();</span>
<span class="nc" id="L1134">                    hash[0] ^= invokedynamic(context, value, HASH).convertToInteger().getLongValue();</span>
<span class="nc" id="L1135">                }</span>
            });
        } finally {
<span class="nc" id="L1138">            runtime.unregisterInspecting(this);</span>
<span class="nc" id="L1139">        }</span>
<span class="nc" id="L1140">        return RubyFixnum.newFixnum(runtime, hash[0]);</span>
    }

    /** rb_hash_hash
     * 
     */
    @JRubyMethod(name = &quot;hash&quot;)
    public RubyFixnum hash19() {
<span class="fc" id="L1148">        final Ruby runtime = getRuntime();</span>
<span class="fc" id="L1149">        final ThreadContext context = runtime.getCurrentContext();</span>
<span class="fc" id="L1150">        return (RubyFixnum)getRuntime().execRecursiveOuter(new Ruby.RecursiveFunction() {</span>
                @Override
                public IRubyObject call(IRubyObject obj, boolean recur) {
<span class="pc bpc" id="L1153" title="1 of 2 branches missed.">                    if(size == 0) {</span>
<span class="nc" id="L1154">                        return RubyFixnum.zero(runtime);</span>
                    }
<span class="fc" id="L1156">                    final long[] h = new long[]{1};</span>
<span class="fc bfc" id="L1157" title="All 2 branches covered.">                    if(recur) {</span>
<span class="fc" id="L1158">                        h[0] ^= RubyNumeric.num2long(invokedynamic(context, runtime.getHash(), HASH));</span>
                    } else {
<span class="fc" id="L1160">                        visitAll(new Visitor() {</span>
                                @Override
                                public void visit(IRubyObject key, IRubyObject value) {
<span class="fc" id="L1163">                                    h[0] += invokedynamic(context, key, HASH).convertToInteger().getLongValue() ^ invokedynamic(context, value, HASH).convertToInteger().getLongValue();</span>
<span class="fc" id="L1164">                                }</span>
                            });
                    }
<span class="fc" id="L1167">                    return runtime.newFixnum(h[0]);</span>
                }
            }, this);
    }

    /** rb_hash_fetch
     *
     */
    public IRubyObject fetch(ThreadContext context, IRubyObject[] args, Block block) {
<span class="nc" id="L1176">        Arity.checkArgumentCount(context.runtime, args.length, 1, 2);</span>
        
<span class="nc bnc" id="L1178" title="All 3 branches missed.">        switch(args.length) {</span>
<span class="nc" id="L1179">            case 1: return fetch(context, args[0], block);</span>
<span class="nc" id="L1180">            case 2: return fetch(context, args[0], args[1], block);</span>
        }

<span class="nc" id="L1183">        return null;</span>
    }
    
    @JRubyMethod
    public IRubyObject fetch(ThreadContext context, IRubyObject key, Block block) {
<span class="fc" id="L1188">        Ruby runtime = context.runtime;</span>

<span class="fc" id="L1190">        IRubyObject value = internalGet(key);</span>
        
<span class="fc bfc" id="L1192" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc bfc" id="L1193" title="All 2 branches covered.">            if (block.isGiven()) return block.yield(context, key);</span>
            
<span class="fc" id="L1195">            throw runtime.newKeyError(&quot;key not found: &quot; + key);</span>
        }
        
<span class="fc" id="L1198">        return value;</span>
    }
    
    @JRubyMethod
    public IRubyObject fetch(ThreadContext context, IRubyObject key, IRubyObject _default, Block block) {
<span class="fc" id="L1203">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L1204">        boolean blockGiven = block.isGiven();</span>

<span class="fc bfc" id="L1206" title="All 2 branches covered.">        if (blockGiven) {</span>
<span class="fc" id="L1207">            runtime.getWarnings().warn(ID.BLOCK_BEATS_DEFAULT_VALUE, &quot;block supersedes default value argument&quot;);</span>
        }

<span class="fc" id="L1210">        IRubyObject value = internalGet(key);</span>
        
<span class="fc bfc" id="L1212" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc bfc" id="L1213" title="All 2 branches covered.">            if (blockGiven) return block.yield(context, key);</span>
            
<span class="fc" id="L1215">            return _default;</span>
        }
        
<span class="fc" id="L1218">        return value;</span>
    }

    /** rb_hash_has_key
     *
     */
    @JRubyMethod(name = {&quot;has_key?&quot;, &quot;key?&quot;, &quot;include?&quot;, &quot;member?&quot;}, required = 1)
    public RubyBoolean has_key_p(IRubyObject key) {
<span class="fc bfc" id="L1226" title="All 2 branches covered.">        return internalGetEntry(key) == NO_ENTRY ? getRuntime().getFalse() : getRuntime().getTrue();</span>
    }

<span class="fc" id="L1229">    private static class Found extends RuntimeException {</span>
        @Override
        public Throwable fillInStackTrace() {
<span class="fc" id="L1232">            return null;</span>
        }
    }

<span class="fc" id="L1236">    private static final Found FOUND = new Found();</span>

    private static class FoundKey extends Found {
        public final IRubyObject key;
        FoundKey(IRubyObject key) {
<span class="fc" id="L1241">            super();</span>
<span class="fc" id="L1242">            this.key = key;</span>
<span class="fc" id="L1243">        }</span>
    }

    private static class FoundPair extends FoundKey {
        public final IRubyObject value;
        FoundPair(IRubyObject key, IRubyObject value) {
<span class="fc" id="L1249">            super(key);</span>
<span class="fc" id="L1250">            this.value = value;</span>
<span class="fc" id="L1251">        }</span>
    }

    private boolean hasValue(final ThreadContext context, final IRubyObject expected) {
        try {
<span class="fc" id="L1256">            visitAll(new Visitor() {</span>
                @Override
                public void visit(IRubyObject key, IRubyObject value) {
<span class="fc bfc" id="L1259" title="All 2 branches covered.">                    if (equalInternal(context, value, expected)) {</span>
<span class="fc" id="L1260">                        throw FOUND;</span>
                    }
<span class="fc" id="L1262">                }</span>
            });
<span class="fc" id="L1264">            return false;</span>
<span class="fc" id="L1265">        } catch (Found found) {</span>
<span class="fc" id="L1266">            return true;</span>
        }
    }

    /** rb_hash_has_value
     *
     */
    @JRubyMethod(name = {&quot;has_value?&quot;, &quot;value?&quot;}, required = 1)
    public RubyBoolean has_value_p(ThreadContext context, IRubyObject expected) {
<span class="fc" id="L1275">        return getRuntime().newBoolean(hasValue(context, expected));</span>
    }

    private volatile int iteratorCount;
    
    private static final AtomicIntegerFieldUpdater&lt;RubyHash&gt; ITERATOR_UPDATER;
    static {
<span class="fc" id="L1282">        AtomicIntegerFieldUpdater&lt;RubyHash&gt; iterUp = null;</span>
        try {
<span class="fc" id="L1284">            iterUp = AtomicIntegerFieldUpdater.newUpdater(RubyHash.class, &quot;iteratorCount&quot;);</span>
<span class="nc" id="L1285">        } catch (Exception e) {</span>
            // ignore, leave null
<span class="fc" id="L1287">        }</span>
<span class="fc" id="L1288">        ITERATOR_UPDATER = iterUp;</span>
    }

    private void iteratorEntry() {
<span class="pc bpc" id="L1292" title="1 of 2 branches missed.">        if (ITERATOR_UPDATER == null) {</span>
<span class="nc" id="L1293">            iteratorEntrySync();</span>
<span class="nc" id="L1294">            return;</span>
        }
<span class="fc" id="L1296">        ITERATOR_UPDATER.incrementAndGet(this);</span>
<span class="fc" id="L1297">    }</span>

    private void iteratorExit() {
<span class="pc bpc" id="L1300" title="1 of 2 branches missed.">        if (ITERATOR_UPDATER == null) {</span>
<span class="nc" id="L1301">            iteratorExitSync();</span>
<span class="nc" id="L1302">            return;</span>
        }
<span class="fc" id="L1304">        ITERATOR_UPDATER.decrementAndGet(this);</span>
<span class="fc" id="L1305">    }</span>

    private synchronized void iteratorEntrySync() {
<span class="nc" id="L1308">        ++iteratorCount;</span>
<span class="nc" id="L1309">    }</span>

    private void iteratorExitSync() {
<span class="nc" id="L1312">        --iteratorCount;</span>
<span class="nc" id="L1313">    }</span>

    private void iteratorVisitAll(Visitor visitor) {
        try {
<span class="fc" id="L1317">            iteratorEntry();</span>
<span class="fc" id="L1318">            visitAll(visitor);</span>
        } finally {
<span class="pc" id="L1320">            iteratorExit();</span>
<span class="fc" id="L1321">        }</span>
<span class="fc" id="L1322">    }</span>

    /** rb_hash_each
     *
     */
    public RubyHash eachCommon(final ThreadContext context, final Block block) {
<span class="nc bnc" id="L1328" title="All 2 branches missed.">        if (block.arity() == Arity.TWO_ARGUMENTS) {</span>
<span class="nc" id="L1329">            iteratorVisitAll(new Visitor() {</span>
                @Override
                public void visit(IRubyObject key, IRubyObject value) {
<span class="nc" id="L1332">                    block.yieldSpecific(context, key, value);</span>
<span class="nc" id="L1333">                }</span>
            });
        } else {
<span class="nc" id="L1336">            final Ruby runtime = context.runtime;</span>
            
<span class="nc" id="L1338">            iteratorVisitAll(new Visitor() {</span>
                @Override
                public void visit(IRubyObject key, IRubyObject value) {
<span class="nc" id="L1341">                    block.yield(context, RubyArray.newArray(runtime, key, value));</span>
<span class="nc" id="L1342">                }</span>
            });
        }

<span class="nc" id="L1346">        return this;</span>
    }

    public IRubyObject each(final ThreadContext context, final Block block) {
<span class="nc" id="L1350">        return each19(context, block);</span>
    }

    @JRubyMethod(name = &quot;each&quot;)
    public IRubyObject each19(final ThreadContext context, final Block block) {
<span class="fc bfc" id="L1355" title="All 2 branches covered.">        return block.isGiven() ? each_pairCommon(context, block, true) : enumeratorizeWithSize(context, this, &quot;each&quot;, enumSizeFn());</span>
    }

    /** rb_hash_each_pair
     *
     */
    public RubyHash each_pairCommon(final ThreadContext context, final Block block, final boolean oneNine) {
<span class="fc" id="L1362">        final Ruby runtime = getRuntime();</span>

<span class="fc" id="L1364">        iteratorVisitAll(new Visitor() {</span>
            @Override
            public void visit(IRubyObject key, IRubyObject value) {
                // rb_yield_values(2,...) equivalent
<span class="pc bpc" id="L1368" title="1 of 2 branches missed.">                if (oneNine) {</span>
<span class="fc" id="L1369">                    block.yield(context, RubyArray.newArray(runtime, key, value));</span>
                } else {
<span class="nc" id="L1371">                    block.yieldArray(context, RubyArray.newArray(runtime, key, value), null);</span>
                }
<span class="fc" id="L1373">            }</span>
        });

<span class="fc" id="L1376">        return this;	</span>
    }

    @JRubyMethod
    public IRubyObject each_pair(final ThreadContext context, final Block block) {
<span class="fc bfc" id="L1381" title="All 2 branches covered.">        return block.isGiven() ? each_pairCommon(context, block, true) : enumeratorizeWithSize(context, this, &quot;each_pair&quot;, enumSizeFn());</span>
    }

    /** rb_hash_each_value
     *
     */
    public RubyHash each_valueCommon(final ThreadContext context, final Block block) {
<span class="fc" id="L1388">        iteratorVisitAll(new Visitor() {</span>
            @Override
            public void visit(IRubyObject key, IRubyObject value) {
<span class="fc" id="L1391">                block.yield(context, value);</span>
<span class="fc" id="L1392">            }</span>
        });

<span class="fc" id="L1395">        return this;</span>
    }

    @JRubyMethod
    public IRubyObject each_value(final ThreadContext context, final Block block) {
<span class="fc bfc" id="L1400" title="All 2 branches covered.">        return block.isGiven() ? each_valueCommon(context, block) : enumeratorizeWithSize(context, this, &quot;each_value&quot;, enumSizeFn());</span>
    }

    /** rb_hash_each_key
     *
     */
    public RubyHash each_keyCommon(final ThreadContext context, final Block block) {
<span class="fc" id="L1407">        iteratorVisitAll(new Visitor() {</span>
            @Override
            public void visit(IRubyObject key, IRubyObject value) {
<span class="fc" id="L1410">                block.yield(context, key);</span>
<span class="fc" id="L1411">            }</span>
        });

<span class="fc" id="L1414">        return this;</span>
    }

    @JRubyMethod
    public IRubyObject each_key(final ThreadContext context, final Block block) {
<span class="fc bfc" id="L1419" title="All 2 branches covered.">        return block.isGiven() ? each_keyCommon(context, block) : enumeratorizeWithSize(context, this, &quot;each_key&quot;, enumSizeFn());</span>
    }

    @JRubyMethod(name = &quot;select!&quot;)
    public IRubyObject select_bang(final ThreadContext context, final Block block) {
<span class="fc bfc" id="L1424" title="All 4 branches covered.">        if (block.isGiven()) return keep_ifCommon(context, block) ? this : context.runtime.getNil();</span>

<span class="fc" id="L1426">        return enumeratorizeWithSize(context, this, &quot;select!&quot;, enumSizeFn());</span>
    }

    @JRubyMethod
    public IRubyObject keep_if(final ThreadContext context, final Block block) {
<span class="fc bfc" id="L1431" title="All 2 branches covered.">        if (block.isGiven()) {</span>
<span class="fc" id="L1432">            keep_ifCommon(context, block);</span>
<span class="fc" id="L1433">            return this;</span>
        } 

<span class="fc" id="L1436">        return enumeratorizeWithSize(context, this, &quot;keep_if&quot;, enumSizeFn());</span>
    }
    
    public boolean keep_ifCommon(final ThreadContext context, final Block block) {
<span class="fc" id="L1440">        testFrozen(&quot;Hash&quot;);</span>
<span class="fc" id="L1441">        final boolean[] modified = {false};</span>
<span class="fc" id="L1442">        iteratorVisitAll(new Visitor() {</span>
            @Override
            public void visit(IRubyObject key, IRubyObject value) {
<span class="fc bfc" id="L1445" title="All 2 branches covered.">                if (!block.yieldSpecific(context, key, value).isTrue()) {</span>
<span class="fc" id="L1446">                    modified[0] = true;</span>
<span class="fc" id="L1447">                    remove(key);</span>
                }
<span class="fc" id="L1449">            }</span>
        });
<span class="fc" id="L1451">        return modified[0];</span>
    }

    /** rb_hash_sort
     *
     */
    @JRubyMethod
    public IRubyObject sort(ThreadContext context, Block block) {
<span class="fc" id="L1459">        return to_a().sort_bang(context, block);</span>
    }

    /** rb_hash_index
     *
     */
    public IRubyObject index(ThreadContext context, IRubyObject expected) {
<span class="nc" id="L1466">        return index19(context, expected);</span>
    }

    @JRubyMethod(name = &quot;index&quot;)
    public IRubyObject index19(ThreadContext context, IRubyObject expected) {
<span class="fc" id="L1471">        context.runtime.getWarnings().warn(ID.DEPRECATED_METHOD, &quot;Hash#index is deprecated; use Hash#key&quot;);</span>
<span class="fc" id="L1472">        return key(context, expected);</span>
    }

    @JRubyMethod
    public IRubyObject key(ThreadContext context, IRubyObject expected) {
<span class="fc" id="L1477">        IRubyObject key = internalIndex(context, expected);</span>
<span class="fc bfc" id="L1478" title="All 2 branches covered.">        return key != null ? key : context.runtime.getNil();</span>
    }

    private IRubyObject internalIndex(final ThreadContext context, final IRubyObject expected) {
        try {
<span class="fc" id="L1483">            visitAll(new Visitor() {</span>
                @Override
                public void visit(IRubyObject key, IRubyObject value) {
<span class="fc bfc" id="L1486" title="All 2 branches covered.">                    if (equalInternal(context, value, expected)) {</span>
<span class="fc" id="L1487">                        throw new FoundKey(key);</span>
                    }
<span class="fc" id="L1489">                }</span>
            });
<span class="fc" id="L1491">            return null;</span>
<span class="fc" id="L1492">        } catch (FoundKey found) {</span>
<span class="fc" id="L1493">            return found.key;</span>
        }
    }

    /** rb_hash_indexes
     *
     */
    @JRubyMethod(name = {&quot;indexes&quot;, &quot;indices&quot;}, rest = true)
    public RubyArray indices(ThreadContext context, IRubyObject[] indices) {
<span class="nc" id="L1502">        return values_at(context, indices);</span>
    }

    /** rb_hash_keys
     *
     */
    @JRubyMethod(name = &quot;keys&quot;)
    public RubyArray keys() {
<span class="fc" id="L1510">        final Ruby runtime = getRuntime();</span>
        try {
<span class="fc" id="L1512">            final RubyArray keys = RubyArray.newArray(runtime, size);</span>

<span class="fc" id="L1514">            visitAll(new Visitor() {</span>
                @Override
                public void visit(IRubyObject key, IRubyObject value) {
<span class="fc" id="L1517">                    keys.append(key);</span>
<span class="fc" id="L1518">                }</span>
            });

<span class="fc" id="L1521">            return keys;</span>
<span class="nc" id="L1522">        } catch (NegativeArraySizeException nase) {</span>
<span class="nc" id="L1523">            throw concurrentModification();</span>
        }
    }

    /** rb_hash_values
     *
     */
    @JRubyMethod(name = &quot;values&quot;)
    public RubyArray rb_values() {
        try {
<span class="fc" id="L1533">            final RubyArray values = RubyArray.newArray(getRuntime(), size);</span>

<span class="fc" id="L1535">            visitAll(new Visitor() {</span>
                @Override
                public void visit(IRubyObject key, IRubyObject value) {
<span class="fc" id="L1538">                    values.append(value);</span>
<span class="fc" id="L1539">                }</span>
            });

<span class="fc" id="L1542">            return values;</span>
<span class="nc" id="L1543">        } catch (NegativeArraySizeException nase) {</span>
<span class="nc" id="L1544">            throw concurrentModification();</span>
        }
    }

    /** rb_hash_equal
     *
     */

<span class="fc" id="L1552">    private static class Mismatch extends RuntimeException {}</span>
<span class="fc" id="L1553">    private static final Mismatch MISMATCH = new Mismatch();</span>

    /** rb_hash_shift
     *
     */
    @JRubyMethod(name = &quot;shift&quot;)
    public IRubyObject shift(ThreadContext context) {
<span class="fc" id="L1560">        modify();</span>

<span class="fc" id="L1562">        RubyHashEntry entry = head.nextAdded;</span>
<span class="fc bfc" id="L1563" title="All 2 branches covered.">        if (entry != head) {</span>
<span class="fc" id="L1564">            RubyArray result = RubyArray.newArray(getRuntime(), entry.key, entry.value);</span>
<span class="fc" id="L1565">            internalDeleteEntry(entry);</span>
<span class="fc" id="L1566">            return result;</span>
        }

<span class="fc bfc" id="L1569" title="All 2 branches covered.">        if ((flags &amp; PROCDEFAULT_HASH_F) != 0) {</span>
<span class="fc" id="L1570">            return Helpers.invoke(context, ifNone, &quot;call&quot;, this, getRuntime().getNil());</span>
        } else {
<span class="fc" id="L1572">            return ifNone;</span>
        }
    }

    public final boolean fastDelete(IRubyObject key) {
<span class="fc bfc" id="L1577" title="All 2 branches covered.">        return internalDelete(key) != NO_ENTRY;</span>
    }

    /** rb_hash_delete
     *
     */
    @JRubyMethod
    public IRubyObject delete(ThreadContext context, IRubyObject key, Block block) {
<span class="fc" id="L1585">        modify();</span>

<span class="fc" id="L1587">        final RubyHashEntry entry = internalDelete(key);</span>
<span class="fc bfc" id="L1588" title="All 2 branches covered.">        if (entry != NO_ENTRY) return entry.value;</span>

<span class="fc bfc" id="L1590" title="All 2 branches covered.">        if (block.isGiven()) return block.yield(context, key);</span>
<span class="fc" id="L1591">        return getRuntime().getNil();</span>
    }

    /** rb_hash_select
     *
     */
    public IRubyObject select(final ThreadContext context, final Block block) {
<span class="nc" id="L1598">        return select19(context, block);</span>
    }

    @JRubyMethod(name = &quot;select&quot;)
    public IRubyObject select19(final ThreadContext context, final Block block) {
<span class="fc" id="L1603">        final Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L1604" title="All 2 branches covered.">        if (!block.isGiven()) return enumeratorizeWithSize(context, this, &quot;select&quot;, enumSizeFn());</span>

<span class="fc" id="L1606">        final RubyHash result = newHash(runtime);</span>

<span class="fc" id="L1608">        iteratorVisitAll(new Visitor() {</span>
            @Override
            public void visit(IRubyObject key, IRubyObject value) {
<span class="fc bfc" id="L1611" title="All 2 branches covered.">                if (block.yieldArray(context, runtime.newArray(key, value), null).isTrue()) {</span>
<span class="fc" id="L1612">                    result.fastASet(key, value);</span>
                }
<span class="fc" id="L1614">            }</span>
        });

<span class="fc" id="L1617">        return result;        </span>
    }

    /** rb_hash_delete_if
     *
     */
    public RubyHash delete_ifInternal(final ThreadContext context, final Block block) {
<span class="fc" id="L1624">        modify();</span>

<span class="fc" id="L1626">        final Ruby runtime = getRuntime();</span>
<span class="fc" id="L1627">        final RubyHash self = this;</span>
<span class="fc" id="L1628">        iteratorVisitAll(new Visitor() {</span>
            @Override
            public void visit(IRubyObject key, IRubyObject value) {
<span class="fc bfc" id="L1631" title="All 2 branches covered.">                if (block.yieldArray(context, RubyArray.newArray(runtime, key, value), null).isTrue()) {</span>
<span class="fc" id="L1632">                    self.delete(context, key, Block.NULL_BLOCK);</span>
                }
<span class="fc" id="L1634">            }</span>
        });

<span class="fc" id="L1637">        return this;</span>
    }

    @JRubyMethod
    public IRubyObject delete_if(final ThreadContext context, final Block block) {
<span class="fc bfc" id="L1642" title="All 2 branches covered.">        return block.isGiven() ? delete_ifInternal(context, block) : enumeratorizeWithSize(context, this, &quot;delete_if&quot;, enumSizeFn());</span>
    }

    /** rb_hash_reject
     *
     */
    public RubyHash rejectInternal(ThreadContext context, Block block) {
<span class="fc" id="L1649">        return ((RubyHash)dup()).delete_ifInternal(context, block);</span>
    }

    @JRubyMethod
    public IRubyObject reject(final ThreadContext context, final Block block) {
<span class="fc bfc" id="L1654" title="All 2 branches covered.">        return block.isGiven() ? rejectInternal(context, block) : enumeratorizeWithSize(context, this, &quot;reject&quot;, enumSizeFn());</span>
    }

    /** rb_hash_reject_bang
     *
     */
    public IRubyObject reject_bangInternal(ThreadContext context, Block block) {
<span class="fc" id="L1661">        int n = size;</span>
<span class="fc" id="L1662">        delete_if(context, block);</span>
<span class="fc bfc" id="L1663" title="All 2 branches covered.">        if (n == size) return getRuntime().getNil();</span>
<span class="fc" id="L1664">        return this;</span>
    }

    @JRubyMethod(name = &quot;reject!&quot;)
    public IRubyObject reject_bang(final ThreadContext context, final Block block) {
<span class="fc bfc" id="L1669" title="All 2 branches covered.">        return block.isGiven() ? reject_bangInternal(context, block) : enumeratorizeWithSize(context, this, &quot;reject!&quot;, enumSizeFn());</span>
    }

    /** rb_hash_clear
     *
     */
    @JRubyMethod(name = &quot;clear&quot;)
    public RubyHash rb_clear() {
<span class="fc" id="L1677">        modify();</span>

<span class="fc bfc" id="L1679" title="All 2 branches covered.">        if (size &gt; 0) {</span>
<span class="fc" id="L1680">            alloc();</span>
<span class="fc" id="L1681">            size = 0;</span>
        }

<span class="fc" id="L1684">        return this;</span>
    }

    /** rb_hash_invert
     *
     */
    @JRubyMethod(name = &quot;invert&quot;)
    public RubyHash invert(final ThreadContext context) {
<span class="fc" id="L1692">        final RubyHash result = newHash(getRuntime());</span>

<span class="fc" id="L1694">        visitAll(new Visitor() {</span>
            @Override
            public void visit(IRubyObject key, IRubyObject value) {
<span class="fc" id="L1697">                result.op_aset(context, value, key);</span>
<span class="fc" id="L1698">            }</span>
        });

<span class="fc" id="L1701">        return result;</span>
    }

    /** rb_hash_update
     *
     */
    public RubyHash merge_bang(final ThreadContext context, final IRubyObject other, final Block block) {
<span class="fc" id="L1708">        return merge_bang19(context, other, block);</span>
    }

    /** rb_hash_update
     *
     */
    @JRubyMethod(name = {&quot;merge!&quot;, &quot;update&quot;}, required = 1)
    public RubyHash merge_bang19(final ThreadContext context, final IRubyObject other, final Block block) {
<span class="fc" id="L1716">        modify();</span>
<span class="fc" id="L1717">        final RubyHash otherHash = other.convertToHash();</span>
        
<span class="pc bpc" id="L1719" title="1 of 2 branches missed.">        if (otherHash.empty_p().isTrue()) return this;</span>

<span class="fc" id="L1721">        final Ruby runtime = getRuntime();</span>
<span class="fc" id="L1722">        final RubyHash self = this;</span>
<span class="fc" id="L1723">        otherHash.visitAll(new Visitor() {</span>
            @Override
            public void visit(IRubyObject key, IRubyObject value) {
<span class="fc bfc" id="L1726" title="All 2 branches covered.">                if (block.isGiven()) {</span>
<span class="fc" id="L1727">                    IRubyObject existing = self.internalGet(key);</span>
<span class="fc bfc" id="L1728" title="All 2 branches covered.">                    if (existing != null) {</span>
<span class="fc" id="L1729">                        value = block.yield(context, RubyArray.newArrayNoCopy(runtime, new IRubyObject[]{key, existing, value}));</span>
                    }
                }
<span class="fc" id="L1732">                self.op_aset(context, key, value);</span>
<span class="fc" id="L1733">            }</span>
        });

<span class="fc" id="L1736">        return this;</span>
    }

    /** rb_hash_merge
     *
     */
    @JRubyMethod
    public RubyHash merge(ThreadContext context, IRubyObject other, Block block) {
<span class="fc" id="L1744">        return ((RubyHash)dup()).merge_bang(context, other, block);</span>
    }

    /** rb_hash_replace
     *
     */
    public RubyHash initialize_copy(ThreadContext context, IRubyObject other) {
<span class="nc" id="L1751">        return initialize_copy19(context, other);</span>
    }

    /** rb_hash_replace
     *
     */
    @JRubyMethod(name = &quot;initialize_copy&quot;, required = 1, visibility = PRIVATE)
    public RubyHash initialize_copy19(ThreadContext context, IRubyObject other) {
<span class="fc" id="L1759">        return replace19(context, other);</span>
    }

    /** rb_hash_replace
     *
     */
    public RubyHash replace(final ThreadContext context, IRubyObject other) {
<span class="fc" id="L1766">        return replace19(context, other);</span>
    }

    @JRubyMethod(name = &quot;replace&quot;, required = 1)
    public RubyHash replace19(final ThreadContext context, IRubyObject other) {
<span class="fc" id="L1771">        final RubyHash self = this;</span>
<span class="fc" id="L1772">        return replaceCommon19(context, other, new Visitor() {</span>
            @Override
            public void visit(IRubyObject key, IRubyObject value) {
<span class="fc" id="L1775">                self.op_aset(context, key, value);</span>
<span class="fc" id="L1776">            }</span>
        });
    }

    private RubyHash replaceCommon19(final ThreadContext context, IRubyObject other, Visitor visitor) {
<span class="fc" id="L1781">        modify();</span>
        
<span class="fc" id="L1783">        final RubyHash otherHash = other.convertToHash();</span>

<span class="pc bpc" id="L1785" title="1 of 2 branches missed.">        if (this == otherHash) return this;</span>

<span class="fc" id="L1787">        rb_clear();</span>

<span class="pc bpc" id="L1789" title="1 of 4 branches missed.">        if (!isComparedByIdentity() &amp;&amp; otherHash.isComparedByIdentity()) {</span>
<span class="fc" id="L1790">            setComparedByIdentity(true);</span>
        }

<span class="fc" id="L1793">        otherHash.visitAll(visitor);</span>

<span class="fc" id="L1795">        ifNone = otherHash.ifNone;</span>

<span class="fc bfc" id="L1797" title="All 2 branches covered.">        if ((otherHash.flags &amp; PROCDEFAULT_HASH_F) != 0) {</span>
<span class="fc" id="L1798">            flags |= PROCDEFAULT_HASH_F;</span>
        } else {
<span class="fc" id="L1800">            flags &amp;= ~PROCDEFAULT_HASH_F;</span>
        }

<span class="fc" id="L1803">        return this;</span>
    }

    /** rb_hash_values_at
     *
     */
    @JRubyMethod(name = &quot;values_at&quot;, rest = true)
    public RubyArray values_at(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L1811">        RubyArray result = RubyArray.newArray(getRuntime(), args.length);</span>
<span class="fc bfc" id="L1812" title="All 2 branches covered.">        for (int i = 0; i &lt; args.length; i++) {</span>
<span class="fc" id="L1813">            result.append(op_aref(context, args[i]));</span>
        }
<span class="fc" id="L1815">        return result;</span>
    }

    @JRubyMethod(name = &quot;assoc&quot;)
    public IRubyObject assoc(final ThreadContext context, final IRubyObject obj) {
        try {
<span class="fc" id="L1821">            visitAll(new Visitor() {</span>
                @Override
                public void visit(IRubyObject key, IRubyObject value) {
<span class="fc bfc" id="L1824" title="All 2 branches covered.">                    if (equalInternal(context, obj, key)) {</span>
<span class="fc" id="L1825">                        throw new FoundPair(key, value);</span>
                    }
<span class="fc" id="L1827">                }</span>
            });
<span class="fc" id="L1829">            return context.runtime.getNil();</span>
<span class="fc" id="L1830">        } catch (FoundPair found) {</span>
<span class="fc" id="L1831">            return context.runtime.newArray(found.key, found.value);</span>
        }
    }

    @JRubyMethod(name = &quot;rassoc&quot;)
    public IRubyObject rassoc(final ThreadContext context, final IRubyObject obj) {
        try {
<span class="fc" id="L1838">            visitAll(new Visitor() {</span>
                @Override
                public void visit(IRubyObject key, IRubyObject value) {
<span class="fc bfc" id="L1841" title="All 2 branches covered.">                    if (equalInternal(context, obj, value)) {</span>
<span class="fc" id="L1842">                        throw new FoundPair(key, value);</span>
                    }
<span class="fc" id="L1844">                }</span>
            });
<span class="fc" id="L1846">            return context.runtime.getNil();</span>
<span class="fc" id="L1847">        } catch (FoundPair found) {</span>
<span class="fc" id="L1848">            return context.runtime.newArray(found.key, found.value);</span>
        }
    }

    @JRubyMethod
    public IRubyObject flatten(ThreadContext context) {
<span class="fc" id="L1854">        RubyArray ary = to_a();</span>
<span class="fc" id="L1855">        ary.callMethod(context, &quot;flatten!&quot;, RubyFixnum.one(context.runtime));</span>
<span class="fc" id="L1856">        return ary;</span>
    }

    @JRubyMethod
    public IRubyObject flatten(ThreadContext context, IRubyObject level) {
<span class="fc" id="L1861">        RubyArray ary = to_a();</span>
<span class="fc" id="L1862">        ary.callMethod(context, &quot;flatten!&quot;, level);</span>
<span class="fc" id="L1863">        return ary;</span>
    }

    @JRubyMethod(name = &quot;compare_by_identity&quot;)
    public IRubyObject getCompareByIdentity(ThreadContext context) {
<span class="fc" id="L1868">        modify();</span>
<span class="fc" id="L1869">        setComparedByIdentity(true);</span>
<span class="fc" id="L1870">        return this;</span>
    }

    @JRubyMethod(name = &quot;compare_by_identity?&quot;)
    public IRubyObject getCompareByIdentity_p(ThreadContext context) {
<span class="fc" id="L1875">        return context.runtime.newBoolean(isComparedByIdentity());</span>
    }

    @JRubyMethod
    public IRubyObject dup(ThreadContext context) {
<span class="fc" id="L1880">        RubyHash dup = (RubyHash) super.dup();</span>
<span class="fc" id="L1881">        dup.setComparedByIdentity(isComparedByIdentity());</span>
<span class="fc" id="L1882">        return dup;</span>
    }

    @JRubyMethod(name = &quot;clone&quot;)
    public IRubyObject rbClone(ThreadContext context) {
<span class="fc" id="L1887">        RubyHash clone = (RubyHash) super.rbClone();</span>
<span class="fc" id="L1888">        clone.setComparedByIdentity(isComparedByIdentity());</span>
<span class="fc" id="L1889">        return clone;</span>
    }

    /**
     * A lightweight dup for internal use that does not dispatch to initialize_copy nor rehash the keys. Intended for
     * use in dup'ing keyword args for processing.
     *
     * @param context
     * @return
     */
    public RubyHash dupFast(final ThreadContext context) {
<span class="fc" id="L1900">        final Ruby runtime = context.runtime;</span>
<span class="fc" id="L1901">        RubyHash dup = new RubyHash(runtime, getMetaClass(), this);</span>

<span class="fc" id="L1903">        dup.setComparedByIdentity(this.isComparedByIdentity());</span>

<span class="fc" id="L1905">        dup.ifNone = this.ifNone;</span>

<span class="pc bpc" id="L1907" title="1 of 2 branches missed.">        if ((this.flags &amp; PROCDEFAULT_HASH_F) != 0) {</span>
<span class="nc" id="L1908">            dup.flags |= PROCDEFAULT_HASH_F;</span>
        } else {
<span class="fc" id="L1910">            dup.flags &amp;= ~PROCDEFAULT_HASH_F;</span>
        }

<span class="fc" id="L1913">        return dup;</span>
    }

    public boolean hasDefaultProc() {
<span class="fc bfc" id="L1917" title="All 2 branches covered.">        return (flags &amp; PROCDEFAULT_HASH_F) != 0;</span>
    }

    public IRubyObject getIfNone(){
<span class="fc" id="L1921">        return ifNone;</span>
    }

    private static class VisitorIOException extends RuntimeException {
        VisitorIOException(Throwable cause) {
<span class="nc" id="L1926">            super(cause);</span>
<span class="nc" id="L1927">        }</span>
    }

    // FIXME:  Total hack to get flash in Rails marshalling/unmarshalling in session ok...We need
    // to totally change marshalling to work with overridden core classes.
    public static void marshalTo(final RubyHash hash, final MarshalStream output) throws IOException {
<span class="fc" id="L1933">        output.registerLinkTarget(hash);</span>
<span class="fc" id="L1934">       int hashSize = hash.size;</span>
<span class="fc" id="L1935">       output.writeInt(hashSize);</span>
        try {
<span class="fc" id="L1937">            hash.visitLimited(new Visitor() {</span>
                public void visit(IRubyObject key, IRubyObject value) {
                    try {
<span class="fc" id="L1940">                        output.dumpObject(key);</span>
<span class="fc" id="L1941">                        output.dumpObject(value);</span>
<span class="nc" id="L1942">                    } catch (IOException e) {</span>
<span class="nc" id="L1943">                        throw new VisitorIOException(e);</span>
<span class="fc" id="L1944">                    }</span>
<span class="fc" id="L1945">                }</span>
            }, hashSize);
<span class="nc" id="L1947">        } catch (VisitorIOException e) {</span>
<span class="nc" id="L1948">            throw (IOException)e.getCause();</span>
<span class="fc" id="L1949">        }</span>

<span class="fc bfc" id="L1951" title="All 2 branches covered.">        if (!hash.ifNone.isNil()) output.dumpObject(hash.ifNone);</span>
<span class="fc" id="L1952">    }</span>

    public static RubyHash unmarshalFrom(UnmarshalStream input, boolean defaultValue) throws IOException {
<span class="fc" id="L1955">        RubyHash result = newHash(input.getRuntime());</span>
<span class="fc" id="L1956">        input.registerLinkTarget(result);</span>
<span class="fc" id="L1957">        int size = input.unmarshalInt();</span>
<span class="fc bfc" id="L1958" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1959">            result.fastASetCheckString(input.getRuntime(), input.unmarshalObject(), input.unmarshalObject());</span>
        }
<span class="pc bpc" id="L1961" title="1 of 2 branches missed.">        if (defaultValue) result.default_value_set(input.unmarshalObject());</span>
<span class="fc" id="L1962">        return result;</span>
    }

    @Override
    public Class getJavaClass() {
<span class="nc" id="L1967">        return Map.class;</span>
    }

    // Satisfy java.util.Set interface (for Java integration)

    @Override
    public int size() {
<span class="fc" id="L1974">        return size;</span>
    }

    @Override
    public boolean isEmpty() {
<span class="pc bpc" id="L1979" title="1 of 2 branches missed.">        return size == 0;</span>
    }

    @Override
    public boolean containsKey(Object key) {
<span class="nc bnc" id="L1984" title="All 2 branches missed.">        return internalGet(JavaUtil.convertJavaToUsableRubyObject(getRuntime(), key)) != null;</span>
    }

    @Override
    public boolean containsValue(Object value) {
<span class="nc" id="L1989">        return hasValue(getRuntime().getCurrentContext(), JavaUtil.convertJavaToUsableRubyObject(getRuntime(), value));</span>
    }

    @Override
    public Object get(Object key) {
<span class="fc" id="L1994">        IRubyObject gotten = internalGet(JavaUtil.convertJavaToUsableRubyObject(getRuntime(), key));</span>
<span class="fc bfc" id="L1995" title="All 2 branches covered.">        return gotten == null ? null : gotten.toJava(Object.class);</span>
    }

    @Override
    public Object put(Object key, Object value) {
<span class="nc" id="L2000">        internalPut(JavaUtil.convertJavaToUsableRubyObject(getRuntime(), key), JavaUtil.convertJavaToUsableRubyObject(getRuntime(), value));</span>
<span class="nc" id="L2001">        return value;</span>
    }

    @Override
    public Object remove(Object key) {
<span class="fc" id="L2006">        IRubyObject rubyKey = JavaUtil.convertJavaToUsableRubyObject(getRuntime(), key);</span>
<span class="fc" id="L2007">        return internalDelete(rubyKey).value;</span>
    }

    @Override
    public void putAll(Map map) {
<span class="nc" id="L2012">        Ruby runtime = getRuntime();</span>
<span class="nc bnc" id="L2013" title="All 2 branches missed.">        for (Iterator&lt;Map.Entry&gt; iter = map.entrySet().iterator(); iter.hasNext();) {</span>
<span class="nc" id="L2014">            Map.Entry entry = iter.next();</span>
<span class="nc" id="L2015">            internalPut(JavaUtil.convertJavaToUsableRubyObject(runtime, entry.getKey()), JavaUtil.convertJavaToUsableRubyObject(runtime, entry.getValue()));</span>
<span class="nc" id="L2016">        }</span>
<span class="nc" id="L2017">    }</span>

    @Override
    public void clear() {
<span class="nc" id="L2021">        rb_clear();</span>
<span class="nc" id="L2022">    }</span>

    @Override
    public boolean equals(Object other) {
<span class="nc bnc" id="L2026" title="All 2 branches missed.">        if (!(other instanceof RubyHash)) return false;</span>
<span class="nc bnc" id="L2027" title="All 2 branches missed.">        if (this == other) return true;</span>
<span class="nc bnc" id="L2028" title="All 2 branches missed.">        return op_equal(getRuntime().getCurrentContext(), (RubyHash)other).isTrue() ? true : false;</span>
    }

    @Override
    public Set keySet() {
<span class="nc" id="L2033">        return new BaseSet(KEY_VIEW);</span>
    }

    public Set directKeySet() {
<span class="nc" id="L2037">        return new BaseSet(DIRECT_KEY_VIEW);</span>
    }

    @Override
    public Collection values() {
<span class="nc" id="L2042">        return new BaseCollection(VALUE_VIEW);</span>
    }

    public Collection directValues() {
<span class="nc" id="L2046">        return new BaseCollection(DIRECT_VALUE_VIEW);</span>
    }

    @Override
    public Set entrySet() {
<span class="fc" id="L2051">        return new BaseSet(ENTRY_VIEW);</span>
    }

    public Set directEntrySet() {
<span class="fc" id="L2055">        return new BaseSet(DIRECT_ENTRY_VIEW);</span>
    }

    private final RaiseException concurrentModification() {
<span class="nc" id="L2059">        return getRuntime().newConcurrencyError(</span>
                &quot;Detected invalid hash contents due to unsynchronized modifications with concurrent users&quot;);
    }

    /**
     * Is this object compared by identity or not? Shortcut for doing
     * getFlag(COMPARE_BY_IDENTITY_F).
     *
     * @return true if this object is compared by identity, false otherwise
     */
    protected boolean isComparedByIdentity() {
<span class="fc bfc" id="L2070" title="All 2 branches covered.">        return (flags &amp; COMPARE_BY_IDENTITY_F) != 0;</span>
    }

    /**
     * Sets whether this object is compared by identity or not. Shortcut for doing
     * setFlag(COMPARE_BY_IDENTITY_F, frozen).
     *
     * @param comparedByIdentity should this object be compared by identity?
     */
    public void setComparedByIdentity(boolean comparedByIdentity) {
<span class="fc bfc" id="L2080" title="All 2 branches covered.">        if (comparedByIdentity) {</span>
<span class="fc" id="L2081">            flags |= COMPARE_BY_IDENTITY_F;</span>
        } else {
<span class="fc" id="L2083">            flags &amp;= ~COMPARE_BY_IDENTITY_F;</span>
        }
<span class="fc" id="L2085">    }</span>

    private class BaseSet extends AbstractSet {
        final EntryView view;

<span class="fc" id="L2090">        public BaseSet(EntryView view) {</span>
<span class="fc" id="L2091">            this.view = view;</span>
<span class="fc" id="L2092">        }</span>

        @Override
        public Iterator iterator() {
<span class="fc" id="L2096">            return new BaseIterator(view);</span>
        }

        @Override
        public boolean contains(Object o) {
<span class="nc" id="L2101">            return view.contains(RubyHash.this, o);</span>
        }

        @Override
        public void clear() {
<span class="nc" id="L2106">            RubyHash.this.clear();</span>
<span class="nc" id="L2107">        }</span>

        @Override
        public int size() {
<span class="nc" id="L2111">            return RubyHash.this.size;</span>
        }

        @Override
        public boolean remove(Object o) {
<span class="nc" id="L2116">            return view.remove(RubyHash.this, o);</span>
        }
    }

    private class BaseCollection extends AbstractCollection {
        final EntryView view;

<span class="nc" id="L2123">        public BaseCollection(EntryView view) {</span>
<span class="nc" id="L2124">            this.view = view;</span>
<span class="nc" id="L2125">        }</span>

        @Override
        public Iterator iterator() {
<span class="nc" id="L2129">            return new BaseIterator(view);</span>
        }

        @Override
        public boolean contains(Object o) {
<span class="nc" id="L2134">            return view.contains(RubyHash.this, o);</span>
        }

        @Override
        public void clear() {
<span class="nc" id="L2139">            RubyHash.this.clear();</span>
<span class="nc" id="L2140">        }</span>

        @Override
        public int size() {
<span class="nc" id="L2144">            return RubyHash.this.size;</span>
        }

        @Override
        public boolean remove(Object o) {
<span class="nc" id="L2149">            return view.remove(RubyHash.this, o);</span>
        }
    }

    private class BaseIterator implements Iterator {
        final private EntryView view;
        private RubyHashEntry entry;
        private boolean peeking;
        private int startGeneration;

<span class="fc" id="L2159">        public BaseIterator(EntryView view) {</span>
<span class="fc" id="L2160">            this.view = view;</span>
<span class="fc" id="L2161">            this.entry = head;</span>
<span class="fc" id="L2162">            this.startGeneration = generation;</span>
<span class="fc" id="L2163">        }</span>

        private void advance(boolean consume) {
<span class="fc bfc" id="L2166" title="All 2 branches covered.">            if (!peeking) {</span>
                do {
<span class="pc bpc" id="L2168" title="1 of 2 branches missed.">                    if (startGeneration != generation) {</span>
<span class="nc" id="L2169">                        startGeneration = generation;</span>
<span class="nc" id="L2170">                        entry = head;</span>
                    }
<span class="fc" id="L2172">                    entry = entry.nextAdded;</span>
<span class="pc bpc" id="L2173" title="1 of 4 branches missed.">                } while (entry != head &amp;&amp; !entry.isLive());</span>
            }
<span class="fc bfc" id="L2175" title="All 2 branches covered.">            peeking = !consume;</span>
<span class="fc" id="L2176">        }</span>

        @Override
        public Object next() {
<span class="fc" id="L2180">            advance(true);</span>
<span class="pc bpc" id="L2181" title="1 of 2 branches missed.">            if (entry == head) {</span>
<span class="nc" id="L2182">                peeking = true; // remain where we are</span>
<span class="nc" id="L2183">                throw new NoSuchElementException();</span>
            }
<span class="fc" id="L2185">            return view.convertEntry(getRuntime(), entry);</span>
        }

        // once hasNext has been called, we commit to next() returning
        // the entry it found, even if it were subsequently deleted
        @Override
        public boolean hasNext() {
<span class="fc" id="L2192">            advance(false);</span>
<span class="fc bfc" id="L2193" title="All 2 branches covered.">            return entry != head;</span>
        }

        @Override
        public void remove() {
<span class="nc bnc" id="L2198" title="All 2 branches missed.">            if (entry == head) {</span>
<span class="nc" id="L2199">                throw new IllegalStateException(&quot;Iterator out of range&quot;);</span>
            }
<span class="nc" id="L2201">            internalDeleteEntry(entry);</span>
<span class="nc" id="L2202">        }</span>
    }

<span class="fc" id="L2205">    private static abstract class EntryView {</span>
        public abstract Object convertEntry(Ruby runtime, RubyHashEntry value);
        public abstract boolean contains(RubyHash hash, Object o);
        public abstract boolean remove(RubyHash hash, Object o);
    }

<span class="fc" id="L2211">    private static final EntryView DIRECT_KEY_VIEW = new EntryView() {</span>
        @Override
        public Object convertEntry(Ruby runtime, RubyHashEntry entry) {
<span class="nc" id="L2214">            return entry.key;</span>
        }
        @Override
        public boolean contains(RubyHash hash, Object o) {
<span class="nc bnc" id="L2218" title="All 2 branches missed.">            if (!(o instanceof IRubyObject)) return false;</span>
<span class="nc bnc" id="L2219" title="All 2 branches missed.">            return hash.internalGet((IRubyObject)o) != null;</span>
        }
        @Override
        public boolean remove(RubyHash hash, Object o) {
<span class="nc bnc" id="L2223" title="All 2 branches missed.">            if (!(o instanceof IRubyObject)) return false;</span>
<span class="nc bnc" id="L2224" title="All 2 branches missed.">            return hash.internalDelete((IRubyObject)o) != NO_ENTRY;</span>
        }
    };

<span class="fc" id="L2228">    private static final EntryView KEY_VIEW = new EntryView() {</span>
        @Override
        public Object convertEntry(Ruby runtime, RubyHashEntry entry) {
<span class="nc" id="L2231">            return entry.key.toJava(Object.class);</span>
        }
        @Override
        public boolean contains(RubyHash hash, Object o) {
<span class="nc" id="L2235">            return hash.containsKey(o);</span>
        }
        @Override
        public boolean remove(RubyHash hash, Object o) {
<span class="nc bnc" id="L2239" title="All 2 branches missed.">            return hash.remove(o) != null;</span>
        }
    };

<span class="fc" id="L2243">    private static final EntryView DIRECT_VALUE_VIEW = new EntryView() {</span>
        @Override
        public Object convertEntry(Ruby runtime, RubyHashEntry entry) {
<span class="nc" id="L2246">            return entry.value;</span>
        }
        @Override
        public boolean contains(RubyHash hash, Object o) {
<span class="nc bnc" id="L2250" title="All 2 branches missed.">            if (!(o instanceof IRubyObject)) return false;</span>
<span class="nc" id="L2251">            IRubyObject obj = (IRubyObject)o;</span>
<span class="nc" id="L2252">            return hash.hasValue(obj.getRuntime().getCurrentContext(), obj);</span>
        }
        @Override
        public boolean remove(RubyHash hash, Object o) {
<span class="nc bnc" id="L2256" title="All 2 branches missed.">            if (!(o instanceof IRubyObject)) return false;</span>
<span class="nc" id="L2257">            IRubyObject obj = (IRubyObject) o;</span>
<span class="nc" id="L2258">            IRubyObject key = hash.internalIndex(obj.getRuntime().getCurrentContext(), obj);</span>
<span class="nc bnc" id="L2259" title="All 2 branches missed.">            if (key == null) return false;</span>
<span class="nc bnc" id="L2260" title="All 2 branches missed.">            return hash.internalDelete(key) != NO_ENTRY;</span>
        }
    };

<span class="fc" id="L2264">    private static final EntryView VALUE_VIEW = new EntryView() {</span>
        @Override
        public Object convertEntry(Ruby runtime, RubyHashEntry entry) {
<span class="nc" id="L2267">            return entry.value.toJava(Object.class);</span>
        }
        @Override
        public boolean contains(RubyHash hash, Object o) {
<span class="nc" id="L2271">            return hash.containsValue(o);</span>
        }
        @Override
        public boolean remove(RubyHash hash, Object o) {
<span class="nc" id="L2275">            IRubyObject value = JavaUtil.convertJavaToUsableRubyObject(hash.getRuntime(), o);</span>
<span class="nc" id="L2276">            IRubyObject key = hash.internalIndex(hash.getRuntime().getCurrentContext(), value);</span>
<span class="nc bnc" id="L2277" title="All 2 branches missed.">            if (key == null) return false;</span>
<span class="nc bnc" id="L2278" title="All 2 branches missed.">            return hash.internalDelete(key) != NO_ENTRY;</span>
        }
    };

<span class="fc" id="L2282">    private static final EntryView DIRECT_ENTRY_VIEW = new EntryView() {</span>
        @Override
        public Object convertEntry(Ruby runtime, RubyHashEntry entry) {
<span class="fc" id="L2285">            return entry;</span>
        }
        @Override
        public boolean contains(RubyHash hash, Object o) {
<span class="nc bnc" id="L2289" title="All 2 branches missed.">            if (!(o instanceof RubyHashEntry)) return false;</span>
<span class="nc" id="L2290">            RubyHashEntry entry = (RubyHashEntry)o;</span>
<span class="nc" id="L2291">            RubyHashEntry candidate = hash.internalGetEntry(entry.key);</span>
<span class="nc bnc" id="L2292" title="All 4 branches missed.">            return candidate != NO_ENTRY &amp;&amp; entry.equals(candidate);</span>
        }
        @Override
        public boolean remove(RubyHash hash, Object o) {
<span class="nc bnc" id="L2296" title="All 2 branches missed.">            if (!(o instanceof RubyHashEntry)) return false;</span>
<span class="nc bnc" id="L2297" title="All 2 branches missed.">            return hash.internalDeleteEntry((RubyHashEntry)o) != NO_ENTRY;</span>
        }
    };

<span class="fc" id="L2301">    private static final EntryView ENTRY_VIEW = new EntryView() {</span>
        @Override
        public Object convertEntry(Ruby runtime, RubyHashEntry entry) {
<span class="fc" id="L2304">            return new ConvertingEntry(runtime, entry);</span>
        }
        @Override
        public boolean contains(RubyHash hash, Object o) {
<span class="nc bnc" id="L2308" title="All 2 branches missed.">            if (!(o instanceof ConvertingEntry)) return false;</span>
<span class="nc" id="L2309">            ConvertingEntry entry = (ConvertingEntry)o;</span>
<span class="nc" id="L2310">            RubyHashEntry candidate = hash.internalGetEntry(entry.entry.key);</span>
<span class="nc bnc" id="L2311" title="All 4 branches missed.">            return candidate != NO_ENTRY &amp;&amp; entry.entry.equals(candidate);</span>
        }
        @Override
        public boolean remove(RubyHash hash, Object o) {
<span class="nc bnc" id="L2315" title="All 2 branches missed.">            if (!(o instanceof ConvertingEntry)) return false;</span>
<span class="nc" id="L2316">            ConvertingEntry entry = (ConvertingEntry)o;</span>
<span class="nc bnc" id="L2317" title="All 2 branches missed.">            return hash.internalDeleteEntry(entry.entry) != NO_ENTRY;</span>
        }
    };

    private static class ConvertingEntry implements Map.Entry {
        private final RubyHashEntry entry;
        private final Ruby runtime;

<span class="fc" id="L2325">        public ConvertingEntry(Ruby runtime, RubyHashEntry entry) {</span>
<span class="fc" id="L2326">            this.entry = entry;</span>
<span class="fc" id="L2327">            this.runtime = runtime;</span>
<span class="fc" id="L2328">        }</span>

        @Override
        public Object getKey() {
<span class="fc" id="L2332">            return entry.key.toJava(Object.class);</span>
        }
        @Override
        public Object getValue() {
<span class="fc" id="L2336">            return entry.value.toJava(Object.class);</span>
        }
        @Override
        public Object setValue(Object o) {
<span class="nc" id="L2340">            return entry.setValue(JavaUtil.convertJavaToUsableRubyObject(runtime, o));</span>
        }

        @Override
        public boolean equals(Object o) {
<span class="nc bnc" id="L2345" title="All 2 branches missed.">            if (!(o instanceof ConvertingEntry)) {</span>
<span class="nc" id="L2346">                return false;</span>
            }
<span class="nc" id="L2348">            ConvertingEntry other = (ConvertingEntry)o;</span>
<span class="nc" id="L2349">            return entry.equals(other.entry);</span>
        }
        
        @Override
        public int hashCode() {
<span class="nc" id="L2354">            return entry.hashCode();</span>
        }
    }
    
    @Deprecated
    public IRubyObject op_aset19(ThreadContext context, IRubyObject key, IRubyObject value) {
<span class="nc" id="L2360">        modify();</span>

<span class="nc" id="L2362">        fastASetCheckString19(context.runtime, key, value);</span>
<span class="nc" id="L2363">        return value;</span>
    }

    /**
     * Note: this is included as a compatibility measure for AR-JDBC
     * @deprecated use RubyHash.op_aset instead
     */
    public IRubyObject aset(IRubyObject key, IRubyObject value) {
<span class="nc" id="L2371">        return op_aset(getRuntime().getCurrentContext(), key, value);</span>
    }

    /**
     * Note: this is included as a compatibility measure for Mongrel+JRuby
     * @deprecated use RubyHash.op_aref instead
     */
    public IRubyObject aref(IRubyObject key) {
<span class="nc" id="L2379">        return op_aref(getRuntime().getCurrentContext(), key);</span>
    }

    @Deprecated
    public final void fastASetCheckString19(Ruby runtime, IRubyObject key, IRubyObject value) {
<span class="nc" id="L2384">        fastASetCheckString(runtime, key, value);</span>
<span class="nc" id="L2385">    }</span>

    @Deprecated
    public final void fastASetSmallCheckString19(Ruby runtime, IRubyObject key, IRubyObject value) {
<span class="nc" id="L2389">        fastASetSmallCheckString(runtime, key, value);</span>
<span class="nc" id="L2390">    }</span>

    @Deprecated
    public IRubyObject op_aset(IRubyObject key, IRubyObject value) {
<span class="fc" id="L2394">        return op_aset(getRuntime().getCurrentContext(), key, value);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>