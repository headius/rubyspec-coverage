<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RubyIO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby</a> &gt; <span class="el_source">RubyIO.java</span></div><h1>RubyIO.java</h1><pre class="source lang-java linenums">/*
 **** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2001-2004 Jan Arne Petersen &lt;jpetersen@uni-bonn.de&gt;
 * Copyright (C) 2002 Benoit Cerrina &lt;b.cerrina@wanadoo.fr&gt;
 * Copyright (C) 2002-2004 Anders Bengtsson &lt;ndrsbngtssn@yahoo.se&gt;
 * Copyright (C) 2002-2006 Thomas E Enebo &lt;enebo@acm.org&gt;
 * Copyright (C) 2004-2006 Charles O Nutter &lt;headius@headius.com&gt;
 * Copyright (C) 2004 Stefan Matthias Aust &lt;sma@3plus4.de&gt;
 * Copyright (C) 2006 Evan Buswell &lt;ebuswell@gmail.com&gt;
 * Copyright (C) 2007 Miguel Covarrubias &lt;mlcovarrubias@gmail.com&gt;
 * 
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby;

import jnr.constants.platform.Errno;
import jnr.constants.platform.OpenFlags;
import jnr.enxio.channels.NativeDeviceChannel;
import jnr.enxio.channels.NativeSelectableChannel;
import org.jcodings.transcode.EConvFlags;
import org.jruby.runtime.Helpers;
import org.jruby.util.StringSupport;
import org.jruby.util.io.ChannelFD;
import org.jruby.util.io.EncodingUtils;
import static org.jruby.util.io.EncodingUtils.vmodeVperm;
import static org.jruby.util.io.EncodingUtils.vperm;

import org.jruby.util.io.FilenoUtil;
import org.jruby.util.io.ModeFlags;
import org.jruby.util.io.POSIXProcess;
import org.jruby.util.io.PopenExecutor;
import org.jruby.util.io.PosixShim;
import jnr.constants.platform.Fcntl;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.nio.channels.Channel;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.WritableByteChannel;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.jcodings.Encoding;
import org.jruby.anno.FrameField;
import org.jruby.anno.JRubyMethod;
import org.jruby.anno.JRubyClass;
import org.jruby.common.IRubyWarnings.ID;
import org.jruby.exceptions.RaiseException;
import org.jruby.ext.fcntl.FcntlLibrary;
import org.jruby.platform.Platform;
import org.jruby.runtime.Block;
import org.jruby.runtime.ClassIndex;
import org.jruby.runtime.ObjectAllocator;
import org.jruby.runtime.ThreadContext;
import org.jruby.runtime.Visibility;
import static org.jruby.runtime.Visibility.*;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.util.ByteList;
import org.jruby.util.io.SelectExecutor;
import org.jruby.util.io.IOOptions;
import org.jruby.util.SafePropertyAccessor;
import org.jruby.util.ShellLauncher;
import org.jruby.util.TypeConverter;
import org.jruby.util.io.InvalidValueException;
import org.jruby.util.io.STDIO;
import org.jruby.util.io.OpenFile;

import org.jruby.runtime.Arity;

import static org.jruby.RubyEnumerator.enumeratorize;
import org.jruby.ast.util.ArgsUtil;
import org.jruby.internal.runtime.ThreadedRunnable;
import org.jruby.runtime.encoding.EncodingService;
import org.jruby.util.ShellLauncher.POpenProcess;
import org.jruby.util.io.IOEncodable;

/**
 * 
 * @author jpetersen
 */
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">@JRubyClass(name=&quot;IO&quot;, include=&quot;Enumerable&quot;)</span>
public class RubyIO extends RubyObject implements IOEncodable {
    // We use a highly uncommon string to represent the paragraph delimiter (100% soln not worth it)
<span class="fc" id="L113">    public static final ByteList PARAGRAPH_DELIMETER = ByteList.create(&quot;PARAGRPH_DELIM_MRK_ER&quot;);</span>
<span class="fc" id="L114">    public static final ByteList PARAGRAPH_SEPARATOR = ByteList.create(&quot;\n\n&quot;);</span>
    public static final String CLOSED_STREAM_MSG = &quot;closed stream&quot;;

    // This should only be called by this and RubyFile.
    // It allows this object to be created without a IOHandler.
    public RubyIO(Ruby runtime, RubyClass type) {
<span class="fc" id="L120">        super(runtime, type);</span>
<span class="fc" id="L121">    }</span>
    
    public RubyIO(Ruby runtime, OutputStream outputStream) {
<span class="nc" id="L124">        this(runtime, outputStream, true);</span>
<span class="nc" id="L125">    }</span>

    public RubyIO(Ruby runtime, OutputStream outputStream, boolean autoclose) {
<span class="nc" id="L128">        super(runtime, runtime.getIO());</span>
        
        // We only want IO objects with valid streams (better to error now). 
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (outputStream == null) {</span>
<span class="nc" id="L132">            throw runtime.newRuntimeError(&quot;Opening null stream&quot;);</span>
        }
        
<span class="nc" id="L135">        openFile = MakeOpenFile();</span>
<span class="nc" id="L136">        openFile.setFD(new ChannelFD(Channels.newChannel(outputStream), runtime.getPosix(), runtime.getFilenoUtil()));</span>
<span class="nc" id="L137">        openFile.setMode(OpenFile.WRITABLE | OpenFile.APPEND);</span>
<span class="nc" id="L138">        openFile.setAutoclose(autoclose);</span>
<span class="nc" id="L139">    }</span>
    
    public RubyIO(Ruby runtime, InputStream inputStream) {
<span class="nc" id="L142">        super(runtime, runtime.getIO());</span>
        
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (inputStream == null) {</span>
<span class="nc" id="L145">            throw runtime.newRuntimeError(&quot;Opening null stream&quot;);</span>
        }
        
<span class="nc" id="L148">        openFile = MakeOpenFile();</span>
<span class="nc" id="L149">        openFile.setFD(new ChannelFD(Channels.newChannel(inputStream), runtime.getPosix(), runtime.getFilenoUtil()));</span>
<span class="nc" id="L150">        openFile.setMode(OpenFile.READABLE);</span>
<span class="nc" id="L151">    }</span>
    
    public RubyIO(Ruby runtime, Channel channel) {
<span class="nc" id="L154">        this(runtime, runtime.getIO(), channel);</span>
<span class="nc" id="L155">    }</span>

    public RubyIO(Ruby runtime, RubyClass klass, Channel channel) {
<span class="nc" id="L158">        super(runtime, klass);</span>

        // We only want IO objects with valid streams (better to error now).
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (channel == null) {</span>
<span class="nc" id="L162">            throw runtime.newRuntimeError(&quot;Opening null channel&quot;);</span>
        }

<span class="nc" id="L165">        ThreadContext context = runtime.getCurrentContext();</span>
<span class="nc" id="L166">        initializeCommon(context, new ChannelFD(channel, runtime.getPosix(), runtime.getFilenoUtil()), runtime.newFixnum(ModeFlags.oflagsFrom(runtime.getPosix(), channel)), context.nil);</span>
<span class="nc" id="L167">    }</span>

    public RubyIO(Ruby runtime, ShellLauncher.POpenProcess process, IOOptions ioOptions) {
<span class="nc" id="L170">        super(runtime, runtime.getIO());</span>

<span class="nc" id="L172">        ioOptions = updateIOOptionsFromOptions(runtime.getCurrentContext(), null, ioOptions);</span>

<span class="nc" id="L174">        openFile = MakeOpenFile();</span>

<span class="nc" id="L176">        setupPopen(ioOptions.getModeFlags(), process);</span>
<span class="nc" id="L177">    }</span>

    // MRI: prep_stdio
    public static RubyIO prepStdio(Ruby runtime, InputStream f, Channel c, int fmode, RubyClass klass, String path) {
        OpenFile fptr;
<span class="fc" id="L182">        RubyIO io = prepIO(runtime, c, fmode | OpenFile.PREP | EncodingUtils.DEFAULT_TEXTMODE, klass, path);</span>

<span class="fc" id="L184">        fptr = io.getOpenFileChecked();</span>
<span class="fc" id="L185">        prepStdioEcflags(fptr, fmode);</span>
<span class="fc" id="L186">        fptr.stdio_file = f;</span>

        // We checkTTY again here because we're using stdout/stdin to indicate this is stdio
<span class="fc" id="L189">        return recheckTTY(runtime, fptr, io);</span>
    }

    // MRI: prep_stdio
    public static RubyIO prepStdio(Ruby runtime, OutputStream f, Channel c, int fmode, RubyClass klass, String path) {
        OpenFile fptr;
<span class="fc" id="L195">        RubyIO io = prepIO(runtime, c, fmode | OpenFile.PREP | EncodingUtils.DEFAULT_TEXTMODE, klass, path);</span>

<span class="fc" id="L197">        fptr = io.getOpenFileChecked();</span>
<span class="fc" id="L198">        prepStdioEcflags(fptr, fmode);</span>
<span class="fc" id="L199">        fptr.stdio_file = f;</span>

<span class="fc" id="L201">        return recheckTTY(runtime, fptr, io);</span>
    }

    private static RubyIO recheckTTY(Ruby runtime, OpenFile fptr, RubyIO io) {
        // We checkTTY again here because we're using stdout/stdin to indicate this is stdio
<span class="fc" id="L206">        fptr.checkTTY();</span>

<span class="fc" id="L208">        return io;</span>
    }

    // MRI: part of prep_stdio
    private static void prepStdioEcflags(OpenFile fptr, int fmode) {
<span class="fc" id="L213">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L215">            fptr.encs.ecflags |= EncodingUtils.ECONV_DEFAULT_NEWLINE_DECORATOR;</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">            if (EncodingUtils.TEXTMODE_NEWLINE_DECORATOR_ON_WRITE != 0) {</span>
<span class="nc" id="L217">                fptr.encs.ecflags |= EncodingUtils.TEXTMODE_NEWLINE_DECORATOR_ON_WRITE;</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">                if ((fmode &amp; OpenFile.READABLE) != 0) {</span>
<span class="nc" id="L219">                    fptr.encs.ecflags |= EConvFlags.UNIVERSAL_NEWLINE_DECORATOR;</span>
                }
            }
        } finally {
<span class="pc bpc" id="L223" title="3 of 4 branches missed.">            if (locked) fptr.unlock();</span>
        }
<span class="fc" id="L225">    }</span>

    // MRI: prep_io
    private static RubyIO prepIO(Ruby runtime, Channel fd, int fmode, RubyClass klass, String path) {
        OpenFile fp;
<span class="fc" id="L230">        RubyIO io = (RubyIO)klass.allocate();</span>

<span class="fc" id="L232">        fp = io.MakeOpenFile();</span>
<span class="fc" id="L233">        fp.setChannel(fd);</span>
        // Can we determine this?
//        if (Platform.IS_CYGWIN) {
//            if (!runtime.getPosix().isatty(fd)) {
//                fmode |= OpenFile.BINMODE;
                // TODO: setmode O_BINARY means what via NIO?
//                setmode(fd, OpenFlags.O_BINARY);
//            }
//        }
<span class="fc" id="L242">        fp.setMode(fmode);</span>
<span class="fc" id="L243">        fp.checkTTY();</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        if (path != null) fp.setPath(path);</span>
//        rb_update_max_fd(fd);

<span class="fc" id="L247">        return io;</span>
    }
    
    public static RubyIO newIO(Ruby runtime, Channel channel) {
<span class="nc" id="L251">        return new RubyIO(runtime, channel);</span>
    }
    
    public OpenFile getOpenFile() {
<span class="nc" id="L255">        return openFile;</span>
    }
    
    public OpenFile getOpenFileChecked() {
<span class="fc" id="L259">        openFile.checkClosed();</span>
<span class="fc" id="L260">        return openFile;</span>
    }
    
<span class="fc" id="L263">    private static ObjectAllocator IO_ALLOCATOR = new ObjectAllocator() {</span>
        @Override
        public IRubyObject allocate(Ruby runtime, RubyClass klass) {
<span class="fc" id="L266">            return new RubyIO(runtime, klass);</span>
        }
    };

    /*
     * We use FILE versus IO to match T_FILE in MRI.
     */
    @Override
    public ClassIndex getNativeClassIndex() {
<span class="fc" id="L275">        return ClassIndex.FILE;</span>
    }

    public static RubyClass createIOClass(Ruby runtime) {
<span class="fc" id="L279">        RubyClass ioClass = runtime.defineClass(&quot;IO&quot;, runtime.getObject(), IO_ALLOCATOR);</span>

<span class="fc" id="L281">        ioClass.setClassIndex(ClassIndex.IO);</span>
<span class="fc" id="L282">        ioClass.setReifiedClass(RubyIO.class);</span>

<span class="fc" id="L284">        ioClass.kindOf = new RubyModule.JavaClassKindOf(RubyIO.class);</span>

<span class="fc" id="L286">        ioClass.includeModule(runtime.getEnumerable());</span>
        
<span class="fc" id="L288">        ioClass.defineAnnotatedMethods(RubyIO.class);</span>

        // Constants for seek
<span class="fc" id="L291">        ioClass.setConstant(&quot;SEEK_SET&quot;, runtime.newFixnum(PosixShim.SEEK_SET));</span>
<span class="fc" id="L292">        ioClass.setConstant(&quot;SEEK_CUR&quot;, runtime.newFixnum(PosixShim.SEEK_CUR));</span>
<span class="fc" id="L293">        ioClass.setConstant(&quot;SEEK_END&quot;, runtime.newFixnum(PosixShim.SEEK_END));</span>

<span class="fc" id="L295">        ioClass.defineModuleUnder(&quot;WaitReadable&quot;);</span>
<span class="fc" id="L296">        ioClass.defineModuleUnder(&quot;WaitWritable&quot;);</span>

<span class="fc" id="L298">        return ioClass;</span>
    }

    public OutputStream getOutStream() {
        // FIXME: Could be faster by caching bytelist or string rather than creating for every call
<span class="fc" id="L303">        return new OutputStream() {</span>
<span class="fc" id="L304">            final Ruby runtime = getRuntime();</span>

            @Override
            public void write(int b) throws IOException {
<span class="nc" id="L308">                putc(runtime.getCurrentContext(), runtime.newFixnum(b));</span>
<span class="nc" id="L309">            }</span>

            @Override
            public void write(byte[] b) throws IOException {
<span class="nc" id="L313">                RubyIO.this.write(runtime.getCurrentContext(), RubyString.newStringNoCopy(runtime, b));</span>
<span class="nc" id="L314">            }</span>

            @Override
            public void write(byte[] b, int off, int len) throws IOException {
<span class="nc" id="L318">                RubyIO.this.write(runtime.getCurrentContext(), RubyString.newStringNoCopy(runtime, b, off, len));</span>
<span class="nc" id="L319">            }</span>

            @Override
            public void flush() throws IOException {
<span class="nc" id="L323">                RubyIO.this.flush(runtime.getCurrentContext());</span>
<span class="nc" id="L324">            }</span>

            @Override
            public void close() throws IOException {
<span class="nc" id="L328">                RubyIO.this.close();</span>
<span class="nc" id="L329">            }</span>
        };
    }

    public InputStream getInStream() {
        // FIXME: Could be faster by caching bytelist or string rather than creating for every call
<span class="fc" id="L335">        return new InputStream() {</span>
<span class="fc" id="L336">            final Ruby runtime = getRuntime();</span>

            @Override
            public int read() throws IOException {
<span class="fc" id="L340">                return getByte(runtime.getCurrentContext());</span>
            }

            @Override
            public int read(byte[] b) throws IOException {
<span class="nc" id="L345">                return read(b, 0, b.length);</span>
            }

            @Override
            public int read(byte[] b, int off, int len) throws IOException {
<span class="nc" id="L350">                RubyFixnum c = runtime.newFixnum(len);</span>
<span class="nc" id="L351">                RubyString s = RubyString.newStringNoCopy(runtime, b, off, len);</span>
<span class="nc" id="L352">                IRubyObject i = RubyIO.this.read(runtime.getCurrentContext(), c, s);</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">                if (i.isNil()) return -1;</span>
<span class="nc" id="L354">                return s.size();</span>
            }

            @Override
            public long skip(long n) throws IOException {
<span class="nc" id="L359">                return seek(runtime.getCurrentContext(), runtime.newFixnum(PosixShim.SEEK_CUR), runtime.newFixnum(n)).getLongValue();</span>
            }

            @Override
            public int available() throws IOException {
<span class="nc bnc" id="L364" title="All 2 branches missed.">                if (RubyIO.this instanceof RubyFile) {</span>
<span class="nc" id="L365">                    long size = ((RubyFixnum)((RubyFile)RubyIO.this).size(runtime.getCurrentContext())).getLongValue();</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">                    if (size == 0) return 0;</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">                    if (size &gt;= 0) return (int)(size - pos(runtime.getCurrentContext()).getLongValue());</span>
                }
<span class="nc" id="L369">                return 0;</span>
            }

            @Override
            public void close() throws IOException {
<span class="nc" id="L374">                RubyIO.this.close();</span>
<span class="nc" id="L375">            }</span>
        };
    }

    /**
     * Get the underlying channel from this IO object. Note that IO buffers data internally, so the channel returned
     * here may have been read into those buffers. If the channel and the IO are both being used at the same time, the
     * stream will get out of sync.
     *
     * @return the underlying channel for this IO
     */
    public Channel getChannel() {
        // FIXME: Do we want to make a faux channel that is backed by IO's buffering? Or turn buffering off?
<span class="nc" id="L388">        return openFile.channel();</span>
    }

    // io_reopen
    protected RubyIO reopenIO(ThreadContext context, RubyIO nfile) {
<span class="fc" id="L393">        Ruby runtime = context.runtime;</span>
        OpenFile fptr, orig;
        ChannelFD fd, fd2;
<span class="fc" id="L396">        long pos = 0;</span>

<span class="fc" id="L398">        nfile = TypeConverter.ioGetIO(runtime, nfile);</span>
<span class="fc" id="L399">        fptr = getOpenFileChecked();</span>
<span class="fc" id="L400">        orig = nfile.getOpenFileChecked();</span>

<span class="pc bpc" id="L402" title="1 of 2 branches missed.">        if (fptr == orig) return this;</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">        if (fptr.IS_PREP_STDIO()) {</span>
<span class="pc bpc" id="L404" title="3 of 6 branches missed.">            if ((fptr.stdio_file == System.in &amp;&amp; !orig.isReadable()) ||</span>
<span class="pc bpc" id="L405" title="1 of 4 branches missed.">                    (fptr.stdio_file == System.out &amp;&amp; !orig.isWritable()) ||</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">                    (fptr.stdio_file == System.err &amp;&amp; !orig.isWritable())) {</span>
<span class="nc" id="L407">                throw runtime.newArgumentError(fptr.PREP_STDIO_NAME() + &quot; can't change access mode from \&quot;&quot; + fptr.getModeAsString(runtime) + &quot;\&quot; to \&quot;&quot; + orig.getModeAsString(runtime) + &quot;\&quot;&quot;);</span>
            }
        }
        // FIXME: three lock acquires...trying to reduce risk of deadlock, but not sure it's possible.

<span class="fc" id="L412">        boolean locked = fptr.lock();</span>
        try {
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">            if (fptr.isWritable()) {</span>
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">                if (fptr.io_fflush(context) &lt; 0)</span>
<span class="nc" id="L416">                    throw runtime.newErrnoFromErrno(fptr.errno(), fptr.getPath());</span>
            } else {
<span class="nc" id="L418">                fptr.tell(context);</span>
            }
        } finally {
<span class="pc bpc" id="L421" title="3 of 4 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L424">        locked = orig.lock();</span>
        try {
<span class="fc bfc" id="L426" title="All 2 branches covered.">            if (orig.isReadable()) {</span>
<span class="fc" id="L427">                pos = orig.tell(context);</span>
            }
<span class="fc bfc" id="L429" title="All 2 branches covered.">            if (orig.isWritable()) {</span>
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">                if (orig.io_fflush(context) &lt; 0)</span>
<span class="nc" id="L431">                    throw runtime.newErrnoFromErrno(orig.errno(), fptr.getPath());</span>
            }
        } finally {
<span class="pc bpc" id="L434" title="3 of 4 branches missed.">            if (locked) orig.unlock();</span>
        }

        /* copy rb_io_t structure */
        // NOTE: MRI does not copy sync here, but I can find no way to make stdout/stderr stay sync through a reopen
<span class="fc" id="L439">        locked = fptr.lock();</span>
<span class="fc" id="L440">        boolean locked2 = orig.lock(); // TODO: This WILL deadlock if two threads try to reopen the same IOs in opposite directions. Fix?</span>
        try {
<span class="fc" id="L442">            fptr.setMode(orig.getMode() | (fptr.getMode() &amp; (OpenFile.PREP | OpenFile.SYNC)));</span>
<span class="fc" id="L443">            fptr.setProcess(orig.getProcess());</span>
<span class="fc" id="L444">            fptr.setLineNumber(orig.getLineNumber());</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">            if (orig.getPath() != null) fptr.setPath(orig.getPath());</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">            else if (!fptr.IS_PREP_STDIO()) fptr.setPath(null);</span>
<span class="fc" id="L447">            fptr.setFinalizer(orig.getFinalizer());</span>

            // TODO: unsure what to do here
            //        #if defined (__CYGWIN__) || !defined(HAVE_FORK)
            //        if (fptr-&gt;finalize == pipe_finalize)
            //            pipe_add_fptr(fptr);
            //        #endif

<span class="fc" id="L455">            fd = fptr.fd();</span>
<span class="fc" id="L456">            fd2 = orig.fd();</span>
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">            if (fd != fd2) {</span>
<span class="pc bpc" id="L458" title="2 of 6 branches missed.">                if (fptr.IS_PREP_STDIO() || fd.bestFileno() &lt;= 2 || fptr.stdio_file == null) {</span>
                    /* need to keep FILE objects of stdin, stdout and stderr */
<span class="fc" id="L460">                    checkReopenCloexecDup2(runtime, orig, fd2, fd);</span>
                    //                rb_update_max_fd(fd);
<span class="fc" id="L462">                    fptr.setFD(fd);</span>

                    //                // MRI does not do this, but we seem to need to set some types of channels to sync if they
                    //                // are reopened as stdout/stderr.
                    //                if (fptr.stdio_file == System.out || fptr.stdio_file == System.err) {
                    //                    fd.chFile.force();
                    //                }
                } else {
<span class="nc bnc" id="L470" title="All 2 branches missed.">                    if (fptr.stdio_file != null) try {</span>
<span class="nc" id="L471">                        fptr.stdio_file.close();</span>
<span class="nc" id="L472">                    } catch (IOException ioe) {</span>
<span class="nc" id="L473">                    }</span>
<span class="nc" id="L474">                    fptr.clearStdio();</span>
<span class="nc" id="L475">                    fptr.setFD(null);</span>
<span class="nc" id="L476">                    checkReopenCloexecDup2(runtime, orig, fd2, fd);</span>
                    //                rb_update_max_fd(fd);
<span class="nc" id="L478">                    fptr.setFD(fd);</span>
                }
                // TODO: clear interrupts waiting on this IO?
                //            rb_thread_fd_close(fd);
<span class="pc bpc" id="L482" title="1 of 4 branches missed.">                if (orig.isReadable() &amp;&amp; pos &gt;= 0) {</span>
<span class="fc" id="L483">                    fptr.checkReopenSeek(context, runtime, pos);</span>
<span class="fc" id="L484">                    orig.checkReopenSeek(context, runtime, pos);</span>
                }
            }

<span class="pc bpc" id="L488" title="1 of 2 branches missed.">            if (fptr.isBinmode()) {</span>
<span class="nc" id="L489">                setBinmode();</span>
            }
        } finally {
<span class="pc bpc" id="L492" title="3 of 4 branches missed.">            if (locked2) orig.unlock();</span>
<span class="pc bpc" id="L493" title="3 of 4 branches missed.">            if (locked) fptr.unlock();</span>
        }

        // We simply can't do this and still have real concrete types under RubyIO
//        setMetaClass(nfile.getMetaClass());
<span class="fc" id="L498">        return this;</span>
    }

    private void checkReopenCloexecDup2(Ruby runtime, OpenFile orig, ChannelFD oldfd, ChannelFD newfd) {
<span class="fc" id="L502">        OpenFile.cloexecDup2(new PosixShim(runtime.getPosix()), oldfd, newfd);</span>
<span class="fc" id="L503">    }</span>

    // rb_io_binmode
    private void setBinmode() {
        OpenFile fptr;

<span class="fc" id="L509">        fptr = getOpenFileChecked();</span>
<span class="fc" id="L510">        boolean locked = fptr.lock();</span>
        try {
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">            if (fptr.readconv != null)</span>
<span class="nc" id="L513">                fptr.readconv.binmode();</span>
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">            if (fptr.writeconv != null)</span>
<span class="nc" id="L515">                fptr.writeconv.binmode();</span>
<span class="fc" id="L516">            fptr.setBinmode();</span>
<span class="fc" id="L517">            fptr.clearTextMode();</span>
<span class="fc" id="L518">            fptr.writeconvPreEcflags &amp;= ~EConvFlags.NEWLINE_DECORATOR_MASK;</span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">            if (OpenFlags.O_BINARY.defined()) {</span>
                // TODO: Windows
                //            if (fptr.readconv == null) {
                //                SET_BINARY_MODE_WITH_SEEK_CUR(fptr);
                //            }
                //            else {
                // TODO: setmode O_BINARY means what via NIO?
                //                setmode(fptr-&gt;fd, O_BINARY);
                //            }
            }
        } finally {
<span class="pc bpc" id="L530" title="3 of 4 branches missed.">            if (locked) fptr.unlock();</span>
        }
<span class="fc" id="L532">        return;</span>
    }

    // MRI: rb_io_reopen
    @JRubyMethod(name = &quot;reopen&quot;, required = 1, optional = 1)
    public IRubyObject reopen(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L538">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L539">        RubyIO file = this;</span>
<span class="fc" id="L540">        IRubyObject fname = context.nil, nmode = context.nil, opt = context.nil;</span>
<span class="fc" id="L541">        int[] oflags_p = {0};</span>
        OpenFile fptr;

<span class="pc bpc" id="L544" title="2 of 4 branches missed.">        switch (args.length) {</span>
            case 3:
<span class="nc" id="L546">                opt = TypeConverter.checkHashType(runtime, args[2]);</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">                if (opt.isNil()) throw getRuntime().newArgumentError(3, 2);</span>
            case 2:
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">                if (opt.isNil()) {</span>
<span class="fc" id="L550">                    opt = TypeConverter.checkHashType(runtime, args[1]);</span>
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">                    if (opt.isNil()) {</span>
<span class="fc" id="L552">                        nmode = args[1];</span>
<span class="fc" id="L553">                        opt = context.nil;</span>
                    }
                } else {
<span class="nc" id="L556">                    nmode = args[1];</span>
                }
            case 1:
<span class="fc" id="L559">                fname = args[0];</span>
        }
<span class="fc bfc" id="L561" title="All 2 branches covered.">        if (args.length == 1) {</span>
<span class="fc" id="L562">            IRubyObject tmp = TypeConverter.ioCheckIO(runtime, fname);</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">            if (!tmp.isNil()) {</span>
<span class="fc" id="L564">                return file.reopenIO(context, (RubyIO)tmp);</span>
            }
        }

<span class="fc" id="L568">        fname = RubyFile.get_path(context, fname);</span>
        // Not implemented
//        fname.checkTaint();
<span class="fc" id="L571">        fptr = file.openFile;</span>
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">        if (fptr == null) {</span>
<span class="nc" id="L573">            fptr = file.openFile = MakeOpenFile();</span>
        }

<span class="fc" id="L576">        boolean locked = fptr.lock();</span>
        try {
<span class="pc bpc" id="L578" title="1 of 4 branches missed.">            if (!nmode.isNil() || !opt.isNil()) {</span>
<span class="fc" id="L579">                ConvConfig convconfig = new ConvConfig();</span>
<span class="fc" id="L580">                Object vmode_vperm = vmodeVperm(nmode, null);</span>
<span class="fc" id="L581">                int[] fmode_p = {0};</span>

<span class="fc" id="L583">                EncodingUtils.extractModeEncoding(context, convconfig, vmode_vperm, opt, oflags_p, fmode_p);</span>
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">                if (fptr.IS_PREP_STDIO() &amp;&amp;</span>
<span class="nc" id="L585">                        ((fptr.getMode() &amp; OpenFile.READWRITE) &amp; (fmode_p[0] &amp; OpenFile.READWRITE)) !=</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">                                (fptr.getMode() &amp; OpenFile.READWRITE)) {</span>
<span class="nc" id="L587">                    throw runtime.newArgumentError(fptr.PREP_STDIO_NAME() + &quot; can't change access mode from \&quot;&quot; + fptr.getModeAsString(runtime) + &quot;\&quot; to \&quot;&quot; + OpenFile.getStringFromMode(fmode_p[0]));</span>
                }
<span class="fc" id="L589">                fptr.setMode(fmode_p[0]);</span>
<span class="fc" id="L590">                fptr.encs = convconfig;</span>
<span class="fc" id="L591">            } else {</span>
<span class="fc" id="L592">                oflags_p[0] = OpenFile.getModeFlagsAsIntFrom(fptr.getMode());</span>
            }

<span class="fc" id="L595">            fptr.setPath(fname.toString());</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">            if (fptr.fd() == null) {</span>
<span class="fc" id="L597">                fptr.setFD(sysopen(runtime, fptr.getPath(), oflags_p[0], 0666));</span>
<span class="fc" id="L598">                fptr.clearStdio();</span>
<span class="fc" id="L599">                return file;</span>
            }

<span class="fc bfc" id="L602" title="All 2 branches covered.">            if (fptr.isWritable()) {</span>
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">                if (fptr.io_fflush(context) &lt; 0)</span>
<span class="nc" id="L604">                    throw runtime.newErrnoFromErrno(fptr.errno(), fptr.getPath());</span>
            }
<span class="fc" id="L606">            fptr.rbuf.off = fptr.rbuf.len = 0;</span>

<span class="pc bpc" id="L608" title="1 of 2 branches missed.">            if (fptr.isStdio()) {</span>
                // Logic here reopens the stdio FILE* with a new path and mode. For our purposes, we skip this
                // since we do not want to damage the stdio streams
                //            if (freopen(RSTRING_PTR(fptr.pathv), rb_io_oflags_modestr(oflags), fptr.stdio_file) == 0) {
                //                rb_sys_fail_path(fptr.pathv);
                //            }
<span class="nc" id="L614">                fptr.setFD(sysopen(runtime, fptr.getPath(), oflags_p[0], 0666));</span>

                // This logic fixes the original stdio file descriptor by clearing any CLOEXEC that might have
                // come across with the newly opened file. Since we do not yet support CLOEXEC, we skip this.
                //            fptr.fd = fileno(fptr.stdio_file);
                //            rb_fd_fix_cloexec(fptr.fd);

                // This logic configures buffering (none, line, full) and buffer size to match the original stdio
                // stream associated with this IO. I don't believe we can do this.
                //                #ifdef USE_SETVBUF
                //                if (setvbuf(fptr.stdio_file, NULL, _IOFBF, 0) != 0)
                //                    rb_warn(&quot;setvbuf() can't be honoured for %&quot;PRIsVALUE, fptr.pathv);
                //                #endif
                //                if (fptr.stdio_file == stderr) {
                //                    if (setvbuf(fptr.stdio_file, NULL, _IONBF, BUFSIZ) != 0)
                //                        rb_warn(&quot;setvbuf() can't be honoured for %&quot;PRIsVALUE, fptr.pathv);
                //                }
                //                else if (fptr.stdio_file == stdout &amp;&amp; isatty(fptr.fd)) {
                //                    if (setvbuf(fptr.stdio_file, NULL, _IOLBF, BUFSIZ) != 0)
                //                        rb_warn(&quot;setvbuf() can't be honoured for %&quot;PRIsVALUE, fptr.pathv);
                //                }
            } else {
<span class="fc" id="L636">                ChannelFD tmpfd = sysopen(runtime, fptr.getPath(), oflags_p[0], 0666);</span>
<span class="fc" id="L637">                Errno err = null;</span>
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">                if (fptr.cloexecDup2(fptr.posix, tmpfd, fptr.fd()) &lt; 0)</span>
<span class="nc" id="L639">                    err = fptr.errno();</span>

<span class="pc bpc" id="L641" title="1 of 2 branches missed.">                if (err != null) {</span>
<span class="nc" id="L642">                    throw runtime.newErrnoFromErrno(err, fptr.getPath());</span>
                }
<span class="fc" id="L644">                fptr.setFD(tmpfd);</span>
            }
        } finally {
<span class="pc bpc" id="L647" title="3 of 6 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L650">        return file;</span>
    }

    public IRubyObject getline(ThreadContext context, IRubyObject separator) {
<span class="fc" id="L654">        return getline(context, separator, -1, null);</span>
    }

    /**
     * getline using logic of gets.  If limit is -1 then read unlimited amount.
     *
     */
    public IRubyObject getline(ThreadContext context, IRubyObject separator, long limit) {
<span class="fc" id="L662">        return getline(context, separator, limit, null);</span>
    }

    private IRubyObject getline(ThreadContext context, IRubyObject separator, long limit, ByteListCache cache) {
<span class="fc" id="L666">        return getlineInner(context, separator, (int)limit, cache);</span>
    }
    
    /**
     * getline using logic of gets.  If limit is -1 then read unlimited amount.
     * mri: rb_io_getline_1 (mostly)
     */
    private IRubyObject getlineInner(ThreadContext context, IRubyObject rs, int _limit, ByteListCache cache) {
<span class="fc" id="L674">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L675">        IRubyObject str = context.nil;</span>
<span class="fc" id="L676">        boolean noLimit = false;</span>
        Encoding enc;
        
<span class="fc" id="L679">        OpenFile fptr = getOpenFileChecked();</span>

<span class="fc" id="L681">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L683">            fptr.checkCharReadable(context);</span>

<span class="fc bfc" id="L685" title="All 4 branches covered.">            if (rs.isNil() &amp;&amp; _limit &lt; 0) {</span>
<span class="fc" id="L686">                str = fptr.readAll(context, 0, context.nil);</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">                if (((RubyString) str).size() == 0) return context.nil;</span>
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">            } else if (_limit == 0) {</span>
<span class="nc" id="L689">                return RubyString.newEmptyString(runtime, fptr.readEncoding(runtime));</span>
<span class="fc" id="L690">            } else if (</span>
<span class="fc bfc" id="L691" title="All 4 branches covered.">                    rs == runtime.getGlobalVariables().getDefaultSeparator()</span>
                            &amp;&amp; _limit &lt; 0
<span class="fc bfc" id="L693" title="All 2 branches covered.">                            &amp;&amp; !fptr.needsReadConversion()</span>
<span class="pc bpc" id="L694" title="1 of 2 branches missed.">                            &amp;&amp; (enc = fptr.readEncoding(runtime)).isAsciiCompatible()) {</span>
<span class="fc" id="L695">                fptr.NEED_NEWLINE_DECORATOR_ON_READ_CHECK();</span>
<span class="fc" id="L696">                return fptr.getlineFast(context, enc, this);</span>
            }

            // slow path logic
<span class="fc" id="L700">            int c, newline = -1;</span>
<span class="fc" id="L701">            byte[] rsptrBytes = null;</span>
<span class="fc" id="L702">            int rsptr = 0;</span>
<span class="fc" id="L703">            int rslen = 0;</span>
<span class="fc" id="L704">            boolean rspara = false;</span>
<span class="fc" id="L705">            int extraLimit = 16;</span>

<span class="fc" id="L707">            fptr.SET_BINARY_MODE();</span>
<span class="fc" id="L708">            enc = getReadEncoding();</span>

<span class="fc bfc" id="L710" title="All 2 branches covered.">            if (!rs.isNil()) {</span>
<span class="fc" id="L711">                RubyString rsStr = (RubyString) rs;</span>
<span class="fc" id="L712">                ByteList rsByteList = rsStr.getByteList();</span>
<span class="fc" id="L713">                rslen = rsByteList.getRealSize();</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">                if (rslen == 0) {</span>
<span class="fc" id="L715">                    rsptrBytes = PARAGRAPH_SEPARATOR.unsafeBytes();</span>
<span class="fc" id="L716">                    rsptr = PARAGRAPH_SEPARATOR.getBegin();</span>
<span class="fc" id="L717">                    rslen = 2;</span>
<span class="fc" id="L718">                    rspara = true;</span>
<span class="fc" id="L719">                    fptr.swallow(context, '\n');</span>
<span class="fc" id="L720">                    rs = null;</span>
<span class="pc bpc" id="L721" title="1 of 2 branches missed.">                    if (!enc.isAsciiCompatible()) {</span>
<span class="nc" id="L722">                        rs = RubyString.newUsAsciiStringShared(runtime, rsptrBytes, rsptr, rslen);</span>
<span class="nc" id="L723">                        rs = EncodingUtils.rbStrEncode(context, rs, runtime.getEncodingService().convertEncodingToRubyEncoding(enc), 0, context.nil);</span>
<span class="nc" id="L724">                        rs.setFrozen(true);</span>
<span class="nc" id="L725">                        rsStr = (RubyString) rs;</span>
<span class="nc" id="L726">                        rsByteList = rsStr.getByteList();</span>
<span class="nc" id="L727">                        rsptrBytes = rsByteList.getUnsafeBytes();</span>
<span class="nc" id="L728">                        rsptr = rsByteList.getBegin();</span>
<span class="nc" id="L729">                        rslen = rsByteList.getRealSize();</span>
                    }
                } else {
<span class="fc" id="L732">                    rsptrBytes = rsByteList.unsafeBytes();</span>
<span class="fc" id="L733">                    rsptr = rsByteList.getBegin();</span>
                }
<span class="fc" id="L735">                newline = rsptrBytes[rsptr + rslen - 1] &amp; 0xFF;</span>
            }

<span class="fc bfc" id="L738" title="All 2 branches covered.">            ByteList buf = cache != null ? cache.allocate(0) : new ByteList(0);</span>
            try {
<span class="fc" id="L740">                boolean bufferString = str instanceof RubyString;</span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">                ByteList[] strPtr = {bufferString ? ((RubyString) str).getByteList() : null};</span>

<span class="fc" id="L743">                int[] limit_p = {_limit};</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">                while ((c = fptr.appendline(context, newline, strPtr, limit_p)) != OpenFile.EOF) {</span>
                    int s, p, pp, e;

<span class="fc bfc" id="L747" title="All 2 branches covered.">                    if (c == newline) {</span>
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">                        if (strPtr[0].getRealSize() &lt; rslen) continue;</span>
<span class="fc" id="L749">                        s = strPtr[0].getBegin();</span>
<span class="fc" id="L750">                        e = s + strPtr[0].getRealSize();</span>
<span class="fc" id="L751">                        p = e - rslen;</span>
<span class="fc" id="L752">                        pp = enc.leftAdjustCharHead(strPtr[0].getUnsafeBytes(), s, p, e);</span>
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">                        if (pp != p) continue;</span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">                        if (ByteList.memcmp(strPtr[0].getUnsafeBytes(), p, rsptrBytes, rsptr, rslen) == 0) break;</span>
                    }
<span class="fc bfc" id="L756" title="All 2 branches covered.">                    if (limit_p[0] == 0) {</span>
<span class="fc" id="L757">                        s = strPtr[0].getBegin();</span>
<span class="fc" id="L758">                        p = s + strPtr[0].getRealSize();</span>
<span class="fc" id="L759">                        pp = enc.leftAdjustCharHead(strPtr[0].getUnsafeBytes(), s, p - 1, p);</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">                        if (extraLimit != 0 &amp;&amp;</span>
<span class="fc bfc" id="L761" title="All 2 branches covered.">                                StringSupport.MBCLEN_NEEDMORE_P(StringSupport.preciseLength(enc, strPtr[0].getUnsafeBytes(), pp, p))) {</span>
<span class="fc" id="L762">                            limit_p[0] = 1;</span>
<span class="fc" id="L763">                            extraLimit--;</span>
                        } else {
<span class="fc" id="L765">                            noLimit = true;</span>
<span class="fc" id="L766">                            break;</span>
                        }
                    }
<span class="fc" id="L769">                }</span>
<span class="fc" id="L770">                _limit = limit_p[0];</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">                if (strPtr[0] != null) {</span>
<span class="fc bfc" id="L772" title="All 2 branches covered.">                    if (bufferString) {</span>
<span class="pc bpc" id="L773" title="1 of 2 branches missed.">                        if (strPtr[0] != ((RubyString) str).getByteList()) {</span>
<span class="nc" id="L774">                            ((RubyString) str).setValue(strPtr[0]);</span>
                        } else {
                            // same BL as before
                        }
                    } else {
                        // create string
<span class="fc" id="L780">                        str = runtime.newString(strPtr[0]);</span>
                    }
                }

<span class="fc bfc" id="L784" title="All 4 branches covered.">                if (rspara &amp;&amp; c != OpenFile.EOF) {</span>
                    // FIXME: This may block more often than it should, to clean up extraneous newlines
<span class="fc" id="L786">                    fptr.swallow(context, '\n');</span>
                }
<span class="fc bfc" id="L788" title="All 2 branches covered.">                if (!str.isNil()) {</span>
<span class="fc" id="L789">                    str = EncodingUtils.ioEncStr(runtime, str, fptr);</span>
                }
            } finally {
<span class="pc bpc" id="L792" title="2 of 4 branches missed.">                if (cache != null) cache.release(buf);</span>
            }

<span class="fc bfc" id="L795" title="All 4 branches covered.">            if (!str.isNil() &amp;&amp; !noLimit) {</span>
<span class="fc" id="L796">                fptr.incrementLineno(runtime);</span>
            }
        } finally {
<span class="pc bpc" id="L799" title="6 of 10 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L802">        return str;</span>
    }

    // fptr-&gt;enc and codeconv-&gt;enc
    public Encoding getEnc() {
<span class="nc" id="L807">        return openFile.encs.enc;</span>
    }
    
    // mri: io_read_encoding
    public Encoding getReadEncoding() {
<span class="fc" id="L812">        return openFile.readEncoding(getRuntime());</span>
    }
    
    // fptr-&gt;enc2 and codeconv-&gt;enc2
    public Encoding getEnc2() {
<span class="nc" id="L817">        return openFile.encs.enc2;</span>
    }
    
    // mri: io_input_encoding
    public Encoding getInputEncoding() {
<span class="nc" id="L822">        return openFile.inputEncoding(getRuntime());</span>
    }

    private static final String VENDOR;
<span class="pc bpc" id="L826" title="1 of 2 branches missed.">    static { String v = SafePropertyAccessor.getProperty(&quot;java.VENDOR&quot;) ; VENDOR = (v == null) ? &quot;&quot; : v; };</span>
    private static final String msgEINTR = &quot;Interrupted system call&quot;;

    // FIXME: We needed to use this to raise an appropriate error somewhere...find where...I think IRB related when suspending process?
    public static boolean restartSystemCall(Exception e) {
<span class="nc bnc" id="L831" title="All 4 branches missed.">        return VENDOR.startsWith(&quot;Apple&quot;) &amp;&amp; e.getMessage().equals(msgEINTR);</span>
    }

    // IO class methods.

    @JRubyMethod(name = &quot;new&quot;, rest = true, meta = true)
    public static IRubyObject newInstance(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="fc" id="L838">        RubyClass klass = (RubyClass)recv;</span>
        
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">        if (block.isGiven()) {</span>
<span class="nc" id="L841">            String className = klass.getName();</span>
<span class="nc" id="L842">            context.runtime.getWarnings().warn(</span>
                    ID.BLOCK_NOT_ACCEPTED,
                    className + &quot;::new() does not take block; use &quot; + className + &quot;::open() instead&quot;);
        }
        
<span class="fc" id="L847">        return klass.newInstance(context, args, block);</span>
    }

    @JRubyMethod(rest = true, meta = true)
    public static IRubyObject for_fd(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="fc" id="L852">        RubyClass klass = (RubyClass)recv;</span>

<span class="fc" id="L854">        return klass.newInstance(context, args, block);</span>
    }

    private IRubyObject initializeCommon(ThreadContext context, int fileno, IRubyObject vmodeArg, IRubyObject opt) {
<span class="fc" id="L858">        Ruby runtime = context.runtime;</span>

        ChannelFD fd;

<span class="pc bpc" id="L862" title="1 of 2 branches missed.">        if (!FilenoUtil.isFake(fileno)) {</span>
            // try using existing ChannelFD, then fall back on creating a new one
<span class="fc" id="L864">            fd = runtime.getFilenoUtil().getWrapperFromFileno(fileno);</span>

<span class="pc bpc" id="L866" title="1 of 2 branches missed.">            if (fd == null) {</span>
<span class="nc" id="L867">                fd = new ChannelFD(new NativeDeviceChannel(fileno), runtime.getPosix(), runtime.getFilenoUtil());</span>
            }
        } else {
<span class="nc" id="L870">            ChannelFD descriptor = runtime.getFilenoUtil().getWrapperFromFileno(fileno);</span>

<span class="nc bnc" id="L872" title="All 2 branches missed.">            if (descriptor == null) throw runtime.newErrnoEBADFError();</span>

<span class="nc" id="L874">            fd = descriptor;</span>
        }

<span class="pc bpc" id="L877" title="1 of 2 branches missed.">        if (!fd.ch.isOpen()) {</span>
<span class="nc" id="L878">            throw runtime.newErrnoEBADFError();</span>
        }

<span class="fc" id="L881">        return initializeCommon(context, fd, vmodeArg, opt);</span>
    }

    private IRubyObject initializeCommon(ThreadContext context, ChannelFD fd, IRubyObject vmodeArg, IRubyObject opt) {
<span class="fc" id="L885">        Ruby runtime = context.runtime;</span>

        int ofmode;
<span class="fc" id="L888">        int[] oflags_p = {ModeFlags.RDONLY};</span>

<span class="pc bpc" id="L890" title="1 of 8 branches missed.">        if(opt != null &amp;&amp; !opt.isNil() &amp;&amp; !(opt instanceof RubyHash) &amp;&amp; !(opt.respondsTo(&quot;to_hash&quot;))) {</span>
<span class="fc" id="L891">            throw runtime.newArgumentError(&quot;last argument must be a hash!&quot;);</span>
        }

<span class="pc bpc" id="L894" title="1 of 4 branches missed.">        if (opt != null &amp;&amp; !opt.isNil()) {</span>
<span class="fc" id="L895">            opt = opt.convertToHash();</span>
        }

<span class="pc bpc" id="L898" title="1 of 2 branches missed.">        if (!fd.ch.isOpen()) {</span>
<span class="nc" id="L899">            throw runtime.newErrnoEBADFError();</span>
        }

<span class="fc" id="L902">        Object pm = EncodingUtils.vmodeVperm(vmodeArg, runtime.newFixnum(0));</span>
<span class="fc" id="L903">        int[] fmode_p = {0};</span>
<span class="fc" id="L904">        ConvConfig convconfig = new ConvConfig();</span>
<span class="fc" id="L905">        EncodingUtils.extractModeEncoding(context, convconfig, pm, opt, oflags_p, fmode_p);</span>

        { // normally done with fcntl...which we *could* do too...but this is just checking read/write
<span class="fc" id="L908">            oflags_p[0] = ModeFlags.oflagsFrom(runtime.getPosix(), fd.ch);</span>

<span class="fc" id="L910">            ofmode = ModeFlags.getOpenFileFlagsFor(oflags_p[0]);</span>
<span class="pc bpc" id="L911" title="1 of 4 branches missed.">            if (EncodingUtils.vmode(pm) == null || EncodingUtils.vmode(pm).isNil()) {</span>
<span class="fc" id="L912">                fmode_p[0] = ofmode;</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">            } else if (((~ofmode &amp; fmode_p[0]) &amp; OpenFile.READWRITE) != 0) {</span>
<span class="fc" id="L914">                throw runtime.newErrnoEINVALError();</span>
            }
        }

<span class="pc bpc" id="L918" title="1 of 6 branches missed.">        if (opt != null &amp;&amp; !opt.isNil() &amp;&amp; ((RubyHash)opt).op_aref(context, runtime.newSymbol(&quot;autoclose&quot;)) == runtime.getFalse()) {</span>
<span class="fc" id="L919">            fmode_p[0] |= OpenFile.PREP;</span>
        }

        // JRUBY-4650: Make sure we clean up the old data, if it's present.
<span class="fc" id="L923">        MakeOpenFile();</span>

<span class="fc" id="L925">        openFile.setFD(fd);</span>
<span class="fc" id="L926">        openFile.setMode(fmode_p[0]);</span>
<span class="fc" id="L927">        openFile.encs = convconfig;</span>
<span class="fc" id="L928">        openFile.clearCodeConversion();</span>

<span class="fc" id="L930">        openFile.checkTTY();</span>
<span class="pc bpc" id="L931" title="3 of 4 branches missed.">        switch (fd.bestFileno()) {</span>
            case 0:
<span class="nc" id="L933">                openFile.stdio_file = System.in;</span>
<span class="nc" id="L934">                break;</span>
            case 1:
<span class="nc" id="L936">                openFile.stdio_file = System.out;</span>
<span class="nc" id="L937">                break;</span>
            case 2:
<span class="nc" id="L939">                openFile.stdio_file = System.err;</span>
                break;
        }

<span class="pc bpc" id="L943" title="1 of 2 branches missed.">        if (openFile.isBOM()) {</span>
<span class="nc" id="L944">            EncodingUtils.ioSetEncodingByBOM(context, this);</span>
        }

<span class="fc" id="L947">        return this;</span>
    }

    @JRubyMethod(name = &quot;initialize&quot;, visibility = PRIVATE)
    public IRubyObject initialize(ThreadContext context, IRubyObject fileNumber, Block unused) {
<span class="fc" id="L952">        return initializeCommon(context, RubyNumeric.fix2int(fileNumber), null, context.nil);</span>
    }
    
    @JRubyMethod(name = &quot;initialize&quot;, visibility = PRIVATE)
    public IRubyObject initialize(ThreadContext context, IRubyObject fileNumber, IRubyObject second, Block unused) {
<span class="fc" id="L957">        int fileno = RubyNumeric.fix2int(fileNumber);</span>
<span class="fc" id="L958">        IRubyObject vmode = null;</span>
        IRubyObject options;
<span class="fc" id="L960">        IRubyObject hashTest = TypeConverter.checkHashType(context.runtime, second);</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">        if (hashTest instanceof RubyHash) {</span>
<span class="fc" id="L962">            options = hashTest;</span>
        } else {
<span class="fc" id="L964">            options = context.nil;</span>
<span class="fc" id="L965">            vmode = second;</span>
        }

<span class="fc" id="L968">        return initializeCommon(context, fileno, vmode, options);</span>
    }

    @JRubyMethod(name = &quot;initialize&quot;, visibility = PRIVATE)
    public IRubyObject initialize(ThreadContext context, IRubyObject fileNumber, IRubyObject modeValue, IRubyObject options, Block unused) {
<span class="fc" id="L973">        int fileno = RubyNumeric.fix2int(fileNumber);</span>

<span class="fc" id="L975">        return initializeCommon(context, fileno, modeValue, options);</span>
    }

    // Encoding processing
    protected IOOptions parseIOOptions(IRubyObject arg) {
<span class="nc" id="L980">        Ruby runtime = getRuntime();</span>

<span class="nc bnc" id="L982" title="All 2 branches missed.">        if (arg instanceof RubyFixnum) return newIOOptions(runtime, (int) RubyFixnum.fix2long(arg));</span>

<span class="nc" id="L984">        String modeString = arg.convertToString().toString();</span>
        try {
<span class="nc" id="L986">            return new IOOptions(runtime, modeString);</span>
<span class="nc" id="L987">        } catch (InvalidValueException ive) {</span>
<span class="nc" id="L988">            throw runtime.newArgumentError(&quot;invalid access mode &quot; + modeString);</span>
        }
    }

    @JRubyMethod
    public IRubyObject external_encoding(ThreadContext context) {
<span class="fc" id="L994">        EncodingService encodingService = context.runtime.getEncodingService();</span>
        
<span class="fc bfc" id="L996" title="All 2 branches covered.">        if (openFile.encs.enc2 != null) return encodingService.getEncoding(openFile.encs.enc2);</span>
        
<span class="fc bfc" id="L998" title="All 2 branches covered.">        if (openFile.isWritable()) {</span>
<span class="fc bfc" id="L999" title="All 2 branches covered.">            return openFile.encs.enc == null ? context.runtime.getNil() : encodingService.getEncoding(openFile.encs.enc);</span>
        }
        
<span class="fc" id="L1002">        return encodingService.getEncoding(getReadEncoding());</span>
    }

    @JRubyMethod
    public IRubyObject internal_encoding(ThreadContext context) {
<span class="fc bfc" id="L1007" title="All 2 branches covered.">        if (openFile.encs.enc2 == null) return context.nil;</span>
        
<span class="fc" id="L1009">        return context.runtime.getEncodingService().getEncoding(getReadEncoding());</span>
    }

    @JRubyMethod
    public IRubyObject set_encoding(ThreadContext context, IRubyObject encodingObj) {
<span class="fc" id="L1014">        setEncoding(context, encodingObj, context.nil, context.nil);</span>

<span class="fc" id="L1016">        return context.nil;</span>
    }

    @JRubyMethod
    public IRubyObject set_encoding(ThreadContext context, IRubyObject encodingString, IRubyObject internalEncoding) {
<span class="fc" id="L1021">        IRubyObject opt = TypeConverter.checkHashType(context.runtime, internalEncoding);</span>
<span class="pc bpc" id="L1022" title="1 of 2 branches missed.">        if (!opt.isNil()) {</span>
<span class="nc" id="L1023">            setEncoding(context, encodingString, context.nil, opt);</span>
        } else {
<span class="fc" id="L1025">            setEncoding(context, encodingString, internalEncoding, context.nil);</span>
        }

<span class="fc" id="L1028">        return context.nil;</span>
    }

    @JRubyMethod
    public IRubyObject set_encoding(ThreadContext context, IRubyObject encodingString, IRubyObject internalEncoding, IRubyObject options) {
<span class="nc" id="L1033">        setEncoding(context, encodingString, internalEncoding, options);</span>

<span class="nc" id="L1035">        return context.nil;</span>
    }
    
    // mri: io_encoding_set
    public void setEncoding(ThreadContext context, IRubyObject v1, IRubyObject v2, IRubyObject opt) {
<span class="fc" id="L1040">        IOEncodable.ConvConfig holder = new IOEncodable.ConvConfig();</span>
<span class="fc" id="L1041">        int ecflags = openFile.encs.ecflags;</span>
<span class="fc" id="L1042">        IRubyObject[] ecopts_p = {context.nil};</span>
        IRubyObject tmp;
        
<span class="fc bfc" id="L1045" title="All 2 branches covered.">        if (!v2.isNil()) {</span>
<span class="fc" id="L1046">            holder.enc2 = EncodingUtils.rbToEncoding(context, v1);</span>
<span class="fc" id="L1047">            tmp = v2.checkStringType19();</span>
            
<span class="fc bfc" id="L1049" title="All 2 branches covered.">            if (!tmp.isNil()) {</span>
<span class="fc" id="L1050">                RubyString internalAsString = (RubyString)tmp;</span>
                
                // No encoding '-'
<span class="pc bpc" id="L1053" title="3 of 4 branches missed.">                if (internalAsString.size() == 1 &amp;&amp; internalAsString.asJavaString().equals(&quot;-&quot;)) {</span>
                    /* Special case - &quot;-&quot; =&gt; no transcoding */
<span class="nc" id="L1055">                    holder.enc = holder.enc2;</span>
<span class="nc" id="L1056">                    holder.enc2 = null;</span>
                } else {
<span class="fc" id="L1058">                    holder.enc = EncodingUtils.rbToEncoding(context, internalAsString);</span>
                }
                
<span class="pc bpc" id="L1061" title="1 of 2 branches missed.">                if (holder.enc == holder.enc2) {</span>
                    /* Special case - &quot;-&quot; =&gt; no transcoding */
<span class="nc" id="L1063">                    holder.enc2 = null;</span>
                }
<span class="fc" id="L1065">            } else {</span>
<span class="fc" id="L1066">                holder.enc = EncodingUtils.rbToEncoding(context, v2);</span>
                
<span class="fc bfc" id="L1068" title="All 2 branches covered.">                if (holder.enc == holder.enc2) {</span>
                    /* Special case - &quot;-&quot; =&gt; no transcoding */
<span class="fc" id="L1070">                    holder.enc2 = null;</span>
                }
            }
<span class="fc" id="L1073">            EncodingUtils.SET_UNIVERSAL_NEWLINE_DECORATOR_IF_ENC2(holder.getEnc2(), ecflags);</span>
<span class="fc" id="L1074">            ecflags = EncodingUtils.econvPrepareOptions(context, opt, ecopts_p, ecflags);</span>
        } else {
<span class="fc bfc" id="L1076" title="All 2 branches covered.">            if (v1.isNil()) {</span>
<span class="fc" id="L1077">                EncodingUtils.ioExtIntToEncs(context, holder, null, null, 0);</span>
<span class="fc" id="L1078">                EncodingUtils.SET_UNIVERSAL_NEWLINE_DECORATOR_IF_ENC2(holder.getEnc2(), ecflags);</span>
<span class="fc" id="L1079">                ecopts_p[0] = context.nil;</span>
            } else {
<span class="fc" id="L1081">                tmp = v1.checkStringType19();</span>
<span class="pc bpc" id="L1082" title="1 of 4 branches missed.">                if (!tmp.isNil() &amp;&amp; EncodingUtils.encAsciicompat(EncodingUtils.encGet(context, tmp))) {</span>
<span class="fc" id="L1083">                    EncodingUtils.parseModeEncoding(context, holder, tmp.asJavaString(), null);</span>
<span class="fc" id="L1084">                    EncodingUtils.SET_UNIVERSAL_NEWLINE_DECORATOR_IF_ENC2(holder.getEnc2(), ecflags);</span>
<span class="fc" id="L1085">                    ecflags = EncodingUtils.econvPrepareOptions(context, opt, ecopts_p, ecflags);</span>
                } else {
<span class="fc" id="L1087">                    EncodingUtils.ioExtIntToEncs(context, holder, EncodingUtils.rbToEncoding(context, v1), null, 0);</span>
<span class="fc" id="L1088">                    EncodingUtils.SET_UNIVERSAL_NEWLINE_DECORATOR_IF_ENC2(holder.getEnc2(), ecflags);</span>
                }
            }
            // enc, enc2 should be set by now
        }

<span class="fc" id="L1094">        int[] fmode_p = {openFile.getMode()};</span>
<span class="fc" id="L1095">        EncodingUtils.validateEncodingBinmode(context, fmode_p, ecflags, holder);</span>
<span class="fc" id="L1096">        openFile.setMode(fmode_p[0]);</span>

<span class="fc" id="L1098">        openFile.encs.enc = holder.enc;</span>
<span class="fc" id="L1099">        openFile.encs.enc2 = holder.enc2;</span>
<span class="fc" id="L1100">        openFile.encs.ecflags = ecflags;</span>
<span class="fc" id="L1101">        openFile.encs.ecopts = ecopts_p[0];</span>

<span class="fc" id="L1103">        openFile.clearCodeConversion();</span>
<span class="fc" id="L1104">    }</span>

    // rb_io_s_open, 2014/5/16
    @JRubyMethod(required = 1, rest = true, meta = true)
    public static IRubyObject open(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="fc" id="L1109">        IRubyObject io = ((RubyClass)recv).newInstance(context, args, Block.NULL_BLOCK);</span>

<span class="fc" id="L1111">        return ensureYieldClose(context, io, block);</span>
    }

    public static IRubyObject ensureYieldClose(ThreadContext context, IRubyObject port, Block block) {
<span class="fc bfc" id="L1115" title="All 2 branches covered.">        if (block.isGiven()) {</span>
<span class="fc" id="L1116">            Ruby runtime = context.runtime;</span>
            try {
<span class="fc" id="L1118">                return block.yield(context, port);</span>
            } finally {
<span class="fc" id="L1120">                ioClose(runtime, port);</span>
            }
        }
<span class="fc" id="L1123">        return port;</span>
    }

    public static IRubyObject sysopen(IRubyObject recv, IRubyObject[] args, Block block) {
<span class="nc" id="L1127">        return sysopen19(recv.getRuntime().getCurrentContext(), recv, args, block);</span>
    }

    // rb_io_s_sysopen
    @JRubyMethod(name = &quot;sysopen&quot;, required = 1, optional = 2, meta = true)
    public static IRubyObject sysopen19(ThreadContext context, IRubyObject recv, IRubyObject[] argv, Block block) {
<span class="fc" id="L1133">        Ruby runtime = context.runtime;</span>
        IRubyObject fname, vmode, vperm;
<span class="fc" id="L1135">        fname = vmode = vperm = context.nil;</span>
        IRubyObject intmode;
        int oflags;
        ChannelFD fd;
        int perm;

<span class="pc bpc" id="L1141" title="1 of 4 branches missed.">        switch (argv.length) {</span>
            case 3:
<span class="fc" id="L1143">                vperm = argv[2];</span>
            case 2:
<span class="fc" id="L1145">                vmode = argv[1];</span>
            case 1:
<span class="fc" id="L1147">                fname = argv[0];</span>
        }
<span class="fc" id="L1149">        fname = RubyFile.get_path(context, fname);</span>

<span class="fc bfc" id="L1151" title="All 2 branches covered.">        if (vmode.isNil())</span>
<span class="fc" id="L1152">            oflags = OpenFlags.O_RDONLY.intValue();</span>
<span class="pc bpc" id="L1153" title="1 of 2 branches missed.">        else if (!(intmode = TypeConverter.checkIntegerType(runtime, vmode, &quot;to_int&quot;)).isNil())</span>
<span class="nc" id="L1154">            oflags = RubyNumeric.num2int(intmode);</span>
        else {
<span class="fc" id="L1156">            vmode = vmode.convertToString();</span>
<span class="fc" id="L1157">            oflags = OpenFile.ioModestrOflags(runtime, vmode.toString());</span>
        }
<span class="fc bfc" id="L1159" title="All 2 branches covered.">        if (vperm.isNil()) perm = 0666;</span>
<span class="fc" id="L1160">        else              perm = RubyNumeric.num2int(vperm);</span>

<span class="fc" id="L1162">        StringSupport.checkStringSafety(context.runtime, fname);</span>
<span class="fc" id="L1163">        fname = ((RubyString)fname).dupFrozen();</span>
<span class="fc" id="L1164">        fd = sysopen(runtime, fname.toString(), oflags, perm);</span>
<span class="fc" id="L1165">        return runtime.newFixnum(fd.bestFileno());</span>
    }

<span class="fc" id="L1168">    private static class Sysopen {</span>
        String fname;
        int oflags;
        int perm;
        Errno errno;
    }

    // rb_sysopen
    protected static ChannelFD sysopen(Ruby runtime, String fname, int oflags, int perm) {
        ChannelFD fd;
<span class="fc" id="L1178">        Sysopen data = new Sysopen();</span>

<span class="fc" id="L1180">        data.fname = fname;</span>
<span class="fc" id="L1181">        data.oflags = oflags;</span>
<span class="fc" id="L1182">        data.perm = perm;</span>

<span class="fc" id="L1184">        fd = sysopenInternal(runtime, data);</span>
<span class="fc bfc" id="L1185" title="All 2 branches covered.">        if (fd == null) {</span>
<span class="pc bpc" id="L1186" title="2 of 4 branches missed.">            if (data.errno == Errno.EMFILE || data.errno == Errno.ENFILE) {</span>
<span class="nc" id="L1187">                System.gc();</span>
<span class="nc" id="L1188">                data.errno = null;</span>
<span class="nc" id="L1189">                fd = sysopenInternal(runtime, data);</span>
            }
<span class="pc bpc" id="L1191" title="1 of 2 branches missed.">            if (fd == null) {</span>
<span class="pc bpc" id="L1192" title="1 of 2 branches missed.">                if (data.errno != null) {</span>
<span class="fc" id="L1193">                    throw runtime.newErrnoFromErrno(data.errno, fname.toString());</span>
                } else {
<span class="nc" id="L1195">                    throw runtime.newSystemCallError(fname.toString());</span>
                }
            }
        }
<span class="fc" id="L1199">        return fd;</span>
    }

    // rb_sysopen_internal
    private static ChannelFD sysopenInternal(Ruby runtime, Sysopen data) {
        ChannelFD fd;
        // TODO: thread eventing as in MRI
<span class="fc" id="L1206">        fd = sysopenFunc(runtime, data);</span>
//        if (0 &lt;= fd)
//            rb_update_max_fd(fd);
<span class="fc" id="L1209">        return fd;</span>
    }

    // sysopen_func
    private static ChannelFD sysopenFunc(Ruby runtime, Sysopen data) {
<span class="fc" id="L1214">        return cloexecOpen(runtime, data);</span>
    }

    // rb_cloexec_open
    private static ChannelFD cloexecOpen(Ruby runtime, Sysopen data)
    {
<span class="fc" id="L1220">        Channel ret = null;</span>
//        #ifdef O_CLOEXEC
//            /* O_CLOEXEC is available since Linux 2.6.23.  Linux 2.6.18 silently ignore it. */
//            flags |= O_CLOEXEC;
//        #elif defined O_NOINHERIT
//            flags |= O_NOINHERIT;
//        #endif
<span class="fc" id="L1227">        PosixShim shim = new PosixShim(runtime.getPosix());</span>
<span class="fc" id="L1228">        ret = shim.open(runtime.getCurrentDirectory(), data.fname, ModeFlags.createModeFlags(data.oflags), data.perm);</span>
<span class="fc bfc" id="L1229" title="All 2 branches covered.">        if (ret == null) {</span>
<span class="fc" id="L1230">            data.errno = shim.errno;</span>
<span class="fc" id="L1231">            return null;</span>
        }
        // TODO, if we need it?
//        rb_maygvl_fd_fix_cloexec(ret);
<span class="fc" id="L1235">        return new ChannelFD(ret, runtime.getPosix(), runtime.getFilenoUtil());</span>
    }

    // MRI: rb_io_autoclose_p
    public boolean isAutoclose() {
        OpenFile fptr;
<span class="fc" id="L1241">        fptr = getOpenFileChecked();</span>
<span class="fc" id="L1242">        return fptr.isAutoclose();</span>
    }

    // MRI: rb_io_set_autoclose
    public void setAutoclose(boolean autoclose) {
        OpenFile fptr;
<span class="fc" id="L1248">        fptr = getOpenFileChecked();</span>
<span class="fc" id="L1249">        fptr.setAutoclose(autoclose);</span>
<span class="fc" id="L1250">    }</span>

    @JRubyMethod(name = &quot;autoclose?&quot;)
    public IRubyObject autoclose(ThreadContext context) {
<span class="fc" id="L1254">        return context.runtime.newBoolean(isAutoclose());</span>
    }

    @JRubyMethod(name = &quot;autoclose=&quot;)
    public IRubyObject autoclose_set(ThreadContext context, IRubyObject autoclose) {
<span class="fc" id="L1259">        setAutoclose(autoclose.isTrue());</span>
<span class="fc" id="L1260">        return context.nil;</span>
    }

    // MRI: rb_io_binmode_m
    @JRubyMethod(name = &quot;binmode&quot;)
    public IRubyObject binmode() {
<span class="fc" id="L1266">        setAscii8bitBinmode();</span>

<span class="fc" id="L1268">        RubyIO write_io = GetWriteIO();</span>
<span class="pc bpc" id="L1269" title="1 of 2 branches missed.">        if (write_io != this)</span>
<span class="nc" id="L1270">             write_io.setAscii8bitBinmode();</span>

<span class="fc" id="L1272">        return this;</span>
    }

    // MRI: rb_io_binmode_p
    @JRubyMethod(name = &quot;binmode?&quot;)
    public IRubyObject op_binmode(ThreadContext context) {
<span class="fc" id="L1278">        return RubyBoolean.newBoolean(context.runtime, getOpenFileChecked().isBinmode());</span>
    }

    // rb_io_syswrite
    @JRubyMethod(name = &quot;syswrite&quot;, required = 1)
    public IRubyObject syswrite(ThreadContext context, IRubyObject str) {
<span class="fc" id="L1284">       Ruby runtime = context.runtime;</span>
        OpenFile fptr;
        long n;

<span class="fc bfc" id="L1288" title="All 2 branches covered.">        if (!(str instanceof RubyString))</span>
<span class="fc" id="L1289">            str = str.asString();</span>

<span class="fc" id="L1291">        RubyIO io = GetWriteIO();</span>
<span class="fc" id="L1292">        fptr = io.getOpenFileChecked();</span>

<span class="fc" id="L1294">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L1296">            fptr.checkWritable(context);</span>

<span class="fc" id="L1298">            str.setFrozen(true);</span>

<span class="fc bfc" id="L1300" title="All 2 branches covered.">            if (fptr.wbuf.len != 0) {</span>
<span class="fc" id="L1301">                runtime.getWarnings().warn(&quot;syswrite for buffered IO&quot;);</span>
            }

<span class="fc" id="L1304">            ByteList strByteList = ((RubyString) str).getByteList();</span>
<span class="fc" id="L1305">            n = OpenFile.writeInternal(context, fptr, fptr.fd(), strByteList.unsafeBytes(), strByteList.begin(), strByteList.getRealSize());</span>

<span class="pc bpc" id="L1307" title="1 of 2 branches missed.">            if (n == -1) throw runtime.newErrnoFromErrno(fptr.errno(), fptr.getPath());</span>
        } finally {
<span class="pc bpc" id="L1309" title="2 of 4 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L1312">        return runtime.newFixnum(n);</span>
    }

    // MRI: rb_io_write_nonblock
    @JRubyMethod(name = &quot;write_nonblock&quot;, required = 1, optional = 1)
    public IRubyObject write_nonblock(ThreadContext context, IRubyObject[] argv) {
<span class="fc" id="L1318">        Ruby runtime = context.runtime;</span>
        IRubyObject str;
<span class="fc" id="L1320">        IRubyObject opts = context.nil;</span>
<span class="fc" id="L1321">        boolean no_exceptions = false;</span>

<span class="fc" id="L1323">        int argc = Arity.checkArgumentCount(context, argv, 1, 2);</span>
<span class="pc bpc" id="L1324" title="1 of 2 branches missed.">        if (argc == 2) {</span>
<span class="nc" id="L1325">            opts = argv[1].convertToHash();</span>
        }
<span class="fc" id="L1327">        str = argv[0];</span>

<span class="pc bpc" id="L1329" title="3 of 4 branches missed.">        if (!opts.isNil() &amp;&amp; runtime.getFalse() == ((RubyHash)opts).op_aref(context, runtime.newSymbol(&quot;exception&quot;)))</span>
<span class="nc" id="L1330">            no_exceptions = true;</span>

<span class="fc" id="L1332">        return ioWriteNonblock(context, runtime, str, no_exceptions);</span>
    }

    // MRI: io_write_nonblock
    private IRubyObject ioWriteNonblock(ThreadContext context, Ruby runtime, IRubyObject str, boolean no_exception) {
        OpenFile fptr;
        long n;

<span class="fc bfc" id="L1340" title="All 2 branches covered.">        if (!(str instanceof RubyString))</span>
<span class="fc" id="L1341">            str = str.asString();</span>

<span class="fc" id="L1343">        RubyIO io = GetWriteIO();</span>
<span class="fc" id="L1344">        fptr = io.getOpenFileChecked();</span>

<span class="fc" id="L1346">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L1348">            fptr.checkWritable(context);</span>

<span class="pc bpc" id="L1350" title="1 of 2 branches missed.">            if (fptr.io_fflush(context) &lt; 0)</span>
<span class="nc" id="L1351">                throw runtime.newErrnoFromErrno(fptr.errno(), fptr.getPath());</span>

<span class="fc" id="L1353">            fptr.setNonblock(runtime);</span>
            try {
<span class="fc" id="L1355">                ByteList strByteList = ((RubyString) str).getByteList();</span>
<span class="fc" id="L1356">                n = fptr.posix.write(fptr.fd(), strByteList.unsafeBytes(), strByteList.begin(), strByteList.getRealSize(), true);</span>
            } finally {
<span class="pc" id="L1358">                fptr.setBlock(runtime);</span>
<span class="fc" id="L1359">            }</span>

<span class="pc bpc" id="L1361" title="1 of 2 branches missed.">            if (n == -1) {</span>
<span class="nc bnc" id="L1362" title="All 4 branches missed.">                if (fptr.posix.errno == Errno.EWOULDBLOCK || fptr.posix.errno == Errno.EAGAIN) {</span>
<span class="nc bnc" id="L1363" title="All 2 branches missed.">                    if (no_exception) {</span>
<span class="nc" id="L1364">                        return runtime.newSymbol(&quot;wait_writable&quot;);</span>
                    } else {
<span class="nc" id="L1366">                        throw runtime.newErrnoEAGAINWritableError(&quot;write would block&quot;);</span>
                    }
                }
<span class="nc" id="L1369">                throw runtime.newErrnoFromErrno(fptr.posix.errno, fptr.getPath());</span>
            }
        } finally {
<span class="pc bpc" id="L1372" title="4 of 6 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L1375">        return runtime.newFixnum(n);</span>
    }

    public RubyIO GetWriteIO() {
        RubyIO writeIO;
<span class="fc" id="L1380">        checkInitialized();</span>
<span class="fc" id="L1381">        writeIO = openFile.tiedIOForWriting;</span>
<span class="fc bfc" id="L1382" title="All 2 branches covered.">        if (writeIO != null) {</span>
<span class="fc" id="L1383">            return writeIO;</span>
        }
<span class="fc" id="L1385">        return this;</span>
    }

    private void checkInitialized() {
<span class="pc bpc" id="L1389" title="1 of 2 branches missed.">        if (openFile == null) {</span>
<span class="nc" id="L1390">            throw getRuntime().newIOError(&quot;uninitialized stream&quot;);</span>
        }
<span class="fc" id="L1392">    }</span>
    
    /** io_write_m
     * 
     */
    @JRubyMethod(name = &quot;write&quot;, required = 1)
    public IRubyObject write(ThreadContext context, IRubyObject str) {
<span class="fc" id="L1399">        return write(context, str, false);</span>
    }

    // io_write
    public IRubyObject write(ThreadContext context, IRubyObject str, boolean nosync) {
<span class="fc" id="L1404">        Ruby runtime = context.runtime;</span>
        OpenFile fptr;
        long n;
        IRubyObject tmp;

<span class="fc" id="L1409">        RubyIO io = GetWriteIO();</span>

<span class="fc" id="L1411">        str = str.asString();</span>
<span class="fc" id="L1412">        tmp = TypeConverter.ioCheckIO(runtime, io);</span>
<span class="pc bpc" id="L1413" title="1 of 2 branches missed.">        if (tmp.isNil()) {</span>
	        /* port is not IO, call write method for it. */
<span class="nc" id="L1415">            return io.callMethod(context, &quot;write&quot;, str);</span>
        }
<span class="fc" id="L1417">        io = (RubyIO)tmp;</span>
<span class="fc bfc" id="L1418" title="All 2 branches covered.">        if (((RubyString)str).size() == 0) return RubyFixnum.zero(runtime);</span>

<span class="fc" id="L1420">        str = ((RubyString)str).dupFrozen();</span>

<span class="fc" id="L1422">        fptr = io.getOpenFileChecked();</span>

<span class="fc" id="L1424">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L1426">            fptr = io.getOpenFileChecked();</span>
<span class="fc" id="L1427">            fptr.checkWritable(context);</span>

<span class="fc" id="L1429">            n = fptr.fwrite(context, str, nosync);</span>
<span class="pc bpc" id="L1430" title="1 of 2 branches missed.">            if (n == -1) throw runtime.newErrnoFromErrno(fptr.errno(), fptr.getPath());</span>
        } finally {
<span class="pc bpc" id="L1432" title="2 of 4 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L1435">        return RubyFixnum.newFixnum(runtime, n);</span>
    }

    /** rb_io_addstr
     * 
     */
    @JRubyMethod(name = &quot;&lt;&lt;&quot;, required = 1)
    public IRubyObject op_append(ThreadContext context, IRubyObject anObject) {
        // Claims conversion is done via 'to_s' in docs.
<span class="fc" id="L1444">        callMethod(context, &quot;write&quot;, anObject);</span>
        
<span class="fc" id="L1446">        return this;</span>
    }

    @JRubyMethod(name = &quot;fileno&quot;, alias = &quot;to_i&quot;)
    public RubyFixnum fileno(ThreadContext context) {
<span class="fc" id="L1451">        return context.runtime.newFixnum(getOpenFileChecked().getFileno());</span>
    }
    
    /** Returns the current line number.
     * 
     * @return the current line number.
     */
    @JRubyMethod(name = &quot;lineno&quot;)
    public RubyFixnum lineno(ThreadContext context) {
<span class="fc" id="L1460">        return context.runtime.newFixnum(getOpenFileChecked().getLineNumber());</span>
    }

    /** Sets the current line number.
     * 
     * @param newLineNumber The new line number.
     */
    @JRubyMethod(name = &quot;lineno=&quot;, required = 1)
    public RubyFixnum lineno_set(ThreadContext context, IRubyObject newLineNumber) {
<span class="fc" id="L1469">        getOpenFileChecked().setLineNumber(RubyNumeric.fix2int(newLineNumber));</span>

<span class="fc" id="L1471">        return context.runtime.newFixnum(getOpenFileChecked().getLineNumber());</span>
    }

    /** Returns the current sync mode.
     *
     * MRI: rb_io_sync
     * 
     * @return the current sync mode.
     */
    @JRubyMethod
    public RubyBoolean sync(ThreadContext context) {
<span class="fc" id="L1482">        Ruby runtime = context.runtime;</span>
        OpenFile fptr;

<span class="fc" id="L1485">        RubyIO io = GetWriteIO();</span>
<span class="fc" id="L1486">        fptr = io.getOpenFileChecked();</span>
<span class="fc" id="L1487">        fptr.lock();</span>
        try {
<span class="fc bfc" id="L1489" title="All 2 branches covered.">            return (fptr.getMode() &amp; OpenFile.SYNC) != 0 ? runtime.getTrue() : runtime.getFalse();</span>
        } finally {
<span class="pc" id="L1491">            fptr.unlock();</span>
        }
    }
    
    /**
     * &lt;p&gt;Return the process id (pid) of the process this IO object
     * spawned.  If no process exists (popen was not called), then
     * nil is returned.  This is not how it appears to be defined
     * but ruby 1.8 works this way.&lt;/p&gt;
     * 
     * @return the pid or nil
     */
    @JRubyMethod
    public IRubyObject pid(ThreadContext context) {
<span class="fc" id="L1505">        OpenFile myOpenFile = getOpenFileChecked();</span>
        
<span class="fc bfc" id="L1507" title="All 2 branches covered.">        if (myOpenFile.getProcess() == null) {</span>
<span class="fc" id="L1508">            return context.runtime.getNil();</span>
        }
        
        // Of course this isn't particularly useful.
<span class="fc" id="L1512">        long pid = myOpenFile.getPid();</span>

<span class="fc" id="L1514">        return context.runtime.newFixnum(pid);</span>
    }

    // rb_io_pos
    @JRubyMethod(name = {&quot;pos&quot;, &quot;tell&quot;})
    public RubyFixnum pos(ThreadContext context) {
<span class="fc" id="L1520">        OpenFile fptr = getOpenFileChecked();</span>

<span class="fc" id="L1522">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L1524">            long pos = fptr.tell(context);</span>
<span class="pc bpc" id="L1525" title="3 of 4 branches missed.">            if (pos &lt; 0 &amp;&amp; fptr.errno() != null) throw context.runtime.newErrnoFromErrno(fptr.errno(), fptr.getPath());</span>
<span class="fc" id="L1526">            pos -= fptr.rbuf.len;</span>
<span class="fc" id="L1527">            return context.runtime.newFixnum(pos);</span>
        } finally {
<span class="pc bpc" id="L1529" title="3 of 4 branches missed.">            if (locked) fptr.unlock();</span>
        }
    }

    // rb_io_set_pos
    @JRubyMethod(name = &quot;pos=&quot;, required = 1)
    public RubyFixnum pos_set(ThreadContext context, IRubyObject offset) {
        OpenFile fptr;
        long pos;

<span class="fc" id="L1539">        pos = offset.convertToInteger().getLongValue();</span>
<span class="fc" id="L1540">        fptr = getOpenFileChecked();</span>

<span class="fc" id="L1542">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L1544">            pos = fptr.seek(context, pos, PosixShim.SEEK_SET);</span>
<span class="pc bpc" id="L1545" title="3 of 4 branches missed.">            if (pos &lt; 0 &amp;&amp; fptr.errno() != null) throw context.runtime.newErrnoFromErrno(fptr.errno(), fptr.getPath());</span>
        } finally {
<span class="pc bpc" id="L1547" title="3 of 4 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L1550">        return context.runtime.newFixnum(pos);</span>
    }
    
    /** Print some objects to the stream.
     * 
     */
    @JRubyMethod(rest = true, reads = FrameField.LASTLINE)
    public IRubyObject print(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L1558">        return print(context, this, args);</span>
    }

    /**
     * Print some objects to the stream.
     *
     * MRI: rb_io_print
     */
    public static IRubyObject print(ThreadContext context, IRubyObject out, IRubyObject[] args) {
<span class="fc" id="L1567">        Ruby runtime = context.runtime;</span>
        int i;
        IRubyObject line;
<span class="fc" id="L1570">        int argc = args.length;</span>

        /* if no argument given, print `$_' */
<span class="fc bfc" id="L1573" title="All 2 branches covered.">        if (argc == 0) {</span>
<span class="fc" id="L1574">            argc = 1;</span>
<span class="fc" id="L1575">            line = context.getLastLine();</span>
<span class="fc" id="L1576">            args = new IRubyObject[]{line};</span>
        }
<span class="fc bfc" id="L1578" title="All 2 branches covered.">        for (i=0; i&lt;argc; i++) {</span>
<span class="fc" id="L1579">            IRubyObject outputFS = runtime.getGlobalVariables().get(&quot;$,&quot;);</span>
<span class="pc bpc" id="L1580" title="3 of 4 branches missed.">            if (!outputFS.isNil() &amp;&amp; i&gt;0) {</span>
<span class="nc" id="L1581">                write(context, out, outputFS);</span>
            }
<span class="fc" id="L1583">            write(context, out, args[i]);</span>
        }
<span class="fc" id="L1585">        IRubyObject outputRS = runtime.getGlobalVariables().get(&quot;$\\&quot;);</span>
<span class="pc bpc" id="L1586" title="1 of 4 branches missed.">        if (argc &gt; 0 &amp;&amp; !outputRS.isNil()) {</span>
<span class="fc" id="L1587">            write(context, out, outputRS);</span>
        }

<span class="fc" id="L1590">        return context.nil;</span>
    }

    @JRubyMethod(required = 1, rest = true)
    public IRubyObject printf(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L1595">        write(context, this, RubyKernel.sprintf(context, this, args));</span>
<span class="fc" id="L1596">        return context.nil;</span>
    }

    @JRubyMethod(required = 1)
    public IRubyObject putc(ThreadContext context, IRubyObject ch) {
<span class="fc" id="L1601">        Ruby runtime = context.runtime;</span>
        IRubyObject str;
<span class="pc bpc" id="L1603" title="1 of 2 branches missed.">        if (ch instanceof RubyString) {</span>
<span class="fc" id="L1604">            str = ((RubyString)ch).substr(runtime, 0, 1);</span>
        }
        else {
<span class="nc" id="L1607">            str = RubyString.newStringShared(runtime, RubyFixnum.SINGLE_CHAR_BYTELISTS19[RubyNumeric.num2chr(ch) &amp; 0xFF]);</span>
        }
<span class="nc" id="L1609">        write(context, str);</span>
<span class="nc" id="L1610">        return ch;</span>
    }

    public static IRubyObject putc(ThreadContext context, IRubyObject maybeIO, IRubyObject object) {
<span class="nc bnc" id="L1614" title="All 2 branches missed.">        if (maybeIO instanceof RubyIO) {</span>
<span class="nc" id="L1615">            ((RubyIO)maybeIO).putc(context, object);</span>
        } else {
<span class="nc" id="L1617">            byte c = RubyNumeric.num2chr(object);</span>
<span class="nc" id="L1618">            IRubyObject str = RubyString.newStringShared(context.runtime, RubyFixnum.SINGLE_CHAR_BYTELISTS19[c &amp; 0xFF]);</span>
<span class="nc" id="L1619">            maybeIO.callMethod(context, &quot;write&quot;, str);</span>
        }

<span class="nc" id="L1622">        return object;</span>
    }

    public RubyFixnum seek(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L1626">        int whence = PosixShim.SEEK_SET;</span>
        
<span class="fc bfc" id="L1628" title="All 2 branches covered.">        if (args.length &gt; 1) {</span>
<span class="fc" id="L1629">            whence = interpretSeekWhence(args[1]);</span>
        }
        
<span class="fc" id="L1632">        return doSeek(context, args[0], whence);</span>
    }

    @JRubyMethod
    public RubyFixnum seek(ThreadContext context, IRubyObject arg0) {
<span class="fc" id="L1637">        int whence = PosixShim.SEEK_SET;</span>
        
<span class="fc" id="L1639">        return doSeek(context, arg0, whence);</span>
    }

    @JRubyMethod
    public RubyFixnum seek(ThreadContext context, IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L1644">        int whence = interpretSeekWhence(arg1);</span>
        
<span class="fc" id="L1646">        return doSeek(context, arg0, whence);</span>
    }

    // rb_io_seek
    private RubyFixnum doSeek(ThreadContext context, IRubyObject offset, int whence) {
        OpenFile fptr;
        long pos;

<span class="fc" id="L1654">        pos = RubyNumeric.num2long(offset);</span>
<span class="fc" id="L1655">        fptr = getOpenFileChecked();</span>

<span class="fc" id="L1657">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L1659">            pos = fptr.seek(context, pos, whence);</span>
<span class="pc bpc" id="L1660" title="1 of 4 branches missed.">            if (pos &lt; 0 &amp;&amp; fptr.errno() != null) throw getRuntime().newErrnoFromErrno(fptr.errno(), fptr.getPath());</span>
        } finally {
<span class="pc bpc" id="L1662" title="2 of 4 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L1665">        return RubyFixnum.zero(context.runtime);</span>
    }
    
    // This was a getOpt with one mandatory arg, but it did not work
    // so I am parsing it for now.
    @JRubyMethod(required = 1, optional = 1)
    public RubyFixnum sysseek(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L1672">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L1673">        IRubyObject offset = context.nil, ptrname = context.nil;</span>
<span class="fc" id="L1674">        int whence = PosixShim.SEEK_SET;</span>
        OpenFile fptr;
        long pos;

<span class="pc bpc" id="L1678" title="2 of 3 branches missed.">        switch (args.length) {</span>
            case 2:
<span class="fc" id="L1680">                ptrname = args[1];</span>
<span class="fc" id="L1681">                whence = interpretSeekWhence(ptrname);</span>
            case 1:
<span class="fc" id="L1683">                offset = args[0];</span>
        }
<span class="fc" id="L1685">        pos = offset.convertToInteger().getLongValue();</span>
<span class="fc" id="L1686">        fptr = getOpenFileChecked();</span>

<span class="fc" id="L1688">        boolean locked = fptr.lock();</span>
        try {
<span class="pc bpc" id="L1690" title="1 of 2 branches missed.">            if ((fptr.isReadable()) &amp;&amp;</span>
<span class="pc bpc" id="L1691" title="1 of 4 branches missed.">                    (fptr.READ_DATA_BUFFERED() || fptr.READ_CHAR_PENDING())) {</span>
<span class="fc" id="L1692">                throw runtime.newIOError(&quot;sysseek for buffered IO&quot;);</span>
            }
<span class="pc bpc" id="L1694" title="3 of 4 branches missed.">            if (fptr.isWritable() &amp;&amp; fptr.wbuf.len != 0) {</span>
<span class="nc" id="L1695">                runtime.getWarnings().warn(&quot;sysseek for buffered IO&quot;);</span>
            }
<span class="fc" id="L1697">            fptr.errno(null);</span>
<span class="fc" id="L1698">            pos = fptr.posix.lseek(fptr.fd(), pos, whence);</span>
<span class="pc bpc" id="L1699" title="3 of 4 branches missed.">            if (pos == -1 &amp;&amp; fptr.errno() != null) throw runtime.newErrnoFromErrno(fptr.errno(), fptr.getPath());</span>
        } finally {
<span class="pc bpc" id="L1701" title="2 of 4 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L1704">        return RubyFixnum.newFixnum(runtime, pos);</span>
    }

    private static int interpretSeekWhence(IRubyObject vwhence) {
<span class="pc bpc" id="L1708" title="1 of 2 branches missed.">        if (vwhence instanceof RubySymbol) {</span>
<span class="nc bnc" id="L1709" title="All 2 branches missed.">            if (vwhence.toString() == &quot;SET&quot;)</span>
<span class="nc" id="L1710">                return PosixShim.SEEK_SET;</span>
<span class="nc bnc" id="L1711" title="All 2 branches missed.">            if (vwhence.toString() == &quot;CUR&quot;)</span>
<span class="nc" id="L1712">                return PosixShim.SEEK_CUR;</span>
<span class="nc bnc" id="L1713" title="All 2 branches missed.">            if (vwhence.toString() == &quot;END&quot;)</span>
<span class="nc" id="L1714">                return PosixShim.SEEK_END;</span>
        }
<span class="fc" id="L1716">        return (int)vwhence.convertToInteger().getLongValue();</span>
    }

    // rb_io_rewind
    @JRubyMethod
    public RubyFixnum rewind(ThreadContext context) {
<span class="fc" id="L1722">        Ruby runtime = context.runtime;</span>
        OpenFile fptr;

<span class="fc" id="L1725">        fptr = getOpenFileChecked();</span>
<span class="fc" id="L1726">        boolean locked = fptr.lock();</span>
        try {
<span class="pc bpc" id="L1728" title="3 of 4 branches missed.">            if (fptr.seek(context, 0L, 0) &lt; 0 &amp;&amp; fptr.errno() != null)</span>
<span class="nc" id="L1729">                throw context.runtime.newErrnoFromErrno(fptr.errno(), fptr.getPath());</span>
<span class="fc" id="L1730">            RubyArgsFile.ArgsFileData data = RubyArgsFile.ArgsFileData.getDataFrom(runtime.getArgsFile());</span>
<span class="fc bfc" id="L1731" title="All 2 branches covered.">            if (this == data.currentFile) {</span>
<span class="fc" id="L1732">                data.currentLineNumber -= fptr.getLineNumber();</span>
            }
<span class="fc" id="L1734">            fptr.setLineNumber(0);</span>
<span class="pc bpc" id="L1735" title="1 of 2 branches missed.">            if (fptr.readconv != null) {</span>
<span class="nc" id="L1736">                fptr.clearReadConversion();</span>
            }
        } finally {
<span class="pc bpc" id="L1739" title="3 of 4 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L1742">        return RubyFixnum.zero(runtime);</span>
    }

    // rb_io_fsync
    @JRubyMethod
    public RubyFixnum fsync(ThreadContext context) {
<span class="fc" id="L1748">        Ruby runtime = context.runtime;</span>
        OpenFile fptr;

<span class="fc" id="L1751">        RubyIO io = GetWriteIO();</span>
<span class="fc" id="L1752">        fptr = io.getOpenFileChecked();</span>

<span class="pc bpc" id="L1754" title="1 of 2 branches missed.">        if (fptr.io_fflush(context) &lt; 0)</span>
<span class="nc" id="L1755">            throw runtime.newSystemCallError(&quot;&quot;);</span>

//        # ifndef _WIN32	/* already called in io_fflush() */
//        if ((int)rb_thread_io_blocking_region(nogvl_fsync, fptr, fptr-&gt;fd) &lt; 0)
//            rb_sys_fail_path(fptr-&gt;pathv);
//        # endif
<span class="fc" id="L1761">        return RubyFixnum.zero(runtime);</span>
    }

    /** Sets the current sync mode.
     *
     * MRI: rb_io_set_sync
     * 
     * @param sync The new sync mode.
     */
    @JRubyMethod(name = &quot;sync=&quot;, required = 1)
    public IRubyObject sync_set(IRubyObject sync) {
        OpenFile fptr;

<span class="fc" id="L1774">        RubyIO io = GetWriteIO();</span>
<span class="fc" id="L1775">        fptr = io.getOpenFileChecked();</span>
<span class="fc" id="L1776">        fptr.setSync(sync.isTrue());</span>
<span class="fc" id="L1777">        return sync;</span>
    }

    // rb_io_eof
    @JRubyMethod(name = {&quot;eof?&quot;, &quot;eof&quot;})
    public RubyBoolean eof_p(ThreadContext context) {
<span class="fc" id="L1783">        Ruby runtime = context.runtime;</span>
        OpenFile fptr;

<span class="fc" id="L1786">        fptr = getOpenFileChecked();</span>

<span class="fc" id="L1788">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L1790">            fptr.checkCharReadable(context);</span>

<span class="pc bpc" id="L1792" title="1 of 2 branches missed.">            if (fptr.READ_CHAR_PENDING()) return runtime.getFalse();</span>
<span class="fc bfc" id="L1793" title="All 2 branches covered.">            if (fptr.READ_DATA_PENDING()) return runtime.getFalse();</span>
<span class="fc" id="L1794">            fptr.READ_CHECK(context);</span>
            //        #if defined(RUBY_TEST_CRLF_ENVIRONMENT) || defined(_WIN32)
            //        if (!NEED_READCONV(fptr) &amp;&amp; NEED_NEWLINE_DECORATOR_ON_READ(fptr)) {
            //            return eof(fptr-&gt;fd) ? Qtrue : Qfalse;
            //        }
            //        #endif
<span class="fc bfc" id="L1800" title="All 2 branches covered.">            if (fptr.fillbuf(context) &lt; 0) {</span>
<span class="fc" id="L1801">                return runtime.getTrue();</span>
            }
        } finally {
<span class="pc bpc" id="L1804" title="6 of 10 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L1807">        return runtime.getFalse();</span>
    }

    @JRubyMethod(name = {&quot;tty?&quot;, &quot;isatty&quot;})
    public RubyBoolean tty_p(ThreadContext context) {
<span class="fc" id="L1812">        Ruby runtime = context.runtime;</span>
        OpenFile fptr;

<span class="fc" id="L1815">        fptr = getOpenFileChecked();</span>

<span class="fc" id="L1817">        fptr.lock();</span>
        try {
<span class="fc bfc" id="L1819" title="All 2 branches covered.">            if (fptr.isStdio()) return runtime.getTrue();</span>
<span class="pc bpc" id="L1820" title="1 of 4 branches missed.">            if (runtime.getPosix().isNative() &amp;&amp; runtime.getPosix().libc().isatty(fptr.getFileno()) != 0)</span>
<span class="fc" id="L1821">                return runtime.getTrue();</span>
        } finally {
<span class="pc" id="L1823">            fptr.unlock();</span>
<span class="fc" id="L1824">        }</span>

<span class="fc" id="L1826">        return runtime.getFalse();</span>
    }

    // rb_io_init_copy
    @JRubyMethod(required = 1, visibility = Visibility.PRIVATE)
    @Override
    public IRubyObject initialize_copy(IRubyObject _io){
<span class="fc" id="L1833">        RubyIO dest = this;</span>
<span class="fc" id="L1834">        Ruby runtime = getRuntime();</span>
<span class="fc" id="L1835">        ThreadContext context = runtime.getCurrentContext();</span>

        OpenFile fptr, orig;
        ChannelFD fd;
        RubyIO write_io;
        long pos;

<span class="fc" id="L1842">        RubyIO io = TypeConverter.ioGetIO(runtime, _io);</span>
<span class="pc bpc" id="L1843" title="1 of 2 branches missed.">        if (!OBJ_INIT_COPY(dest, io)) return dest;</span>
<span class="fc" id="L1844">        orig = io.getOpenFileChecked();</span>
<span class="fc" id="L1845">        fptr = dest.MakeOpenFile();</span>

        // orig is the visible one here but we lock both anyway
<span class="fc" id="L1848">        boolean locked1 = orig.lock();</span>
<span class="fc" id="L1849">        boolean locked2 = fptr.lock();</span>
        try {
<span class="fc" id="L1851">            io.flush(context);</span>

            /* copy rb_io_t structure */
<span class="fc" id="L1854">            fptr.setMode(orig.getMode() &amp; ~OpenFile.PREP);</span>
<span class="fc" id="L1855">            fptr.encs = orig.encs;</span>
<span class="fc" id="L1856">            fptr.setProcess(orig.getProcess());</span>
<span class="fc" id="L1857">            fptr.setLineNumber(orig.getLineNumber());</span>
<span class="pc bpc" id="L1858" title="1 of 2 branches missed.">            if (orig.getPath() != null) fptr.setPath(orig.getPath());</span>
<span class="fc" id="L1859">            fptr.setFinalizer(orig.getFinalizer());</span>
            // TODO: not using pipe_finalize yet
            //        #if defined (__CYGWIN__) || !defined(HAVE_FORK)
            //        if (fptr.finalize == pipe_finalize)
            //            pipe_add_fptr(fptr);
            //        #endif

<span class="fc" id="L1866">            fd = orig.fd().dup();</span>
<span class="fc" id="L1867">            fptr.setFD(fd);</span>
<span class="fc" id="L1868">            pos = orig.tell(context);</span>
<span class="pc bpc" id="L1869" title="1 of 2 branches missed.">            if (0 &lt;= pos)</span>
<span class="fc" id="L1870">                fptr.seek(context, pos, PosixShim.SEEK_SET);</span>
        } finally {
<span class="pc bpc" id="L1872" title="3 of 4 branches missed.">            if (locked2) fptr.unlock();</span>
<span class="pc bpc" id="L1873" title="3 of 4 branches missed.">            if (locked1) orig.unlock();</span>
        }

<span class="fc bfc" id="L1876" title="All 2 branches covered.">        if (fptr.isBinmode()) {</span>
<span class="fc" id="L1877">            dest.setBinmode();</span>
        }

<span class="fc" id="L1880">        write_io = io.GetWriteIO();</span>
<span class="pc bpc" id="L1881" title="1 of 2 branches missed.">        if (io != write_io) {</span>
<span class="nc" id="L1882">            write_io = (RubyIO)write_io.dup();</span>
<span class="nc" id="L1883">            fptr.tiedIOForWriting = write_io;</span>
<span class="nc" id="L1884">            dest.getInstanceVariables().setInstanceVariable(&quot;@tied_io_for_writing&quot;, write_io);</span>
        }

<span class="fc" id="L1887">        return dest;</span>
    }
    
    @JRubyMethod(name = &quot;closed?&quot;)
    public RubyBoolean closed_p(ThreadContext context) {
<span class="fc" id="L1892">        return context.runtime.newBoolean(isClosed());</span>
    }

    /**
     * Is this IO closed
     *
     * MRI: rb_io_closed
     * 
     * @return true if closed
     */
    public boolean isClosed() {
        OpenFile fptr;
        RubyIO write_io;
        OpenFile write_fptr;

<span class="fc" id="L1907">        write_io = GetWriteIO();</span>
<span class="fc bfc" id="L1908" title="All 2 branches covered.">        if (this != write_io) {</span>
<span class="fc" id="L1909">            write_fptr = write_io.openFile;</span>
<span class="pc bpc" id="L1910" title="1 of 4 branches missed.">            if (write_fptr != null &amp;&amp; write_fptr.fd() != null) {</span>
<span class="fc" id="L1911">                return false;</span>
            }
        }

<span class="fc" id="L1915">        fptr = openFile;</span>
<span class="fc" id="L1916">        checkInitialized();</span>
<span class="fc bfc" id="L1917" title="All 2 branches covered.">        return fptr.fd() != null ? false : true;</span>
    }

    /** 
     * &lt;p&gt;Closes all open resources for the IO.  It also removes
     * it from our magical all open file descriptor pool.&lt;/p&gt;
     * 
     * @return The IO.
     *
     * MRI: rb_io_close_m
     */
    @JRubyMethod
    public IRubyObject close() {
<span class="fc" id="L1930">        Ruby runtime = getRuntime();</span>

<span class="fc" id="L1932">        openFile.checkClosed();</span>
<span class="fc" id="L1933">        return rbIoClose(runtime);</span>
    }

    // io_close
    protected static IRubyObject ioClose(Ruby runtime, IRubyObject io) {
<span class="fc" id="L1938">        ThreadContext context = runtime.getCurrentContext();</span>
<span class="fc" id="L1939">        IRubyObject closed = io.checkCallMethod(context, &quot;closed?&quot;);</span>
<span class="fc bfc" id="L1940" title="All 4 branches covered.">        if (closed != null &amp;&amp; closed.isTrue()) return io;</span>
<span class="fc" id="L1941">        IRubyObject oldExc = context.getErrorInfo();</span>
        try {
<span class="fc" id="L1943">            return io.checkCallMethod(context, &quot;close&quot;);</span>
<span class="fc" id="L1944">        } catch (RaiseException re) {</span>
<span class="pc bpc" id="L1945" title="1 of 2 branches missed.">            if (re.getMessage().contains(CLOSED_STREAM_MSG)) {</span>
                // ignore
<span class="nc" id="L1947">                context.setErrorInfo(oldExc);</span>
<span class="nc" id="L1948">                return context.nil;</span>
            } else {
<span class="fc" id="L1950">                throw re;</span>
            }
        }
    }
    
    // rb_io_close  
    protected IRubyObject rbIoClose(Ruby runtime) {
<span class="fc" id="L1957">        ThreadContext context = runtime.getCurrentContext();</span>
        OpenFile fptr;
        RubyIO write_io;
        OpenFile write_fptr;

<span class="fc" id="L1962">        write_io = GetWriteIO();</span>
<span class="fc bfc" id="L1963" title="All 2 branches covered.">        if (this != write_io) {</span>
<span class="fc" id="L1964">            write_fptr = write_io.openFile;</span>

<span class="fc" id="L1966">            boolean locked = write_fptr.lock();</span>
            try {
<span class="pc bpc" id="L1968" title="2 of 4 branches missed.">                if (write_fptr != null &amp;&amp; write_fptr.fd() != null) {</span>
<span class="fc" id="L1969">                    write_fptr.cleanup(runtime, true);</span>
                }
            } finally {
<span class="pc bpc" id="L1972" title="3 of 4 branches missed.">                if (locked) write_fptr.unlock();</span>
            }
        }

<span class="fc" id="L1976">        fptr = openFile;</span>

<span class="fc" id="L1978">        boolean locked = fptr.lock();</span>
        try {
<span class="pc bpc" id="L1980" title="1 of 2 branches missed.">            if (fptr == null) return runtime.getNil();</span>
<span class="fc bfc" id="L1981" title="All 2 branches covered.">            if (fptr.fd() == null) return runtime.getNil();</span>

            // interrupt waiting threads
<span class="fc" id="L1984">            fptr.interruptBlockingThreads();</span>
<span class="fc" id="L1985">            fptr.cleanup(runtime, false);</span>

<span class="fc bfc" id="L1987" title="All 2 branches covered.">            if (fptr.getProcess() != null) {</span>
<span class="fc" id="L1988">                context.setLastExitStatus(context.nil);</span>

<span class="pc bpc" id="L1990" title="2 of 4 branches missed.">                if (runtime.getPosix().isNative() &amp;&amp; fptr.getProcess() instanceof POSIXProcess) {</span>
                    // We do not need to nuke native-launched child process, since we now have full control
                    // over child process pipes.
<span class="fc" id="L1993">                    IRubyObject processResult = RubyProcess.RubyStatus.newProcessStatus(runtime, ((POSIXProcess) fptr.getProcess()).status(), fptr.getPid());</span>
<span class="fc" id="L1994">                    context.setLastExitStatus(processResult);</span>
<span class="fc" id="L1995">                } else {</span>
                    // If this is not a popen3/popen4 stream and it has a process, attempt to shut down that process
<span class="nc bnc" id="L1997" title="All 2 branches missed.">                    if (!popenSpecial) {</span>
<span class="nc" id="L1998">                        obliterateProcess(fptr.getProcess());</span>
                        // RubyStatus uses real native status now, so we unshift Java's shifted exit status
<span class="nc" id="L2000">                        IRubyObject processResult = RubyProcess.RubyStatus.newProcessStatus(runtime, fptr.getProcess().exitValue() &lt;&lt; 8, fptr.getPid());</span>
<span class="nc" id="L2001">                        context.setLastExitStatus(processResult);</span>
                    }
                }
<span class="fc" id="L2004">                fptr.setProcess(null);</span>
            }
        } finally {
<span class="pc bpc" id="L2007" title="5 of 8 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L2010">        return runtime.getNil();</span>
    }

    // MRI: rb_io_close_write
    @JRubyMethod
    public IRubyObject close_write(ThreadContext context) {
<span class="fc" id="L2016">        Ruby runtime = context.runtime;</span>
        OpenFile fptr;
        RubyIO write_io;

<span class="fc" id="L2020">        write_io = GetWriteIO();</span>
<span class="fc" id="L2021">        fptr = write_io.getOpenFileChecked();</span>
<span class="fc" id="L2022">        boolean locked = fptr.lock();</span>
        try {
<span class="pc bpc" id="L2024" title="1 of 2 branches missed.">            if (fptr.socketChannel() != null) {</span>
                try {
<span class="nc" id="L2026">                    fptr.socketChannel().shutdownOutput();</span>
<span class="nc" id="L2027">                } catch (IOException ioe) {</span>
<span class="nc" id="L2028">                    throw runtime.newErrnoFromErrno(Helpers.errnoFromException(ioe), fptr.getPath());</span>
<span class="nc" id="L2029">                }</span>
<span class="nc" id="L2030">                fptr.setMode(fptr.getMode() &amp; ~OpenFile.WRITABLE);</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">                if (!fptr.isReadable())</span>
<span class="nc" id="L2032">                    return write_io.rbIoClose(runtime);</span>
<span class="nc" id="L2033">                return context.nil;</span>
            }

<span class="fc bfc" id="L2036" title="All 2 branches covered.">            if (fptr.isReadable()) {</span>
<span class="fc" id="L2037">                throw runtime.newIOError(&quot;closing non-duplex IO for writing&quot;);</span>
            }
        } finally {
<span class="pc bpc" id="L2040" title="6 of 8 branches missed.">            if (locked) fptr.unlock();</span>
        }


<span class="fc bfc" id="L2044" title="All 2 branches covered.">        if (this != write_io) {</span>
<span class="fc" id="L2045">            fptr = getOpenFileChecked();</span>

<span class="fc" id="L2047">            locked = fptr.lock();</span>
            try {
<span class="fc" id="L2049">                fptr.tiedIOForWriting = null;</span>
<span class="fc" id="L2050">                fptr.setMode(fptr.getMode() &amp; ~OpenFile.DUPLEX);</span>
            } finally {
<span class="pc bpc" id="L2052" title="3 of 4 branches missed.">                if (locked) fptr.unlock();</span>
            }
        }

<span class="fc" id="L2056">        write_io.rbIoClose(runtime);</span>
<span class="fc" id="L2057">        return context.nil;</span>
    }

    @JRubyMethod
    public IRubyObject close_read(ThreadContext context) {
<span class="fc" id="L2062">        Ruby runtime = context.runtime;</span>
        OpenFile fptr;
        RubyIO write_io;

<span class="fc" id="L2066">        fptr = getOpenFileChecked();</span>

<span class="fc" id="L2068">        boolean locked = fptr.lock();</span>
        try {
<span class="pc bpc" id="L2070" title="1 of 2 branches missed.">            if (fptr.socketChannel() != null) {</span>
                try {
<span class="nc" id="L2072">                    fptr.socketChannel().socket().shutdownInput();</span>
<span class="nc" id="L2073">                } catch (IOException ioe) {</span>
<span class="nc" id="L2074">                    throw runtime.newErrnoFromErrno(Helpers.errnoFromException(ioe), fptr.getPath());</span>
<span class="nc" id="L2075">                }</span>
<span class="nc" id="L2076">                fptr.setMode(fptr.getMode() &amp; ~OpenFile.READABLE);</span>
<span class="nc bnc" id="L2077" title="All 2 branches missed.">                if (!fptr.isWritable())</span>
<span class="nc" id="L2078">                    return rbIoClose(runtime);</span>
<span class="nc" id="L2079">                return context.nil;</span>
            }

<span class="fc" id="L2082">            write_io = GetWriteIO();</span>
<span class="fc bfc" id="L2083" title="All 2 branches covered.">            if (this != write_io) {</span>
                OpenFile wfptr;
<span class="fc" id="L2085">                wfptr = write_io.getOpenFileChecked();</span>

<span class="fc" id="L2087">                boolean locked2 = wfptr.lock();</span>
                try {
<span class="fc" id="L2089">                    wfptr.setProcess(fptr.getProcess());</span>
<span class="fc" id="L2090">                    wfptr.setPid(fptr.getPid());</span>
<span class="fc" id="L2091">                    fptr.setProcess(null);</span>
<span class="fc" id="L2092">                    fptr.setPid(-1);</span>
<span class="fc" id="L2093">                    this.openFile = wfptr;</span>
                    /* bind to write_io temporarily to get rid of memory/fd leak */
<span class="fc" id="L2095">                    fptr.tiedIOForWriting = null;</span>
<span class="fc" id="L2096">                    fptr.setMode(fptr.getMode() &amp; ~OpenFile.DUPLEX);</span>
<span class="fc" id="L2097">                    write_io.openFile = fptr;</span>
<span class="fc" id="L2098">                    fptr.cleanup(runtime, false);</span>
                    /* should not finalize fptr because another thread may be reading it */
<span class="fc" id="L2100">                    return context.nil;</span>
                } finally {
<span class="pc bpc" id="L2102" title="3 of 4 branches missed.">                    if (locked2) wfptr.unlock();</span>
                }
            }

<span class="fc bfc" id="L2106" title="All 2 branches covered.">            if (fptr.isWritable()) {</span>
<span class="fc" id="L2107">                throw runtime.newIOError(&quot;closing non-duplex IO for reading&quot;);</span>
            }
        } finally {
<span class="pc bpc" id="L2110" title="7 of 10 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L2113">        return rbIoClose(runtime);</span>
    }

    @JRubyMethod(name = &quot;close_on_exec=&quot;, notImplemented = true)
    public IRubyObject close_on_exec_set(ThreadContext context, IRubyObject arg) {
        // TODO: rb_io_set_close_on_exec
<span class="nc" id="L2119">        throw context.runtime.newNotImplementedError(&quot;close_on_exec=&quot;);</span>
    }

    @JRubyMethod(name = &quot;close_on_exec?&quot;, notImplemented = true)
    public IRubyObject close_on_exec_p(ThreadContext context) {
        // TODO: rb_io_close_on_exec_p
<span class="nc" id="L2125">        throw context.runtime.newNotImplementedError(&quot;close_on_exec=&quot;);</span>
    }

    /** Flushes the IO output stream.
     *
     * MRI: rb_io_flush
     *
     * @return The IO.
     */
    @JRubyMethod
    public RubyIO flush(ThreadContext context) {
<span class="fc" id="L2136">        return flushRaw(context, true);</span>
    }

    // rb_io_flush_raw
    protected RubyIO flushRaw(ThreadContext context, boolean sync) {
        OpenFile fptr;

        // not possible here
//        if (!RB_TYPE_P(io, T_FILE)) {
//            return rb_funcall(io, id_flush, 0);
//        }

<span class="fc" id="L2148">        RubyIO io = GetWriteIO();</span>
<span class="fc" id="L2149">        fptr = io.getOpenFileChecked();</span>

<span class="fc" id="L2151">        boolean locked = fptr.lock();</span>
        try {
<span class="pc bpc" id="L2153" title="1 of 2 branches missed.">            if ((fptr.getMode() &amp; OpenFile.WRITABLE) != 0) {</span>
<span class="pc bpc" id="L2154" title="1 of 2 branches missed.">                if (fptr.io_fflush(context) &lt; 0)</span>
<span class="nc" id="L2155">                    throw context.runtime.newErrnoFromErrno(fptr.errno(), &quot;&quot;);</span>
                //            #ifdef _WIN32
                //            if (sync &amp;&amp; GetFileType((HANDLE)rb_w32_get_osfhandle(fptr-&gt;fd)) == FILE_TYPE_DISK) {
                //                rb_thread_io_blocking_region(nogvl_fsync, fptr, fptr-&gt;fd);
                //            }
                //            #endif
            }
<span class="fc bfc" id="L2162" title="All 2 branches covered.">            if ((fptr.getMode() &amp; OpenFile.READABLE) != 0) {</span>
<span class="fc" id="L2163">                fptr.unread(context);</span>
            }
        } finally {
<span class="pc bpc" id="L2166" title="2 of 4 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L2169">        return io;</span>
    }

    /** Read a line.
     * 
     */

    // rb_io_gets_m
    @JRubyMethod(name = &quot;gets&quot;, writes = FrameField.LASTLINE)
    public IRubyObject gets(ThreadContext context) {
<span class="fc" id="L2179">        IRubyObject separator = prepareGetsSeparator(context, null, null);</span>
<span class="fc" id="L2180">        IRubyObject result = getline(context, separator);</span>

<span class="fc bfc" id="L2182" title="All 2 branches covered.">        if (!result.isNil()) context.setLastLine(result);</span>

<span class="fc" id="L2184">        return result;</span>
    }

    // rb_io_gets_m
    @JRubyMethod(name = &quot;gets&quot;, writes = FrameField.LASTLINE)
    public IRubyObject gets(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L2190">        IRubyObject separator = prepareGetsSeparator(context, arg, null);</span>
<span class="fc" id="L2191">        long limit = prepareGetsLimit(context, arg, null);</span>

<span class="fc" id="L2193">        IRubyObject result = getline(context, separator, limit);</span>

<span class="fc bfc" id="L2195" title="All 2 branches covered.">        if (!result.isNil()) context.setLastLine(result);</span>

<span class="fc" id="L2197">        return result;</span>
    }

    // rb_io_gets_m
    @JRubyMethod(name = &quot;gets&quot;, writes = FrameField.LASTLINE)
    public IRubyObject gets(ThreadContext context, IRubyObject rs, IRubyObject limit_arg) {
<span class="fc" id="L2203">        rs = prepareGetsSeparator(context, rs, limit_arg);</span>
<span class="fc" id="L2204">        long limit = prepareGetsLimit(context, rs, limit_arg);</span>
<span class="fc" id="L2205">        IRubyObject result = getline(context, rs, limit);</span>

<span class="fc bfc" id="L2207" title="All 2 branches covered.">        if (!result.isNil()) context.setLastLine(result);</span>

<span class="fc" id="L2209">        return result;</span>
    }

    private IRubyObject prepareGetsSeparator(ThreadContext context, IRubyObject[] args) {
<span class="pc bpc" id="L2213" title="1 of 4 branches missed.">        switch (args.length) {</span>
            case 0:
<span class="fc" id="L2215">                return prepareGetsSeparator(context, null, null);</span>
            case 1:
<span class="fc" id="L2217">                return prepareGetsSeparator(context, args[0], null);</span>
            case 2:
<span class="fc" id="L2219">                return prepareGetsSeparator(context, args[0], args[1]);</span>
        }
<span class="nc" id="L2221">        throw new RuntimeException(&quot;invalid size for gets args: &quot; + args.length);</span>
    }

    // MRI: prepare_getline_args, separator logic
    private IRubyObject prepareGetsSeparator(ThreadContext context, IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L2226">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L2227">        IRubyObject rs = runtime.getRecordSeparatorVar().get();</span>
<span class="fc bfc" id="L2228" title="All 4 branches covered.">        if (arg0 != null &amp;&amp; arg1 == null) { // argc == 1</span>
<span class="fc" id="L2229">            IRubyObject tmp = context.nil;</span>

<span class="fc bfc" id="L2231" title="All 4 branches covered.">            if (arg0.isNil() || !(tmp = TypeConverter.checkStringType(runtime, arg0)).isNil()) {</span>
<span class="fc" id="L2232">                rs = tmp;</span>
            }
<span class="pc bpc" id="L2234" title="1 of 4 branches missed.">        } else if (arg0 != null &amp;&amp; arg1 != null) { // argc &gt;= 2</span>
<span class="fc" id="L2235">            rs = arg0;</span>
<span class="fc bfc" id="L2236" title="All 2 branches covered.">            if (!rs.isNil()) {</span>
<span class="fc" id="L2237">                rs = rs.convertToString();</span>
            }
        }
<span class="fc bfc" id="L2240" title="All 2 branches covered.">        if (!rs.isNil()) {</span>
            Encoding enc_rs, enc_io;

<span class="fc" id="L2243">            OpenFile fptr = getOpenFileChecked();</span>
<span class="fc" id="L2244">            enc_rs = ((RubyString)rs).getEncoding();</span>
<span class="fc" id="L2245">            enc_io = fptr.readEncoding(runtime);</span>
<span class="fc bfc" id="L2246" title="All 2 branches covered.">            if (enc_io != enc_rs &amp;&amp;</span>
<span class="pc bpc" id="L2247" title="1 of 2 branches missed.">                    (((RubyString)rs).scanForCodeRange() != StringSupport.CR_7BIT ||</span>
<span class="pc bpc" id="L2248" title="1 of 4 branches missed.">                            (((RubyString)rs).size() &gt; 0 &amp;&amp; !enc_io.isAsciiCompatible()))) {</span>
<span class="pc bpc" id="L2249" title="1 of 2 branches missed.">                if (rs == runtime.getGlobalVariables().getDefaultSeparator()) {</span>
<span class="fc" id="L2250">                    rs = RubyString.newStringLight(runtime, 0, enc_io);</span>
<span class="fc" id="L2251">                    ((RubyString)rs).catAscii(NEWLINE_BYTES, 0, 1);</span>
                }
                else {
<span class="nc" id="L2254">                    throw runtime.newArgumentError(&quot;encoding mismatch: &quot; + enc_io + &quot; IO with &quot; + enc_rs + &quot; RS&quot;);</span>
                }
            }
        }
<span class="fc" id="L2258">        return rs;</span>
    }

    private long prepareGetsLimit(ThreadContext context, IRubyObject[] args) {
<span class="pc bpc" id="L2262" title="1 of 4 branches missed.">        switch (args.length) {</span>
            case 0:
<span class="fc" id="L2264">                return prepareGetsLimit(context, null, null);</span>
            case 1:
<span class="fc" id="L2266">                return prepareGetsLimit(context, args[0], null);</span>
            case 2:
<span class="fc" id="L2268">                return prepareGetsLimit(context, args[0], args[1]);</span>
        }
<span class="nc" id="L2270">        throw new RuntimeException(&quot;invalid size for gets args: &quot; + args.length);</span>
    }

    // MRI: prepare_getline_args, limit logic
    private long prepareGetsLimit(ThreadContext context, IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L2275">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L2276">        IRubyObject lim = context.nil;</span>
<span class="fc bfc" id="L2277" title="All 4 branches covered.">        if (arg0 != null &amp;&amp; arg1 == null) { // argc == 1</span>
<span class="fc" id="L2278">            IRubyObject tmp = context.nil;</span>

<span class="fc bfc" id="L2280" title="All 4 branches covered.">            if (arg0.isNil() || !(tmp = TypeConverter.checkStringType(runtime, arg0)).isNil()) {</span>
                // only separator logic
            } else {
<span class="fc" id="L2283">                lim = arg0;</span>
            }
<span class="pc bpc" id="L2285" title="1 of 4 branches missed.">        } else if (arg0 != null &amp;&amp; arg1 != null) { // argc &gt;= 2</span>
<span class="fc" id="L2286">            lim = arg1;</span>
        }
<span class="fc bfc" id="L2288" title="All 2 branches covered.">        return lim.isNil() ? -1 : lim.convertToInteger().getLongValue();</span>
    }

    private IRubyObject gets(ThreadContext context, IRubyObject[] args) {
<span class="pc bpc" id="L2292" title="1 of 4 branches missed.">        switch (args.length) {</span>
            case 0:
<span class="fc" id="L2294">                return gets(context);</span>
            case 1:
<span class="fc" id="L2296">                return gets(context, args[0]);</span>
            case 2:
<span class="fc" id="L2298">                return gets(context, args[0], args[1]);</span>
            default:
<span class="nc" id="L2300">                Arity.raiseArgumentError(context, args.length, 0, 2);</span>
<span class="nc" id="L2301">                return null; // not reached</span>
        }
    }

    public boolean getBlocking() {
<span class="nc bnc" id="L2306" title="All 2 branches missed.">        if (openFile.selectChannel() != null) {</span>
<span class="nc" id="L2307">            return openFile.selectChannel().isBlocking();</span>
        }
<span class="nc" id="L2309">        return true;</span>
    }

    @JRubyMethod(name = &quot;fcntl&quot;)
    public IRubyObject fcntl(ThreadContext context, IRubyObject cmd) {
        // TODO: This version differs from ioctl by checking whether fcntl exists
        // and raising notimplemented if it doesn't; perhaps no difference for us?
<span class="nc" id="L2316">        return ctl(context.runtime, cmd, null);</span>
    }

    @JRubyMethod(name = &quot;fcntl&quot;)
    public IRubyObject fcntl(ThreadContext context, IRubyObject cmd, IRubyObject arg) {
        // TODO: This version differs from ioctl by checking whether fcntl exists
        // and raising notimplemented if it doesn't; perhaps no difference for us?
<span class="nc" id="L2323">        return ctl(context.runtime, cmd, arg);</span>
    }

    @JRubyMethod(name = &quot;ioctl&quot;, required = 1, optional = 1)
    public IRubyObject ioctl(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L2328">        IRubyObject cmd = args[0];</span>
        IRubyObject arg;
        
<span class="pc bpc" id="L2331" title="1 of 2 branches missed.">        if (args.length == 2) {</span>
<span class="fc" id="L2332">            arg = args[1];</span>
        } else {
<span class="nc" id="L2334">            arg = context.runtime.getNil();</span>
        }

<span class="nc" id="L2337">        return ctl(context.runtime, cmd, arg);</span>
    }

    public IRubyObject ctl(Ruby runtime, IRubyObject cmd, IRubyObject arg) {
<span class="fc" id="L2341">        long realCmd = cmd.convertToInteger().getLongValue();</span>
<span class="fc" id="L2342">        long nArg = 0;</span>

<span class="pc bpc" id="L2344" title="1 of 2 branches missed.">        if (realCmd == Fcntl.F_GETFL.intValue()) {</span>
<span class="nc" id="L2345">            OpenFile myOpenFile = getOpenFileChecked();</span>
<span class="nc" id="L2346">            return runtime.newFixnum(OpenFile.ioFmodeOflags(myOpenFile.getMode()));</span>
        }
        
        // FIXME: Arg may also be true, false, and nil and still be valid.  Strangely enough, 
        // protocol conversion is not happening in Ruby on this arg?
<span class="pc bpc" id="L2351" title="3 of 6 branches missed.">        if (arg == null || arg.isNil() || arg == runtime.getFalse()) {</span>
<span class="nc" id="L2352">            nArg = 0;</span>
<span class="pc bpc" id="L2353" title="1 of 2 branches missed.">        } else if (arg instanceof RubyFixnum) {</span>
<span class="fc" id="L2354">            nArg = RubyFixnum.fix2long(arg);</span>
<span class="nc bnc" id="L2355" title="All 2 branches missed.">        } else if (arg == runtime.getTrue()) {</span>
<span class="nc" id="L2356">            nArg = 1;</span>
        } else {
<span class="nc" id="L2358">            throw runtime.newNotImplementedError(&quot;JRuby does not support string for second fcntl/ioctl argument yet&quot;);</span>
        }
        
<span class="nc" id="L2361">        OpenFile fptr = getOpenFileChecked();</span>

        // Fixme: Only F_SETFL and F_GETFL is current supported
        // FIXME: Only NONBLOCK flag is supported
        // FIXME: F_SETFL and F_SETFD are treated as the same thing here.  For the case of dup(fd) we
        //   should actually have F_SETFL only affect one (it is unclear how well we do, but this TODO
        //   is here to at least document that we might need to do more work here.  Mostly SETFL is
        //   for mode changes which should persist across fork() boundaries.  Since JVM has no fork
        //   this is not a problem for us.
<span class="nc bnc" id="L2370" title="All 2 branches missed.">        if (realCmd == FcntlLibrary.FD_CLOEXEC) {</span>
            // Do nothing.  FD_CLOEXEC has no meaning in JVM since we cannot really exec.
            // And why the hell does webrick pass this in as a first argument!!!!!
<span class="nc bnc" id="L2373" title="All 4 branches missed.">        } else if (realCmd == Fcntl.F_SETFL.intValue() || realCmd == Fcntl.F_SETFD.intValue()) {</span>
<span class="nc bnc" id="L2374" title="All 2 branches missed.">            if ((nArg &amp; FcntlLibrary.FD_CLOEXEC) == FcntlLibrary.FD_CLOEXEC) {</span>
                // Do nothing.  FD_CLOEXEC has no meaning in JVM since we cannot really exec.
            } else {
<span class="nc bnc" id="L2377" title="All 2 branches missed.">                boolean block = (nArg &amp; ModeFlags.NONBLOCK) != ModeFlags.NONBLOCK;</span>

<span class="nc" id="L2379">                fptr.setBlocking(runtime, block);</span>
<span class="nc" id="L2380">            }</span>
<span class="nc bnc" id="L2381" title="All 2 branches missed.">        } else if (realCmd == Fcntl.F_GETFL.intValue()) {</span>
<span class="nc bnc" id="L2382" title="All 2 branches missed.">            return fptr.isBlocking() ? RubyFixnum.zero(runtime) : RubyFixnum.newFixnum(runtime, ModeFlags.NONBLOCK);</span>
        } else {
<span class="nc" id="L2384">            throw runtime.newNotImplementedError(&quot;JRuby only supports F_SETFL and F_GETFL with NONBLOCK for fcntl/ioctl&quot;);</span>
        }
        
<span class="nc" id="L2387">        return runtime.newFixnum(0);</span>
    }

<span class="fc" id="L2390">    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];</span>

    @JRubyMethod(name = &quot;puts&quot;)
    public IRubyObject puts(ThreadContext context) {
<span class="fc" id="L2394">        return puts0(context, this);</span>
    }

    @JRubyMethod(name = &quot;puts&quot;)
    public IRubyObject puts(ThreadContext context, IRubyObject arg0) {
<span class="fc" id="L2399">        return puts1(context, this, arg0);</span>
    }

    @JRubyMethod(name = &quot;puts&quot;)
    public IRubyObject puts(ThreadContext context, IRubyObject arg0, IRubyObject arg1) {
<span class="nc" id="L2404">        return puts2(context, this, arg0, arg1);</span>
    }

    @JRubyMethod(name = &quot;puts&quot;)
    public IRubyObject puts(ThreadContext context, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {
<span class="nc" id="L2409">        return puts3(context, this, arg0, arg1, arg2);</span>
    }

    @JRubyMethod(name = &quot;puts&quot;, rest = true)
    public IRubyObject puts(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L2414">        return puts(context, this, args);</span>
    }

    public static IRubyObject puts0(ThreadContext context, IRubyObject maybeIO) {
<span class="fc" id="L2418">        return writeSeparator(context, maybeIO);</span>
    }

    public static IRubyObject puts1(ThreadContext context, IRubyObject maybeIO, IRubyObject arg0) {
<span class="fc" id="L2422">        Ruby runtime = context.runtime;</span>
<span class="pc bpc" id="L2423" title="3 of 4 branches missed.">        assert runtime.getGlobalVariables().getDefaultSeparator() instanceof RubyString;</span>
<span class="fc" id="L2424">        RubyString separator = (RubyString) runtime.getGlobalVariables().getDefaultSeparator();</span>

<span class="fc" id="L2426">        putsSingle(context, runtime, maybeIO, arg0, separator);</span>

<span class="fc" id="L2428">        return context.nil;</span>
    }

    public static IRubyObject puts2(ThreadContext context, IRubyObject maybeIO, IRubyObject arg0, IRubyObject arg1) {
<span class="nc" id="L2432">        Ruby runtime = context.runtime;</span>
<span class="nc bnc" id="L2433" title="All 4 branches missed.">        assert runtime.getGlobalVariables().getDefaultSeparator() instanceof RubyString;</span>
<span class="nc" id="L2434">        RubyString separator = (RubyString) runtime.getGlobalVariables().getDefaultSeparator();</span>

<span class="nc" id="L2436">        putsSingle(context, runtime, maybeIO, arg0, separator);</span>
<span class="nc" id="L2437">        putsSingle(context, runtime, maybeIO, arg1, separator);</span>

<span class="nc" id="L2439">        return context.nil;</span>
    }

    public static IRubyObject puts3(ThreadContext context, IRubyObject maybeIO, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {
<span class="nc" id="L2443">        Ruby runtime = context.runtime;</span>
<span class="nc bnc" id="L2444" title="All 4 branches missed.">        assert runtime.getGlobalVariables().getDefaultSeparator() instanceof RubyString;</span>
<span class="nc" id="L2445">        RubyString separator = (RubyString) runtime.getGlobalVariables().getDefaultSeparator();</span>

<span class="nc" id="L2447">        putsSingle(context, runtime, maybeIO, arg0, separator);</span>
<span class="nc" id="L2448">        putsSingle(context, runtime, maybeIO, arg1, separator);</span>
<span class="nc" id="L2449">        putsSingle(context, runtime, maybeIO, arg2, separator);</span>

<span class="nc" id="L2451">        return context.nil;</span>
    }

    public static IRubyObject puts(ThreadContext context, IRubyObject maybeIO, IRubyObject... args) {
<span class="pc bpc" id="L2455" title="1 of 2 branches missed.">        if (args.length == 0) {</span>
<span class="nc" id="L2456">            return writeSeparator(context, maybeIO);</span>
        }

<span class="fc" id="L2459">        return putsArray(context, maybeIO, args);</span>
    }

    private static IRubyObject writeSeparator(ThreadContext context, IRubyObject maybeIO) {
<span class="fc" id="L2463">        Ruby runtime = context.runtime;</span>
<span class="pc bpc" id="L2464" title="3 of 4 branches missed.">        assert runtime.getGlobalVariables().getDefaultSeparator() instanceof RubyString;</span>
<span class="fc" id="L2465">        RubyString separator = (RubyString) runtime.getGlobalVariables().getDefaultSeparator();</span>

<span class="fc" id="L2467">        write(context, maybeIO, separator);</span>
<span class="fc" id="L2468">        return runtime.getNil();</span>
    }

    private static IRubyObject putsArray(ThreadContext context, IRubyObject maybeIO, IRubyObject[] args) {
<span class="fc" id="L2472">        Ruby runtime = context.runtime;</span>
<span class="pc bpc" id="L2473" title="3 of 4 branches missed.">        assert runtime.getGlobalVariables().getDefaultSeparator() instanceof RubyString;</span>
<span class="fc" id="L2474">        RubyString separator = (RubyString) runtime.getGlobalVariables().getDefaultSeparator();</span>

<span class="fc bfc" id="L2476" title="All 2 branches covered.">        for (int i = 0; i &lt; args.length; i++) {</span>
<span class="fc" id="L2477">            putsSingle(context, runtime, maybeIO, args[i], separator);</span>
        }

<span class="fc" id="L2480">        return runtime.getNil();</span>
    }

<span class="fc" id="L2483">    private static final ByteList RECURSIVE_BYTELIST = ByteList.create(&quot;[...]&quot;);</span>

    private static void putsSingle(ThreadContext context, Ruby runtime, IRubyObject maybeIO, IRubyObject arg, RubyString separator) {
        ByteList line;

<span class="fc bfc" id="L2488" title="All 2 branches covered.">        if (arg.isNil()) {</span>
<span class="fc" id="L2489">            line = getNilByteList(runtime);</span>
<span class="fc bfc" id="L2490" title="All 2 branches covered.">        } else if (runtime.isInspecting(arg)) {</span>
<span class="fc" id="L2491">            line = RECURSIVE_BYTELIST;</span>
<span class="fc bfc" id="L2492" title="All 2 branches covered.">        } else if (arg instanceof RubyArray) {</span>
<span class="fc" id="L2493">            inspectPuts(context, maybeIO, (RubyArray) arg);</span>
<span class="fc" id="L2494">            return;</span>
        } else {
<span class="fc" id="L2496">            line = arg.asString().getByteList();</span>
        }

<span class="fc" id="L2499">        write(context, maybeIO, line);</span>

<span class="fc bfc" id="L2501" title="All 4 branches covered.">        if (line.length() == 0 || !line.endsWith(separator.getByteList())) {</span>
<span class="fc" id="L2502">            write(context, maybeIO, separator.getByteList());</span>
        }
<span class="fc" id="L2504">    }</span>

    private static IRubyObject inspectPuts(ThreadContext context, IRubyObject maybeIO, RubyArray array) {
        try {
<span class="fc" id="L2508">            context.runtime.registerInspecting(array);</span>
<span class="fc" id="L2509">            return putsArray(context, maybeIO, array.toJavaArray());</span>
        } finally {
<span class="pc" id="L2511">            context.runtime.unregisterInspecting(array);</span>
        }
    }

    protected IRubyObject write(ThreadContext context, ByteList byteList) {
<span class="nc" id="L2516">        return callMethod(context, &quot;write&quot;, RubyString.newStringShared(context.runtime, byteList));</span>
    }

    protected static IRubyObject write(ThreadContext context, IRubyObject maybeIO, ByteList byteList) {
<span class="fc" id="L2520">        return maybeIO.callMethod(context, &quot;write&quot;, RubyString.newStringShared(context.runtime, byteList));</span>
    }

    public static IRubyObject write(ThreadContext context, IRubyObject maybeIO, IRubyObject str) {
<span class="fc" id="L2524">        return maybeIO.callMethod(context, &quot;write&quot;, str);</span>
    }
    
    @Override
    public IRubyObject inspect() {
<span class="fc" id="L2529">        Ruby runtime = getRuntime();</span>
        
<span class="pc bpc" id="L2531" title="1 of 2 branches missed.">        if (openFile == null) return super.inspect();</span>
        
<span class="fc" id="L2533">        String className = getMetaClass().getRealClass().getName();</span>
<span class="fc" id="L2534">        String path = openFile.getPath();</span>
<span class="fc" id="L2535">        String status = &quot;&quot;;</span>
        
<span class="pc bpc" id="L2537" title="1 of 2 branches missed.">        if (path == null) {</span>
<span class="fc bfc" id="L2538" title="All 2 branches covered.">            if (openFile.fd() == null) {</span>
<span class="fc" id="L2539">                path = &quot;&quot;;</span>
<span class="fc" id="L2540">                status = &quot;(closed)&quot;;</span>
            } else {
<span class="fc" id="L2542">                path = &quot;fd &quot; + openFile.fd().bestFileno();</span>
            }
<span class="nc bnc" id="L2544" title="All 2 branches missed.">        } else if (!openFile.isOpen()) {</span>
<span class="nc" id="L2545">            status = &quot; (closed)&quot;;</span>
        }
        
<span class="fc" id="L2548">        String inspectStr = &quot;#&lt;&quot; + className + &quot;:&quot; + path + status + &quot;&gt;&quot;;</span>
        
<span class="fc" id="L2550">        return runtime.newString(inspectStr);</span>
    }

    /** Read a line.
     * 
     */
    @JRubyMethod(name = &quot;readline&quot;, writes = FrameField.LASTLINE)
    public IRubyObject readline(ThreadContext context) {
<span class="fc" id="L2558">        IRubyObject line = gets(context);</span>

<span class="fc bfc" id="L2560" title="All 2 branches covered.">        if (line.isNil()) {</span>
<span class="fc" id="L2561">            throw context.runtime.newEOFError();</span>
        }
        
<span class="fc" id="L2564">        return line;</span>
    }

    @JRubyMethod(name = &quot;readline&quot;, writes = FrameField.LASTLINE)
    public IRubyObject readline(ThreadContext context, IRubyObject separator) {
<span class="nc" id="L2569">        IRubyObject line = gets(context, separator);</span>

<span class="nc bnc" id="L2571" title="All 2 branches missed.">        if (line.isNil()) {</span>
<span class="nc" id="L2572">            throw context.runtime.newEOFError();</span>
        }

<span class="nc" id="L2575">        return line;</span>
    }

    /** Read a byte. On EOF returns nil.
     * 
     */
    public IRubyObject getc() {
<span class="fc" id="L2582">        return getbyte(getRuntime().getCurrentContext());</span>
    }

    // rb_io_readchar
    @JRubyMethod
    public IRubyObject readchar(ThreadContext context) {
<span class="fc" id="L2588">        IRubyObject c = getc19(context);</span>
        
<span class="fc bfc" id="L2590" title="All 2 branches covered.">        if (c.isNil()) {</span>
<span class="fc" id="L2591">            throw context.runtime.newEOFError();</span>
        }
<span class="fc" id="L2593">        return c;</span>
    }

    // rb_io_getbyte
    @JRubyMethod
    public IRubyObject getbyte(ThreadContext context) {
<span class="fc" id="L2599">        int c = getByte(context);</span>

<span class="fc bfc" id="L2601" title="All 2 branches covered.">        if (c == -1) return context.nil;</span>

<span class="fc" id="L2603">        return RubyNumeric.int2fix(context.runtime, c &amp; 0xff);</span>
    }

    // rb_io_getbyte
    public int getByte(ThreadContext context) {
        int c;

<span class="fc" id="L2610">        OpenFile fptr = getOpenFileChecked();</span>

<span class="fc" id="L2612">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L2614">            fptr.checkByteReadable(context);</span>
<span class="fc" id="L2615">            fptr.READ_CHECK(context);</span>
            // TODO: tty flushing
            //        if (fptr-&gt;fd == 0 &amp;&amp; (fptr-&gt;mode &amp; FMODE_TTY) &amp;&amp; RB_TYPE_P(rb_stdout, T_FILE)) {
            //            rb_io_t *ofp;
            //            GetOpenFile(rb_stdout, ofp);
            //            if (ofp-&gt;mode &amp; FMODE_TTY) {
            //                rb_io_flush(rb_stdout);
            //            }
            //        }
<span class="fc bfc" id="L2624" title="All 2 branches covered.">            if (fptr.fillbuf(context) &lt; 0) {</span>
<span class="fc" id="L2625">                return -1;</span>
            }
<span class="fc" id="L2627">            fptr.rbuf.off++;</span>
<span class="fc" id="L2628">            fptr.rbuf.len--;</span>
<span class="fc" id="L2629">            return fptr.rbuf.ptr[fptr.rbuf.off - 1] &amp; 0xFF;</span>
        } finally {
<span class="pc bpc" id="L2631" title="4 of 6 branches missed.">            if (locked) fptr.unlock();</span>
        }
    }

    // rb_io_readbyte
    @JRubyMethod
    public IRubyObject readbyte(ThreadContext context) {
<span class="fc" id="L2638">        IRubyObject c = getbyte(context);</span>

<span class="fc bfc" id="L2640" title="All 2 branches covered.">        if (c.isNil()) {</span>
<span class="fc" id="L2641">            throw getRuntime().newEOFError();</span>
        }
<span class="fc" id="L2643">        return c;</span>
    }

    // rb_io_getc
    @JRubyMethod(name = &quot;getc&quot;)
    public IRubyObject getc19(ThreadContext context) {
<span class="fc" id="L2649">        Ruby runtime = context.runtime;</span>
        Encoding enc;

<span class="fc" id="L2652">        OpenFile fptr = getOpenFileChecked();</span>

<span class="fc" id="L2654">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L2656">            fptr.checkCharReadable(context);</span>

<span class="fc" id="L2658">            enc = fptr.inputEncoding(runtime);</span>
<span class="fc" id="L2659">            fptr.READ_CHECK(context);</span>
<span class="fc" id="L2660">            return fptr.getc(context, enc);</span>
        } finally {
<span class="pc bpc" id="L2662" title="3 of 4 branches missed.">            if (locked) fptr.unlock();</span>
        }
    }

    // rb_io_ungetbyte
    @JRubyMethod
    public IRubyObject ungetbyte(ThreadContext context, IRubyObject b) {
<span class="fc" id="L2669">        OpenFile fptr = getOpenFileChecked();</span>

<span class="fc" id="L2671">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L2673">            fptr.checkByteReadable(context);</span>
<span class="fc bfc" id="L2674" title="All 2 branches covered.">            if (b.isNil()) return context.nil;</span>
<span class="fc bfc" id="L2675" title="All 2 branches covered.">            if (b instanceof RubyFixnum) {</span>
<span class="fc" id="L2676">                byte cc = (byte) RubyNumeric.fix2int(b);</span>
<span class="fc" id="L2677">                b = RubyString.newStringNoCopy(context.runtime, new byte[]{cc});</span>
<span class="fc" id="L2678">            } else {</span>
<span class="fc" id="L2679">                b = b.convertToString();</span>
            }
<span class="fc" id="L2681">            fptr.ungetbyte(context, b);</span>
        } finally {
<span class="pc bpc" id="L2683" title="4 of 6 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L2686">        return context.nil;</span>
    }

    // MRI: rb_io_ungetc
    @JRubyMethod
    public IRubyObject ungetc(ThreadContext context, IRubyObject c) {
<span class="fc" id="L2692">        Ruby runtime = context.runtime;</span>
        OpenFile fptr;
        int len;

<span class="fc" id="L2696">        fptr = getOpenFileChecked();</span>

<span class="fc" id="L2698">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L2700">            fptr.checkCharReadable(context);</span>
<span class="fc bfc" id="L2701" title="All 2 branches covered.">            if (c.isNil()) return c;</span>
<span class="fc bfc" id="L2702" title="All 2 branches covered.">            if (c instanceof RubyFixnum) {</span>
<span class="fc" id="L2703">                c = EncodingUtils.encUintChr(context, (int) ((RubyFixnum) c).getLongValue(), fptr.readEncoding(runtime));</span>
<span class="pc bpc" id="L2704" title="1 of 2 branches missed.">            } else if (c instanceof RubyBignum) {</span>
<span class="nc" id="L2705">                c = EncodingUtils.encUintChr(context, (int) ((RubyBignum) c).getLongValue(), fptr.readEncoding(runtime));</span>
            } else {
<span class="fc" id="L2707">                c = c.convertToString();</span>
            }
<span class="pc bpc" id="L2709" title="1 of 2 branches missed.">            if (fptr.needsReadConversion()) {</span>
<span class="nc" id="L2710">                fptr.SET_BINARY_MODE();</span>
<span class="nc" id="L2711">                len = ((RubyString) c).size();</span>
                //            #if SIZEOF_LONG &gt; SIZEOF_INT
                //            if (len &gt; INT_MAX)
                //                rb_raise(rb_eIOError, &quot;ungetc failed&quot;);
                //            #endif
<span class="nc" id="L2716">                fptr.makeReadConversion(context, (int) len);</span>
<span class="nc bnc" id="L2717" title="All 2 branches missed.">                if (fptr.cbuf.capa - fptr.cbuf.len &lt; len)</span>
<span class="nc" id="L2718">                    throw runtime.newIOError(&quot;ungetc failed&quot;);</span>
                // shift cbuf back to 0
<span class="nc bnc" id="L2720" title="All 2 branches missed.">                if (fptr.cbuf.off &lt; len) {</span>
<span class="nc" id="L2721">                    System.arraycopy(</span>
                            fptr.cbuf.ptr, fptr.cbuf.off,
                            fptr.cbuf.ptr, fptr.cbuf.capa - fptr.cbuf.len, // this should be 0
                            fptr.cbuf.len);
<span class="nc" id="L2725">                    fptr.cbuf.off = fptr.cbuf.capa - fptr.cbuf.len; // this should be 0 too</span>
                }
<span class="nc" id="L2727">                fptr.cbuf.off -= (int) len;</span>
<span class="nc" id="L2728">                fptr.cbuf.len += (int) len;</span>
<span class="nc" id="L2729">                ByteList cByteList = ((RubyString) c).getByteList();</span>
<span class="nc" id="L2730">                System.arraycopy(cByteList.unsafeBytes(), cByteList.begin(), fptr.cbuf.ptr, fptr.cbuf.off, len);</span>
<span class="nc" id="L2731">            } else {</span>
<span class="fc" id="L2732">                fptr.NEED_NEWLINE_DECORATOR_ON_READ_CHECK();</span>
<span class="fc" id="L2733">                fptr.ungetbyte(context, c);</span>
            }
        } finally {
<span class="pc bpc" id="L2736" title="4 of 6 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L2739">        return context.nil;</span>
    }

    @JRubyMethod(name = &quot;read_nonblock&quot;, required = 1, optional = 1)
    public IRubyObject read_nonblock(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L2744">        return doReadNonblock(context, args, true);</span>
    }

    // MRI: io_read_nonblock
    public IRubyObject doReadNonblock(ThreadContext context, IRubyObject[] args, boolean useException) {
<span class="fc" id="L2749">        Ruby runtime = context.runtime;</span>
        IRubyObject ret;
        IRubyObject opts;
<span class="pc bpc" id="L2752" title="1 of 2 branches missed.">        boolean no_exception = !useException;</span>

<span class="fc" id="L2754">        opts = ArgsUtil.getOptionsArg(runtime, args);</span>

<span class="pc bpc" id="L2756" title="3 of 4 branches missed.">        if (!opts.isNil() &amp;&amp; runtime.getFalse() == ((RubyHash)opts).op_aref(context, runtime.newSymbol(&quot;exception&quot;)))</span>
<span class="nc" id="L2757">            no_exception = true;</span>

<span class="fc" id="L2759">        ret = getPartial(context, args, true, no_exception);</span>

<span class="fc bfc" id="L2761" title="All 2 branches covered.">        if (ret.isNil()) {</span>
<span class="pc bpc" id="L2762" title="1 of 2 branches missed.">            if (no_exception)</span>
<span class="nc" id="L2763">                return ret;</span>
            else
<span class="fc" id="L2765">                throw runtime.newEOFError();</span>
        }
<span class="fc" id="L2767">        return ret;</span>
    }

    @JRubyMethod(name = &quot;readpartial&quot;, required = 1, optional = 1)
    public IRubyObject readpartial(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L2772">        IRubyObject value = getPartial(context, args, false, false);</span>

<span class="fc bfc" id="L2774" title="All 2 branches covered.">        if (value.isNil()) {</span>
<span class="fc" id="L2775">            throw context.runtime.newEOFError();</span>
        }

<span class="fc" id="L2778">        return value;</span>
    }

    // MRI: io_getpartial
    private IRubyObject getPartial(ThreadContext context, IRubyObject[] args, boolean nonblock, boolean noException) {
<span class="fc" id="L2783">        Ruby runtime = context.runtime;</span>
        OpenFile fptr;
        IRubyObject length, str;
        int n, len;

<span class="pc bpc" id="L2788" title="2 of 4 branches missed.">        switch (args.length) {</span>
            case 3:
<span class="nc" id="L2790">                length = args[0];</span>
<span class="nc" id="L2791">                str = args[1];</span>
<span class="nc" id="L2792">                args[2].convertToHash();</span>
<span class="nc" id="L2793">                break;</span>
            case 2:
<span class="fc" id="L2795">                length = args[0];</span>
<span class="fc" id="L2796">                str = TypeConverter.checkHashType(runtime, args[1]);</span>
<span class="pc bpc" id="L2797" title="1 of 2 branches missed.">                str = str.isNil() ? args[1] : context.nil;</span>
<span class="fc" id="L2798">                break;</span>
            case 1:
<span class="fc" id="L2800">                length = args[0];</span>
<span class="fc" id="L2801">                str = context.nil;</span>
<span class="fc" id="L2802">                break;</span>
            default:
<span class="nc" id="L2804">                length = context.nil;</span>
<span class="nc" id="L2805">                str = context.nil;</span>
        }

<span class="fc bfc" id="L2808" title="All 2 branches covered.">        if ((len = RubyNumeric.num2int(length)) &lt; 0) {</span>
<span class="fc" id="L2809">            throw runtime.newArgumentError(&quot;negative length &quot; + len + &quot; given&quot;);</span>
        }

<span class="fc" id="L2812">        str = EncodingUtils.setStrBuf(runtime, str, len);</span>
<span class="fc" id="L2813">        str.setTaint(true);</span>

<span class="fc" id="L2815">        fptr = getOpenFileChecked();</span>

<span class="fc" id="L2817">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L2819">            fptr.checkByteReadable(context);</span>

<span class="fc bfc" id="L2821" title="All 2 branches covered.">            if (len == 0)</span>
<span class="fc" id="L2822">                return str;</span>

<span class="fc bfc" id="L2824" title="All 2 branches covered.">            if (!nonblock)</span>
<span class="fc" id="L2825">                fptr.READ_CHECK(context);</span>
<span class="fc" id="L2826">            ByteList strByteList = ((RubyString) str).getByteList();</span>
<span class="fc" id="L2827">            n = fptr.readBufferedData(strByteList.unsafeBytes(), strByteList.begin(), len);</span>
<span class="fc bfc" id="L2828" title="All 2 branches covered.">            if (n &lt;= 0) {</span>
                again:
                while (true) {
<span class="fc bfc" id="L2831" title="All 2 branches covered.">                    if (nonblock) {</span>
<span class="fc" id="L2832">                        fptr.setNonblock(runtime);</span>
                    }
                    try {
<span class="fc" id="L2835">                        str = EncodingUtils.setStrBuf(runtime, str, len);</span>
<span class="fc" id="L2836">                        strByteList = ((RubyString) str).getByteList();</span>
                        //                arg.fd = fptr-&gt;fd;
                        //                arg.str_ptr = RSTRING_PTR(str);
                        //                arg.len = len;
                        //                rb_str_locktmp_ensure(str, read_internal_call, (VALUE)&amp;arg);
                        //                n = arg.len;
<span class="fc" id="L2842">                        n = OpenFile.readInternal(context, fptr, fptr.fd(), strByteList.unsafeBytes(), strByteList.begin(), len);</span>
<span class="fc bfc" id="L2843" title="All 2 branches covered.">                        if (n &lt; 0) {</span>
<span class="pc bpc" id="L2844" title="3 of 4 branches missed.">                            if (!nonblock &amp;&amp; fptr.waitReadable(context))</span>
                                continue again;
<span class="pc bpc" id="L2846" title="3 of 6 branches missed.">                            if (nonblock &amp;&amp; (fptr.errno() == Errno.EWOULDBLOCK || fptr.errno() == Errno.EAGAIN)) {</span>
<span class="pc bpc" id="L2847" title="1 of 2 branches missed.">                                if (noException)</span>
<span class="nc" id="L2848">                                    return runtime.newSymbol(&quot;wait_readable&quot;);</span>
                                else
<span class="fc" id="L2850">                                    throw runtime.newErrnoEAGAINReadableError(&quot;read would block&quot;);</span>
                            }
<span class="nc" id="L2852">                            throw runtime.newEOFError(fptr.getPath());</span>
                        }
                    } finally {
<span class="pc bpc" id="L2855" title="5 of 8 branches missed.">                        if (nonblock) {</span>
<span class="pc" id="L2856">                            fptr.setBlock(runtime);</span>
                        }
                    }
<span class="fc" id="L2859">                    break;</span>
                }
            }
        } finally {
<span class="pc bpc" id="L2863" title="5 of 8 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L2866">        ((RubyString)str).setReadLength(n);</span>

<span class="fc bfc" id="L2868" title="All 2 branches covered.">        if (n == 0)</span>
<span class="fc" id="L2869">            return context.nil;</span>
        else
<span class="fc" id="L2871">            return str;</span>
    }

    // MRI: rb_io_sysread
    @JRubyMethod(name = &quot;sysread&quot;, required = 1, optional = 1)
    public IRubyObject sysread(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L2877">        Ruby runtime = context.runtime;</span>
        IRubyObject len, str;
        OpenFile fptr;
        int ilen, n;
//        struct read_internal_arg arg;

<span class="pc bpc" id="L2883" title="1 of 2 branches missed.">        len = args.length &gt;= 1 ? args[0] : context.nil;</span>
<span class="fc bfc" id="L2884" title="All 2 branches covered.">        str = args.length &gt;= 2 ? args[1] : context.nil;</span>
<span class="fc" id="L2885">        ilen = RubyNumeric.num2int(len);</span>

<span class="fc" id="L2887">        str = EncodingUtils.setStrBuf(runtime, str, (int)ilen);</span>
<span class="pc bpc" id="L2888" title="1 of 2 branches missed.">        if (ilen == 0) return str;</span>

<span class="fc" id="L2890">        fptr = getOpenFileChecked();</span>

<span class="fc" id="L2892">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L2894">            fptr.checkByteReadable(context);</span>

<span class="fc bfc" id="L2896" title="All 2 branches covered.">            if (fptr.READ_DATA_BUFFERED()) {</span>
<span class="fc" id="L2897">                throw runtime.newIOError(&quot;sysread for buffered IO&quot;);</span>
            }

            /*
             * MRI COMMENT:
             * FIXME: removing rb_thread_wait_fd() here changes sysread semantics
             * on non-blocking IOs.  However, it's still currently possible
             * for sysread to raise Errno::EAGAIN if another thread read()s
             * the IO after we return from rb_thread_wait_fd() but before
             * we call read()
             */
<span class="fc" id="L2908">            context.getThread().select(fptr.channel(), fptr, SelectionKey.OP_READ);</span>

<span class="fc" id="L2910">            fptr.checkClosed();</span>

<span class="fc" id="L2912">            str = EncodingUtils.setStrBuf(runtime, str, ilen);</span>
<span class="fc" id="L2913">            ByteList strByteList = ((RubyString) str).getByteList();</span>
<span class="fc" id="L2914">            n = OpenFile.readInternal(context, fptr, fptr.fd(), strByteList.unsafeBytes(), strByteList.begin(), ilen);</span>

<span class="pc bpc" id="L2916" title="1 of 2 branches missed.">            if (n == -1) {</span>
<span class="nc" id="L2917">                throw runtime.newErrnoFromErrno(fptr.errno(), fptr.getPath());</span>
            }
        } finally {
<span class="pc bpc" id="L2920" title="2 of 4 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L2923">        ((RubyString)str).setReadLength(n);</span>
<span class="pc bpc" id="L2924" title="1 of 4 branches missed.">        if (n == 0 &amp;&amp; ilen &gt; 0) {</span>
<span class="fc" id="L2925">            throw runtime.newEOFError();</span>
        }
<span class="fc" id="L2927">        str.setTaint(true);</span>

<span class="fc" id="L2929">        return str;</span>
    }

    // io_read
    public IRubyObject read(IRubyObject[] args) {
<span class="fc" id="L2934">        ThreadContext context = getRuntime().getCurrentContext();</span>
        
<span class="pc bpc" id="L2936" title="1 of 4 branches missed.">        switch (args.length) {</span>
<span class="fc" id="L2937">        case 0: return read(context);</span>
<span class="fc" id="L2938">        case 1: return read(context, args[0]);</span>
<span class="fc" id="L2939">        case 2: return read(context, args[0], args[1]);</span>
<span class="nc" id="L2940">        default: throw getRuntime().newArgumentError(args.length, 2);</span>
        }
    }

    // io_read
    @JRubyMethod(name = &quot;read&quot;)
    public IRubyObject read(ThreadContext context) {
<span class="fc" id="L2947">        return read(context, context.nil, context.nil);</span>
    }

    // io_read
    @JRubyMethod(name = &quot;read&quot;)
    public IRubyObject read(ThreadContext context, IRubyObject arg0) {
<span class="fc" id="L2953">        return read(context, arg0, context.nil);</span>
    }

    // io_read
    @JRubyMethod(name = &quot;read&quot;)
    public IRubyObject read(ThreadContext context, IRubyObject length, IRubyObject str) {
<span class="fc" id="L2959">        Ruby runtime = context.runtime;</span>
        OpenFile fptr;
        int n, len;
        
<span class="fc bfc" id="L2963" title="All 2 branches covered.">        if (length.isNil()) {</span>
<span class="fc" id="L2964">            fptr = getOpenFileChecked();</span>

<span class="fc" id="L2966">            boolean locked = fptr.lock();</span>
            try {
<span class="fc" id="L2968">                fptr.checkCharReadable(context);</span>
<span class="fc" id="L2969">                return fptr.readAll(context, 0, str);</span>
            } finally {
<span class="pc bpc" id="L2971" title="2 of 4 branches missed.">                if (locked) fptr.unlock();</span>
            }
        }
        
<span class="fc" id="L2975">        len = RubyNumeric.num2int(length);</span>
<span class="fc bfc" id="L2976" title="All 2 branches covered.">        if (len &lt; 0) {</span>
<span class="fc" id="L2977">            throw runtime.newArgumentError(&quot;negative length &quot; + len + &quot; given&quot;);</span>
        }

<span class="fc" id="L2980">        str = EncodingUtils.setStrBuf(runtime, str, len);</span>

<span class="fc" id="L2982">        fptr = getOpenFileChecked();</span>

<span class="fc" id="L2984">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L2986">            fptr.checkByteReadable(context);</span>
<span class="fc bfc" id="L2987" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L2988">                ((RubyString)str).setReadLength(0);</span>
<span class="fc" id="L2989">                return str;</span>
            }

<span class="fc" id="L2992">            fptr.READ_CHECK(context);</span>
            //        #if defined(RUBY_TEST_CRLF_ENVIRONMENT) || defined(_WIN32)
            //        previous_mode = set_binary_mode_with_seek_cur(fptr);
            //        #endif
<span class="fc" id="L2996">            n = fptr.fread(context, str, 0, len);</span>
        } finally {
<span class="pc bpc" id="L2998" title="3 of 6 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L3001">        ((RubyString)str).setReadLength(n);</span>
//        #if defined(RUBY_TEST_CRLF_ENVIRONMENT) || defined(_WIN32)
//        if (previous_mode == O_TEXT) {
//            setmode(fptr-&gt;fd, O_TEXT);
//        }
//        #endif
<span class="fc bfc" id="L3007" title="All 2 branches covered.">        if (n == 0) return context.nil;</span>
<span class="fc" id="L3008">        str.setTaint(true);</span>

<span class="fc" id="L3010">        return str;</span>
    }
    
    /** Read a byte. On EOF throw EOFError.
     * 
     */
    public IRubyObject readchar() {
<span class="nc" id="L3017">        return readchar(getRuntime().getCurrentContext());</span>
    }
    
    @JRubyMethod
    public IRubyObject stat(ThreadContext context) {
<span class="fc" id="L3022">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L3023">        OpenFile fptr = getOpenFileChecked();</span>

<span class="fc" id="L3025">        boolean locked = fptr.lock();</span>
        try {
            int realFileno;
<span class="fc" id="L3028">            fptr.checkClosed();</span>
<span class="pc bpc" id="L3029" title="2 of 4 branches missed.">            if (runtime.getPosix().isNative() &amp;&amp; (realFileno = fptr.fd().realFileno) != -1) {</span>
<span class="fc" id="L3030">                return RubyFileStat.newFileStat(runtime, realFileno);</span>
            } else {
                // no real fd, stat the path
<span class="nc" id="L3033">                return context.runtime.newFileStat(fptr.getPath(), false);</span>
            }
        } finally {
<span class="pc bpc" id="L3036" title="5 of 6 branches missed.">            if (locked) fptr.unlock();</span>
        }
    }

    /** 
     * &lt;p&gt;Invoke a block for each byte.&lt;/p&gt;
     *
     * MRI: rb_io_each_byte
     */
    public IRubyObject each_byteInternal(ThreadContext context, Block block) {
<span class="fc" id="L3046">        Ruby runtime = context.runtime;</span>
        OpenFile fptr;

<span class="pc bpc" id="L3049" title="1 of 2 branches missed.">        if (!block.isGiven()) return enumeratorize(context.runtime, this, &quot;each_byte&quot;);</span>
<span class="fc" id="L3050">        fptr = getOpenFileChecked();</span>

<span class="fc" id="L3052">        boolean locked = fptr.lock();</span>
        try {
            do {
<span class="fc bfc" id="L3055" title="All 2 branches covered.">                while (fptr.rbuf.len &gt; 0) {</span>
<span class="fc" id="L3056">                    byte[] pBytes = fptr.rbuf.ptr;</span>
<span class="fc" id="L3057">                    int p = fptr.rbuf.off++;</span>
<span class="fc" id="L3058">                    fptr.rbuf.len--;</span>
<span class="fc" id="L3059">                    block.yield(context, runtime.newFixnum(pBytes[p] &amp; 0xFF));</span>
<span class="fc" id="L3060">                    fptr.errno(null);</span>
<span class="fc" id="L3061">                }</span>
<span class="fc" id="L3062">                fptr.checkByteReadable(context);</span>
<span class="fc" id="L3063">                fptr.READ_CHECK(context);</span>
<span class="fc bfc" id="L3064" title="All 2 branches covered.">            } while (fptr.fillbuf(context) &gt;= 0);</span>
        } finally {
<span class="pc bpc" id="L3066" title="2 of 4 branches missed.">            if (locked) fptr.unlock();</span>
        }
<span class="fc" id="L3068">        return this;</span>
    }

    @JRubyMethod
    public IRubyObject each_byte(ThreadContext context, Block block) {
<span class="fc bfc" id="L3073" title="All 2 branches covered.">        return block.isGiven() ? each_byteInternal(context, block) : enumeratorize(context.runtime, this, &quot;each_byte&quot;);</span>
    }

    // rb_io_bytes
    @JRubyMethod(name = &quot;bytes&quot;)
    public IRubyObject bytes(ThreadContext context, Block block) {
<span class="fc" id="L3079">        context.runtime.getWarnings().warn(&quot;IO#bytes is deprecated; use #each_byte instead&quot;);</span>
<span class="fc" id="L3080">        return each_byte(context, block);</span>
    }

    // rb_io_each_char
    public IRubyObject each_charInternal(ThreadContext context, Block block) {
<span class="fc" id="L3085">        Ruby runtime = context.runtime;</span>
        OpenFile fptr;
        Encoding enc;
        IRubyObject c;

<span class="fc bfc" id="L3090" title="All 2 branches covered.">        if (!block.isGiven()) return enumeratorize(context.runtime, this, &quot;each_char&quot;);</span>
<span class="fc" id="L3091">        fptr = getOpenFileChecked();</span>

<span class="fc" id="L3093">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L3095">            fptr.checkCharReadable(context);</span>

<span class="fc" id="L3097">            enc = fptr.inputEncoding(runtime);</span>
<span class="fc" id="L3098">            fptr.READ_CHECK(context);</span>
<span class="fc bfc" id="L3099" title="All 2 branches covered.">            while (!(c = fptr.getc(context, enc)).isNil()) {</span>
<span class="fc" id="L3100">                block.yield(context, c);</span>
            }
        } finally {
<span class="pc bpc" id="L3103" title="2 of 4 branches missed.">            if (locked) fptr.unlock();</span>
        }

<span class="fc" id="L3106">        return this;</span>
    }

    @JRubyMethod(name = &quot;each_char&quot;)
    public IRubyObject each_char(ThreadContext context, Block block) {
<span class="fc" id="L3111">        return each_charInternal(context, block);</span>
    }

    @JRubyMethod(name = &quot;chars&quot;)
    public IRubyObject chars(ThreadContext context, Block block) {
<span class="fc" id="L3116">        context.runtime.getWarnings().warn(&quot;IO#chars is deprecated; use #each_char instead&quot;);</span>
<span class="fc" id="L3117">        return each_charInternal(context, block);</span>
    }

    @JRubyMethod
    public IRubyObject codepoints(ThreadContext context, Block block) {
<span class="fc" id="L3122">        context.runtime.getWarnings().warn(&quot;IO#codepoints is deprecated; use #each_codepoint instead&quot;);</span>
<span class="fc" id="L3123">        return eachCodePointCommon(context, block, &quot;each_codepoint&quot;);</span>
    }

    @JRubyMethod
    public IRubyObject each_codepoint(ThreadContext context, Block block) {
<span class="fc" id="L3128">        return eachCodePointCommon(context, block, &quot;each_codepoint&quot;);</span>
    }

    // rb_io_each_codepoint
    private IRubyObject eachCodePointCommon(ThreadContext context, Block block, String methodName) {
<span class="fc" id="L3133">        Ruby runtime = context.runtime;</span>
        OpenFile fptr;
        Encoding enc;
        int c;
        int r, n;

<span class="fc bfc" id="L3139" title="All 2 branches covered.">        if (!block.isGiven()) return enumeratorize(context.runtime, this, methodName);</span>
<span class="fc" id="L3140">        fptr = getOpenFileChecked();</span>

<span class="fc" id="L3142">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L3144">            fptr.checkCharReadable(context);</span>

<span class="fc" id="L3146">            fptr.READ_CHECK(context);</span>
<span class="pc bpc" id="L3147" title="1 of 2 branches missed.">            if (fptr.needsReadConversion()) {</span>
<span class="nc" id="L3148">                fptr.SET_BINARY_MODE();</span>
                for (;;) {
<span class="nc" id="L3150">                    fptr.makeReadConversion(context);</span>
                    for (;;) {
<span class="nc bnc" id="L3152" title="All 2 branches missed.">                        if (fptr.cbuf.len != 0) {</span>
<span class="nc bnc" id="L3153" title="All 2 branches missed.">                            if (fptr.encs.enc != null)</span>
<span class="nc" id="L3154">                                r = StringSupport.preciseLength(fptr.encs.enc, fptr.cbuf.ptr, fptr.cbuf.off, fptr.cbuf.off + fptr.cbuf.len);</span>
                            else
<span class="nc" id="L3156">                                r = StringSupport.CONSTRUCT_MBCLEN_CHARFOUND(1);</span>
<span class="nc bnc" id="L3157" title="All 2 branches missed.">                            if (!StringSupport.MBCLEN_NEEDMORE_P(r))</span>
<span class="nc" id="L3158">                                break;</span>
<span class="nc bnc" id="L3159" title="All 2 branches missed.">                            if (fptr.cbuf.len == fptr.cbuf.capa) {</span>
<span class="nc" id="L3160">                                throw runtime.newIOError(&quot;too long character&quot;);</span>
                            }
                        }
<span class="nc bnc" id="L3163" title="All 2 branches missed.">                        if (fptr.moreChar(context) == OpenFile.MORE_CHAR_FINISHED) {</span>
<span class="nc" id="L3164">                            fptr.clearReadConversion();</span>
                            /* ignore an incomplete character before EOF */
<span class="nc" id="L3166">                            return this;</span>
                        }
                    }
<span class="nc bnc" id="L3169" title="All 2 branches missed.">                    if (StringSupport.MBCLEN_INVALID_P(r)) {</span>
<span class="nc" id="L3170">                        throw runtime.newArgumentError(&quot;invalid byte sequence in &quot; + fptr.encs.enc.toString());</span>
                    }
<span class="nc" id="L3172">                    n = StringSupport.MBCLEN_CHARFOUND_LEN(r);</span>
<span class="nc bnc" id="L3173" title="All 2 branches missed.">                    if (fptr.encs.enc != null) {</span>
<span class="nc" id="L3174">                        c = StringSupport.codePoint(runtime, fptr.encs.enc, fptr.cbuf.ptr, fptr.cbuf.off, fptr.cbuf.off + fptr.cbuf.len);</span>
                    }
                    else {
<span class="nc" id="L3177">                        c = fptr.cbuf.ptr[fptr.cbuf.off] &amp; 0xFF;</span>
                    }
<span class="nc" id="L3179">                    fptr.cbuf.off += n;</span>
<span class="nc" id="L3180">                    fptr.cbuf.len -= n;</span>
<span class="nc" id="L3181">                    block.yield(context, runtime.newFixnum(c &amp; 0xFFFFFFFF));</span>
                }
            }
<span class="fc" id="L3184">            fptr.NEED_NEWLINE_DECORATOR_ON_READ_CHECK();</span>
<span class="fc" id="L3185">            enc = fptr.inputEncoding(runtime);</span>
<span class="fc bfc" id="L3186" title="All 2 branches covered.">            while (fptr.fillbuf(context) &gt;= 0) {</span>
<span class="fc" id="L3187">                r = StringSupport.preciseLength(enc, fptr.rbuf.ptr, fptr.rbuf.off, fptr.rbuf.off + fptr.rbuf.len);</span>
<span class="fc bfc" id="L3188" title="All 2 branches covered.">                if (StringSupport.MBCLEN_CHARFOUND_P(r) &amp;&amp;</span>
<span class="pc bpc" id="L3189" title="1 of 2 branches missed.">                        (n = StringSupport.MBCLEN_CHARFOUND_LEN(r)) &lt;= fptr.rbuf.len) {</span>
<span class="fc" id="L3190">                    c = StringSupport.codePoint(runtime, fptr.encs.enc, fptr.rbuf.ptr, fptr.rbuf.off, fptr.rbuf.off + fptr.rbuf.len);</span>
<span class="fc" id="L3191">                    fptr.rbuf.off += n;</span>
<span class="fc" id="L3192">                    fptr.rbuf.len -= n;</span>
<span class="fc" id="L3193">                    block.yield(context, runtime.newFixnum(c &amp; 0xFFFFFFFF));</span>
<span class="pc bpc" id="L3194" title="1 of 2 branches missed.">                } else if (StringSupport.MBCLEN_INVALID_P(r)) {</span>
<span class="fc" id="L3195">                    throw runtime.newArgumentError(&quot;invalid byte sequence in &quot; + enc.toString());</span>
                } else {
                    continue;
                }
            }
        } finally {
<span class="pc bpc" id="L3201" title="4 of 6 branches missed.">            if (locked) fptr.unlock();</span>
        }
<span class="fc" id="L3203">        return this;</span>
    }

    /** 
     * &lt;p&gt;Invoke a block for each line.&lt;/p&gt;
     *
     * MRI: rb_io_each_line
     */
    private IRubyObject each_lineInternal(ThreadContext context, IRubyObject[] args, Block block, String name) {
<span class="fc bfc" id="L3212" title="All 2 branches covered.">        if (!block.isGiven()) return enumeratorize(context.runtime, this, name, args);</span>

<span class="fc" id="L3214">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L3215">        IRubyObject separator = prepareGetsSeparator(context, args);</span>

<span class="fc" id="L3217">        ByteListCache cache = new ByteListCache();</span>
<span class="fc bfc" id="L3218" title="All 2 branches covered.">        for (IRubyObject line = getline(context, separator); !line.isNil();</span>
<span class="fc" id="L3219">		        line = getline(context, separator, -1, cache)) {</span>
<span class="fc" id="L3220">            block.yield(context, line);</span>
        }
        
<span class="fc" id="L3223">        return this;</span>
    }

    @JRubyMethod(optional = 1)
    public IRubyObject each(final ThreadContext context, IRubyObject[]args, final Block block) {
<span class="fc" id="L3228">        return each_lineInternal(context, args, block, &quot;each&quot;);</span>
    }

    @JRubyMethod(optional = 1)
    public IRubyObject each_line(final ThreadContext context, IRubyObject[]args, final Block block) {
<span class="fc" id="L3233">        return each_lineInternal(context, args, block, &quot;each_line&quot;);</span>
    }

    @JRubyMethod(name = &quot;lines&quot;)
    public IRubyObject lines(final ThreadContext context, Block block) {
<span class="fc" id="L3238">        context.runtime.getWarnings().warn(&quot;IO#lines is deprecated; use #each_line instead&quot;);</span>
<span class="fc" id="L3239">        return each_lineInternal(context, NULL_ARRAY, block, &quot;each_line&quot;);</span>
    }

    @JRubyMethod(name = &quot;readlines&quot;, optional = 2)
    public RubyArray readlines(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L3244">        return readlinesCommon(context, args);</span>
    }

    private RubyArray readlinesCommon(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L3248">        Ruby runtime = context.runtime;</span>
        
<span class="fc" id="L3250">        long limit = prepareGetsLimit(context, args);</span>
<span class="fc" id="L3251">        IRubyObject separator = prepareGetsSeparator(context, args);</span>
<span class="fc" id="L3252">        RubyArray result = runtime.newArray();</span>
        IRubyObject line;

<span class="fc bfc" id="L3255" title="All 2 branches covered.">        while (! (line = getline(context, separator, limit, null)).isNil()) {</span>
<span class="fc" id="L3256">            result.append(line);</span>
        }
<span class="fc" id="L3258">        return result;</span>
    }

    @JRubyMethod(name = &quot;to_io&quot;)
    public RubyIO to_io() {
<span class="fc" id="L3263">    	return this;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L3268">        return inspect().toString();</span>
    }
    
    /* class methods for IO */

    // rb_io_s_foreach
    private static IRubyObject foreachInternal19(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="fc" id="L3275">        Ruby runtime = context.runtime;</span>
       
<span class="fc" id="L3277">        IRubyObject opt = ArgsUtil.getOptionsArg(context.runtime, args);</span>
<span class="fc" id="L3278">        IRubyObject io = openKeyArgs(context, recv, args, opt);</span>
<span class="pc bpc" id="L3279" title="1 of 2 branches missed.">        if (io.isNil()) return io;</span>

        // io_s_foreach

<span class="fc" id="L3283">        IRubyObject[] methodArguments = processReadlinesMethodArguments(args);</span>

        try {
            IRubyObject str;
<span class="fc bfc" id="L3287" title="All 2 branches covered.">            while (!(str = ((RubyIO)io).gets(context, methodArguments)).isNil()) {</span>
<span class="fc" id="L3288">                block.yield(context, str);</span>
            }
        } finally {
<span class="fc" id="L3291">            ((RubyIO)io).close();</span>
<span class="fc" id="L3292">            runtime.getGlobalVariables().clear(&quot;$_&quot;);</span>
<span class="fc" id="L3293">        }</span>

<span class="fc" id="L3295">        return context.nil;</span>
    }

    @JRubyMethod(name = &quot;foreach&quot;, required = 1, optional = 3, meta = true)
    public static IRubyObject foreach(final ThreadContext context, IRubyObject recv, IRubyObject[] args, final Block block) {
<span class="fc bfc" id="L3300" title="All 2 branches covered.">        if (!block.isGiven()) return enumeratorize(context.runtime, recv, &quot;foreach&quot;, args);</span>

<span class="fc" id="L3302">        return foreachInternal19(context, recv, args, block);</span>
    }

    public static RubyIO convertToIO(ThreadContext context, IRubyObject obj) {
<span class="fc" id="L3306">        return (RubyIO)TypeConverter.ioGetIO(context.runtime, obj);</span>
    }
   
    @JRubyMethod(name = &quot;select&quot;, required = 1, optional = 3, meta = true)
    public static IRubyObject select(ThreadContext context, IRubyObject recv, IRubyObject[] argv) {
        IRubyObject read, write, except, _timeout;
        Long timeout;
<span class="fc" id="L3313">        read = write = except = _timeout = context.nil;</span>

<span class="pc bpc" id="L3315" title="1 of 5 branches missed.">        switch (argv.length) {</span>
            case 4:
<span class="fc" id="L3317">                _timeout = argv[3];</span>
            case 3:
<span class="fc" id="L3319">                except = argv[2];</span>
            case 2:
<span class="fc" id="L3321">                write = argv[1];</span>
            case 1:
<span class="fc" id="L3323">                read = argv[0];</span>
        }
<span class="fc bfc" id="L3325" title="All 2 branches covered.">        if (_timeout.isNil()) {</span>
<span class="fc" id="L3326">            timeout = null;</span>
        }
        else {
<span class="fc" id="L3329">            double tmp = _timeout.convertToFloat().getDoubleValue();</span>
<span class="fc bfc" id="L3330" title="All 2 branches covered.">            if (tmp &lt; 0) throw context.runtime.newArgumentError(&quot;negative timeout&quot;);</span>
<span class="fc" id="L3331">            timeout = (long)(tmp * 1000); // ms</span>
        }

<span class="fc" id="L3334">        SelectExecutor args = new SelectExecutor(read, write, except, timeout);</span>

<span class="fc" id="L3336">        return args.go(context);</span>
    }

    // MRI: rb_io_advise
    @JRubyMethod(required = 1, optional = 2)
    public IRubyObject advise(ThreadContext context, IRubyObject[] argv) {
        IRubyObject advice, offset, len;
<span class="fc" id="L3343">        advice = offset = len = context.nil;</span>
        int off, l;
        OpenFile fptr;

<span class="pc bpc" id="L3347" title="1 of 4 branches missed.">        switch (argv.length) {</span>
            case 3:
<span class="fc" id="L3349">                len = argv[2];</span>
            case 2:
<span class="fc" id="L3351">                offset = argv[1];</span>
            case 1:
<span class="fc" id="L3353">                advice = argv[0];</span>
        }
<span class="fc" id="L3355">        adviceArgCheck(context, advice);</span>

<span class="fc" id="L3357">        RubyIO io = GetWriteIO();</span>
<span class="fc" id="L3358">        fptr = io.getOpenFileChecked();</span>

<span class="fc" id="L3360">        boolean locked = fptr.lock();</span>
        try {
<span class="fc bfc" id="L3362" title="All 2 branches covered.">            off = offset.isNil() ? 0 : offset.convertToInteger().getIntValue();</span>
<span class="pc bpc" id="L3363" title="1 of 2 branches missed.">            l = len.isNil() ? 0 : len.convertToInteger().getIntValue();</span>

            // TODO: implement advise
            //        #ifdef HAVE_POSIX_FADVISE
            //        return do_io_advise(fptr, advice, off, l);
            //        #else
            //        ((void)off, (void)l);	/* Ignore all hint */
<span class="fc" id="L3370">            return context.nil;</span>
            //        #endif
        } finally {
<span class="pc bpc" id="L3373" title="2 of 4 branches missed.">            if (locked) fptr.unlock();</span>
        }
    }

    // MRI: advice_arg_check
    static void adviceArgCheck(ThreadContext context, IRubyObject advice) {
<span class="fc bfc" id="L3379" title="All 2 branches covered.">        if (!(advice instanceof RubySymbol))</span>
<span class="fc" id="L3380">            throw context.runtime.newTypeError(&quot;advise must be a symbol&quot;);</span>

<span class="fc" id="L3382">        String adviceStr = advice.asJavaString();</span>
<span class="pc bpc" id="L3383" title="6 of 21 branches missed.">        switch (adviceStr) {</span>
            default:
<span class="fc" id="L3385">                throw context.runtime.newNotImplementedError(rbInspect(context, advice).toString());</span>

            case &quot;normal&quot;:
            case &quot;sequential&quot;:
            case &quot;random&quot;:
            case &quot;willneed&quot;:
            case &quot;dontneed&quot;:
            case &quot;noreuse&quot;:
                // ok
        }
<span class="fc" id="L3395">    }</span>
   
    public static IRubyObject read(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="nc" id="L3398">        return read19(context, recv, args, Block.NULL_BLOCK);</span>
   }

    public static void failIfDirectory(Ruby runtime, RubyString pathStr) {
<span class="fc bfc" id="L3402" title="All 2 branches covered.">        if (RubyFileTest.directory_p(runtime, pathStr).isTrue()) {</span>
<span class="pc bpc" id="L3403" title="1 of 2 branches missed.">            if (Platform.IS_WINDOWS) {</span>
<span class="nc" id="L3404">                throw runtime.newErrnoEACCESError(pathStr.asJavaString());</span>
            } else {
<span class="fc" id="L3406">                throw runtime.newErrnoEISDirError(pathStr.asJavaString());</span>
            }
        }
<span class="fc" id="L3409">    }</span>

    // open_key_args
    private static IRubyObject openKeyArgs(ThreadContext context, IRubyObject recv, IRubyObject[] argv, IRubyObject opt) {
<span class="fc" id="L3413">        Ruby runtime = context.runtime;</span>
        IRubyObject path, v;
        
<span class="fc" id="L3416">        path = RubyFile.get_path(context, argv[0]);</span>
<span class="fc" id="L3417">        failIfDirectory(runtime, (RubyString)path); // only in JRuby</span>
        // MRI increments args past 0 now, so remaining uses of args only see non-path args
        
<span class="fc bfc" id="L3420" title="All 2 branches covered.">        if (opt.isNil()) {</span>
<span class="fc" id="L3421">            return ioOpen(context, path, runtime.newFixnum(ModeFlags.RDONLY), runtime.newFixnum(0666), opt);</span>
        }
        
<span class="fc" id="L3424">        v = ((RubyHash)opt).op_aref(context, runtime.newSymbol(&quot;open_args&quot;));</span>
<span class="fc bfc" id="L3425" title="All 2 branches covered.">        if (!v.isNil()) {</span>
            IRubyObject args;
            int n;
            
<span class="fc" id="L3429">            v = v.convertToArray();</span>
<span class="fc" id="L3430">            n = ((RubyArray)v).size() + 1;</span>
            
<span class="fc" id="L3432">            args = runtime.newArray(n);</span>
<span class="fc" id="L3433">            ((RubyArray)args).push_m19(new IRubyObject[]{path});</span>
<span class="fc" id="L3434">            ((RubyArray)args).concat19(v);</span>
            
<span class="fc" id="L3436">            return RubyKernel.open19(context, recv, ((RubyArray)args).toJavaArray(), Block.NULL_BLOCK);</span>
        }
        
<span class="fc" id="L3439">        return ioOpen(context, path, context.nil, context.nil, opt);</span>
    }
    
    // rb_io_open
    public static IRubyObject ioOpen(ThreadContext context, IRubyObject filename, IRubyObject vmode, IRubyObject vperm, IRubyObject opt) {
<span class="fc" id="L3444">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L3445">        int[] oflags_p = {0}, fmode_p = {0};</span>
        int perm;
        IRubyObject cmd;
        
<span class="pc bpc" id="L3449" title="2 of 4 branches missed.">        if ((filename instanceof RubyString) &amp;&amp; ((RubyString) filename).isEmpty()) {</span>
<span class="nc" id="L3450">            throw context.getRuntime().newErrnoENOENTError();</span>
        }

<span class="fc" id="L3453">        Object pm = EncodingUtils.vmodeVperm(vmode, vperm);</span>

<span class="fc" id="L3455">        IOEncodable convconfig = new IOEncodable.ConvConfig();</span>
<span class="fc" id="L3456">        EncodingUtils.extractModeEncoding(context, convconfig, pm, opt, oflags_p, fmode_p);</span>
<span class="pc bpc" id="L3457" title="1 of 4 branches missed.">        perm = (vperm(pm) == null || vperm(pm).isNil()) ? 0666 : RubyNumeric.num2int(vperm(pm));</span>

<span class="fc bfc" id="L3459" title="All 2 branches covered.">        if (!(cmd = PopenExecutor.checkPipeCommand(context, filename)).isNil()) {</span>
<span class="fc" id="L3460">            return PopenExecutor.pipeOpen(context, cmd, OpenFile.ioOflagsModestr(runtime, oflags_p[0]), fmode_p[0], convconfig);</span>
        } else {
<span class="fc" id="L3462">            return ((RubyFile)context.runtime.getFile().allocate()).fileOpenGeneric(context, filename, oflags_p[0], fmode_p[0], convconfig, perm);</span>
        }
    }

    /**
     *  options is a hash which can contain:
     *    encoding: string or encoding
     *    mode: string
     *    open_args: array of string
     */
    private static IRubyObject write19(ThreadContext context, IRubyObject recv, IRubyObject path, IRubyObject str, IRubyObject offset, RubyHash options) {
<span class="nc" id="L3473">        RubyString pathStr = RubyFile.get_path(context, path);</span>
<span class="nc" id="L3474">        Ruby runtime = context.runtime;</span>
<span class="nc" id="L3475">        failIfDirectory(runtime, pathStr);</span>

<span class="nc" id="L3477">        RubyIO file = null;</span>

<span class="nc" id="L3479">        long mode = ModeFlags.CREAT;</span>

<span class="nc bnc" id="L3481" title="All 6 branches missed.">        if (options == null || (options != null &amp;&amp; options.isEmpty())) {</span>
<span class="nc bnc" id="L3482" title="All 2 branches missed.">            if (offset.isNil()) {</span>
<span class="nc" id="L3483">                mode |= ModeFlags.WRONLY;</span>
            } else {
<span class="nc" id="L3485">                mode |= ModeFlags.RDWR;</span>
            }

<span class="nc" id="L3488">            file = (RubyIO) Helpers.invoke(context, runtime.getFile(), &quot;new&quot;, path, RubyFixnum.newFixnum(runtime, mode));</span>
<span class="nc bnc" id="L3489" title="All 2 branches missed.">        } else if (!options.containsKey(runtime.newSymbol(&quot;mode&quot;))) {</span>
<span class="nc" id="L3490">            mode |= ModeFlags.WRONLY;</span>
<span class="nc" id="L3491">            file = (RubyIO) Helpers.invoke(context, runtime.getFile(), &quot;new&quot;, path, RubyFixnum.newFixnum(runtime, mode), options); </span>
        } else {
<span class="nc" id="L3493">            file = (RubyIO) Helpers.invoke(context, runtime.getFile(), &quot;new&quot;, path, options);</span>
        }

        try {
<span class="nc bnc" id="L3497" title="All 2 branches missed.">            if (!offset.isNil()) file.seek(context, offset);</span>
<span class="nc" id="L3498">            return file.write(context, str);</span>
        } finally  {
<span class="nc" id="L3500">            file.close();</span>
        }
    }

    /**
     * binread is just like read, except it doesn't take options and it forces
     * mode to be &quot;rb:ASCII-8BIT&quot;
     *
     * @param context the current ThreadContext
     * @param recv the target of the call (IO or a subclass)
     * @param args arguments; path [, length [, offset]]
     * @return the binary contents of the given file, at specified length and offset
     */
    @JRubyMethod(meta = true, required = 1, optional = 2)
    public static IRubyObject binread(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="fc" id="L3515">        IRubyObject nil = context.runtime.getNil();</span>
<span class="fc" id="L3516">        IRubyObject path = RubyFile.get_path(context, args[0]);</span>
<span class="fc" id="L3517">        IRubyObject length = nil;</span>
<span class="fc" id="L3518">        IRubyObject offset = nil;</span>
<span class="fc" id="L3519">        Ruby runtime = context.runtime;</span>

<span class="fc bfc" id="L3521" title="All 2 branches covered.">        if (args.length &gt; 2) {</span>
<span class="fc" id="L3522">            offset = args[2];</span>
<span class="fc" id="L3523">            length = args[1];</span>
<span class="fc bfc" id="L3524" title="All 2 branches covered.">        } else if (args.length &gt; 1) {</span>
<span class="fc" id="L3525">            length = args[1];</span>
        }
<span class="fc" id="L3527">        RubyIO file = (RubyIO) Helpers.invoke(context, runtime.getFile(), &quot;new&quot;, path, runtime.newString(&quot;rb:ASCII-8BIT&quot;));</span>

        try {
<span class="fc bfc" id="L3530" title="All 2 branches covered.">            if (!offset.isNil()) {</span>
<span class="fc" id="L3531">                file.seek(context, offset);</span>
            }
<span class="fc" id="L3533">            return file.read(context, length);</span>
        } finally  {
<span class="fc" id="L3535">            file.close();</span>
        }
    }

    // Enebo: annotation processing forced me to do pangea method here...
    @JRubyMethod(name = &quot;read&quot;, meta = true, required = 1, optional = 3)
    public static IRubyObject read19(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block unusedBlock) {
<span class="fc" id="L3542">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L3543">        IRubyObject nil = runtime.getNil();</span>
<span class="fc" id="L3544">        IRubyObject path = args[0];</span>
<span class="fc" id="L3545">        IRubyObject length = nil;</span>
<span class="fc" id="L3546">        IRubyObject offset = nil;</span>
<span class="fc" id="L3547">        IRubyObject options = nil;</span>

        { // rb_scan_args logic, basically
<span class="fc bfc" id="L3550" title="All 2 branches covered.">            if (args.length &gt; 3) {</span>
<span class="pc bpc" id="L3551" title="1 of 2 branches missed.">                if (!(args[3] instanceof RubyHash)) throw runtime.newTypeError(&quot;Must be a hash&quot;);</span>
<span class="fc" id="L3552">                options = (RubyHash) args[3];</span>
<span class="fc" id="L3553">                offset = args[2];</span>
<span class="fc" id="L3554">                length = args[1];</span>
<span class="fc bfc" id="L3555" title="All 2 branches covered.">            } else if (args.length &gt; 2) {</span>
<span class="pc bpc" id="L3556" title="1 of 2 branches missed.">                if (args[2] instanceof RubyHash) {</span>
<span class="nc" id="L3557">                    options = (RubyHash) args[2];</span>
                } else {
<span class="fc" id="L3559">                    offset = args[2];</span>
                }
<span class="fc" id="L3561">                length = args[1];</span>
<span class="fc bfc" id="L3562" title="All 2 branches covered.">            } else if (args.length &gt; 1) {</span>
<span class="fc bfc" id="L3563" title="All 2 branches covered.">                if (args[1] instanceof RubyHash) {</span>
<span class="fc" id="L3564">                    options = (RubyHash) args[1];</span>
                } else {
<span class="fc" id="L3566">                    length = args[1];</span>
                }
            }
<span class="pc bpc" id="L3569" title="1 of 2 branches missed.">            if (options == null) {</span>
<span class="nc" id="L3570">                options = RubyHash.newHash(runtime);</span>
            }
        }

<span class="fc" id="L3574">        RubyIO file = (RubyIO)openKeyArgs(context, recv, new IRubyObject[]{path, length, offset}, options);</span>

        try {
<span class="fc bfc" id="L3577" title="All 2 branches covered.">            if (!offset.isNil()) {</span>
                // protect logic around here in MRI?
<span class="fc" id="L3579">                file.seek(context, offset);</span>
            }
<span class="fc" id="L3581">            return file.read(context, length);</span>
        } finally  {
<span class="fc" id="L3583">            file.close();</span>
        }
    }

    // rb_io_s_binwrite
    @JRubyMethod(meta = true, required = 2, optional = 2)
    public static IRubyObject binwrite(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="fc" id="L3590">        return ioStaticWrite(context, recv, args, true);</span>
    }

    // MRI: rb_io_s_write
    @JRubyMethod(name = &quot;write&quot;, meta = true, required = 2, optional = 2)
    public static IRubyObject write(ThreadContext context, IRubyObject recv, IRubyObject[] argv) {
<span class="fc" id="L3596">        return (ioStaticWrite(context, recv, argv, false));</span>
    }

    // MRI: io_s_write
    public static IRubyObject ioStaticWrite(ThreadContext context, IRubyObject recv, IRubyObject[] argv, boolean binary) {
<span class="fc" id="L3601">        Ruby runtime = context.runtime;</span>
        IRubyObject string, offset, opt;
<span class="fc" id="L3603">        string = offset = opt = context.nil;</span>

<span class="pc bpc" id="L3605" title="1 of 4 branches missed.">        switch (argv.length) {</span>
            case 4:
<span class="fc" id="L3607">                opt = argv[3].convertToHash();</span>
<span class="fc" id="L3608">                offset = argv[2];</span>
<span class="fc" id="L3609">                string = argv[1];</span>
<span class="fc" id="L3610">                break;</span>
            case 3:
<span class="fc" id="L3612">                opt = TypeConverter.checkHashType(runtime, argv[2]);</span>
<span class="fc bfc" id="L3613" title="All 2 branches covered.">                if (opt.isNil()) offset = argv[2];</span>
<span class="fc" id="L3614">                string = argv[1];</span>
<span class="fc" id="L3615">                break;</span>
            case 2:
<span class="fc" id="L3617">                string = argv[1];</span>
<span class="fc" id="L3618">                break;</span>
            default:
<span class="nc" id="L3620">                Arity.raiseArgumentError(runtime, argv.length, 2, 4);</span>
        }

<span class="fc bfc" id="L3623" title="All 2 branches covered.">        if (opt.isNil()) opt = RubyHash.newHash(runtime);</span>
<span class="fc" id="L3624">        else opt = ((RubyHash)opt).dupFast(context);</span>

<span class="fc bfc" id="L3626" title="All 2 branches covered.">        if (((RubyHash)opt).op_aref(context, runtime.newSymbol(&quot;mode&quot;)).isNil()) {</span>
<span class="fc" id="L3627">            int mode = OpenFlags.O_WRONLY.intValue()|OpenFlags.O_CREAT.intValue();</span>
<span class="pc bpc" id="L3628" title="1 of 2 branches missed.">            if (OpenFlags.O_BINARY.defined()) {</span>
<span class="nc bnc" id="L3629" title="All 2 branches missed.">                if (binary) mode |= OpenFlags.O_BINARY.intValue();</span>
            }
<span class="fc bfc" id="L3631" title="All 2 branches covered.">            if (offset.isNil()) mode |= OpenFlags.O_TRUNC.intValue();</span>
<span class="fc" id="L3632">            ((RubyHash)opt).op_aset(runtime.newSymbol(&quot;mode&quot;), runtime.newFixnum(mode));</span>
        }
<span class="fc" id="L3634">        IRubyObject _io = openKeyArgs(context, recv, argv, opt);</span>

<span class="pc bpc" id="L3636" title="1 of 2 branches missed.">        if (_io.isNil()) return context.nil;</span>

<span class="fc" id="L3638">        RubyIO io = (RubyIO)_io;</span>

<span class="pc bpc" id="L3640" title="1 of 2 branches missed.">        if (!OpenFlags.O_BINARY.defined()) {</span>
<span class="fc bfc" id="L3641" title="All 2 branches covered.">            if (binary) io.binmode();</span>
        }

<span class="fc bfc" id="L3644" title="All 2 branches covered.">        if (!offset.isNil()) {</span>
<span class="fc" id="L3645">            seekBeforeAccess(context, io, offset, PosixShim.SEEK_SET);</span>
        }

        try {
<span class="fc" id="L3649">            return io.write(context, string, false);</span>
        } finally {
<span class="fc" id="L3651">            ioClose(runtime, io);</span>
        }
    }

    static IRubyObject seekBeforeAccess(ThreadContext context, RubyIO io, IRubyObject offset, int mode) {
<span class="fc" id="L3656">        io.setBinmode();</span>
<span class="fc" id="L3657">        return io.doSeek(context, offset, mode);</span>
    }

    public static IRubyObject readlines(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block unusedBlock) {
<span class="nc" id="L3661">        return readlines19(context, recv, args, unusedBlock);</span>
    }

    // rb_io_s_readlines
    @JRubyMethod(name = &quot;readlines&quot;, required = 1, optional = 3, meta = true)
    public static IRubyObject readlines19(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block unusedBlock) {
<span class="fc" id="L3667">        int argc = args.length;</span>
<span class="fc" id="L3668">        IRubyObject opt = ArgsUtil.getOptionsArg(context.runtime, args);</span>
<span class="fc" id="L3669">        IRubyObject io = openKeyArgs(context, recv, args, opt);</span>
<span class="pc bpc" id="L3670" title="1 of 2 branches missed.">        if (io.isNil()) return io;</span>
        
<span class="fc" id="L3672">        IRubyObject[] methodArguments = processReadlinesMethodArguments(args);</span>

<span class="fc" id="L3674">        return readlinesCommon19(context, (RubyIO)io, methodArguments);</span>
    }

    private static IRubyObject[] processReadlinesMethodArguments(IRubyObject[] args) {
<span class="fc" id="L3678">        int count = args.length;</span>
<span class="fc" id="L3679">        IRubyObject[] methodArguments = IRubyObject.NULL_ARRAY;</span>
        
<span class="fc bfc" id="L3681" title="All 6 branches covered.">        if(count &gt;= 3 &amp;&amp; (args[2] instanceof RubyFixnum || args[2].respondsTo(&quot;to_int&quot;))) {</span>
<span class="fc" id="L3682">            methodArguments = new IRubyObject[]{args[1], args[2]};   </span>
<span class="pc bpc" id="L3683" title="1 of 6 branches missed.">        } else if (count &gt;= 2 &amp;&amp; (args[1] instanceof RubyFixnum || args[1].respondsTo(&quot;to_int&quot;))) {</span>
<span class="fc" id="L3684">            methodArguments = new IRubyObject[]{args[1]};  </span>
<span class="fc bfc" id="L3685" title="All 4 branches covered.">        } else if (count &gt;= 2 &amp;&amp; !(args[1] instanceof RubyHash))  {</span>
<span class="fc" id="L3686">            methodArguments = new IRubyObject[]{args[1]};  </span>
        }
        
<span class="fc" id="L3689">        return methodArguments;</span>
    }
    
    private static RubyArray readlinesCommon19(ThreadContext context, RubyIO file, IRubyObject[] newArguments) {
        try {
<span class="fc" id="L3694">            return (RubyArray) file.callMethod(context, &quot;readlines&quot;, newArguments);</span>
        } finally {
<span class="fc" id="L3696">            file.close();</span>
        }
    }

    private void setupPopen(ModeFlags modes, POpenProcess process) throws RaiseException {
<span class="nc" id="L3701">        Ruby runtime = getRuntime();</span>
<span class="nc" id="L3702">        openFile.setMode(modes.getOpenFileFlags() | OpenFile.SYNC);</span>
<span class="nc" id="L3703">        openFile.setProcess(process);</span>

<span class="nc bnc" id="L3705" title="All 2 branches missed.">        if (openFile.isReadable()) {</span>
            Channel inChannel;
<span class="nc bnc" id="L3707" title="All 2 branches missed.">            if (process.getInput() != null) {</span>
                // NIO-based
<span class="nc" id="L3709">                inChannel = process.getInput();</span>
            } else {
                // Stream-based
<span class="nc" id="L3712">                inChannel = Channels.newChannel(process.getInputStream());</span>
            }

<span class="nc" id="L3715">            ChannelFD main = new ChannelFD(inChannel, runtime.getPosix(), runtime.getFilenoUtil());</span>

<span class="nc" id="L3717">            openFile.setFD(main);</span>
<span class="nc" id="L3718">            openFile.setMode(OpenFile.READABLE);</span>
        }

<span class="nc bnc" id="L3721" title="All 4 branches missed.">        if (openFile.isWritable() &amp;&amp; process.hasOutput()) {</span>
            Channel outChannel;
<span class="nc bnc" id="L3723" title="All 2 branches missed.">            if (process.getOutput() != null) {</span>
                // NIO-based
<span class="nc" id="L3725">                outChannel = process.getOutput();</span>
            } else {
<span class="nc" id="L3727">                outChannel = Channels.newChannel(process.getOutputStream());</span>
            }

<span class="nc" id="L3730">            ChannelFD pipe = new ChannelFD(outChannel, runtime.getPosix(), runtime.getFilenoUtil());</span>

<span class="nc" id="L3732">            RubyIO writeIO = new RubyIO(runtime, runtime.getIO());</span>
<span class="nc" id="L3733">            writeIO.initializeCommon(runtime.getCurrentContext(), pipe, runtime.newFixnum(OpenFlags.O_WRONLY), runtime.getNil());</span>

<span class="nc" id="L3735">            openFile.tiedIOForWriting = writeIO;</span>
<span class="nc" id="L3736">            setInstanceVariable(&quot;@tied_io_for_writing&quot;, writeIO);</span>
        }
<span class="nc" id="L3738">    }</span>

    private static class Ruby19POpen {
        public final RubyString cmd;
        public final IRubyObject[] cmdPlusArgs;
        public final RubyHash env;
        
<span class="nc" id="L3745">        public Ruby19POpen(Ruby runtime, IRubyObject[] args) {</span>
<span class="nc" id="L3746">            IRubyObject[] _cmdPlusArgs = null;</span>
<span class="nc" id="L3747">            RubyHash _env = null;</span>
            IRubyObject _cmd;
<span class="nc" id="L3749">            IRubyObject arg0 = args[0].checkArrayType();</span>

<span class="nc bnc" id="L3751" title="All 2 branches missed.">            if (args[0] instanceof RubyHash) {</span>
                // use leading hash as env
<span class="nc bnc" id="L3753" title="All 2 branches missed.">                if (args.length &gt; 1) {</span>
<span class="nc" id="L3754">                    _env = (RubyHash)args[0];</span>
                } else {
<span class="nc" id="L3756">                    Arity.raiseArgumentError(runtime, 0, 1, 2);</span>
                }

<span class="nc bnc" id="L3759" title="All 2 branches missed.">                if (Platform.IS_WINDOWS) {</span>
<span class="nc" id="L3760">                    String[] tokens = args[1].convertToString().toString().split(&quot; &quot;, 2);</span>
<span class="nc bnc" id="L3761" title="All 2 branches missed.">                    String commandString = tokens[0].replace('/', '\\') +</span>
                            (tokens.length &gt; 1 ? ' ' + tokens[1] : &quot;&quot;);
<span class="nc" id="L3763">                    _cmd = runtime.newString(commandString);</span>
<span class="nc" id="L3764">                } else {</span>
<span class="nc" id="L3765">                    _cmd = args[1].convertToString();</span>
                }
<span class="nc bnc" id="L3767" title="All 2 branches missed.">            } else if (args[0] instanceof RubyArray) {</span>
<span class="nc" id="L3768">                RubyArray arg0Ary = (RubyArray)arg0;</span>
<span class="nc bnc" id="L3769" title="All 2 branches missed.">                if (arg0Ary.isEmpty()) throw runtime.newArgumentError(&quot;wrong number of arguments&quot;);</span>
<span class="nc bnc" id="L3770" title="All 2 branches missed.">                if (arg0Ary.eltOk(0) instanceof RubyHash) {</span>
                    // leading hash, use for env
<span class="nc" id="L3772">                    _env = (RubyHash)arg0Ary.delete_at(0);</span>
                }
<span class="nc bnc" id="L3774" title="All 2 branches missed.">                if (arg0Ary.isEmpty()) throw runtime.newArgumentError(&quot;wrong number of arguments&quot;);</span>
<span class="nc bnc" id="L3775" title="All 4 branches missed.">                if (arg0Ary.size() &gt; 1 &amp;&amp; arg0Ary.eltOk(arg0Ary.size() - 1) instanceof RubyHash) {</span>
                    // trailing hash, use for opts
<span class="nc" id="L3777">                    _env = (RubyHash)arg0Ary.eltOk(arg0Ary.size() - 1);</span>
                }
<span class="nc" id="L3779">                _cmdPlusArgs = (IRubyObject[])arg0Ary.toJavaArray();</span>

<span class="nc bnc" id="L3781" title="All 2 branches missed.">                if (Platform.IS_WINDOWS) {</span>
<span class="nc" id="L3782">                    String commandString = _cmdPlusArgs[0].convertToString().toString().replace('/', '\\');</span>
<span class="nc" id="L3783">                    _cmdPlusArgs[0] = runtime.newString(commandString);</span>
<span class="nc" id="L3784">                } else {</span>
<span class="nc" id="L3785">                    _cmdPlusArgs[0] = _cmdPlusArgs[0].convertToString();</span>
                }
<span class="nc" id="L3787">                _cmd = _cmdPlusArgs[0];</span>
<span class="nc" id="L3788">            } else {</span>
<span class="nc bnc" id="L3789" title="All 2 branches missed.">                if (Platform.IS_WINDOWS) {</span>
<span class="nc" id="L3790">                    String[] tokens = args[0].convertToString().toString().split(&quot; &quot;, 2);</span>
<span class="nc bnc" id="L3791" title="All 2 branches missed.">                    String commandString = tokens[0].replace('/', '\\') +</span>
                            (tokens.length &gt; 1 ? ' ' + tokens[1] : &quot;&quot;);
<span class="nc" id="L3793">                    _cmd = runtime.newString(commandString);</span>
<span class="nc" id="L3794">                } else {</span>
<span class="nc" id="L3795">                    _cmd = args[0].convertToString();</span>
                }
            }

<span class="nc" id="L3799">            this.cmd = (RubyString)_cmd;</span>
<span class="nc" id="L3800">            this.cmdPlusArgs = _cmdPlusArgs;</span>
<span class="nc" id="L3801">            this.env = _env;</span>
<span class="nc" id="L3802">        }</span>
    }

    @JRubyMethod(name = &quot;popen&quot;, required = 1, optional = 2, meta = true)
    public static IRubyObject popen(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="fc" id="L3807">        Ruby runtime = context.runtime;</span>

<span class="pc bpc" id="L3809" title="2 of 4 branches missed.">        if (runtime.getPosix().isNative() &amp;&amp; !Platform.IS_WINDOWS) {</span>
            // new native popen logic
<span class="fc" id="L3811">            return PopenExecutor.popen(context, args, (RubyClass)recv, block);</span>
        }

        // old JDK popen logic
<span class="nc" id="L3815">        IRubyObject pmode = null;</span>
<span class="nc" id="L3816">        RubyHash options = null;</span>
        
<span class="nc bnc" id="L3818" title="All 4 branches missed.">        switch(args.length) {</span>
            case 1:
<span class="nc" id="L3820">                break;</span>
            case 2:
<span class="nc bnc" id="L3822" title="All 2 branches missed.">                if (args[1] instanceof RubyHash) {</span>
<span class="nc" id="L3823">                    options = (RubyHash) args[1];</span>
                } else {
<span class="nc" id="L3825">                    pmode = args[1];</span>
                }
<span class="nc" id="L3827">                break;</span>
            case 3:
<span class="nc" id="L3829">                options = args[2].convertToHash();</span>
<span class="nc" id="L3830">                pmode = args[1];</span>
                break;
        }
        
<span class="nc" id="L3834">        RubyIO io = new RubyIO(runtime, (RubyClass) recv);</span>
        
<span class="nc" id="L3836">        io.MakeOpenFile();</span>
        
<span class="nc" id="L3838">        Object pm = vmodeVperm(pmode, runtime.newFixnum(0));</span>
<span class="nc" id="L3839">        int[] oflags_p = {0}, fmode_p = {0};</span>
<span class="nc" id="L3840">        EncodingUtils.extractModeEncoding(context, io, pm, options, oflags_p, fmode_p);</span>
<span class="nc" id="L3841">        ModeFlags modes = ModeFlags.createModeFlags(oflags_p[0]);</span>
        
        // FIXME: Reprocessing logic twice for now...
        // for 1.9 mode, strip off the trailing options hash, if there
<span class="nc bnc" id="L3845" title="All 4 branches missed.">        if (args.length &gt; 1 &amp;&amp; args[args.length - 1] instanceof RubyHash) {</span>
<span class="nc" id="L3846">            options = (RubyHash)args[args.length - 1];</span>
<span class="nc" id="L3847">            IRubyObject[] newArgs = new IRubyObject[args.length - 1];</span>
<span class="nc" id="L3848">            System.arraycopy(args, 0, newArgs, 0, args.length - 1);</span>
<span class="nc" id="L3849">            args = newArgs;</span>
        }
        
<span class="nc" id="L3852">        Ruby19POpen r19Popen = new Ruby19POpen(runtime, args);</span>
        
<span class="nc bnc" id="L3854" title="All 2 branches missed.">        if (&quot;-&quot;.equals(r19Popen.cmd.toString())) {</span>
<span class="nc" id="L3855">            throw runtime.newNotImplementedError(&quot;popen(\&quot;-\&quot;) is unimplemented&quot;);</span>
        }

        try {
            ShellLauncher.POpenProcess process;
<span class="nc bnc" id="L3860" title="All 2 branches missed.">            if (r19Popen.cmdPlusArgs == null) {</span>
<span class="nc" id="L3861">                process = ShellLauncher.popen(runtime, r19Popen.cmd, modes);</span>
            } else {
<span class="nc" id="L3863">                process = ShellLauncher.popen(runtime, r19Popen.cmdPlusArgs, r19Popen.env, modes);</span>
            }

            // Yes, this is gross. java.lang.Process does not appear to be guaranteed
            // &quot;ready&quot; when we get it back from Runtime#exec, so we try to give it a
            // chance by waiting for 10ms before we proceed. Only doing this on 1.5
            // since Hotspot 1.6+ does not seem to exhibit the problem.
<span class="nc bnc" id="L3870" title="All 2 branches missed.">            if (System.getProperty(&quot;java.specification.version&quot;, &quot;&quot;).equals(&quot;1.5&quot;)) {</span>
<span class="nc" id="L3871">                synchronized (process) {</span>
                    try {
<span class="nc" id="L3873">                        process.wait(100);</span>
<span class="nc" id="L3874">                    } catch (InterruptedException ie) {}</span>
<span class="nc" id="L3875">                }</span>
            }

<span class="nc" id="L3878">            checkPopenOptions(options);</span>

<span class="nc" id="L3880">            io.setupPopen(modes, process);</span>

<span class="nc bnc" id="L3882" title="All 2 branches missed.">            if (block.isGiven()) {</span>
                try {
<span class="nc" id="L3884">                    return block.yield(context, io);</span>
                } finally {
<span class="nc bnc" id="L3886" title="All 4 branches missed.">                    if (io.openFile.isOpen()) {</span>
<span class="nc" id="L3887">                        io.close();</span>
                    }
                    // RubyStatus uses real native status now, so we unshift Java's shifted exit status
<span class="nc" id="L3890">                    context.setLastExitStatus(RubyProcess.RubyStatus.newProcessStatus(runtime, process.waitFor() &lt;&lt; 8, ShellLauncher.getPidFromProcess(process)));</span>
                }
            }
<span class="nc" id="L3893">            return io;</span>
<span class="nc" id="L3894">        } catch (IOException e) {</span>
<span class="nc" id="L3895">            throw runtime.newIOErrorFromException(e);</span>
<span class="nc" id="L3896">        } catch (InterruptedException e) {</span>
<span class="nc" id="L3897">            throw runtime.newThreadError(&quot;unexpected interrupt&quot;);</span>
        }
    }

    public static IRubyObject pipe(ThreadContext context, IRubyObject recv) {
<span class="nc" id="L3902">        return pipe19(context, recv);</span>
    }

    public static IRubyObject pipe19(ThreadContext context, IRubyObject recv) {
<span class="nc" id="L3906">        return pipe19(context, recv, IRubyObject.NULL_ARRAY, Block.NULL_BLOCK);</span>
    }

    public static IRubyObject pipe19(ThreadContext context, IRubyObject recv, IRubyObject modes) {
<span class="nc" id="L3910">        return pipe19(context, recv, new IRubyObject[] {modes}, Block.NULL_BLOCK);</span>
    }

    @JRubyMethod(name = &quot;pipe&quot;, optional = 3, meta = true)
    public static IRubyObject pipe19(ThreadContext context, IRubyObject klass, IRubyObject[] argv, Block block) {
<span class="fc" id="L3915">        Ruby runtime = context.runtime;</span>
        int state;
        RubyIO r, w;
//        IRubyObject args[] = new IRubyObject[3]
        IRubyObject v1, v2;
        IRubyObject opt;
<span class="fc" id="L3921">        v1 = v2 = opt = context.nil;</span>
        OpenFile fptr, fptr2;
<span class="fc" id="L3923">        int[] fmode_p = {0};</span>
        IRubyObject ret;
<span class="fc" id="L3925">        int argc = argv.length;</span>

<span class="fc bfc" id="L3927" title="All 4 branches covered.">        switch (argc) {</span>
            case 3:
<span class="fc" id="L3929">                opt = argv[2].convertToHash();</span>
<span class="fc" id="L3930">                argc--;</span>
<span class="fc" id="L3931">                v2 = argv[1];</span>
<span class="fc" id="L3932">                v1 = argv[0];</span>
<span class="fc" id="L3933">                break;</span>
            case 2:
<span class="fc" id="L3935">                opt = TypeConverter.checkHashType(runtime, argv[1]);</span>
<span class="fc bfc" id="L3936" title="All 2 branches covered.">                if (!opt.isNil()) {</span>
<span class="fc" id="L3937">                    argc--;</span>
                } else {
<span class="fc" id="L3939">                    v2 = argv[1];</span>
                }
<span class="fc" id="L3941">                v1 = argv[0];</span>
<span class="fc" id="L3942">                break;</span>
            case 1:
<span class="fc" id="L3944">                opt = TypeConverter.checkHashType(runtime, argv[0]);</span>
<span class="pc bpc" id="L3945" title="1 of 2 branches missed.">                if (!opt.isNil()) {</span>
<span class="nc" id="L3946">                    argc--;</span>
                } else {
<span class="fc" id="L3948">                    v1 = argv[0];</span>
                }
        }

<span class="fc" id="L3952">        PosixShim posix = new PosixShim(runtime.getPosix());</span>
<span class="fc" id="L3953">        Channel[] fds = posix.pipe();</span>
<span class="pc bpc" id="L3954" title="1 of 2 branches missed.">        if (fds == null)</span>
<span class="nc" id="L3955">            throw runtime.newErrnoFromErrno(posix.errno, &quot;opening pipe&quot;);</span>

//        args[0] = klass;
//        args[1] = INT2NUM(pipes[0]);
//        args[2] = INT2FIX(O_RDONLY);
//        r = rb_protect(io_new_instance, (VALUE)args, &amp;state);
//        if (state) {
//            close(pipes[0]);
//            close(pipes[1]);
//            rb_jump_tag(state);
//        }
<span class="fc" id="L3966">        r = new RubyIO(runtime, (RubyClass)klass);</span>
<span class="fc" id="L3967">        r.initializeCommon(context, new ChannelFD(fds[0], runtime.getPosix(), runtime.getFilenoUtil()), runtime.newFixnum(OpenFlags.O_RDONLY), context.nil);</span>
<span class="fc" id="L3968">        fptr = r.getOpenFileChecked();</span>

<span class="fc" id="L3970">        r.setEncoding(context, v1, v2, opt);</span>

//        args[1] = INT2NUM(pipes[1]);
//        args[2] = INT2FIX(O_WRONLY);
//        w = rb_protect(io_new_instance, (VALUE)args, &amp;state);
//        if (state) {
//            close(pipes[1]);
//            if (!NIL_P(r)) rb_io_close(r);
//            rb_jump_tag(state);
//        }
<span class="fc" id="L3980">        w = new RubyIO(runtime, (RubyClass)klass);</span>
<span class="fc" id="L3981">        w.initializeCommon(context, new ChannelFD(fds[1], runtime.getPosix(), runtime.getFilenoUtil()), runtime.newFixnum(OpenFlags.O_WRONLY), context.nil);</span>
<span class="fc" id="L3982">        fptr2 = w.getOpenFileChecked();</span>
<span class="fc" id="L3983">        fptr2.setSync(true);</span>

<span class="fc" id="L3985">        EncodingUtils.extractBinmode(runtime, opt, fmode_p);</span>

<span class="pc bpc" id="L3987" title="1 of 2 branches missed.">        if (EncodingUtils.DEFAULT_TEXTMODE != 0) {</span>
<span class="nc bnc" id="L3988" title="All 4 branches missed.">            if ((fptr.getMode() &amp; OpenFile.TEXTMODE) != 0 &amp;&amp; (fmode_p[0] &amp; OpenFile.BINMODE) != 0) {</span>
<span class="nc" id="L3989">                fptr.setMode(fptr.getMode() &amp; ~OpenFile.TEXTMODE);</span>
                // TODO: setmode O_BINARY means what via NIO?
//                setmode(fptr-&gt;fd, O_BINARY);
            }
<span class="nc bnc" id="L3993" title="All 2 branches missed.">            if (Platform.IS_WINDOWS) { // #if defined(RUBY_TEST_CRLF_ENVIRONMENT) || defined(_WIN32)</span>
<span class="nc bnc" id="L3994" title="All 2 branches missed.">                if ((fptr.encs.ecflags &amp; EncodingUtils.ECONV_DEFAULT_NEWLINE_DECORATOR) != 0) {</span>
<span class="nc" id="L3995">                    fptr.encs.ecflags |= EConvFlags.UNIVERSAL_NEWLINE_DECORATOR;</span>
                }
            }
        }
<span class="fc" id="L3999">        fptr.setMode(fptr.getMode() | fmode_p[0]);</span>

<span class="pc bpc" id="L4001" title="1 of 2 branches missed.">        if (EncodingUtils.DEFAULT_TEXTMODE != 0) {</span>
<span class="nc bnc" id="L4002" title="All 4 branches missed.">            if ((fptr2.getMode() &amp; OpenFile.TEXTMODE) != 0 &amp;&amp; (fmode_p[0] &amp; OpenFile.BINMODE) != 0) {</span>
<span class="nc" id="L4003">                fptr2.setMode(fptr2.getMode() &amp; ~OpenFile.TEXTMODE);</span>
                // TODO: setmode O_BINARY means what via NIO?
//                setmode(fptr2-&gt;fd, O_BINARY);
            }
        }
<span class="fc" id="L4008">        fptr2.setMode(fptr2.getMode() | fmode_p[0]);</span>

<span class="fc" id="L4010">        ret = runtime.newArray(r, w);</span>
<span class="fc bfc" id="L4011" title="All 2 branches covered.">        if (block.isGiven()) {</span>
<span class="fc" id="L4012">            return ensureYieldClosePipes(context, ret, r, w, block);</span>
        }
<span class="fc" id="L4014">        return ret;</span>
    }

    // MRI: rb_ensure(... pipe_pair_close ...)
    public static IRubyObject ensureYieldClosePipes(ThreadContext context, IRubyObject obj, RubyIO r, RubyIO w, Block block) {
        try {
<span class="fc" id="L4020">            return block.yield(context, obj);</span>
        } finally {
<span class="fc" id="L4022">            pipePairClose(context.runtime, r, w);</span>
        }
    }

    // MRI: pipe_pair_close
    private static void pipePairClose(Ruby runtime, RubyIO r, RubyIO w) {
        try {
<span class="fc" id="L4029">            ioClose(runtime, r);</span>
        } finally {
<span class="pc" id="L4031">            ioClose(runtime, w);</span>
<span class="fc" id="L4032">        }</span>
<span class="fc" id="L4033">    }</span>

    @JRubyMethod(name = &quot;copy_stream&quot;, required = 2, optional = 2, meta = true)
    public static IRubyObject copy_stream(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="fc" id="L4037">        Ruby runtime = context.runtime;</span>

<span class="fc" id="L4039">        IRubyObject arg1 = args[0];</span>
<span class="fc" id="L4040">        IRubyObject arg2 = args[1];</span>

<span class="fc" id="L4042">        RubyInteger length = null;</span>
<span class="fc" id="L4043">        RubyInteger offset = null;</span>

<span class="fc" id="L4045">        RubyIO io1 = null;</span>
<span class="fc" id="L4046">        RubyIO io2 = null;</span>

<span class="fc" id="L4048">        RubyString read = null;</span>

<span class="fc bfc" id="L4050" title="All 2 branches covered.">        if (args.length &gt;= 3) {</span>
<span class="fc" id="L4051">            length = args[2].convertToInteger();</span>
<span class="fc bfc" id="L4052" title="All 2 branches covered.">            if (args.length == 4) {</span>
<span class="fc" id="L4053">                offset = args[3].convertToInteger();</span>
            }
        }

<span class="fc bfc" id="L4057" title="All 2 branches covered.">        if (arg1 instanceof RubyString) {</span>
<span class="fc" id="L4058">            io1 = (RubyIO) RubyFile.open(context, runtime.getFile(), new IRubyObject[] {arg1}, Block.NULL_BLOCK);</span>
<span class="fc bfc" id="L4059" title="All 2 branches covered.">        } else if (arg1 instanceof RubyIO) {</span>
<span class="fc" id="L4060">            io1 = (RubyIO) arg1;</span>
<span class="fc bfc" id="L4061" title="All 2 branches covered.">        } else if (arg1.respondsTo(&quot;to_path&quot;)) {</span>
<span class="fc" id="L4062">            RubyString path = (RubyString) TypeConverter.convertToType19(arg1, runtime.getString(), &quot;to_path&quot;);</span>
<span class="fc" id="L4063">            io1 = (RubyIO) RubyFile.open(context, runtime.getFile(), new IRubyObject[] {path}, Block.NULL_BLOCK);</span>
<span class="pc bpc" id="L4064" title="1 of 2 branches missed.">        } else if (arg1.respondsTo(&quot;read&quot;)) {</span>
<span class="pc bpc" id="L4065" title="1 of 2 branches missed.">            if (length == null) {</span>
<span class="fc" id="L4066">                read = arg1.callMethod(context, &quot;read&quot;, runtime.getNil()).convertToString();</span>
            } else {
<span class="nc" id="L4068">                read = arg1.callMethod(context, &quot;read&quot;, length).convertToString();</span>
            }
        } else {
<span class="nc" id="L4071">            throw runtime.newArgumentError(&quot;Should be String or IO&quot;);</span>
        }

<span class="fc bfc" id="L4074" title="All 2 branches covered.">        if (arg2 instanceof RubyString) {</span>
<span class="fc" id="L4075">            io2 = (RubyIO) RubyFile.open(context, runtime.getFile(), new IRubyObject[] {arg2, runtime.newString(&quot;w&quot;)}, Block.NULL_BLOCK);</span>
<span class="fc bfc" id="L4076" title="All 2 branches covered.">        } else if (arg2 instanceof RubyIO) {</span>
<span class="fc" id="L4077">            io2 = (RubyIO) arg2;</span>
<span class="fc bfc" id="L4078" title="All 2 branches covered.">        } else if (arg2.respondsTo(&quot;to_path&quot;)) {</span>
<span class="fc" id="L4079">            RubyString path = (RubyString) TypeConverter.convertToType19(arg2, runtime.getString(), &quot;to_path&quot;);</span>
<span class="fc" id="L4080">            io2 = (RubyIO) RubyFile.open(context, runtime.getFile(), new IRubyObject[] {path, runtime.newString(&quot;w&quot;)}, Block.NULL_BLOCK);</span>
<span class="pc bpc" id="L4081" title="1 of 2 branches missed.">        } else if (arg2.respondsTo(&quot;write&quot;)) {</span>
<span class="pc bpc" id="L4082" title="1 of 2 branches missed.">            if (read == null) {</span>
<span class="pc bpc" id="L4083" title="1 of 2 branches missed.">                if (length == null) {</span>
<span class="fc" id="L4084">                    read = io1.read(context, runtime.getNil()).convertToString();</span>
                } else {
<span class="nc" id="L4086">                    read = io1.read(context, length).convertToString();</span>
                }
            }
<span class="fc" id="L4089">            return arg2.callMethod(context, &quot;write&quot;, read);</span>
        } else {
<span class="nc" id="L4091">            throw runtime.newArgumentError(&quot;Should be String or IO&quot;);</span>
        }

<span class="fc bfc" id="L4094" title="All 2 branches covered.">        if (io1 == null) {</span>
<span class="fc" id="L4095">            IRubyObject size = io2.write(context, read);</span>
<span class="fc" id="L4096">            io2.flush(context);</span>
<span class="fc" id="L4097">            return size;</span>
        }

<span class="fc" id="L4100">        io2 = io2.GetWriteIO();</span>

<span class="fc bfc" id="L4102" title="All 2 branches covered.">        if (!io1.openFile.isReadable()) throw runtime.newIOError(&quot;from IO is not readable&quot;);</span>
<span class="fc bfc" id="L4103" title="All 2 branches covered.">        if (!io2.openFile.isWritable()) throw runtime.newIOError(&quot;to IO is not writable&quot;);</span>

        // attempt to preserve position of original
<span class="fc" id="L4106">        OpenFile fptr = io1.getOpenFileChecked();</span>

<span class="fc" id="L4108">        boolean locked = fptr.lock();</span>
        try {
<span class="fc" id="L4110">            long pos = fptr.tell(context);</span>
<span class="fc" id="L4111">            long size = 0;</span>

            try {
<span class="pc bpc" id="L4114" title="1 of 2 branches missed.">                if (io1.openFile.fileChannel() == null) {</span>
<span class="fc bfc" id="L4115" title="All 2 branches covered.">                    long remaining = length == null ? -1 : length.getLongValue();</span>
<span class="fc bfc" id="L4116" title="All 2 branches covered.">                    long position = offset == null ? -1 : offset.getLongValue();</span>
<span class="pc bpc" id="L4117" title="1 of 2 branches missed.">                    if (io2.openFile.fileChannel() == null) {</span>
<span class="fc" id="L4118">                        ReadableByteChannel from = io1.openFile.readChannel();</span>
<span class="fc" id="L4119">                        WritableByteChannel to = io2.openFile.writeChannel();</span>

<span class="fc" id="L4121">                        size = transfer(context, from, to, remaining, position);</span>
<span class="fc" id="L4122">                    } else {</span>
<span class="nc" id="L4123">                        ReadableByteChannel from = io1.openFile.readChannel();</span>
<span class="nc" id="L4124">                        FileChannel to = io2.openFile.fileChannel();</span>

<span class="nc" id="L4126">                        size = transfer(context, from, to, remaining, position);</span>
                    }
<span class="fc" id="L4128">                } else {</span>
<span class="nc" id="L4129">                    FileChannel from = io1.openFile.fileChannel();</span>
<span class="nc" id="L4130">                    WritableByteChannel to = io2.openFile.writeChannel();</span>
<span class="nc bnc" id="L4131" title="All 2 branches missed.">                    long remaining = length == null ? from.size() : length.getLongValue();</span>
<span class="nc bnc" id="L4132" title="All 2 branches missed.">                    long position = offset == null ? from.position() : offset.getLongValue();</span>

<span class="nc" id="L4134">                    size = transfer(from, to, remaining, position);</span>
                }

<span class="fc" id="L4137">                return context.runtime.newFixnum(size);</span>
<span class="nc" id="L4138">            } catch (IOException ioe) {</span>
<span class="nc" id="L4139">                ioe.printStackTrace();</span>
<span class="nc" id="L4140">                throw runtime.newIOErrorFromException(ioe);</span>
            } finally {
<span class="pc bpc" id="L4142" title="2 of 4 branches missed.">                if (offset != null) {</span>
<span class="pc" id="L4143">                    fptr.seek(context, pos, PosixShim.SEEK_SET);</span>
                } else {
<span class="pc" id="L4145">                    fptr.seek(context, pos + size, PosixShim.SEEK_SET);</span>
                }
            }
        } finally {
<span class="pc bpc" id="L4149" title="3 of 4 branches missed.">            if (locked) fptr.unlock();</span>
        }
    }

    private static long transfer(ThreadContext context, ReadableByteChannel from, FileChannel to, long length, long position) throws IOException {
        // handle large files on 32-bit JVMs
<span class="nc" id="L4155">        long chunkSize = 128 * 1024 * 1024;</span>
<span class="nc" id="L4156">        long transferred = 0;</span>
        long bytes;
<span class="nc" id="L4158">        long startPosition = to.position();</span>

<span class="nc bnc" id="L4160" title="All 2 branches missed.">        if (position != -1) {</span>
<span class="nc bnc" id="L4161" title="All 2 branches missed.">            if (from instanceof NativeSelectableChannel) {</span>
<span class="nc" id="L4162">                int ret = context.runtime.getPosix().lseek(((NativeSelectableChannel)from).getFD(), position, PosixShim.SEEK_SET);</span>
<span class="nc bnc" id="L4163" title="All 2 branches missed.">                if (ret == -1) {</span>
<span class="nc" id="L4164">                    throw context.runtime.newErrnoFromErrno(Errno.valueOf(context.runtime.getPosix().errno()), from.toString());</span>
                }
            }
        }
<span class="nc bnc" id="L4168" title="All 2 branches missed.">        if (length &gt; 0) {</span>
<span class="nc bnc" id="L4169" title="All 2 branches missed.">            while ((bytes = to.transferFrom(from, startPosition+transferred, Math.min(chunkSize, length))) &gt; 0) {</span>
<span class="nc" id="L4170">                transferred += bytes;</span>
<span class="nc" id="L4171">                length -= bytes;</span>
            }
        } else {
<span class="nc bnc" id="L4174" title="All 2 branches missed.">            while ((bytes = to.transferFrom(from, startPosition+transferred, chunkSize)) &gt; 0) {</span>
<span class="nc" id="L4175">                transferred += bytes;</span>
            }
        }
        // transforFrom does not change position of target
<span class="nc" id="L4179">        to.position(startPosition + transferred);</span>

<span class="nc" id="L4181">        return transferred;</span>
    }

    private static long transfer(FileChannel from, WritableByteChannel to, long remaining, long position) throws IOException {
        // handle large files on 32-bit JVMs
<span class="nc" id="L4186">        long chunkSize = 128 * 1024 * 1024;</span>
<span class="nc" id="L4187">        long transferred = 0;</span>

<span class="nc bnc" id="L4189" title="All 2 branches missed.">        if (remaining &lt; 0) remaining = from.size();</span>
<span class="nc bnc" id="L4190" title="All 2 branches missed.">        while (remaining &gt; 0) {</span>
<span class="nc" id="L4191">            long count = Math.min(remaining, chunkSize);</span>
<span class="nc" id="L4192">            long n = from.transferTo(position, count, to);</span>
<span class="nc bnc" id="L4193" title="All 2 branches missed.">            if (n == 0) {</span>
<span class="nc" id="L4194">                break;</span>
            }
            
<span class="nc" id="L4197">            position += n;</span>
<span class="nc" id="L4198">            remaining -= n;</span>
<span class="nc" id="L4199">            transferred += n;</span>
<span class="nc" id="L4200">        }</span>

<span class="nc" id="L4202">        return transferred;</span>
    }

    private static long transfer(ThreadContext context, ReadableByteChannel from, WritableByteChannel to, long length, long position) throws IOException {
<span class="fc" id="L4206">        int chunkSize = 8 * 1024;</span>
<span class="fc" id="L4207">        ByteBuffer buffer = ByteBuffer.allocateDirect(chunkSize);</span>
<span class="fc" id="L4208">        long transferred = 0;</span>

<span class="fc bfc" id="L4210" title="All 2 branches covered.">        if (position != -1) {</span>
<span class="pc bpc" id="L4211" title="1 of 2 branches missed.">            if (from instanceof NativeSelectableChannel) {</span>
<span class="fc" id="L4212">                int ret = context.runtime.getPosix().lseek(((NativeSelectableChannel)from).getFD(), position, PosixShim.SEEK_SET);</span>
<span class="pc bpc" id="L4213" title="1 of 2 branches missed.">                if (ret == -1) {</span>
<span class="nc" id="L4214">                    throw context.runtime.newErrnoFromErrno(Errno.valueOf(context.runtime.getPosix().errno()), from.toString());</span>
                }
            }
        }

        while (true) {
<span class="fc" id="L4220">            context.pollThreadEvents();</span>

<span class="pc bpc" id="L4222" title="1 of 4 branches missed.">            if (length &gt; 0 &amp;&amp; length &lt; chunkSize) {</span>
                // last read should limit to remaining length
<span class="fc" id="L4224">                buffer.limit((int)length);</span>
            }
<span class="fc" id="L4226">            long n = from.read(buffer);</span>

<span class="fc bfc" id="L4228" title="All 2 branches covered.">            if (n == -1) break;</span>

<span class="fc" id="L4230">            buffer.flip();</span>
<span class="fc" id="L4231">            to.write(buffer);</span>
<span class="fc" id="L4232">            buffer.clear();</span>

<span class="fc" id="L4234">            transferred += n;</span>
<span class="fc bfc" id="L4235" title="All 2 branches covered.">            if (length &gt; 0) {</span>
<span class="fc" id="L4236">                length -= n;</span>
<span class="pc bpc" id="L4237" title="1 of 2 branches missed.">                if (length &lt;= 0) break;</span>
            }

<span class="pc bpc" id="L4240" title="1 of 2 branches missed.">            if (!from.isOpen()) break;</span>
<span class="fc" id="L4241">        }</span>

<span class="fc" id="L4243">        return transferred;</span>
    }

    @JRubyMethod(name = &quot;try_convert&quot;, meta = true)
    public static IRubyObject tryConvert(ThreadContext context, IRubyObject recv, IRubyObject arg) {
<span class="fc bfc" id="L4248" title="All 2 branches covered.">        return arg.respondsTo(&quot;to_io&quot;) ? convertToIO(context, arg) : context.runtime.getNil();</span>
    }

    private static ByteList getNilByteList(Ruby runtime) {
<span class="fc" id="L4252">        return ByteList.EMPTY_BYTELIST;</span>
    }
    
    /**
     * Add a thread to the list of blocking threads for this IO.
     * 
     * @param thread A thread blocking on this IO
     */
    public void addBlockingThread(RubyThread thread) {
<span class="nc" id="L4261">        OpenFile fptr = openFile;</span>
<span class="nc bnc" id="L4262" title="All 2 branches missed.">        if (openFile != null) openFile.addBlockingThread(thread);</span>
<span class="nc" id="L4263">    }</span>
    
    /**
     * Remove a thread from the list of blocking threads for this IO.
     * 
     * @param thread A thread blocking on this IO
     */
    public void removeBlockingThread(RubyThread thread) {
<span class="nc bnc" id="L4271" title="All 2 branches missed.">        if (openFile != null) openFile.removeBlockingThread(thread);</span>
<span class="nc" id="L4272">    }</span>
    
    /**
     * Fire an IOError in all threads blocking on this IO object
     */
    protected void interruptBlockingThreads() {
<span class="nc bnc" id="L4278" title="All 2 branches missed.">        if (openFile != null) openFile.interruptBlockingThreads();</span>
<span class="nc" id="L4279">    }</span>

    /**
     * Caching reference to allocated byte-lists, allowing for internal byte[] to be
     * reused, rather than reallocated.
     *
     * Predominately used on {@link RubyIO#getline(Ruby, ByteList)} and variants.
     *
     * @author realjenius
     */
<span class="fc" id="L4289">    private static class ByteListCache {</span>
<span class="fc" id="L4290">        private byte[] buffer = EMPTY_BYTE_ARRAY;</span>
        public void release(ByteList l) {
<span class="fc" id="L4292">            buffer = l.getUnsafeBytes();</span>
<span class="fc" id="L4293">        }</span>

        public ByteList allocate(int size) {
<span class="fc" id="L4296">            ByteList l = new ByteList(buffer, 0, size, false);</span>
<span class="fc" id="L4297">            return l;</span>
        }
    }

    /**
     * See http://ruby-doc.org/core-1.9.3/IO.html#method-c-new for the format of modes in options
     */
    protected IOOptions updateIOOptionsFromOptions(ThreadContext context, RubyHash options, IOOptions ioOptions) {
<span class="nc bnc" id="L4305" title="All 4 branches missed.">        if (options == null || options.isNil()) return ioOptions;</span>

<span class="nc" id="L4307">        Ruby runtime = context.runtime;</span>

<span class="nc bnc" id="L4309" title="All 2 branches missed.">        if (options.containsKey(runtime.newSymbol(&quot;mode&quot;))) {</span>
<span class="nc" id="L4310">            ioOptions = parseIOOptions(options.fastARef(runtime.newSymbol(&quot;mode&quot;)));</span>
        }

        // This duplicates the non-error behavior of MRI 1.9: the
        // :binmode option is ORed in with other options. It does
        // not obliterate what came before.

<span class="nc bnc" id="L4317" title="All 2 branches missed.">        if (options.containsKey(runtime.newSymbol(&quot;binmode&quot;)) &amp;&amp;</span>
<span class="nc bnc" id="L4318" title="All 2 branches missed.">                options.fastARef(runtime.newSymbol(&quot;binmode&quot;)).isTrue()) {</span>

<span class="nc" id="L4320">            ioOptions = newIOOptions(runtime, ioOptions, ModeFlags.BINARY);</span>
        }

        // This duplicates the non-error behavior of MRI 1.9: the
        // :binmode option is ORed in with other options. It does
        // not obliterate what came before.

<span class="nc bnc" id="L4327" title="All 2 branches missed.">        if (options.containsKey(runtime.newSymbol(&quot;binmode&quot;)) &amp;&amp;</span>
<span class="nc bnc" id="L4328" title="All 2 branches missed.">                options.fastARef(runtime.newSymbol(&quot;binmode&quot;)).isTrue()) {</span>

<span class="nc" id="L4330">            ioOptions = newIOOptions(runtime, ioOptions, ModeFlags.BINARY);</span>
        }

<span class="nc bnc" id="L4333" title="All 2 branches missed.">        if (options.containsKey(runtime.newSymbol(&quot;textmode&quot;)) &amp;&amp;</span>
<span class="nc bnc" id="L4334" title="All 2 branches missed.">                options.fastARef(runtime.newSymbol(&quot;textmode&quot;)).isTrue()) {</span>

<span class="nc" id="L4336">            ioOptions = newIOOptions(runtime, ioOptions, ModeFlags.TEXT);</span>
        }
        
        // TODO: Waaaay different than MRI.  They uniformly have all opening logic
        // do a scan of args before anything opens.  We do this logic in a less
        // consistent way.  We should consider re-impling all IO/File construction
        // logic.
<span class="nc bnc" id="L4343" title="All 2 branches missed.">        if (options.containsKey(runtime.newSymbol(&quot;open_args&quot;))) {</span>
<span class="nc" id="L4344">            IRubyObject args = options.fastARef(runtime.newSymbol(&quot;open_args&quot;));</span>
            
<span class="nc" id="L4346">            RubyArray openArgs = args.convertToArray();</span>
            
<span class="nc bnc" id="L4348" title="All 2 branches missed.">            for (int i = 0; i &lt; openArgs.size(); i++) {</span>
<span class="nc" id="L4349">                IRubyObject arg = openArgs.eltInternal(i);</span>
                
<span class="nc bnc" id="L4351" title="All 2 branches missed.">                if (arg instanceof RubyString) { // Overrides all?</span>
<span class="nc" id="L4352">                    ioOptions = newIOOptions(runtime, arg.asJavaString());</span>
<span class="nc bnc" id="L4353" title="All 2 branches missed.">                } else if (arg instanceof RubyFixnum) {</span>
<span class="nc" id="L4354">                    ioOptions = newIOOptions(runtime, ((RubyFixnum) arg).getLongValue());</span>
<span class="nc bnc" id="L4355" title="All 2 branches missed.">                } else if (arg instanceof RubyHash) {</span>
<span class="nc" id="L4356">                    ioOptions = updateIOOptionsFromOptions(context, (RubyHash) arg, ioOptions);</span>
                }
            }
        }

<span class="nc" id="L4361">        EncodingUtils.ioExtractEncodingOption(context, this, options, null);</span>

<span class="nc" id="L4363">        return ioOptions;</span>
    }

<span class="fc" id="L4366">    private static final Set&lt;String&gt; UNSUPPORTED_SPAWN_OPTIONS = new HashSet&lt;String&gt;(Arrays.asList(new String[] {</span>
            &quot;unsetenv_others&quot;,
            &quot;prgroup&quot;,
            &quot;new_pgroup&quot;,
            &quot;rlimit_resourcename&quot;,
            &quot;chdir&quot;,
            &quot;umask&quot;,
            &quot;in&quot;,
            &quot;out&quot;,
            &quot;err&quot;,
            &quot;close_others&quot;
    }));

<span class="fc" id="L4379">    private static final Set&lt;String&gt; ALL_SPAWN_OPTIONS = new HashSet&lt;String&gt;(Arrays.asList(new String[] {</span>
            &quot;unsetenv_others&quot;,
            &quot;prgroup&quot;,
            &quot;new_pgroup&quot;,
            &quot;rlimit_resourcename&quot;,
            &quot;chdir&quot;,
            &quot;umask&quot;,
            &quot;in&quot;,
            &quot;out&quot;,
            &quot;err&quot;,
            &quot;close_others&quot;
    }));

    /**
     * Warn when using exec with unsupported options.
     *
     * @param options
     */
    public static void checkExecOptions(IRubyObject options) {
<span class="fc" id="L4398">        checkUnsupportedOptions(options, UNSUPPORTED_SPAWN_OPTIONS, &quot;unsupported exec option&quot;);</span>
<span class="fc" id="L4399">        checkValidOptions(options, ALL_SPAWN_OPTIONS);</span>
<span class="fc" id="L4400">    }</span>

    /**
     * Warn when using spawn with unsupported options.
     *
     * @param options
     */
    public static void checkSpawnOptions(IRubyObject options) {
<span class="nc" id="L4408">        checkUnsupportedOptions(options, UNSUPPORTED_SPAWN_OPTIONS, &quot;unsupported spawn option&quot;);</span>
<span class="nc" id="L4409">        checkValidOptions(options, ALL_SPAWN_OPTIONS);</span>
<span class="nc" id="L4410">    }</span>

    /**
     * Warn when using spawn with unsupported options.
     *
     * @param options
     */
    public static void checkPopenOptions(IRubyObject options) {
<span class="nc" id="L4418">        checkUnsupportedOptions(options, UNSUPPORTED_SPAWN_OPTIONS, &quot;unsupported popen option&quot;);</span>
<span class="nc" id="L4419">    }</span>

    /**
     * Warn when using unsupported options.
     *
     * @param options
     */
    private static void checkUnsupportedOptions(IRubyObject options, Set&lt;String&gt; unsupported, String error) {
<span class="pc bpc" id="L4427" title="4 of 6 branches missed.">        if (options == null || options.isNil() || !(options instanceof RubyHash)) return;</span>

<span class="nc" id="L4429">        RubyHash optsHash = (RubyHash)options;</span>
<span class="nc" id="L4430">        Ruby runtime = optsHash.getRuntime();</span>

<span class="nc bnc" id="L4432" title="All 2 branches missed.">        for (String key : unsupported) {</span>
<span class="nc bnc" id="L4433" title="All 2 branches missed.">            if (optsHash.containsKey(runtime.newSymbol(key))) {</span>
<span class="nc" id="L4434">                runtime.getWarnings().warn(error + &quot;: &quot; + key);</span>
            }
<span class="nc" id="L4436">        }</span>
<span class="nc" id="L4437">    }</span>

    /**
     * Error when using unknown option.
     *
     * @param options
     */
    private static void checkValidOptions(IRubyObject options, Set&lt;String&gt; valid) {
<span class="pc bpc" id="L4445" title="4 of 6 branches missed.">        if (options == null || options.isNil() || !(options instanceof RubyHash)) return;</span>

<span class="nc" id="L4447">        RubyHash optsHash = (RubyHash)options;</span>
<span class="nc" id="L4448">        Ruby runtime = optsHash.getRuntime();</span>

<span class="nc bnc" id="L4450" title="All 2 branches missed.">        for (Object opt : optsHash.keySet()) {</span>
<span class="nc bnc" id="L4451" title="All 8 branches missed.">            if (opt instanceof RubySymbol || opt instanceof RubyFixnum || opt instanceof RubyArray || valid.contains(opt.toString())) {</span>
<span class="nc" id="L4452">                continue;</span>
            }

<span class="nc" id="L4455">            throw runtime.newTypeError(&quot;wrong exec option: &quot; + opt);</span>
        }
<span class="nc" id="L4457">    }</span>

    // MRI: check_exec_env, w/ check_exec_env_i body in-line
    public static RubyArray checkExecEnv(ThreadContext context, RubyHash hash) {
<span class="fc" id="L4461">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L4462">        RubyArray env = runtime.newArray();</span>
<span class="fc bfc" id="L4463" title="All 2 branches covered.">        for (Map.Entry&lt;IRubyObject, IRubyObject&gt; entry : (Set&lt;Map.Entry&lt;IRubyObject, IRubyObject&gt;&gt;)hash.directEntrySet()) {</span>
<span class="fc" id="L4464">            IRubyObject key = entry.getKey();</span>
<span class="fc" id="L4465">            IRubyObject val = entry.getValue();</span>
            ByteList k;

<span class="fc" id="L4468">            k = StringSupport.checkEmbeddedNulls(runtime, key).getByteList();</span>
<span class="pc bpc" id="L4469" title="1 of 2 branches missed.">            if (k.indexOf('=') != -1)</span>
<span class="nc" id="L4470">                throw runtime.newArgumentError(&quot;environment name contains a equal : &quot; + k);</span>

<span class="pc bpc" id="L4472" title="1 of 2 branches missed.">            if (!val.isNil())</span>
<span class="fc" id="L4473">                StringSupport.checkEmbeddedNulls(runtime, val);</span>

<span class="pc bpc" id="L4475" title="1 of 2 branches missed.">            if (Platform.IS_WINDOWS) {</span>
<span class="nc" id="L4476">                key = ((RubyString)key).export(context);</span>
            }
<span class="pc bpc" id="L4478" title="1 of 2 branches missed.">            if (!val.isNil()) val = ((RubyString)val).export(context);</span>

<span class="fc" id="L4480">            env.push(runtime.newArray(key, val));</span>
<span class="fc" id="L4481">        }</span>

<span class="fc" id="L4483">        return env;</span>
    }
    
    /**
     * Try for around 1s to destroy the child process. This is to work around
     * issues on some JVMs where if you try to destroy the process too quickly
     * it may not be ready and may ignore the destroy. A subsequent waitFor
     * will then hang. This version tries to destroy and call exitValue
     * repeatedly for up to 1000 calls with 1ms delay between iterations, with
     * the intent that the target process ought to be &quot;ready to die&quot; fairly
     * quickly and we don't get stuck in a blocking waitFor call.
     *
     * @param process The process to obliterate
     */
    public static void obliterateProcess(Process process) {
<span class="nc" id="L4498">        int i = 0;</span>
<span class="nc" id="L4499">        Object waitLock = new Object();</span>
        while (true) {
            // only try 1000 times with a 1ms sleep between, so we don't hang
            // forever on processes that ignore SIGTERM. After that, not much
            // we can do...
<span class="nc bnc" id="L4504" title="All 2 branches missed.">            if (i &gt;= 1000) {</span>
<span class="nc" id="L4505">                return;</span>
            }

            // attempt to destroy (SIGTERM on UNIX, TerminateProcess on Windows)
<span class="nc" id="L4509">            process.destroy();</span>
            
            try {
                // get the exit value; succeeds if it has terminated, throws
                // IllegalThreadStateException if not.
<span class="nc" id="L4514">                process.exitValue();</span>
<span class="nc" id="L4515">            } catch (IllegalThreadStateException itse) {</span>
                // increment count and try again after a 1ms sleep
<span class="nc" id="L4517">                i += 1;</span>
<span class="nc" id="L4518">                synchronized (waitLock) {</span>
<span class="nc" id="L4519">                    try {waitLock.wait(1);} catch (InterruptedException ie) {}</span>
<span class="nc" id="L4520">                }</span>
<span class="nc" id="L4521">                continue;</span>
<span class="nc" id="L4522">            }</span>
            // success!
            break;
        }
<span class="nc" id="L4526">    }</span>

    public static ModeFlags newModeFlags(Ruby runtime, long mode) {
<span class="nc" id="L4529">        return newModeFlags(runtime, (int) mode);</span>
    }

    public static ModeFlags newModeFlags(Ruby runtime, int mode) {
        try {
<span class="fc" id="L4534">            return new ModeFlags(mode);</span>
<span class="nc" id="L4535">        } catch (InvalidValueException ive) {</span>
<span class="nc" id="L4536">            throw runtime.newErrnoEINVALError();</span>
        }
    }

    public static ModeFlags newModeFlags(Ruby runtime, String mode) {
        try {
<span class="nc" id="L4542">            return new ModeFlags(mode);</span>
<span class="nc" id="L4543">        } catch (InvalidValueException ive) {</span>
            // This is used by File and StringIO, which seem to want an ArgumentError instead of EINVAL
<span class="nc" id="L4545">            throw runtime.newArgumentError(&quot;illegal access mode &quot; + mode);       </span>
        }
    }

    public static IOOptions newIOOptions(Ruby runtime, ModeFlags modeFlags) {
<span class="nc" id="L4550">        return new IOOptions(modeFlags);</span>
    }

    public static IOOptions newIOOptions(Ruby runtime, long mode) {
<span class="nc" id="L4554">        return newIOOptions(runtime, (int) mode);</span>
    }

    public static IOOptions newIOOptions(Ruby runtime, int mode) {
        try {
<span class="nc" id="L4559">            ModeFlags modeFlags = new ModeFlags(mode);</span>
<span class="nc" id="L4560">            return new IOOptions(modeFlags);</span>
<span class="nc" id="L4561">        } catch (InvalidValueException ive) {</span>
<span class="nc" id="L4562">            throw runtime.newErrnoEINVALError();</span>
        }
    }

    public static IOOptions newIOOptions(Ruby runtime, String mode) {
        try {
<span class="nc" id="L4568">            return new IOOptions(runtime, mode);</span>
<span class="nc" id="L4569">        } catch (InvalidValueException ive) {</span>
            // This is used by File and StringIO, which seem to want an ArgumentError instead of EINVAL
<span class="nc" id="L4571">            throw runtime.newArgumentError(&quot;illegal access mode &quot; + mode);</span>
        }
    }

    public static IOOptions newIOOptions(Ruby runtime, IOOptions oldFlags, int orOflags) {
        try {
<span class="nc" id="L4577">            return new IOOptions(new ModeFlags(oldFlags.getModeFlags().getFlags() | orOflags));</span>
<span class="nc" id="L4578">        } catch (InvalidValueException ive) {</span>
<span class="nc" id="L4579">            throw runtime.newErrnoEINVALError();</span>
        }
    }

    @Deprecated
    public IRubyObject readline(ThreadContext context, IRubyObject[] args) {
<span class="nc bnc" id="L4585" title="All 2 branches missed.">        return args.length == 0 ? readline(context) : readline(context, args[0]);</span>
    }

    @Override
    public void setEnc2(Encoding enc2) {
<span class="nc" id="L4590">        openFile.encs.enc2 = enc2;</span>
<span class="nc" id="L4591">    }</span>
    
    @Override
    public void setEnc(Encoding enc) {
<span class="nc" id="L4595">        openFile.encs.enc = enc;</span>
<span class="nc" id="L4596">    }</span>
    
    @Override
    public void setEcflags(int ecflags) {
<span class="nc" id="L4600">        openFile.encs.ecflags = ecflags;</span>
<span class="nc" id="L4601">    }</span>
    
    @Override
    public int getEcflags() {
<span class="nc" id="L4605">        return openFile.encs.ecflags;</span>
    }
    
    @Override
    public void setEcopts(IRubyObject ecopts) {
<span class="nc" id="L4610">        openFile.encs.ecopts = ecopts;</span>
<span class="nc" id="L4611">    }</span>
    
    @Override
    public IRubyObject getEcopts() {
<span class="nc" id="L4615">        return openFile.encs.ecopts;</span>
    }
    
    @Override
    public void setBOM(boolean bom) {
<span class="nc" id="L4620">        openFile.setBOM(bom);</span>
<span class="nc" id="L4621">    }</span>
    
    @Override
    public boolean getBOM() {
<span class="nc" id="L4625">        return openFile.isBOM();</span>
    }


    // MRI: rb_io_ascii8bit_binmode
    protected RubyIO setAscii8bitBinmode() {
        OpenFile fptr;

<span class="fc" id="L4633">        fptr = getOpenFileChecked();</span>
<span class="fc" id="L4634">        fptr.ascii8bitBinmode(getRuntime());</span>

<span class="fc" id="L4636">        return this;</span>
    }
    
    public OpenFile MakeOpenFile() {
<span class="fc" id="L4640">        Ruby runtime = getRuntime();</span>
<span class="fc bfc" id="L4641" title="All 2 branches covered.">        if (openFile != null) {</span>
<span class="fc" id="L4642">            rbIoClose(runtime);</span>
<span class="fc" id="L4643">            rb_io_fptr_finalize(runtime, openFile);</span>
<span class="fc" id="L4644">            openFile = null;</span>
        }
<span class="fc" id="L4646">        openFile = new OpenFile(runtime.getNil());</span>
<span class="fc" id="L4647">        runtime.addInternalFinalizer(openFile);</span>
<span class="fc" id="L4648">        return openFile;</span>
    }

    private static int rb_io_fptr_finalize(Ruby runtime, OpenFile fptr) {
<span class="pc bpc" id="L4652" title="1 of 2 branches missed.">        if (fptr == null) return 0;</span>
<span class="fc" id="L4653">        fptr.setPath(null);;</span>
<span class="pc bpc" id="L4654" title="1 of 2 branches missed.">        if (fptr.fd() != null)</span>
<span class="nc" id="L4655">            fptr.cleanup(runtime, true);</span>
<span class="fc" id="L4656">        fptr.write_lock = null;</span>
<span class="pc bpc" id="L4657" title="1 of 2 branches missed.">        if (fptr.rbuf.ptr != null) {</span>
<span class="nc" id="L4658">            fptr.rbuf.ptr = null;</span>
        }
<span class="pc bpc" id="L4660" title="1 of 2 branches missed.">        if (fptr.wbuf.ptr != null) {</span>
<span class="nc" id="L4661">            fptr.wbuf.ptr = null;</span>
        }
<span class="fc" id="L4663">        fptr.clearCodeConversion();</span>
<span class="fc" id="L4664">        return 1;</span>
    }

<span class="fc" id="L4667">    private static final byte[] NEWLINE_BYTES = {(byte)'\n'};</span>

    @Deprecated
    public IRubyObject getline(Ruby runtime, ByteList separator) {
<span class="nc" id="L4671">        return getline(runtime.getCurrentContext(), runtime.newString(separator), -1, null);</span>
    }
    
    @Deprecated
    public IRubyObject getline(Ruby runtime, ByteList separator, long limit) {
<span class="nc" id="L4676">        return getline(runtime.getCurrentContext(), runtime.newString(separator), limit, null);</span>
    }

    @Deprecated
    private IRubyObject getline(ThreadContext context, IRubyObject separator, ByteListCache cache) {
<span class="nc" id="L4681">        return getline(context, separator, -1, cache);</span>
    }

    @Deprecated
    public IRubyObject getline(ThreadContext context, ByteList separator) {
<span class="nc" id="L4686">        return getline(context, RubyString.newString(context.runtime, separator), -1, null);</span>
    }

    @Deprecated
    public IRubyObject getline(ThreadContext context, ByteList separator, long limit) {
<span class="nc" id="L4691">        return getline(context, RubyString.newString(context.runtime, separator), limit, null);</span>
    }

    @Deprecated
    public IRubyObject lines19(final ThreadContext context, Block block) {
<span class="nc" id="L4696">        return lines(context, block);</span>
    }

    @Deprecated
    public IRubyObject each_char19(final ThreadContext context, final Block block) {
<span class="nc" id="L4701">        return each_char(context, block);</span>
    }

    @Deprecated
    public IRubyObject chars19(final ThreadContext context, final Block block) {
<span class="nc" id="L4706">        return chars(context, block);</span>
    }

    @Deprecated
    public RubyArray readlines19(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L4711">        return readlines(context, args);</span>
    }

    @Deprecated
    public RubyIO(Ruby runtime, STDIO stdio) {
<span class="nc" id="L4716">        super(runtime, runtime.getIO());</span>

<span class="nc" id="L4718">        RubyIO tmp = null;</span>
<span class="nc bnc" id="L4719" title="All 4 branches missed.">        switch (stdio) {</span>
            case IN:
<span class="nc" id="L4721">                tmp = prepStdio(runtime, runtime.getIn(), Channels.newChannel(runtime.getIn()), OpenFile.READABLE, runtime.getIO(), &quot;&lt;STDIN&gt;&quot;);</span>
<span class="nc" id="L4722">                break;</span>
            case OUT:
<span class="nc" id="L4724">                tmp = prepStdio(runtime, runtime.getOut(), Channels.newChannel(runtime.getOut()), OpenFile.WRITABLE, runtime.getIO(), &quot;&lt;STDOUT&gt;&quot;);</span>
<span class="nc" id="L4725">                break;</span>
            case ERR:
<span class="nc" id="L4727">                tmp = prepStdio(runtime, runtime.getIn(), Channels.newChannel(runtime.getErr()), OpenFile.WRITABLE | OpenFile.SYNC, runtime.getIO(), &quot;&lt;STDERR&gt;&quot;);</span>
                break;
        }

<span class="nc" id="L4731">        this.openFile = tmp.openFile;</span>
<span class="nc" id="L4732">        tmp.openFile = null;</span>
<span class="nc" id="L4733">    }</span>

    @Deprecated
    public RubyIO(Ruby runtime, RubyClass cls, ShellLauncher.POpenProcess process, RubyHash options, IOOptions ioOptions) {
<span class="nc" id="L4737">        super(runtime, cls);</span>

<span class="nc" id="L4739">        ioOptions = updateIOOptionsFromOptions(runtime.getCurrentContext(), options, ioOptions);</span>

<span class="nc" id="L4741">        openFile = MakeOpenFile();</span>

<span class="nc" id="L4743">        setupPopen(ioOptions.getModeFlags(), process);</span>
<span class="nc" id="L4744">    }</span>

    @Deprecated
    public static ModeFlags getIOModes(Ruby runtime, String modesString) {
<span class="nc" id="L4748">        return newModeFlags(runtime, modesString);</span>
    }

    @Deprecated
    public static int getIOModesIntFromString(Ruby runtime, String modesString) {
        try {
<span class="nc" id="L4754">            return ModeFlags.getOFlagsFromString(modesString);</span>
<span class="nc" id="L4755">        } catch (InvalidValueException ive) {</span>
<span class="nc" id="L4756">            throw runtime.newArgumentError(&quot;illegal access mode&quot;);</span>
        }
    }

    @Deprecated
    public static IRubyObject writeStatic(ThreadContext context, IRubyObject recv, IRubyObject[] argv, Block unusedBlock) {
<span class="nc" id="L4762">        return write(context, recv, argv);</span>
    }

    @Deprecated
    public static IRubyObject popen3(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="nc" id="L4767">        return popen3_19(context, recv, args, block);</span>
    }

    @Deprecated
    public static IRubyObject popen3_19(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="nc" id="L4772">        final Ruby runtime = context.runtime;</span>

        // TODO: handle opts
<span class="nc bnc" id="L4775" title="All 4 branches missed.">        if (args.length &gt; 0 &amp;&amp; args[args.length - 1] instanceof RubyHash) {</span>
<span class="nc" id="L4776">            args = Arrays.copyOf(args, args.length - 1);</span>
        }

<span class="nc" id="L4779">        final POpenTuple tuple = popenSpecial(context, args);</span>
<span class="nc" id="L4780">        final long pid = ShellLauncher.getPidFromProcess(tuple.process);</span>

        // array trick to be able to reference enclosing RubyThread
<span class="nc" id="L4783">        final RubyThread[] waitThread = new RubyThread[1];</span>
<span class="nc" id="L4784">        waitThread[0] = new RubyThread(</span>
                runtime,
<span class="nc" id="L4786">                (RubyClass) runtime.getClassFromPath(&quot;Process::WaitThread&quot;),</span>
<span class="nc" id="L4787">                new ThreadedRunnable() {</span>

                    volatile Thread javaThread;

                    @Override
                    public Thread getJavaThread() {
<span class="nc" id="L4793">                        return javaThread;</span>
                    }

                    @Override
                    public void run() {
<span class="nc" id="L4798">                        javaThread = Thread.currentThread();</span>
                        RubyThread rubyThread;
                        // spin a bit until this happens; should almost never spin
<span class="nc bnc" id="L4801" title="All 2 branches missed.">                        while ((rubyThread = waitThread[0]) == null) {</span>
<span class="nc" id="L4802">                            Thread.yield();</span>
                        }

<span class="nc" id="L4805">                        ThreadContext context = runtime.getThreadService().registerNewThread(rubyThread);</span>

<span class="nc" id="L4807">                        rubyThread.op_aset(</span>
<span class="nc" id="L4808">                                runtime.newSymbol(&quot;pid&quot;),</span>
<span class="nc" id="L4809">                                runtime.newFixnum(pid));</span>

                        try {
<span class="nc" id="L4812">                            int exitValue = tuple.process.waitFor();</span>

                            // RubyStatus uses real native status now, so we unshift Java's shifted exit status
<span class="nc" id="L4815">                            RubyProcess.RubyStatus status = RubyProcess.RubyStatus.newProcessStatus(</span>
                                    runtime,
                                    exitValue &lt;&lt; 8,
                                    pid);

<span class="nc" id="L4820">                            rubyThread.cleanTerminate(status);</span>
<span class="nc" id="L4821">                        } catch (Throwable t) {</span>
<span class="nc" id="L4822">                            rubyThread.exceptionRaised(t);</span>
                        } finally {
<span class="nc" id="L4824">                            rubyThread.dispose();</span>
<span class="nc" id="L4825">                        }</span>
<span class="nc" id="L4826">                    }</span>

                });

<span class="nc" id="L4830">        RubyArray yieldArgs = RubyArray.newArrayLight(runtime,</span>
                tuple.output,
                tuple.input,
                tuple.error,
                waitThread[0]);

<span class="nc bnc" id="L4836" title="All 2 branches missed.">        if (block.isGiven()) {</span>
            try {
<span class="nc" id="L4838">                return block.yield(context, yieldArgs);</span>
            } finally {
<span class="nc" id="L4840">                cleanupPOpen(tuple);</span>

<span class="nc" id="L4842">                IRubyObject status = waitThread[0].join(IRubyObject.NULL_ARRAY);</span>
<span class="nc" id="L4843">                context.setLastExitStatus(status);</span>
<span class="nc" id="L4844">            }</span>
        }

<span class="nc" id="L4847">        return yieldArgs;</span>
    }

    @Deprecated
    public static IRubyObject popen4(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="nc" id="L4852">        Ruby runtime = context.runtime;</span>

        try {
<span class="nc" id="L4855">            POpenTuple tuple = popenSpecial(context, args);</span>

<span class="nc" id="L4857">            RubyArray yieldArgs = RubyArray.newArrayLight(runtime,</span>
<span class="nc" id="L4858">                    runtime.newFixnum(ShellLauncher.getPidFromProcess(tuple.process)),</span>
                    tuple.output,
                    tuple.input,
                    tuple.error);

<span class="nc bnc" id="L4863" title="All 2 branches missed.">            if (block.isGiven()) {</span>
                try {
<span class="nc" id="L4865">                    return block.yield(context, yieldArgs);</span>
                } finally {
<span class="nc" id="L4867">                    cleanupPOpen(tuple);</span>
                    // RubyStatus uses real native status now, so we unshift Java's shifted exit status
<span class="nc" id="L4869">                    context.setLastExitStatus(RubyProcess.RubyStatus.newProcessStatus(runtime, tuple.process.waitFor() &lt;&lt; 8, ShellLauncher.getPidFromProcess(tuple.process)));</span>
                }
            }
<span class="nc" id="L4872">            return yieldArgs;</span>
<span class="nc" id="L4873">        } catch (InterruptedException e) {</span>
<span class="nc" id="L4874">            throw runtime.newThreadError(&quot;unexpected interrupt&quot;);</span>
        }
    }

    @Deprecated
    private static void cleanupPOpen(POpenTuple tuple) {
<span class="nc bnc" id="L4880" title="All 2 branches missed.">        if (tuple.input.openFile.isOpen()) {</span>
<span class="nc" id="L4881">            tuple.input.close();</span>
        }
<span class="nc bnc" id="L4883" title="All 2 branches missed.">        if (tuple.output.openFile.isOpen()) {</span>
<span class="nc" id="L4884">            tuple.output.close();</span>
        }
<span class="nc bnc" id="L4886" title="All 2 branches missed.">        if (tuple.error.openFile.isOpen()) {</span>
<span class="nc" id="L4887">            tuple.error.close();</span>
        }
<span class="nc" id="L4889">    }</span>

    @Deprecated
    private static class POpenTuple {
<span class="nc" id="L4893">        public POpenTuple(RubyIO i, RubyIO o, RubyIO e, Process p) {</span>
<span class="nc" id="L4894">            input = i; output = o; error = e; process = p;</span>
<span class="nc" id="L4895">        }</span>
        public final RubyIO input;
        public final RubyIO output;
        public final RubyIO error;
        public final Process process;
    }

    @Deprecated
    public static POpenTuple popenSpecial(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L4904">        Ruby runtime = context.runtime;</span>

        try {
<span class="nc" id="L4907">            ShellLauncher.POpenProcess process = ShellLauncher.popen3(runtime, args, false);</span>
<span class="nc bnc" id="L4908" title="All 2 branches missed.">            RubyIO input = process.getInput() != null ?</span>
<span class="nc" id="L4909">                    new RubyIO(runtime, process.getInput()) :</span>
<span class="nc" id="L4910">                    new RubyIO(runtime, process.getInputStream());</span>
<span class="nc bnc" id="L4911" title="All 2 branches missed.">            RubyIO output = process.getOutput() != null ?</span>
<span class="nc" id="L4912">                    new RubyIO(runtime, process.getOutput()) :</span>
<span class="nc" id="L4913">                    new RubyIO(runtime, process.getOutputStream());</span>
<span class="nc bnc" id="L4914" title="All 2 branches missed.">            RubyIO error = process.getError() != null ?</span>
<span class="nc" id="L4915">                    new RubyIO(runtime, process.getError()) :</span>
<span class="nc" id="L4916">                    new RubyIO(runtime, process.getErrorStream());</span>

            // ensure the OpenFile knows it's a process; see OpenFile#finalize
<span class="nc" id="L4919">            input.getOpenFile().setProcess(process);</span>
<span class="nc" id="L4920">            output.getOpenFile().setProcess(process);</span>
<span class="nc" id="L4921">            error.getOpenFile().setProcess(process);</span>

            // set all streams as popenSpecial streams, so we don't shut down process prematurely
<span class="nc" id="L4924">            input.popenSpecial = true;</span>
<span class="nc" id="L4925">            output.popenSpecial = true;</span>
<span class="nc" id="L4926">            error.popenSpecial = true;</span>

            // process streams are not seekable
//            input.getOpenFile().getMainStreamSafe().getDescriptor().
//              setCanBeSeekable(false);
//            output.getOpenFile().getMainStreamSafe().getDescriptor().
//              setCanBeSeekable(false);
//            error.getOpenFile().getMainStreamSafe().getDescriptor().
//              setCanBeSeekable(false);

<span class="nc" id="L4936">            return new POpenTuple(input, output, error, process);</span>
//        } catch (BadDescriptorException e) {
//            throw runtime.newErrnoEBADFError();
<span class="nc" id="L4939">        } catch (IOException e) {</span>
<span class="nc" id="L4940">            throw runtime.newIOErrorFromException(e);</span>
        }
    }

    @Deprecated
    public IRubyObject doWriteNonblock(ThreadContext context, IRubyObject[] argv, boolean useException) {
<span class="nc" id="L4946">        return write_nonblock(context, argv);</span>
    }

    @Deprecated
    public static IRubyObject select_static(ThreadContext context, Ruby runtime, IRubyObject[] args) {
<span class="nc" id="L4951">        return select(context, runtime.getIO(), args);</span>
    }
    
    protected OpenFile openFile;

    /**
     * If the stream is being used for popen, we don't want to destroy the process
     * when we close the stream.
     */
    protected boolean popenSpecial;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>