<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RubyString.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby</a> &gt; <span class="el_source">RubyString.java</span></div><h1>RubyString.java</h1><pre class="source lang-java linenums">/*
 **** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2001 Alan Moore &lt;alan_moore@gmx.net&gt;
 * Copyright (C) 2001-2002 Benoit Cerrina &lt;b.cerrina@wanadoo.fr&gt;
 * Copyright (C) 2001-2004 Jan Arne Petersen &lt;jpetersen@uni-bonn.de&gt;
 * Copyright (C) 2002-2004 Anders Bengtsson &lt;ndrsbngtssn@yahoo.se&gt;
 * Copyright (C) 2002-2006 Thomas E Enebo &lt;enebo@acm.org&gt;
 * Copyright (C) 2004 Stefan Matthias Aust &lt;sma@3plus4.de&gt;
 * Copyright (C) 2004 David Corbin &lt;dcorbin@users.sourceforge.net&gt;
 * Copyright (C) 2005 Tim Azzopardi &lt;tim@tigerfive.com&gt;
 * Copyright (C) 2006 Miguel Covarrubias &lt;mlcovarrubias@gmail.com&gt;
 * Copyright (C) 2006 Ola Bini &lt;ola@ologix.com&gt;
 * Copyright (C) 2007 Nick Sieger &lt;nicksieger@gmail.com&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby;

import org.jcodings.Encoding;
import org.jcodings.EncodingDB;
import org.jcodings.ascii.AsciiTables;
import org.jcodings.exception.EncodingException;
import org.jcodings.specific.ASCIIEncoding;
import org.jcodings.specific.USASCIIEncoding;
import org.jcodings.specific.UTF16BEEncoding;
import org.jcodings.specific.UTF16LEEncoding;
import org.jcodings.specific.UTF32BEEncoding;
import org.jcodings.specific.UTF32LEEncoding;
import org.jcodings.specific.UTF8Encoding;
import org.jcodings.util.CaseInsensitiveBytesHash;
import org.jcodings.util.IntHash;
import org.joni.Matcher;
import org.joni.Option;
import org.joni.Regex;
import org.joni.Region;
import org.jruby.anno.JRubyClass;
import org.jruby.anno.JRubyMethod;
import org.jruby.platform.Platform;
import org.jruby.runtime.Block;
import org.jruby.runtime.ClassIndex;
import org.jruby.runtime.Helpers;
import org.jruby.runtime.ObjectAllocator;
import org.jruby.runtime.ThreadContext;
import org.jruby.runtime.Visibility;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.runtime.encoding.EncodingCapable;
import org.jruby.runtime.encoding.MarshalEncoding;
import org.jruby.runtime.marshal.UnmarshalStream;
import org.jruby.util.*;
import org.jruby.util.io.EncodingUtils;

import java.nio.charset.Charset;
import java.util.Locale;

import static org.jruby.RubyComparable.invcmp;
import static org.jruby.RubyEnumerator.enumeratorize;
import static org.jruby.RubyEnumerator.enumeratorizeWithSize;
import static org.jruby.anno.FrameField.BACKREF;
import static org.jruby.runtime.Helpers.invokedynamic;
import static org.jruby.runtime.Visibility.PRIVATE;
import static org.jruby.runtime.invokedynamic.MethodNames.OP_EQUAL;
import static org.jruby.util.StringSupport.CR_7BIT;
import static org.jruby.util.StringSupport.CR_BROKEN;
import static org.jruby.util.StringSupport.CR_MASK;
import static org.jruby.util.StringSupport.CR_UNKNOWN;
import static org.jruby.util.StringSupport.CR_VALID;
import static org.jruby.util.StringSupport.MBCLEN_CHARFOUND_LEN;
import static org.jruby.util.StringSupport.MBCLEN_CHARFOUND_P;
import static org.jruby.util.StringSupport.MBCLEN_INVALID_P;
import static org.jruby.util.StringSupport.MBCLEN_NEEDMORE_P;
import static org.jruby.util.StringSupport.codeLength;
import static org.jruby.util.StringSupport.codePoint;
import static org.jruby.util.StringSupport.codeRangeScan;
import static org.jruby.util.StringSupport.searchNonAscii;
import static org.jruby.util.StringSupport.strLengthWithCodeRange;
import static org.jruby.util.StringSupport.toLower;
import static org.jruby.util.StringSupport.toUpper;
import static org.jruby.util.StringSupport.unpackArg;
import static org.jruby.util.StringSupport.unpackResult;
import static org.jruby.RubyEnumerator.SizeFn;

/**
 * Implementation of Ruby String class
 *
 * Concurrency: no synchronization is required among readers, but
 * all users must synchronize externally with writers.
 *
 */
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">@JRubyClass(name=&quot;String&quot;, include={&quot;Enumerable&quot;, &quot;Comparable&quot;})</span>
public class RubyString extends RubyObject implements EncodingCapable, MarshalEncoding, CodeRangeable {

<span class="fc" id="L114">    private static final ASCIIEncoding ASCII = ASCIIEncoding.INSTANCE;</span>
<span class="fc" id="L115">    private static final UTF8Encoding UTF8 = UTF8Encoding.INSTANCE;</span>
<span class="fc" id="L116">    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];</span>

    // string doesn't share any resources
    private static final int SHARE_LEVEL_NONE = 0;
    // string has it's own ByteList, but it's pointing to a shared buffer (byte[])
    private static final int SHARE_LEVEL_BUFFER = 1;
    // string doesn't have it's own ByteList (values)
    private static final int SHARE_LEVEL_BYTELIST = 2;

<span class="fc" id="L125">    private static final byte[] SCRUB_REPL_UTF8 = new byte[]{(byte)0xEF, (byte)0xBF, (byte)0xBD};</span>
<span class="fc" id="L126">    private static final byte[] SCRUB_REPL_ASCII = new byte[]{(byte)'?'};</span>
<span class="fc" id="L127">    private static final byte[] SCRUB_REPL_UTF16BE = new byte[]{(byte)0xFF, (byte)0xFD};</span>
<span class="fc" id="L128">    private static final byte[] SCRUB_REPL_UTF16LE = new byte[]{(byte)0xFD, (byte)0xFF};</span>
<span class="fc" id="L129">    private static final byte[] SCRUB_REPL_UTF32BE = new byte[]{(byte)0x00, (byte)0x00, (byte)0xFF, (byte)0xFD};</span>
<span class="fc" id="L130">    private static final byte[] SCRUB_REPL_UTF32LE = new byte[]{(byte)0xFD, (byte)0xFF, (byte)0x00, (byte)0x00};</span>

<span class="fc" id="L132">    private volatile int shareLevel = SHARE_LEVEL_NONE;</span>

    private ByteList value;

<span class="fc" id="L136">    private static final String[][] opTable19 = {</span>
        { &quot;+&quot;, &quot;+(binary)&quot; },
        { &quot;-&quot;, &quot;-(binary)&quot; }
    };

    public static RubyClass createStringClass(Ruby runtime) {
<span class="fc" id="L142">        RubyClass stringClass = runtime.defineClass(&quot;String&quot;, runtime.getObject(), STRING_ALLOCATOR);</span>
<span class="fc" id="L143">        runtime.setString(stringClass);</span>
<span class="fc" id="L144">        stringClass.setClassIndex(ClassIndex.STRING);</span>
<span class="fc" id="L145">        stringClass.setReifiedClass(RubyString.class);</span>
<span class="fc" id="L146">        stringClass.kindOf = new RubyModule.JavaClassKindOf(RubyString.class);</span>

<span class="fc" id="L148">        stringClass.includeModule(runtime.getComparable());</span>
<span class="fc" id="L149">        stringClass.defineAnnotatedMethods(RubyString.class);</span>

<span class="fc" id="L151">        return stringClass;</span>
    }

<span class="fc" id="L154">    private static ObjectAllocator STRING_ALLOCATOR = new ObjectAllocator() {</span>
        @Override
        public IRubyObject allocate(Ruby runtime, RubyClass klass) {
<span class="fc" id="L157">            return RubyString.newAllocatedString(runtime, klass);</span>
        }
    };

    @Override
    public Encoding getEncoding() {
<span class="fc" id="L163">        return value.getEncoding();</span>
    }

    @Override
    public void setEncoding(Encoding encoding) {
<span class="fc" id="L168">        value.setEncoding(encoding);</span>
<span class="fc" id="L169">    }</span>

    @Override
    public boolean shouldMarshalEncoding() {
<span class="fc bfc" id="L173" title="All 2 branches covered.">        return getEncoding() != ASCIIEncoding.INSTANCE;</span>
    }

    @Override
    public Encoding getMarshalEncoding() {
<span class="fc" id="L178">        return getEncoding();</span>
    }

    public void associateEncoding(Encoding enc) {
<span class="fc bfc" id="L182" title="All 2 branches covered.">        if (value.getEncoding() != enc) {</span>
<span class="pc bpc" id="L183" title="1 of 4 branches missed.">            if (!isCodeRangeAsciiOnly() || !enc.isAsciiCompatible()) clearCodeRange();</span>
<span class="fc" id="L184">            value.setEncoding(enc);</span>
        }
<span class="fc" id="L186">    }</span>

    public final void setEncodingAndCodeRange(Encoding enc, int cr) {
<span class="fc" id="L189">        value.setEncoding(enc);</span>
<span class="fc" id="L190">        setCodeRange(cr);</span>
<span class="fc" id="L191">    }</span>

    public final Encoding toEncoding(Ruby runtime) {
<span class="fc" id="L194">        return runtime.getEncodingService().findEncoding(this);</span>
    }

    @Override
    public final int getCodeRange() {
<span class="fc" id="L199">        return flags &amp; CR_MASK;</span>
    }

    public final void setCodeRange(int codeRange) {
<span class="fc" id="L203">        clearCodeRange();</span>
<span class="fc" id="L204">        flags |= codeRange &amp; CR_MASK;</span>
<span class="fc" id="L205">    }</span>

    public final void clearCodeRange() {
<span class="fc" id="L208">        flags &amp;= ~CR_MASK;</span>
<span class="fc" id="L209">    }</span>

    private void keepCodeRange() {
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">        if (getCodeRange() == CR_BROKEN) clearCodeRange();</span>
<span class="fc" id="L213">    }</span>

    // ENC_CODERANGE_ASCIIONLY
    public final boolean isCodeRangeAsciiOnly() {
<span class="fc bfc" id="L217" title="All 2 branches covered.">        return getCodeRange() == CR_7BIT;</span>
    }

    // rb_enc_str_asciionly_p
    public final boolean isAsciiOnly() {
<span class="fc bfc" id="L222" title="All 4 branches covered.">        return value.getEncoding().isAsciiCompatible() &amp;&amp; scanForCodeRange() == CR_7BIT;</span>
    }

    public final boolean isCodeRangeValid() {
<span class="fc bfc" id="L226" title="All 2 branches covered.">        return (flags &amp; CR_MASK) == CR_VALID;</span>
    }

    public final boolean isCodeRangeBroken() {
<span class="nc bnc" id="L230" title="All 2 branches missed.">        return (flags &amp; CR_MASK) == CR_BROKEN;</span>
    }

    static int codeRangeAnd(int cr1, int cr2) {
<span class="fc bfc" id="L234" title="All 2 branches covered.">        if (cr1 == CR_7BIT) return cr2;</span>
<span class="fc bfc" id="L235" title="All 4 branches covered.">        if (cr1 == CR_VALID) return cr2 == CR_7BIT ? CR_VALID : cr2;</span>
<span class="fc" id="L236">        return CR_UNKNOWN;</span>
    }

    private void copyCodeRangeForSubstr(RubyString from, Encoding enc) {
<span class="fc" id="L240">        int fromCr = from.getCodeRange();</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">        if (fromCr == CR_7BIT) {</span>
<span class="fc" id="L242">            setCodeRange(fromCr);</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">        } else if (fromCr == CR_VALID) {</span>
<span class="fc bfc" id="L244" title="All 4 branches covered.">            if (!enc.isAsciiCompatible() || searchNonAscii(value) != -1) {</span>
<span class="fc" id="L245">                setCodeRange(CR_VALID);</span>
            } else {
<span class="fc" id="L247">                setCodeRange(CR_7BIT);</span>
            }
        } else{
<span class="fc bfc" id="L250" title="All 2 branches covered.">            if (value.getRealSize() == 0) {</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">                setCodeRange(!enc.isAsciiCompatible() ? CR_VALID : CR_7BIT);</span>
            }
        }
<span class="fc" id="L254">    }</span>

    private void copyCodeRange(RubyString from) {
<span class="fc" id="L257">        value.setEncoding(from.value.getEncoding());</span>
<span class="fc" id="L258">        setCodeRange(from.getCodeRange());</span>
<span class="fc" id="L259">    }</span>

    // rb_enc_str_coderange
    @Override
    public final int scanForCodeRange() {
<span class="fc" id="L264">        int cr = getCodeRange();</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">        if (cr == CR_UNKNOWN) {</span>
<span class="fc" id="L266">            cr = codeRangeScan(value.getEncoding(), value);</span>
<span class="fc" id="L267">            setCodeRange(cr);</span>
        }
<span class="fc" id="L269">        return cr;</span>
    }

    final boolean singleByteOptimizable() {
<span class="fc" id="L273">        return StringSupport.isSingleByteOptimizable(this, value.getEncoding());</span>
    }

    final boolean singleByteOptimizable(Encoding enc) {
<span class="fc bfc" id="L277" title="All 4 branches covered.">        return getCodeRange() == CR_7BIT || enc.maxLength() == 1;</span>
    }

    // rb_enc_compatible
    private Encoding isCompatibleWith(RubyString other) {
<span class="fc" id="L282">        Encoding enc1 = value.getEncoding();</span>
<span class="fc" id="L283">        Encoding enc2 = other.value.getEncoding();</span>

<span class="fc bfc" id="L285" title="All 2 branches covered.">        if (enc1 == enc2) return enc1;</span>

<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (other.value.getRealSize() == 0) return enc1;</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">        if (value.getRealSize() == 0) {</span>
<span class="fc bfc" id="L289" title="All 4 branches covered.">            return (enc1.isAsciiCompatible() &amp;&amp; other.isAsciiOnly()) ? enc1 : enc2;</span>
        }

<span class="fc bfc" id="L292" title="All 4 branches covered.">        if (!enc1.isAsciiCompatible() || !enc2.isAsciiCompatible()) return null;</span>

<span class="fc" id="L294">        return RubyEncoding.areCompatible(enc1, scanForCodeRange(), enc2, other.scanForCodeRange());</span>
    }

    final Encoding isCompatibleWith(EncodingCapable other) {
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if (other instanceof RubyString) return checkEncoding((RubyString)other);</span>
<span class="fc" id="L299">        Encoding enc1 = value.getEncoding();</span>
<span class="fc" id="L300">        Encoding enc2 = other.getEncoding();</span>

<span class="fc bfc" id="L302" title="All 2 branches covered.">        if (enc1 == enc2) return enc1;</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        if (value.getRealSize() == 0) return enc2;</span>
<span class="pc bpc" id="L304" title="2 of 4 branches missed.">        if (!enc1.isAsciiCompatible() || !enc2.isAsciiCompatible()) return null;</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">        if (enc2 instanceof USASCIIEncoding) return enc1;</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">        if (scanForCodeRange() == CR_7BIT) return enc2;</span>
<span class="fc" id="L307">        return null;</span>
    }

    // rb_enc_check
    public final Encoding checkEncoding(RubyString other) {
<span class="fc" id="L312">        Encoding enc = isCompatibleWith(other);</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">        if (enc == null) throw getRuntime().newEncodingCompatibilityError(&quot;incompatible character encodings: &quot; +</span>
<span class="fc" id="L314">                                value.getEncoding() + &quot; and &quot; + other.value.getEncoding());</span>
<span class="fc" id="L315">        return enc;</span>
    }

    final Encoding checkEncoding(EncodingCapable other) {
<span class="fc" id="L319">        Encoding enc = isCompatibleWith(other);</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">        if (enc == null) throw getRuntime().newEncodingCompatibilityError(&quot;incompatible character encodings: &quot; +</span>
<span class="fc" id="L321">                                value.getEncoding() + &quot; and &quot; + other.getEncoding());</span>
<span class="fc" id="L322">        return enc;</span>
    }

    private Encoding checkDummyEncoding() {
<span class="fc" id="L326">        Encoding enc = value.getEncoding();</span>
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">        if (enc.isDummy()) throw getRuntime().newEncodingCompatibilityError(</span>
                &quot;incompatible encoding with this operation: &quot; + enc);
<span class="fc" id="L329">        return enc;</span>
    }

    private boolean isComparableWith(RubyString other) {
<span class="fc" id="L333">        ByteList otherValue = other.value;</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">        if (value.getEncoding() == otherValue.getEncoding() ||</span>
<span class="pc bpc" id="L335" title="1 of 4 branches missed.">            value.getRealSize() == 0 || otherValue.getRealSize() == 0) return true;</span>
<span class="fc" id="L336">        return isComparableViaCodeRangeWith(other);</span>
    }

    private boolean isComparableViaCodeRangeWith(RubyString other) {
<span class="fc" id="L340">        int cr1 = scanForCodeRange();</span>
<span class="fc" id="L341">        int cr2 = other.scanForCodeRange();</span>

<span class="pc bpc" id="L343" title="1 of 6 branches missed.">        if (cr1 == CR_7BIT &amp;&amp; (cr2 == CR_7BIT || other.value.getEncoding().isAsciiCompatible())) return true;</span>
<span class="pc bpc" id="L344" title="3 of 4 branches missed.">        if (cr2 == CR_7BIT &amp;&amp; value.getEncoding().isAsciiCompatible()) return true;</span>
<span class="fc" id="L345">        return false;</span>
    }

    private int strLength(Encoding enc) {
<span class="fc bfc" id="L349" title="All 2 branches covered.">        if (singleByteOptimizable(enc)) return value.getRealSize();</span>
<span class="fc" id="L350">        return strLength(value, enc);</span>
    }

    public final int strLength() {
<span class="fc bfc" id="L354" title="All 2 branches covered.">        if (singleByteOptimizable()) return value.getRealSize();</span>
<span class="fc" id="L355">        return strLength(value);</span>
    }

    private int strLength(ByteList bytes) {
<span class="fc" id="L359">        return strLength(bytes, bytes.getEncoding());</span>
    }

    private int strLength(ByteList bytes, Encoding enc) {
<span class="fc bfc" id="L363" title="All 4 branches covered.">        if (isCodeRangeValid() &amp;&amp; enc instanceof UTF8Encoding) return StringSupport.utf8Length(value);</span>

<span class="fc" id="L365">        long lencr = strLengthWithCodeRange(bytes, enc);</span>
<span class="fc" id="L366">        int cr = unpackArg(lencr);</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">        if (cr != 0) setCodeRange(cr);</span>
<span class="fc" id="L368">        return unpackResult(lencr);</span>
    }

    final int subLength(int pos) {
<span class="pc bpc" id="L372" title="1 of 4 branches missed.">        if (singleByteOptimizable() || pos &lt; 0) return pos;</span>
<span class="fc" id="L373">        return StringSupport.strLength(value.getEncoding(), value.getUnsafeBytes(), value.getBegin(), value.getBegin() + pos);</span>
    }

    /** short circuit for String key comparison
     *
     */
    @Override
    public final boolean eql(IRubyObject other) {
<span class="fc" id="L381">        RubyClass metaclass = getMetaClass();</span>
<span class="fc" id="L382">        Ruby runtime = metaclass.getClassRuntime();</span>
<span class="pc bpc" id="L383" title="2 of 4 branches missed.">        if (metaclass != runtime.getString() || metaclass != other.getMetaClass()) return super.eql(other);</span>
<span class="fc" id="L384">        return eql19(runtime, other);</span>
    }

    // rb_str_hash_cmp
    private boolean eql19(Ruby runtime, IRubyObject other) {
<span class="fc" id="L389">        RubyString otherString = (RubyString)other;</span>
<span class="pc bpc" id="L390" title="2 of 4 branches missed.">        return isComparableWith(otherString) &amp;&amp; value.equal(((RubyString)other).value);</span>
    }

    public RubyString(Ruby runtime, RubyClass rubyClass) {
<span class="nc" id="L394">        this(runtime, rubyClass, EMPTY_BYTE_ARRAY);</span>
<span class="nc" id="L395">    }</span>

    public RubyString(Ruby runtime, RubyClass rubyClass, CharSequence value) {
<span class="fc" id="L398">        this(runtime, rubyClass, value, null);</span>
<span class="fc" id="L399">    }</span>

    public RubyString(Ruby runtime, RubyClass rubyClass, CharSequence value, Encoding enc) {
<span class="fc" id="L402">        super(runtime, rubyClass);</span>
<span class="pc bpc" id="L403" title="3 of 4 branches missed.">        assert value != null;</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">        if (enc == null) enc = UTF8;</span>

<span class="fc" id="L406">        this.value = encodeBytelist(value, enc);</span>
<span class="fc" id="L407">    }</span>

    public RubyString(Ruby runtime, RubyClass rubyClass, byte[] value) {
<span class="fc" id="L410">        super(runtime, rubyClass);</span>
<span class="pc bpc" id="L411" title="3 of 4 branches missed.">        assert value != null;</span>
<span class="fc" id="L412">        this.value = new ByteList(value);</span>
<span class="fc" id="L413">    }</span>

    public RubyString(Ruby runtime, RubyClass rubyClass, ByteList value) {
<span class="fc" id="L416">        super(runtime, rubyClass);</span>
<span class="pc bpc" id="L417" title="3 of 4 branches missed.">        assert value != null;</span>
<span class="fc" id="L418">        this.value = value;</span>
<span class="fc" id="L419">    }</span>

    public RubyString(Ruby runtime, RubyClass rubyClass, ByteList value, boolean objectSpace) {
<span class="fc" id="L422">        super(runtime, rubyClass, objectSpace);</span>
<span class="pc bpc" id="L423" title="3 of 4 branches missed.">        assert value != null;</span>
<span class="fc" id="L424">        this.value = value;</span>
<span class="fc" id="L425">    }</span>

    public RubyString(Ruby runtime, RubyClass rubyClass, ByteList value, Encoding encoding, boolean objectSpace) {
<span class="fc" id="L428">        this(runtime, rubyClass, value, objectSpace);</span>
<span class="fc" id="L429">        value.setEncoding(encoding);</span>
<span class="fc" id="L430">    }</span>

    protected RubyString(Ruby runtime, RubyClass rubyClass, ByteList value, Encoding enc, int cr) {
<span class="fc" id="L433">        this(runtime, rubyClass, value);</span>
<span class="fc" id="L434">        value.setEncoding(enc);</span>
<span class="fc" id="L435">        flags |= cr;</span>
<span class="fc" id="L436">    }</span>

    protected RubyString(Ruby runtime, RubyClass rubyClass, ByteList value, Encoding enc) {
<span class="fc" id="L439">        this(runtime, rubyClass, value);</span>
<span class="fc" id="L440">        value.setEncoding(enc);</span>
<span class="fc" id="L441">    }</span>

    protected RubyString(Ruby runtime, RubyClass rubyClass, ByteList value, int cr) {
<span class="fc" id="L444">        this(runtime, rubyClass, value);</span>
<span class="fc" id="L445">        flags |= cr;</span>
<span class="fc" id="L446">    }</span>

    // Deprecated String construction routines
    /** Create a new String which uses the same Ruby runtime and the same
     *  class like this String.
     *
     *  This method should be used to satisfy RCR #38.
     *  @deprecated
     */
    @Deprecated
    public RubyString newString(CharSequence s) {
<span class="nc" id="L457">        return new RubyString(getRuntime(), getType(), s);</span>
    }

    /** Create a new String which uses the same Ruby runtime and the same
     *  class like this String.
     *
     *  This method should be used to satisfy RCR #38.
     *  @deprecated
     */
    @Deprecated
    public RubyString newString(ByteList s) {
<span class="nc" id="L468">        return new RubyString(getRuntime(), getMetaClass(), s);</span>
    }

    @Deprecated
    public static RubyString newString(Ruby runtime, RubyClass clazz, CharSequence str) {
<span class="nc" id="L473">        return new RubyString(runtime, clazz, str);</span>
    }

    public static RubyString newStringLight(Ruby runtime, ByteList bytes) {
<span class="fc" id="L477">        return new RubyString(runtime, runtime.getString(), bytes, false);</span>
    }

    public static RubyString newStringLight(Ruby runtime, int size) {
<span class="fc" id="L481">        return new RubyString(runtime, runtime.getString(), new ByteList(size), false);</span>
    }

    public static RubyString newStringLight(Ruby runtime, int size, Encoding encoding) {
<span class="fc" id="L485">        return new RubyString(runtime, runtime.getString(), new ByteList(size), encoding, false);</span>
    }

    public static RubyString newString(Ruby runtime, CharSequence str) {
<span class="nc" id="L489">        return new RubyString(runtime, runtime.getString(), str);</span>
    }

    public static RubyString newString(Ruby runtime, String str) {
<span class="fc" id="L493">        return new RubyString(runtime, runtime.getString(), str);</span>
    }

    public static RubyString newString(Ruby runtime, String str, Encoding encoding) {
<span class="fc" id="L497">        return new RubyString(runtime, runtime.getString(), str, encoding);</span>
    }

    public static RubyString newUSASCIIString(Ruby runtime, String str) {
<span class="fc" id="L501">        return new RubyString(runtime, runtime.getString(), str, USASCIIEncoding.INSTANCE);</span>
    }

    public static RubyString newString(Ruby runtime, byte[] bytes) {
<span class="fc" id="L505">        return new RubyString(runtime, runtime.getString(), bytes);</span>
    }

    public static RubyString newString(Ruby runtime, byte[] bytes, int start, int length) {
<span class="fc" id="L509">        return newString(runtime, bytes, start, length, ASCIIEncoding.INSTANCE);</span>
    }

    // rb_enc_str_new
    public static RubyString newString(Ruby runtime, byte[] bytes, int start, int length, Encoding encoding) {
<span class="fc" id="L514">        byte[] copy = new byte[length];</span>
<span class="fc" id="L515">        System.arraycopy(bytes, start, copy, 0, length);</span>
<span class="fc" id="L516">        return new RubyString(runtime, runtime.getString(), new ByteList(copy, encoding, false));</span>
    }

    public static RubyString newString(Ruby runtime, ByteList bytes) {
<span class="fc" id="L520">        return new RubyString(runtime, runtime.getString(), bytes);</span>
    }

    public static RubyString newString(Ruby runtime, ByteList bytes, Encoding encoding) {
<span class="fc" id="L524">        return new RubyString(runtime, runtime.getString(), bytes, encoding);</span>
    }

    public static RubyString newUnicodeString(Ruby runtime, String str) {
<span class="fc" id="L528">        Encoding defaultInternal = runtime.getDefaultInternalEncoding();</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">        if (defaultInternal == UTF16BEEncoding.INSTANCE) {</span>
<span class="nc" id="L530">            return newUTF16String(runtime, str);</span>
        } else {
<span class="fc" id="L532">            return newUTF8String(runtime, str);</span>
        }
    }

    public static RubyString newUTF8String(Ruby runtime, String str) {
<span class="fc" id="L537">        ByteList byteList = new ByteList(RubyEncoding.encodeUTF8(str), UTF8Encoding.INSTANCE, false);</span>
<span class="fc" id="L538">        return new RubyString(runtime, runtime.getString(), byteList);</span>
    }

    public static RubyString newUTF16String(Ruby runtime, String str) {
<span class="nc" id="L542">        ByteList byteList = new ByteList(RubyEncoding.encodeUTF16(str), UTF16BEEncoding.INSTANCE, false);</span>
<span class="nc" id="L543">        return new RubyString(runtime, runtime.getString(), byteList);</span>
    }

    public static RubyString newUnicodeString(Ruby runtime, CharSequence str) {
<span class="nc" id="L547">        Encoding defaultInternal = runtime.getDefaultInternalEncoding();</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">        if (defaultInternal == UTF16BEEncoding.INSTANCE) {</span>
<span class="nc" id="L549">            return newUTF16String(runtime, str);</span>
        } else {
<span class="nc" id="L551">            return newUTF8String(runtime, str);</span>
        }
    }

    public static RubyString newUTF8String(Ruby runtime, CharSequence str) {
<span class="nc" id="L556">        ByteList byteList = new ByteList(RubyEncoding.encodeUTF8(str), UTF8Encoding.INSTANCE, false);</span>
<span class="nc" id="L557">        return new RubyString(runtime, runtime.getString(), byteList);</span>
    }

    public static RubyString newUTF16String(Ruby runtime, CharSequence str) {
<span class="nc" id="L561">        ByteList byteList = new ByteList(RubyEncoding.encodeUTF16(str.toString()), UTF16BEEncoding.INSTANCE, false);</span>
<span class="nc" id="L562">        return new RubyString(runtime, runtime.getString(), byteList);</span>
    }

    /**
     * Return a new Ruby String encoded as the default internal encoding given a Java String that
     * has come from an external source. If there is no default internal encoding set, the Ruby
     * String will be encoded using Java's default external encoding. If an internal encoding is
     * set, that encoding will be used for the Ruby String.
     *
     * @param runtime
     * @param str
     * @return
     */
    public static RubyString newInternalFromJavaExternal(Ruby runtime, String str) {
        // Ruby internal
<span class="fc" id="L577">        Encoding internal = runtime.getDefaultInternalEncoding();</span>
<span class="fc" id="L578">        Charset rubyInt = null;</span>
<span class="pc bpc" id="L579" title="3 of 4 branches missed.">        if (internal != null &amp;&amp; internal.getCharset() != null) rubyInt = internal.getCharset();</span>

<span class="fc" id="L581">        Encoding javaExtEncoding = runtime.getEncodingService().getJavaDefault();</span>

<span class="pc bpc" id="L583" title="1 of 2 branches missed.">        if (rubyInt == null) {</span>
<span class="fc" id="L584">            return RubyString.newString(</span>
                    runtime,
<span class="fc" id="L586">                    new ByteList(str.getBytes(), javaExtEncoding));</span>
        } else {
<span class="nc" id="L588">            return RubyString.newString(</span>
                    runtime,
<span class="nc" id="L590">                    new ByteList(RubyEncoding.encode(str, rubyInt), internal));</span>
        }
    }

    // String construction routines by NOT byte[] buffer and making the target String shared
    public static RubyString newStringShared(Ruby runtime, RubyString orig) {
<span class="nc" id="L596">        orig.shareLevel = SHARE_LEVEL_BYTELIST;</span>
<span class="nc" id="L597">        RubyString str = new RubyString(runtime, runtime.getString(), orig.value);</span>
<span class="nc" id="L598">        str.shareLevel = SHARE_LEVEL_BYTELIST;</span>
<span class="nc" id="L599">        return str;</span>
    }

    public static RubyString newStringShared(Ruby runtime, ByteList bytes) {
<span class="fc" id="L603">        return newStringShared(runtime, runtime.getString(), bytes);</span>
    }

    public static RubyString newStringShared(Ruby runtime, ByteList bytes, Encoding encoding) {
<span class="fc" id="L607">        return newStringShared(runtime, runtime.getString(), bytes, encoding);</span>
    }


    public static RubyString newStringShared(Ruby runtime, ByteList bytes, int codeRange) {
<span class="fc" id="L612">        RubyString str = new RubyString(runtime, runtime.getString(), bytes, codeRange);</span>
<span class="fc" id="L613">        str.shareLevel = SHARE_LEVEL_BYTELIST;</span>
<span class="fc" id="L614">        return str;</span>
    }

    public static RubyString newStringShared(Ruby runtime, RubyClass clazz, ByteList bytes) {
<span class="fc" id="L618">        RubyString str = new RubyString(runtime, clazz, bytes);</span>
<span class="fc" id="L619">        str.shareLevel = SHARE_LEVEL_BYTELIST;</span>
<span class="fc" id="L620">        return str;</span>
    }

    public static RubyString newStringShared(Ruby runtime, RubyClass clazz, ByteList bytes, Encoding encoding) {
<span class="fc" id="L624">        RubyString str = new RubyString(runtime, clazz, bytes, encoding);</span>
<span class="fc" id="L625">        str.shareLevel = SHARE_LEVEL_BYTELIST;</span>
<span class="fc" id="L626">        return str;</span>
    }

    public static RubyString newStringShared(Ruby runtime, byte[] bytes) {
<span class="nc" id="L630">        return newStringShared(runtime, new ByteList(bytes, false));</span>
    }

    public static RubyString newStringShared(Ruby runtime, byte[] bytes, Encoding encoding) {
<span class="nc" id="L634">        return newStringShared(runtime, new ByteList(bytes, encoding, false));</span>
    }

    public static RubyString newStringShared(Ruby runtime, byte[] bytes, int start, int length) {
<span class="fc" id="L638">        return newStringShared(runtime, new ByteList(bytes, start, length, false));</span>
    }

    public static RubyString newStringShared(Ruby runtime, byte[] bytes, int start, int length, Encoding encoding) {
<span class="fc" id="L642">        return newStringShared(runtime, new ByteList(bytes, start, length, encoding, false));</span>
    }

    public static RubyString newEmptyString(Ruby runtime) {
<span class="fc" id="L646">        return newEmptyString(runtime, runtime.getString());</span>
    }

<span class="fc" id="L649">    private static final ByteList EMPTY_ASCII8BIT_BYTELIST = new ByteList(new byte[0], ASCIIEncoding.INSTANCE);</span>
<span class="fc" id="L650">    private static final ByteList EMPTY_USASCII_BYTELIST = new ByteList(new byte[0], USASCIIEncoding.INSTANCE);</span>

    public static RubyString newAllocatedString(Ruby runtime, RubyClass metaClass) {
<span class="fc" id="L653">        RubyString empty = new RubyString(runtime, metaClass, EMPTY_ASCII8BIT_BYTELIST);</span>
<span class="fc" id="L654">        empty.shareLevel = SHARE_LEVEL_BYTELIST;</span>
<span class="fc" id="L655">        return empty;</span>
    }

    public static RubyString newEmptyString(Ruby runtime, RubyClass metaClass) {
<span class="fc" id="L659">        RubyString empty = new RubyString(runtime, metaClass, EMPTY_USASCII_BYTELIST);</span>
<span class="fc" id="L660">        empty.shareLevel = SHARE_LEVEL_BYTELIST;</span>
<span class="fc" id="L661">        return empty;</span>
    }

    // String construction routines by NOT byte[] buffer and NOT making the target String shared
    public static RubyString newStringNoCopy(Ruby runtime, ByteList bytes) {
<span class="fc" id="L666">        return newStringNoCopy(runtime, runtime.getString(), bytes);</span>
    }

    public static RubyString newStringNoCopy(Ruby runtime, RubyClass clazz, ByteList bytes) {
<span class="fc" id="L670">        return new RubyString(runtime, clazz, bytes);</span>
    }

    public static RubyString newStringNoCopy(Ruby runtime, byte[] bytes, int start, int length) {
<span class="nc" id="L674">        return newStringNoCopy(runtime, new ByteList(bytes, start, length, false));</span>
    }

    public static RubyString newStringNoCopy(Ruby runtime, byte[] bytes) {
<span class="fc" id="L678">        return newStringNoCopy(runtime, new ByteList(bytes, false));</span>
    }

    // str_independent
    public boolean independent() {
<span class="nc bnc" id="L683" title="All 2 branches missed.">        return shareLevel == SHARE_LEVEL_NONE;</span>
    }

    // str_make_independent, modified to create a new String rather than possibly modifying a frozen one
    public RubyString makeIndependent() {
<span class="nc" id="L688">        RubyClass klass = metaClass;</span>
<span class="nc" id="L689">        RubyString str = strDup(klass.getClassRuntime(), klass);</span>
<span class="nc" id="L690">        str.modify();</span>
<span class="nc" id="L691">        str.setFrozen(true);</span>
<span class="nc" id="L692">        str.infectBy(this);</span>
<span class="nc" id="L693">        return str;</span>
    }

    // MRI: EXPORT_STR macro in process.c
    public RubyString export(ThreadContext context) {
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">        if (Platform.IS_WINDOWS) {</span>
<span class="nc" id="L699">            return EncodingUtils.strConvEncOpts(context, this, null, UTF8Encoding.INSTANCE, 0, context.nil);</span>
        }
<span class="fc" id="L701">        return this;</span>
    }

    /** Encoding aware String construction routines for 1.9
     *
     */
    private static final class EmptyByteListHolder {
        final ByteList bytes;
        final int cr;
<span class="fc" id="L710">        EmptyByteListHolder(Encoding enc) {</span>
<span class="fc" id="L711">            this.bytes = new ByteList(ByteList.NULL_ARRAY, enc);</span>
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">            this.cr = bytes.getEncoding().isAsciiCompatible() ? CR_7BIT : CR_VALID;</span>
<span class="fc" id="L713">        }</span>
    }

<span class="fc" id="L716">    private static EmptyByteListHolder EMPTY_BYTELISTS[] = new EmptyByteListHolder[4];</span>

    static EmptyByteListHolder getEmptyByteList(Encoding enc) {
<span class="pc bpc" id="L719" title="1 of 2 branches missed.">        if (enc == null) enc = ASCIIEncoding.INSTANCE;</span>
<span class="fc" id="L720">        int index = enc.getIndex();</span>
        EmptyByteListHolder bytes;
<span class="fc bfc" id="L722" title="All 4 branches covered.">        if (index &lt; EMPTY_BYTELISTS.length &amp;&amp; (bytes = EMPTY_BYTELISTS[index]) != null) {</span>
<span class="fc" id="L723">            return bytes;</span>
        }
<span class="fc" id="L725">        return prepareEmptyByteList(enc);</span>
    }

    private static EmptyByteListHolder prepareEmptyByteList(Encoding enc) {
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">        if (enc == null) enc = ASCIIEncoding.INSTANCE;</span>
<span class="fc" id="L730">        int index = enc.getIndex();</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">        if (index &gt;= EMPTY_BYTELISTS.length) {</span>
<span class="fc" id="L732">            EmptyByteListHolder tmp[] = new EmptyByteListHolder[index + 4];</span>
<span class="fc" id="L733">            System.arraycopy(EMPTY_BYTELISTS,0, tmp, 0, EMPTY_BYTELISTS.length);</span>
<span class="fc" id="L734">            EMPTY_BYTELISTS = tmp;</span>
        }
<span class="fc" id="L736">        return EMPTY_BYTELISTS[index] = new EmptyByteListHolder(enc);</span>
    }

    public static RubyString newEmptyString(Ruby runtime, RubyClass metaClass, Encoding enc) {
<span class="fc" id="L740">        EmptyByteListHolder holder = getEmptyByteList(enc);</span>
<span class="fc" id="L741">        RubyString empty = new RubyString(runtime, metaClass, holder.bytes, holder.cr);</span>
<span class="fc" id="L742">        empty.shareLevel = SHARE_LEVEL_BYTELIST;</span>
<span class="fc" id="L743">        return empty;</span>
    }

    public static RubyString newEmptyString(Ruby runtime, Encoding enc) {
<span class="fc" id="L747">        return newEmptyString(runtime, runtime.getString(), enc);</span>
    }

    public static RubyString newStringNoCopy(Ruby runtime, RubyClass clazz, ByteList bytes, Encoding enc, int cr) {
<span class="fc" id="L751">        return new RubyString(runtime, clazz, bytes, enc, cr);</span>
    }

    public static RubyString newStringNoCopy(Ruby runtime, ByteList bytes, Encoding enc, int cr) {
<span class="fc" id="L755">        return newStringNoCopy(runtime, runtime.getString(), bytes, enc, cr);</span>
    }

    public static RubyString newUsAsciiStringNoCopy(Ruby runtime, ByteList bytes) {
<span class="fc" id="L759">        return newStringNoCopy(runtime, bytes, USASCIIEncoding.INSTANCE, CR_7BIT);</span>
    }

    public static RubyString newUsAsciiStringShared(Ruby runtime, ByteList bytes) {
<span class="fc" id="L763">        RubyString str = newUsAsciiStringNoCopy(runtime, bytes);</span>
<span class="fc" id="L764">        str.shareLevel = SHARE_LEVEL_BYTELIST;</span>
<span class="fc" id="L765">        return str;</span>
    }

    public static RubyString newUsAsciiStringShared(Ruby runtime, byte[] bytes, int start, int length) {
<span class="fc" id="L769">        byte[] copy = new byte[length];</span>
<span class="fc" id="L770">        System.arraycopy(bytes, start, copy, 0, length);</span>
<span class="fc" id="L771">        return newUsAsciiStringShared(runtime, new ByteList(copy, false));</span>
    }

    @Override
    public ClassIndex getNativeClassIndex() {
<span class="fc" id="L776">        return ClassIndex.STRING;</span>
    }

    @Override
    public Class getJavaClass() {
<span class="fc" id="L781">        return String.class;</span>
    }

    @Override
    public RubyString convertToString() {
<span class="fc" id="L786">        return this;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L791">        return decodeString();</span>
    }

    /**
     * Convert this Ruby string to a Java String. This version is encoding-aware.
     *
     * @return A decoded Java String, based on this Ruby string's encoding.
     */
    public String decodeString() {
<span class="fc" id="L800">        return Helpers.decodeByteList(getRuntime(), value);</span>
    }

    /**
     * Overridden dup for fast-path logic.
     *
     * @return A new RubyString sharing the original backing store.
     */
    @Override
    public IRubyObject dup() {
<span class="fc" id="L810">        RubyClass mc = metaClass.getRealClass();</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">        if (mc.getClassIndex() != ClassIndex.STRING) return super.dup();</span>

<span class="fc" id="L813">        return strDup(mc.getClassRuntime(), mc.getRealClass());</span>
    }

    // rb_str_new_frozen or rb_str_dup_frozen
    public IRubyObject dupFrozen() {
<span class="fc" id="L818">        RubyString dup = (RubyString)dup();</span>
<span class="fc" id="L819">        dup.setFrozen(true);</span>
<span class="fc" id="L820">        return dup;</span>
    }

    // MRI: rb_str_dup
    public final RubyString strDup(Ruby runtime) {
<span class="fc" id="L825">        return strDup(runtime, getMetaClass().getRealClass());</span>
    }

    final RubyString strDup(Ruby runtime, RubyClass clazz) {
<span class="fc" id="L829">        shareLevel = SHARE_LEVEL_BYTELIST;</span>
<span class="fc" id="L830">        RubyString dup = new RubyString(runtime, clazz, value);</span>
<span class="fc" id="L831">        dup.shareLevel = SHARE_LEVEL_BYTELIST;</span>
<span class="fc" id="L832">        dup.flags |= flags &amp; (CR_MASK | TAINTED_F);</span>

<span class="fc" id="L834">        return dup;</span>
    }

    /* rb_str_subseq */
    public final RubyString makeSharedString(Ruby runtime, int index, int len) {
<span class="nc" id="L839">        return makeShared19(runtime, runtime.getString(), index, len);</span>
    }

    public RubyString makeSharedString19(Ruby runtime, int index, int len) {
<span class="nc" id="L843">        return makeShared19(runtime, runtime.getString(), value, index, len);</span>
    }

    public final RubyString makeShared(Ruby runtime, int index, int len) {
<span class="nc" id="L847">        return makeShared19(runtime, getType(), index, len);</span>
    }

    public final RubyString makeShared(Ruby runtime, RubyClass meta, int index, int len) {
        final RubyString shared;
<span class="nc bnc" id="L852" title="All 2 branches missed.">        if (len == 0) {</span>
<span class="nc" id="L853">            shared = newEmptyString(runtime, meta);</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">        } else if (len == 1) {</span>
<span class="nc" id="L855">            shared = newStringShared(runtime, meta,</span>
<span class="nc" id="L856">                    RubyInteger.SINGLE_CHAR_BYTELISTS[value.getUnsafeBytes()[value.getBegin() + index] &amp; 0xff]);</span>
        } else {
<span class="nc bnc" id="L858" title="All 2 branches missed.">            if (shareLevel == SHARE_LEVEL_NONE) shareLevel = SHARE_LEVEL_BUFFER;</span>
<span class="nc" id="L859">            shared = new RubyString(runtime, meta, value.makeShared(index, len));</span>
<span class="nc" id="L860">            shared.shareLevel = SHARE_LEVEL_BUFFER;</span>
        }

<span class="nc" id="L863">        shared.infectBy(this);</span>
<span class="nc" id="L864">        return shared;</span>
    }

    public final RubyString makeShared19(Ruby runtime, int index, int len) {
<span class="fc" id="L868">        return makeShared19(runtime, value, index, len);</span>
    }

    public final RubyString makeShared19(Ruby runtime, RubyClass meta, int index, int len) {
<span class="fc" id="L872">        return makeShared19(runtime, meta, value, index, len);</span>
    }

    private RubyString makeShared19(Ruby runtime, ByteList value, int index, int len) {
<span class="fc" id="L876">        return makeShared19(runtime, getType(), value, index, len);</span>
    }

    private RubyString makeShared19(Ruby runtime, RubyClass meta, ByteList value, int index, int len) {
        final RubyString shared;
<span class="fc" id="L881">        Encoding enc = value.getEncoding();</span>

<span class="fc bfc" id="L883" title="All 2 branches covered.">        if (len == 0) {</span>
<span class="fc" id="L884">            shared = newEmptyString(runtime, meta, enc);</span>
<span class="fc bfc" id="L885" title="All 2 branches covered.">        } else if (len == 1) {</span>
            // as with the 1.8 makeShared, don't bother sharing for substrings that are a single byte
            // to get a good speed boost in a number of common scenarios (note though that unlike 1.8,
            // we can't take advantage of SINGLE_CHAR_BYTELISTS since our encoding may not be ascii, but the
            // single byte copy is pretty much negligible)
<span class="fc" id="L890">            shared = newStringShared(runtime,</span>
                                     meta,
<span class="fc" id="L892">                                     new ByteList(new byte[] { (byte) value.get(index) }, enc),</span>
                                     enc);
        } else {
<span class="fc bfc" id="L895" title="All 2 branches covered.">            if (shareLevel == SHARE_LEVEL_NONE) shareLevel = SHARE_LEVEL_BUFFER;</span>
<span class="fc" id="L896">            shared = new RubyString(runtime, meta, value.makeShared(index, len));</span>
<span class="fc" id="L897">            shared.shareLevel = SHARE_LEVEL_BUFFER;</span>
        }
<span class="fc" id="L899">        shared.copyCodeRangeForSubstr(this, enc); // no need to assign encoding, same bytelist shared</span>
<span class="fc" id="L900">        shared.infectBy(this);</span>
<span class="fc" id="L901">        return shared;</span>
    }

    public final void setByteListShared() {
<span class="nc bnc" id="L905" title="All 2 branches missed.">        if (shareLevel != SHARE_LEVEL_BYTELIST) shareLevel = SHARE_LEVEL_BYTELIST;</span>
<span class="nc" id="L906">    }</span>

    /**
     * Check that the string can be modified, raising error otherwise.
     *
     * If you plan to modify a string with shared backing store, this
     * method is not sufficient; you will need to call modify() instead.
     */
    public final void modifyCheck() {
<span class="fc" id="L915">        frozenCheck();</span>
<span class="fc" id="L916">    }</span>

    private void modifyCheck(byte[] b, int len) {
<span class="pc bpc" id="L919" title="2 of 4 branches missed.">        if (value.getUnsafeBytes() != b || value.getRealSize() != len) throw getRuntime().newRuntimeError(&quot;string modified&quot;);</span>
<span class="fc" id="L920">    }</span>

    private void modifyCheck(byte[] b, int len, Encoding enc) {
<span class="pc bpc" id="L923" title="2 of 6 branches missed.">        if (value.getUnsafeBytes() != b || value.getRealSize() != len || value.getEncoding() != enc) throw getRuntime().newRuntimeError(&quot;string modified&quot;);</span>
<span class="fc" id="L924">    }</span>

    private void frozenCheck() {
<span class="fc" id="L927">        frozenCheck(false);</span>
<span class="fc" id="L928">    }</span>

    private void frozenCheck(boolean runtimeError) {
<span class="fc bfc" id="L931" title="All 2 branches covered.">        if (isFrozen()) throw getRuntime().newFrozenError(&quot;string&quot;, runtimeError);</span>
<span class="fc" id="L932">    }</span>

    /** rb_str_modify
     *
     */
    public final void modify() {
<span class="fc" id="L938">        modifyCheck();</span>

<span class="fc bfc" id="L940" title="All 2 branches covered.">        if (shareLevel != SHARE_LEVEL_NONE) {</span>
<span class="fc bfc" id="L941" title="All 2 branches covered.">            if (shareLevel == SHARE_LEVEL_BYTELIST) {</span>
<span class="fc" id="L942">                value = value.dup();</span>
            } else {
<span class="fc" id="L944">                value.unshare();</span>
            }
<span class="fc" id="L946">            shareLevel = SHARE_LEVEL_NONE;</span>
        }

<span class="fc" id="L949">        value.invalidate();</span>
<span class="fc" id="L950">    }</span>

    public final void modify19() {
<span class="fc" id="L953">        modify();</span>
<span class="fc" id="L954">        clearCodeRange();</span>
<span class="fc" id="L955">    }</span>

    private void modifyAndKeepCodeRange() {
<span class="fc" id="L958">        modify();</span>
<span class="fc" id="L959">        keepCodeRange();</span>
<span class="fc" id="L960">    }</span>

    /** rb_str_modify (with length bytes ensured)
     *
     */
    public final void modify(int length) {
<span class="fc" id="L966">        modifyCheck();</span>

<span class="fc bfc" id="L968" title="All 2 branches covered.">        if (shareLevel != SHARE_LEVEL_NONE) {</span>
<span class="fc bfc" id="L969" title="All 2 branches covered.">            if (shareLevel == SHARE_LEVEL_BYTELIST) {</span>
<span class="fc" id="L970">                value = value.dup(length);</span>
            } else {
<span class="fc" id="L972">                value.unshare(length);</span>
            }
<span class="fc" id="L974">            shareLevel = SHARE_LEVEL_NONE;</span>
        } else {
<span class="fc" id="L976">            value.ensure(length);</span>
        }

<span class="fc" id="L979">        value.invalidate();</span>
<span class="fc" id="L980">    }</span>

    /**
     * rb_str_modify_expand
     */
    public final void modifyExpand(int length) {
<span class="fc" id="L986">        modify(length);</span>
<span class="fc" id="L987">        clearCodeRange();</span>
<span class="fc" id="L988">    }</span>

    // io_set_read_length
    public void setReadLength(int length) {
<span class="fc bfc" id="L992" title="All 2 branches covered.">        if (size() != length) {</span>
<span class="fc" id="L993">            modify();</span>
<span class="fc" id="L994">            value.setRealSize(length);</span>
        }
<span class="fc" id="L996">    }</span>

    // rb_str_new_frozen, at least in spirit
    public RubyString newFrozen() {
        RubyClass klass;
<span class="fc" id="L1001">        RubyString str = this;</span>

<span class="fc bfc" id="L1003" title="All 2 branches covered.">        if (isFrozen()) return this;</span>
<span class="fc" id="L1004">        klass = getMetaClass();</span>
<span class="fc" id="L1005">        str = strDup(klass.getClassRuntime());</span>
<span class="fc" id="L1006">        str.setCodeRange(getCodeRange());</span>
<span class="fc" id="L1007">        str.modify();</span>
<span class="fc" id="L1008">        str.setFrozen(true);</span>
<span class="fc" id="L1009">        return str;</span>
    }

    /** rb_str_resize
     */
    public final void resize(int length) {
<span class="fc" id="L1015">        modify();</span>
<span class="pc bpc" id="L1016" title="1 of 2 branches missed.">        if (value.getRealSize() &gt; length) {</span>
<span class="nc" id="L1017">            value.setRealSize(length);</span>
<span class="fc bfc" id="L1018" title="All 2 branches covered.">        } else if (value.length() &lt; length) {</span>
<span class="fc" id="L1019">            value.length(length);</span>
        }
<span class="fc" id="L1021">    }</span>

    public final void view(ByteList bytes) {
<span class="fc" id="L1024">        modifyCheck();</span>

<span class="fc" id="L1026">        value = bytes;</span>
<span class="fc" id="L1027">        shareLevel = SHARE_LEVEL_NONE;</span>
<span class="fc" id="L1028">    }</span>

    private void view(byte[]bytes) {
<span class="nc" id="L1031">        modifyCheck();</span>

<span class="nc" id="L1033">        value = new ByteList(bytes);</span>
<span class="nc" id="L1034">        shareLevel = SHARE_LEVEL_NONE;</span>

<span class="nc" id="L1036">        value.invalidate();</span>
<span class="nc" id="L1037">    }</span>

    private void view(int index, int len) {
<span class="fc" id="L1040">        modifyCheck();</span>

<span class="fc bfc" id="L1042" title="All 2 branches covered.">        if (shareLevel != SHARE_LEVEL_NONE) {</span>
<span class="fc bfc" id="L1043" title="All 2 branches covered.">            if (shareLevel == SHARE_LEVEL_BYTELIST) {</span>
                // if len == 0 then shared empty
<span class="fc" id="L1045">                value = value.makeShared(index, len);</span>
<span class="fc" id="L1046">                shareLevel = SHARE_LEVEL_BUFFER;</span>
            } else {
<span class="fc" id="L1048">                value.view(index, len);</span>
            }
        } else {
<span class="fc" id="L1051">            value.view(index, len);</span>
            // FIXME this below is temporary, but its much safer for COW (it prevents not shared Strings with begin != 0)
            // this allows now e.g.: ByteList#set not to be begin aware
<span class="fc" id="L1054">            shareLevel = SHARE_LEVEL_BUFFER;</span>
        }

<span class="fc" id="L1057">        value.invalidate();</span>
<span class="fc" id="L1058">    }</span>

    public static String bytesToString(byte[] bytes, int beg, int len) {
<span class="fc" id="L1061">        return new String(ByteList.plain(bytes, beg, len));</span>
    }

    public static String byteListToString(ByteList bytes) {
<span class="fc" id="L1065">        return bytesToString(bytes.getUnsafeBytes(), bytes.begin(), bytes.length());</span>
    }

    public static String bytesToString(byte[] bytes) {
<span class="nc" id="L1069">        return bytesToString(bytes, 0, bytes.length);</span>
    }

    public static byte[] stringToBytes(String string) {
<span class="fc" id="L1073">        return ByteList.plain(string);</span>
    }

    @Override
    public RubyString asString() {
<span class="fc" id="L1078">        return this;</span>
    }

    @Override
    public IRubyObject checkStringType() {
<span class="fc" id="L1083">        return this;</span>
    }

    @Override
    public IRubyObject checkStringType19() {
<span class="fc" id="L1088">        return this;</span>
    }

    @JRubyMethod(meta = true)
    public static IRubyObject try_convert(ThreadContext context, IRubyObject recv, IRubyObject str) {
<span class="fc" id="L1093">        return str.checkStringType();</span>
    }

    @JRubyMethod(name = {&quot;to_s&quot;, &quot;to_str&quot;})
    @Override
    public IRubyObject to_s() {
<span class="fc" id="L1099">        Ruby runtime = getRuntime();</span>
<span class="fc bfc" id="L1100" title="All 2 branches covered.">        if (getMetaClass().getRealClass() != runtime.getString()) {</span>
<span class="fc" id="L1101">            return strDup(runtime, runtime.getString());</span>
        }
<span class="fc" id="L1103">        return this;</span>
    }

    @Override
    public final int compareTo(IRubyObject other) {
<span class="nc" id="L1108">        return (int)op_cmp(getRuntime().getCurrentContext(), other).convertToInteger().getLongValue();</span>
    }

    /* rb_str_cmp_m */
    @JRubyMethod(name = &quot;&lt;=&gt;&quot;)
    @Override
    public IRubyObject op_cmp(ThreadContext context, IRubyObject other) {
<span class="fc" id="L1115">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L1116" title="All 2 branches covered.">        if (other instanceof RubyString) {</span>
<span class="fc" id="L1117">            return runtime.newFixnum(op_cmp((RubyString)other));</span>
        }
<span class="fc bfc" id="L1119" title="All 2 branches covered.">        if (other.respondsTo(&quot;to_str&quot;)) {</span>
<span class="fc" id="L1120">            IRubyObject tmp = other.callMethod(context, &quot;to_str&quot;);</span>
<span class="pc bpc" id="L1121" title="1 of 2 branches missed.">            if (tmp instanceof RubyString)</span>
<span class="fc" id="L1122">              return runtime.newFixnum(op_cmp((RubyString)tmp));</span>
<span class="nc" id="L1123">        } else {</span>
<span class="fc" id="L1124">            return invcmp(context, this, other);</span>
        }
<span class="nc" id="L1126">        return runtime.getNil();</span>
    }

    /** rb_str_equal
     *
     */
    @Override
    public IRubyObject op_equal(ThreadContext context, IRubyObject other) {
<span class="fc" id="L1134">        return op_equal19(context, other);</span>
    }

    @JRubyMethod(name = {&quot;==&quot;, &quot;===&quot;})
    public IRubyObject op_equal19(ThreadContext context, IRubyObject other) {
<span class="fc" id="L1139">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L1140" title="All 2 branches covered.">        if (this == other) return runtime.getTrue();</span>
<span class="fc bfc" id="L1141" title="All 2 branches covered.">        if (other instanceof RubyString) {</span>
<span class="fc" id="L1142">            RubyString otherString = (RubyString)other;</span>
<span class="fc bfc" id="L1143" title="All 4 branches covered.">            return isComparableWith(otherString) &amp;&amp; value.equal(otherString.value) ? runtime.getTrue() : runtime.getFalse();</span>
        }
<span class="fc" id="L1145">        return op_equalCommon(context, other);</span>
    }

    private IRubyObject op_equalCommon(ThreadContext context, IRubyObject other) {
<span class="fc" id="L1149">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L1150" title="All 2 branches covered.">        if (!other.respondsTo(&quot;to_str&quot;)) return runtime.getFalse();</span>
<span class="pc bpc" id="L1151" title="1 of 2 branches missed.">        return invokedynamic(context, other, OP_EQUAL, this).isTrue() ? runtime.getTrue() : runtime.getFalse();</span>
    }

    public IRubyObject op_plus(ThreadContext context, IRubyObject _str) {
<span class="nc" id="L1155">        return op_plus19(context, _str);</span>
    }

    @JRubyMethod(name = &quot;+&quot;, required = 1)
    public IRubyObject op_plus19(ThreadContext context, IRubyObject _str) {
<span class="fc" id="L1160">        RubyString str = _str.convertToString();</span>
<span class="fc" id="L1161">        Encoding enc = checkEncoding(str);</span>
<span class="fc" id="L1162">        RubyString resultStr = newStringNoCopy(context.runtime, addByteLists(value, str.value),</span>
<span class="fc" id="L1163">                                    enc, codeRangeAnd(getCodeRange(), str.getCodeRange()));</span>
<span class="fc" id="L1164">        resultStr.infectBy(flags | str.flags);</span>
<span class="fc" id="L1165">        return resultStr;</span>
    }

    private ByteList addByteLists(ByteList value1, ByteList value2) {
<span class="fc" id="L1169">        ByteList result = new ByteList(value1.getRealSize() + value2.getRealSize());</span>
<span class="fc" id="L1170">        result.setRealSize(value1.getRealSize() + value2.getRealSize());</span>
<span class="fc" id="L1171">        System.arraycopy(value1.getUnsafeBytes(), value1.getBegin(), result.getUnsafeBytes(), 0, value1.getRealSize());</span>
<span class="fc" id="L1172">        System.arraycopy(value2.getUnsafeBytes(), value2.getBegin(), result.getUnsafeBytes(), value1.getRealSize(), value2.getRealSize());</span>
<span class="fc" id="L1173">        return result;</span>
    }

    public IRubyObject op_mul(ThreadContext context, IRubyObject other) {
<span class="nc" id="L1177">        return op_mul19(context, other);</span>
    }

    @JRubyMethod(name = &quot;*&quot;, required = 1)
    public IRubyObject op_mul19(ThreadContext context, IRubyObject other) {
<span class="fc" id="L1182">        RubyString result = multiplyByteList(context, other);</span>
<span class="fc" id="L1183">        result.value.setEncoding(value.getEncoding());</span>
<span class="fc" id="L1184">        result.copyCodeRange(this);</span>
<span class="fc" id="L1185">        return result;</span>
    }

    private RubyString multiplyByteList(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L1189">        int len = RubyNumeric.num2int(arg);</span>
<span class="fc bfc" id="L1190" title="All 2 branches covered.">        if (len &lt; 0) throw context.runtime.newArgumentError(&quot;negative argument&quot;);</span>

        // we limit to int because ByteBuffer can only allocate int sizes
<span class="pc bpc" id="L1193" title="1 of 4 branches missed.">        if (len &gt; 0 &amp;&amp; Integer.MAX_VALUE / len &lt; value.getRealSize()) {</span>
<span class="nc" id="L1194">            throw context.runtime.newArgumentError(&quot;argument too big&quot;);</span>
        }

<span class="fc" id="L1197">        ByteList bytes = new ByteList(len *= value.getRealSize());</span>
<span class="fc bfc" id="L1198" title="All 2 branches covered.">        if (len &gt; 0) {</span>
<span class="fc" id="L1199">            bytes.setRealSize(len);</span>
<span class="fc" id="L1200">            int n = value.getRealSize();</span>
<span class="fc" id="L1201">            System.arraycopy(value.getUnsafeBytes(), value.getBegin(), bytes.getUnsafeBytes(), 0, n);</span>
<span class="fc bfc" id="L1202" title="All 2 branches covered.">            while (n &lt;= len &gt;&gt; 1) {</span>
<span class="fc" id="L1203">                System.arraycopy(bytes.getUnsafeBytes(), 0, bytes.getUnsafeBytes(), n, n);</span>
<span class="fc" id="L1204">                n &lt;&lt;= 1;</span>
            }
<span class="fc" id="L1206">            System.arraycopy(bytes.getUnsafeBytes(), 0, bytes.getUnsafeBytes(), n, len - n);</span>
        }
<span class="fc" id="L1208">        RubyString result = new RubyString(context.runtime, getMetaClass(), bytes);</span>
<span class="fc" id="L1209">        result.infectBy(this);</span>
<span class="fc" id="L1210">        return result;</span>
    }

    @JRubyMethod(name = &quot;%&quot;, required = 1)
    public IRubyObject op_format(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L1215">        return opFormatCommon(context, arg);</span>
    }

    private IRubyObject opFormatCommon(ThreadContext context, IRubyObject arg) {
        IRubyObject tmp;
<span class="fc bfc" id="L1220" title="All 2 branches covered.">        if (arg instanceof RubyHash) {</span>
<span class="fc" id="L1221">            tmp = arg;</span>
        } else {
<span class="fc" id="L1223">            tmp = arg.checkArrayType();</span>
<span class="fc bfc" id="L1224" title="All 2 branches covered.">            if (tmp.isNil()) tmp = arg;</span>
        }

<span class="fc" id="L1227">        ByteList out = new ByteList(value.getRealSize());</span>
<span class="fc" id="L1228">        out.setEncoding(value.getEncoding());</span>

        boolean tainted;

        // FIXME: Should we make this work with platform's locale,
        // or continue hardcoding US?
<span class="fc" id="L1234">        tainted = Sprintf.sprintf1_9(out, Locale.US, value, tmp);</span>

<span class="fc" id="L1236">        RubyString str = newString(context.runtime, out);</span>

<span class="fc bfc" id="L1238" title="All 4 branches covered.">        str.setTaint(tainted || isTaint());</span>
<span class="fc" id="L1239">        return str;</span>
    }

    @JRubyMethod
    @Override
    public RubyFixnum hash() {
<span class="fc" id="L1245">        Ruby runtime = getRuntime();</span>
<span class="fc" id="L1246">        return RubyFixnum.newFixnum(runtime, strHashCode(runtime));</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L1251">        return strHashCode(getRuntime());</span>
    }

    /**
     * Generate a hash for the String, using its associated Ruby instance's hash seed.
     *
     * @param runtime
     * @return
     */
    public int strHashCode(Ruby runtime) {
<span class="pc bpc" id="L1261" title="1 of 2 branches missed.">        long hash = runtime.isSiphashEnabled() ? SipHashInline.hash24(runtime.getHashSeedK0(),</span>
<span class="nc" id="L1262">                runtime.getHashSeedK1(), value.getUnsafeBytes(), value.getBegin(),</span>
<span class="pc" id="L1263">                value.getRealSize()) : PerlHash.hash(runtime.getHashSeedK0(),</span>
<span class="fc" id="L1264">                value.getUnsafeBytes(), value.getBegin(), value.getRealSize());</span>
<span class="pc bpc" id="L1265" title="2 of 4 branches missed.">        hash ^= (value.getEncoding().isAsciiCompatible() &amp;&amp; scanForCodeRange() == CR_7BIT ? 0</span>
<span class="pc" id="L1266">                : value.getEncoding().getIndex());</span>
<span class="fc" id="L1267">        return (int) hash;</span>
    }

    /**
     * Generate a hash for the String, without a seed.
     *
     * @param runtime
     * @return
     */
    public int unseededStrHashCode(Ruby runtime) {
<span class="nc bnc" id="L1277" title="All 2 branches missed.">        long hash = runtime.isSiphashEnabled() ? SipHashInline.hash24(0, 0, value.getUnsafeBytes(),</span>
<span class="nc" id="L1278">                value.getBegin(), value.getRealSize()) : PerlHash.hash(0, value.getUnsafeBytes(),</span>
<span class="nc" id="L1279">                value.getBegin(), value.getRealSize());</span>
<span class="nc bnc" id="L1280" title="All 4 branches missed.">        hash ^= (value.getEncoding().isAsciiCompatible() &amp;&amp; scanForCodeRange() == CR_7BIT ? 0</span>
<span class="nc" id="L1281">                : value.getEncoding().getIndex());</span>
<span class="nc" id="L1282">        return (int) hash;</span>
    }

    @Override
    public boolean equals(Object other) {
<span class="pc bpc" id="L1287" title="1 of 2 branches missed.">        if (this == other) return true;</span>

<span class="fc bfc" id="L1289" title="All 2 branches covered.">        if (other instanceof RubyString) {</span>
<span class="fc bfc" id="L1290" title="All 2 branches covered.">            if (((RubyString) other).value.equal(value)) return true;</span>
        }

<span class="fc" id="L1293">        return false;</span>
    }

    /** rb_obj_as_string
     *
     */
    public static RubyString objAsString(ThreadContext context, IRubyObject obj) {
<span class="fc bfc" id="L1300" title="All 2 branches covered.">        if (obj instanceof RubyString) return (RubyString) obj;</span>
<span class="fc" id="L1301">        IRubyObject str = obj.callMethod(context, &quot;to_s&quot;);</span>
<span class="pc bpc" id="L1302" title="1 of 2 branches missed.">        if (!(str instanceof RubyString)) return (RubyString) obj.anyToString();</span>
<span class="pc bpc" id="L1303" title="1 of 2 branches missed.">        if (obj.isTaint()) str.setTaint(true);</span>
<span class="fc" id="L1304">        return (RubyString) str;</span>
    }

    /** rb_str_cmp
     *
     */
    public final int op_cmp(RubyString other) {
<span class="fc" id="L1311">        int ret = value.cmp(other.value);</span>
<span class="fc bfc" id="L1312" title="All 4 branches covered.">        if (ret == 0 &amp;&amp; !isComparableWith(other)) {</span>
<span class="fc bfc" id="L1313" title="All 2 branches covered.">            return value.getEncoding().getIndex() &gt; other.value.getEncoding().getIndex() ? 1 : -1;</span>
        }
<span class="fc" id="L1315">        return ret;</span>
    }

    /** rb_to_id
     *
     */
    @Override
    public String asJavaString() {
<span class="fc" id="L1323">        return toString();</span>
    }

    public IRubyObject doClone(){
<span class="nc" id="L1327">        return newString(getRuntime(), value.dup());</span>
    }

    public final RubyString cat(byte[] str) {
<span class="fc" id="L1331">        modify(value.getRealSize() + str.length);</span>
<span class="fc" id="L1332">        System.arraycopy(str, 0, value.getUnsafeBytes(), value.getBegin() + value.getRealSize(), str.length);</span>
<span class="fc" id="L1333">        value.setRealSize(value.getRealSize() + str.length);</span>
<span class="fc" id="L1334">        return this;</span>
    }

    public final RubyString cat(byte[] str, int beg, int len) {
<span class="fc" id="L1338">        modify(value.getRealSize() + len);</span>
<span class="fc" id="L1339">        System.arraycopy(str, beg, value.getUnsafeBytes(), value.getBegin() + value.getRealSize(), len);</span>
<span class="fc" id="L1340">        value.setRealSize(value.getRealSize() + len);</span>
<span class="fc" id="L1341">        return this;</span>
    }

    // // rb_str_buf_append against VALUE
    public final RubyString cat19(RubyString str2) {
<span class="fc" id="L1346">        int str2_cr = cat19(str2.getByteList(), str2.getCodeRange());</span>

<span class="fc" id="L1348">        infectBy(str2);</span>
<span class="fc" id="L1349">        str2.setCodeRange(str2_cr);</span>

<span class="fc" id="L1351">        return this;</span>
    }

    // rb_str_buf_append against ptr
    public final int cat19(ByteList other, int codeRange) {
<span class="fc" id="L1356">        int[] ptr_cr_ret = {codeRange};</span>
<span class="fc" id="L1357">        EncodingUtils.encCrStrBufCat(getRuntime(), this, other, other.getEncoding(), codeRange, ptr_cr_ret);</span>
<span class="fc" id="L1358">        return ptr_cr_ret[0];</span>
    }

    public final RubyString cat(RubyString str) {
<span class="nc" id="L1362">        return cat(str.getByteList());</span>
    }

    public final RubyString cat(ByteList str) {
<span class="fc" id="L1366">        modify(value.getRealSize() + str.getRealSize());</span>
<span class="fc" id="L1367">        System.arraycopy(str.getUnsafeBytes(), str.getBegin(), value.getUnsafeBytes(), value.getBegin() + value.getRealSize(), str.getRealSize());</span>
<span class="fc" id="L1368">        value.setRealSize(value.getRealSize() + str.getRealSize());</span>
<span class="fc" id="L1369">        return this;</span>
    }

    public final RubyString cat(byte ch) {
<span class="fc" id="L1373">        modify(value.getRealSize() + 1);</span>
<span class="fc" id="L1374">        value.getUnsafeBytes()[value.getBegin() + value.getRealSize()] = ch;</span>
<span class="fc" id="L1375">        value.setRealSize(value.getRealSize() + 1);</span>
<span class="fc" id="L1376">        return this;</span>
    }

    public final RubyString cat(int ch) {
<span class="fc" id="L1380">        return cat((byte)ch);</span>
    }

    public final RubyString cat(int code, Encoding enc) {
<span class="nc" id="L1384">        int n = codeLength(getRuntime(), enc, code);</span>
<span class="nc" id="L1385">        modify(value.getRealSize() + n);</span>
<span class="nc" id="L1386">        enc.codeToMbc(code, value.getUnsafeBytes(), value.getBegin() + value.getRealSize());</span>
<span class="nc" id="L1387">        value.setRealSize(value.getRealSize() + n);</span>
<span class="nc" id="L1388">        return this;</span>
    }

    // rb_enc_str_buf_cat
    public final int cat(byte[]bytes, int p, int len, Encoding enc) {
<span class="fc" id="L1393">        int[] ptr_cr_ret = {CR_UNKNOWN};</span>
<span class="fc" id="L1394">        EncodingUtils.encCrStrBufCat(getRuntime(), this, new ByteList(bytes, p, len), enc, CR_UNKNOWN, ptr_cr_ret);</span>
<span class="fc" id="L1395">        return ptr_cr_ret[0];</span>
    }

    // rb_str_buf_cat_ascii
    public final RubyString catAscii(byte[]bytes, int ptr, int ptrLen) {
<span class="fc" id="L1400">        Encoding enc = value.getEncoding();</span>
<span class="pc bpc" id="L1401" title="1 of 2 branches missed.">        if (enc.isAsciiCompatible()) {</span>
<span class="nc" id="L1402">            EncodingUtils.encCrStrBufCat(getRuntime(), this, new ByteList(bytes, ptr, ptrLen), enc, CR_7BIT, null);</span>
        } else {
<span class="fc" id="L1404">            byte buf[] = new byte[enc.maxLength()];</span>
<span class="fc" id="L1405">            int end = ptr + ptrLen;</span>
<span class="fc bfc" id="L1406" title="All 2 branches covered.">            while (ptr &lt; end) {</span>
<span class="fc" id="L1407">                int c = bytes[ptr];</span>
<span class="fc" id="L1408">                int len = codeLength(getRuntime(), enc, c);</span>
<span class="fc" id="L1409">                EncodingUtils.encMbcput(c, buf, 0, enc);</span>
<span class="fc" id="L1410">                EncodingUtils.encCrStrBufCat(getRuntime(), this, buf, 0, len, enc, CR_VALID, null);</span>
<span class="fc" id="L1411">                ptr++;</span>
<span class="fc" id="L1412">            }</span>
        }
<span class="fc" id="L1414">        return this;</span>
    }

    /** rb_str_replace_m
     *
     */
    public IRubyObject replace(IRubyObject other) {
<span class="fc" id="L1421">        return replace19(other);</span>
    }

    @JRubyMethod(name = &quot;initialize_copy&quot;, required = 1, visibility = Visibility.PRIVATE)
    @Override
    public RubyString initialize_copy(IRubyObject other) {
<span class="fc" id="L1427">        return replace19(other);</span>
    }

    @JRubyMethod(name = &quot;replace&quot;, required = 1)
    public RubyString replace19(IRubyObject other) {
<span class="fc" id="L1432">        modifyCheck();</span>
<span class="pc bpc" id="L1433" title="1 of 2 branches missed.">        if (this == other) return this;</span>
<span class="fc" id="L1434">        setCodeRange(replaceCommon(other).getCodeRange()); // encoding doesn't have to be copied.</span>
<span class="fc" id="L1435">        return this;</span>
    }

    private RubyString replaceCommon(IRubyObject other) {
<span class="fc" id="L1439">        modifyCheck();</span>
<span class="fc" id="L1440">        RubyString otherStr = other.convertToString();</span>
<span class="fc" id="L1441">        otherStr.shareLevel = shareLevel = SHARE_LEVEL_BYTELIST;</span>
<span class="fc" id="L1442">        value = otherStr.value;</span>
<span class="fc" id="L1443">        infectBy(otherStr);</span>
<span class="fc" id="L1444">        return otherStr;</span>
    }

    @JRubyMethod
    public RubyString clear() {
<span class="fc" id="L1449">        modifyCheck();</span>
<span class="fc" id="L1450">        Encoding enc = value.getEncoding();</span>

<span class="fc" id="L1452">        EmptyByteListHolder holder = getEmptyByteList(enc);</span>
<span class="fc" id="L1453">        value = holder.bytes;</span>
<span class="fc" id="L1454">        shareLevel = SHARE_LEVEL_BYTELIST;</span>
<span class="fc" id="L1455">        setCodeRange(holder.cr);</span>
<span class="fc" id="L1456">        return this;</span>
    }

    public IRubyObject reverse(ThreadContext context) {
<span class="nc" id="L1460">        return reverse19(context);</span>
    }

    @JRubyMethod(name = &quot;reverse&quot;)
    public IRubyObject reverse19(ThreadContext context) {
<span class="fc" id="L1465">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L1466" title="All 2 branches covered.">        if (value.getRealSize() &lt;= 1) return strDup(context.runtime);</span>

<span class="fc" id="L1468">        byte[]bytes = value.getUnsafeBytes();</span>
<span class="fc" id="L1469">        int p = value.getBegin();</span>
<span class="fc" id="L1470">        int len = value.getRealSize();</span>
<span class="fc" id="L1471">        byte[]obytes = new byte[len];</span>

<span class="fc" id="L1473">        boolean single = true;</span>
<span class="fc" id="L1474">        Encoding enc = value.getEncoding();</span>
        // this really needs to be inlined here
<span class="fc bfc" id="L1476" title="All 2 branches covered.">        if (singleByteOptimizable(enc)) {</span>
<span class="fc bfc" id="L1477" title="All 2 branches covered.">            for (int i = 0; i &lt;= len &gt;&gt; 1; i++) {</span>
<span class="fc" id="L1478">                obytes[i] = bytes[p + len - i - 1];</span>
<span class="fc" id="L1479">                obytes[len - i - 1] = bytes[p + i];</span>
            }
        } else {
<span class="fc" id="L1482">            int end = p + len;</span>
<span class="fc" id="L1483">            int op = len;</span>
<span class="fc bfc" id="L1484" title="All 2 branches covered.">            while (p &lt; end) {</span>
<span class="fc" id="L1485">                int cl = StringSupport.length(enc, bytes, p, end);</span>
<span class="pc bpc" id="L1486" title="1 of 4 branches missed.">                if (cl &gt; 1 || (bytes[p] &amp; 0x80) != 0) {</span>
<span class="fc" id="L1487">                    single = false;</span>
<span class="fc" id="L1488">                    op -= cl;</span>
<span class="fc" id="L1489">                    System.arraycopy(bytes, p, obytes, op, cl);</span>
<span class="fc" id="L1490">                    p += cl;</span>
                } else {
<span class="fc" id="L1492">                    obytes[--op] = bytes[p++];</span>
                }
<span class="fc" id="L1494">            }</span>
        }

<span class="fc" id="L1497">        RubyString result = new RubyString(runtime, getMetaClass(), new ByteList(obytes, false));</span>

<span class="fc bfc" id="L1499" title="All 4 branches covered.">        if (getCodeRange() == CR_UNKNOWN) setCodeRange(single ? CR_7BIT : CR_VALID);</span>
<span class="fc" id="L1500">        Encoding encoding = value.getEncoding();</span>
<span class="fc" id="L1501">        result.value.setEncoding(encoding);</span>
<span class="fc" id="L1502">        result.copyCodeRangeForSubstr(this, encoding);</span>
<span class="fc" id="L1503">        return result.infectBy(this);</span>
    }

    public RubyString reverse_bang(ThreadContext context) {
<span class="nc" id="L1507">        return reverse_bang19(context);</span>
    }

    @JRubyMethod(name = &quot;reverse!&quot;)
    public RubyString reverse_bang19(ThreadContext context) {
<span class="fc" id="L1512">        modifyCheck();</span>
<span class="fc bfc" id="L1513" title="All 2 branches covered.">        if (value.getRealSize() &gt; 1) {</span>
<span class="fc" id="L1514">            modifyAndKeepCodeRange();</span>
<span class="fc" id="L1515">            byte[]bytes = value.getUnsafeBytes();</span>
<span class="fc" id="L1516">            int p = value.getBegin();</span>
<span class="fc" id="L1517">            int len = value.getRealSize();</span>

<span class="fc" id="L1519">            Encoding enc = value.getEncoding();</span>
            // this really needs to be inlined here
<span class="fc bfc" id="L1521" title="All 2 branches covered.">            if (singleByteOptimizable(enc)) {</span>
<span class="fc bfc" id="L1522" title="All 2 branches covered.">                for (int i = 0; i &lt; len &gt;&gt; 1; i++) {</span>
<span class="fc" id="L1523">                    byte b = bytes[p + i];</span>
<span class="fc" id="L1524">                    bytes[p + i] = bytes[p + len - i - 1];</span>
<span class="fc" id="L1525">                    bytes[p + len - i - 1] = b;</span>
                }
            } else {
<span class="fc" id="L1528">                int end = p + len;</span>
<span class="fc" id="L1529">                int op = len;</span>
<span class="fc" id="L1530">                byte[]obytes = new byte[len];</span>
<span class="fc" id="L1531">                boolean single = true;</span>
<span class="fc bfc" id="L1532" title="All 2 branches covered.">                while (p &lt; end) {</span>
<span class="fc" id="L1533">                    int cl = StringSupport.length(enc, bytes, p, end);</span>
<span class="pc bpc" id="L1534" title="1 of 4 branches missed.">                    if (cl &gt; 1 || (bytes[p] &amp; 0x80) != 0) {</span>
<span class="fc" id="L1535">                        single = false;</span>
<span class="fc" id="L1536">                        op -= cl;</span>
<span class="fc" id="L1537">                        System.arraycopy(bytes, p, obytes, op, cl);</span>
<span class="fc" id="L1538">                        p += cl;</span>
                    } else {
<span class="fc" id="L1540">                        obytes[--op] = bytes[p++];</span>
                    }
<span class="fc" id="L1542">                }</span>
<span class="fc" id="L1543">                value.setUnsafeBytes(obytes);</span>
<span class="pc bpc" id="L1544" title="1 of 4 branches missed.">                if (getCodeRange() == CR_UNKNOWN) setCodeRange(single ? CR_7BIT : CR_VALID);</span>
            }
        }
<span class="fc" id="L1547">        return this;</span>
    }

    /** rb_str_s_new
     *
     */
    public static RubyString newInstance(IRubyObject recv, IRubyObject[] args, Block block) {
<span class="nc" id="L1554">        RubyString newString = newStringShared(recv.getRuntime(), ByteList.EMPTY_BYTELIST);</span>
<span class="nc" id="L1555">        newString.setMetaClass((RubyClass) recv);</span>
<span class="nc" id="L1556">        newString.callInit(args, block);</span>
<span class="nc" id="L1557">        return newString;</span>
    }

    @Override
    public IRubyObject initialize(ThreadContext context) {
<span class="nc" id="L1562">        return initialize19(context);</span>
    }

    public IRubyObject initialize(ThreadContext context, IRubyObject arg0) {
<span class="nc" id="L1566">        return initialize19(context, arg0);</span>
    }

    @JRubyMethod(name = &quot;initialize&quot;, visibility = PRIVATE)
    @Override
    public IRubyObject initialize19(ThreadContext context) {
<span class="fc" id="L1572">        return this;</span>
    }

    @JRubyMethod(name = &quot;initialize&quot;, visibility = PRIVATE)
    public IRubyObject initialize19(ThreadContext context, IRubyObject arg0) {
<span class="fc" id="L1577">        replace19(arg0);</span>
<span class="fc" id="L1578">        return this;</span>
    }

    public IRubyObject casecmp(ThreadContext context, IRubyObject other) {
<span class="nc" id="L1582">        return casecmp19(context, other);</span>
    }

    @JRubyMethod(name = &quot;casecmp&quot;)
    public IRubyObject casecmp19(ThreadContext context, IRubyObject other) {
<span class="fc" id="L1587">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L1588">        RubyString otherStr = other.convertToString();</span>
<span class="fc" id="L1589">        Encoding enc = isCompatibleWith(otherStr);</span>
<span class="pc bpc" id="L1590" title="1 of 2 branches missed.">        if (enc == null) return runtime.getNil();</span>

<span class="pc bpc" id="L1592" title="2 of 4 branches missed.">        if (singleByteOptimizable() &amp;&amp; otherStr.singleByteOptimizable()) {</span>
<span class="fc" id="L1593">            return RubyFixnum.newFixnum(runtime, value.caseInsensitiveCmp(otherStr.value));</span>
        } else {
<span class="nc" id="L1595">            return multiByteCasecmp(runtime, enc, value, otherStr.value);</span>
        }
    }

    private IRubyObject multiByteCasecmp(Ruby runtime, Encoding enc, ByteList value, ByteList otherValue) {
<span class="nc" id="L1600">        byte[]bytes = value.getUnsafeBytes();</span>
<span class="nc" id="L1601">        int p = value.getBegin();</span>
<span class="nc" id="L1602">        int end = p + value.getRealSize();</span>

<span class="nc" id="L1604">        byte[]obytes = otherValue.getUnsafeBytes();</span>
<span class="nc" id="L1605">        int op = otherValue.getBegin();</span>
<span class="nc" id="L1606">        int oend = op + otherValue.getRealSize();</span>

<span class="nc bnc" id="L1608" title="All 4 branches missed.">        while (p &lt; end &amp;&amp; op &lt; oend) {</span>
            final int c, oc;
<span class="nc bnc" id="L1610" title="All 2 branches missed.">            if (enc.isAsciiCompatible()) {</span>
<span class="nc" id="L1611">                c = bytes[p] &amp; 0xff;</span>
<span class="nc" id="L1612">                oc = obytes[op] &amp; 0xff;</span>
            } else {
<span class="nc" id="L1614">                c = StringSupport.preciseCodePoint(enc, bytes, p, end);</span>
<span class="nc" id="L1615">                oc = StringSupport.preciseCodePoint(enc, obytes, op, oend);</span>
            }

            int cl, ocl;
<span class="nc bnc" id="L1619" title="All 4 branches missed.">            if (Encoding.isAscii(c) &amp;&amp; Encoding.isAscii(oc)) {</span>
<span class="nc" id="L1620">                byte uc = AsciiTables.ToUpperCaseTable[c];</span>
<span class="nc" id="L1621">                byte uoc = AsciiTables.ToUpperCaseTable[oc];</span>
<span class="nc bnc" id="L1622" title="All 2 branches missed.">                if (uc != uoc) {</span>
<span class="nc bnc" id="L1623" title="All 2 branches missed.">                    return uc &lt; uoc ? RubyFixnum.minus_one(runtime) : RubyFixnum.one(runtime);</span>
                }
<span class="nc" id="L1625">                cl = ocl = 1;</span>
<span class="nc" id="L1626">            } else {</span>
<span class="nc" id="L1627">                cl = StringSupport.length(enc, bytes, p, end);</span>
<span class="nc" id="L1628">                ocl = StringSupport.length(enc, obytes, op, oend);</span>
                // TODO: opt for 2 and 3 ?
<span class="nc bnc" id="L1630" title="All 2 branches missed.">                int ret = StringSupport.caseCmp(bytes, p, obytes, op, cl &lt; ocl ? cl : ocl);</span>
<span class="nc bnc" id="L1631" title="All 4 branches missed.">                if (ret != 0) return ret &lt; 0 ? RubyFixnum.minus_one(runtime) : RubyFixnum.one(runtime);</span>
<span class="nc bnc" id="L1632" title="All 4 branches missed.">                if (cl != ocl) return cl &lt; ocl ? RubyFixnum.minus_one(runtime) : RubyFixnum.one(runtime);</span>
            }

<span class="nc" id="L1635">            p += cl;</span>
<span class="nc" id="L1636">            op += ocl;</span>
<span class="nc" id="L1637">        }</span>
<span class="nc bnc" id="L1638" title="All 2 branches missed.">        if (end - p == oend - op) return RubyFixnum.zero(runtime);</span>
<span class="nc bnc" id="L1639" title="All 2 branches missed.">        return end - p &gt; oend - op ? RubyFixnum.one(runtime) : RubyFixnum.minus_one(runtime);</span>
    }

    /** rb_str_match
     *
     */
    @Override
    public IRubyObject op_match(ThreadContext context, IRubyObject other) {
<span class="nc" id="L1647">        return op_match19(context, other);</span>
    }

    @JRubyMethod(name = &quot;=~&quot;, writes = BACKREF)
    @Override
    public IRubyObject op_match19(ThreadContext context, IRubyObject other) {
<span class="fc bfc" id="L1653" title="All 2 branches covered.">        if (other instanceof RubyRegexp) return ((RubyRegexp) other).op_match19(context, this);</span>
<span class="fc bfc" id="L1654" title="All 2 branches covered.">        if (other instanceof RubyString) throw context.runtime.newTypeError(&quot;type mismatch: String given&quot;);</span>
<span class="fc" id="L1655">        return other.callMethod(context, &quot;=~&quot;, this);</span>
    }
    /**
     * String#match(pattern)
     *
     * rb_str_match_m
     *
     * @param pattern Regexp or String
     */
    public IRubyObject match(ThreadContext context, IRubyObject pattern) {
<span class="nc" id="L1665">        return match19(context, pattern, Block.NULL_BLOCK);</span>
    }

    @JRubyMethod(name = &quot;match&quot;, reads = BACKREF)
    public IRubyObject match19(ThreadContext context, IRubyObject pattern, Block block) {
<span class="fc" id="L1670">        IRubyObject result = getPattern(pattern).callMethod(context, &quot;match&quot;, this);</span>
<span class="pc bpc" id="L1671" title="1 of 4 branches missed.">        return block.isGiven() &amp;&amp; !result.isNil() ? block.yield(context, result) : result;</span>
    }

    @JRubyMethod(name = &quot;match&quot;, required = 1, rest = true, reads = BACKREF)
    public IRubyObject match19(ThreadContext context, IRubyObject[] args, Block block) {
<span class="fc" id="L1676">        RubyRegexp pattern = getPattern(args[0]);</span>
<span class="fc" id="L1677">        args[0] = this;</span>
<span class="fc" id="L1678">        IRubyObject result = pattern.callMethod(context, &quot;match&quot;, args);</span>
<span class="fc bfc" id="L1679" title="All 4 branches covered.">        return block.isGiven() &amp;&amp; !result.isNil() ? block.yield(context, result) : result;</span>
    }

    /** rb_str_capitalize / rb_str_capitalize_bang
     *
     */
    public IRubyObject capitalize(ThreadContext context) {
<span class="nc" id="L1686">        return capitalize19(context);</span>
    }

    public IRubyObject capitalize_bang(ThreadContext context) {
<span class="nc" id="L1690">        return capitalize_bang19(context);</span>
    }

    @JRubyMethod(name = &quot;capitalize&quot;)
    public IRubyObject capitalize19(ThreadContext context) {
<span class="fc" id="L1695">        RubyString str = strDup(context.runtime);</span>
<span class="fc" id="L1696">        str.capitalize_bang19(context);</span>
<span class="fc" id="L1697">        return str;</span>
    }

    @JRubyMethod(name = &quot;capitalize!&quot;)
    public IRubyObject capitalize_bang19(ThreadContext context) {
<span class="fc" id="L1702">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L1703">        Encoding enc = checkDummyEncoding();</span>

<span class="fc bfc" id="L1705" title="All 2 branches covered.">        if (value.getRealSize() == 0) {</span>
<span class="fc" id="L1706">            modifyCheck();</span>
<span class="fc" id="L1707">            return runtime.getNil();</span>
        }

<span class="fc" id="L1710">        modifyAndKeepCodeRange();</span>

<span class="fc" id="L1712">        int s = value.getBegin();</span>
<span class="fc" id="L1713">        int end = s + value.getRealSize();</span>
<span class="fc" id="L1714">        byte[]bytes = value.getUnsafeBytes();</span>
<span class="fc" id="L1715">        boolean modify = false;</span>

<span class="fc" id="L1717">        int c = codePoint(runtime, enc, bytes, s, end);</span>
<span class="fc bfc" id="L1718" title="All 2 branches covered.">        if (enc.isLower(c)) {</span>
<span class="fc" id="L1719">            enc.codeToMbc(toUpper(enc, c), bytes, s);</span>
<span class="fc" id="L1720">            modify = true;</span>
        }

<span class="fc" id="L1723">        s += codeLength(runtime, enc, c);</span>
<span class="fc bfc" id="L1724" title="All 2 branches covered.">        while (s &lt; end) {</span>
<span class="fc" id="L1725">            c = codePoint(runtime, enc, bytes, s, end);</span>
<span class="fc bfc" id="L1726" title="All 2 branches covered.">            if (enc.isUpper(c)) {</span>
<span class="fc" id="L1727">                enc.codeToMbc(toLower(enc, c), bytes, s);</span>
<span class="fc" id="L1728">                modify = true;</span>
            }
<span class="fc" id="L1730">            s += codeLength(runtime, enc, c);</span>
        }

<span class="fc bfc" id="L1733" title="All 2 branches covered.">        return modify ? this : runtime.getNil();</span>
    }

    public IRubyObject op_ge(ThreadContext context, IRubyObject other) {
<span class="nc" id="L1737">        return op_ge19(context, other);</span>
    }

    @JRubyMethod(name = &quot;&gt;=&quot;)
    public IRubyObject op_ge19(ThreadContext context, IRubyObject other) {
<span class="pc bpc" id="L1742" title="1 of 4 branches missed.">        if (other instanceof RubyString) return context.runtime.newBoolean(op_cmp((RubyString) other) &gt;= 0);</span>
<span class="nc" id="L1743">        return RubyComparable.op_ge(context, this, other);</span>
    }

    public IRubyObject op_gt(ThreadContext context, IRubyObject other) {
<span class="nc" id="L1747">        return op_gt19(context, other);</span>
    }

    @JRubyMethod(name = &quot;&gt;&quot;)
    public IRubyObject op_gt19(ThreadContext context, IRubyObject other) {
<span class="nc bnc" id="L1752" title="All 4 branches missed.">        if (other instanceof RubyString) return context.runtime.newBoolean(op_cmp((RubyString) other) &gt; 0);</span>
<span class="nc" id="L1753">        return RubyComparable.op_gt(context, this, other);</span>
    }

    public IRubyObject op_le(ThreadContext context, IRubyObject other) {
<span class="nc" id="L1757">        return op_le19(context, other);</span>
    }

    @JRubyMethod(name = &quot;&lt;=&quot;)
    public IRubyObject op_le19(ThreadContext context, IRubyObject other) {
<span class="nc bnc" id="L1762" title="All 4 branches missed.">        if (other instanceof RubyString) return context.runtime.newBoolean(op_cmp((RubyString) other) &lt;= 0);</span>
<span class="nc" id="L1763">        return RubyComparable.op_le(context, this, other);</span>
    }

    public IRubyObject op_lt(ThreadContext context, IRubyObject other) {
<span class="nc" id="L1767">        return op_lt19(context, other);</span>
    }

    @JRubyMethod(name = &quot;&lt;&quot;)
    public IRubyObject op_lt19(ThreadContext context, IRubyObject other) {
<span class="nc bnc" id="L1772" title="All 4 branches missed.">        if (other instanceof RubyString) return context.runtime.newBoolean(op_cmp((RubyString) other) &lt; 0);</span>
<span class="nc" id="L1773">        return RubyComparable.op_lt(context, this, other);</span>
    }

    public IRubyObject str_eql_p(ThreadContext context, IRubyObject other) {
<span class="nc" id="L1777">        return str_eql_p19(context, other);</span>
    }

    @JRubyMethod(name = &quot;eql?&quot;)
    public IRubyObject str_eql_p19(ThreadContext context, IRubyObject other) {
<span class="fc" id="L1782">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L1783" title="All 2 branches covered.">        if (other instanceof RubyString) {</span>
<span class="fc" id="L1784">            RubyString otherString = (RubyString)other;</span>
<span class="fc bfc" id="L1785" title="All 4 branches covered.">            if (isComparableWith(otherString) &amp;&amp; value.equal(otherString.value)) return runtime.getTrue();</span>
        }
<span class="fc" id="L1787">        return runtime.getFalse();</span>
    }

    /** rb_str_upcase / rb_str_upcase_bang
     *
     */
    public RubyString upcase(ThreadContext context) {
<span class="nc" id="L1794">        return upcase19(context);</span>
    }

    public IRubyObject upcase_bang(ThreadContext context) {
<span class="nc" id="L1798">        return upcase_bang19(context);</span>
    }

    @JRubyMethod(name = &quot;upcase&quot;)
    public RubyString upcase19(ThreadContext context) {
<span class="fc" id="L1803">        RubyString str = strDup(context.runtime);</span>
<span class="fc" id="L1804">        str.upcase_bang19(context);</span>
<span class="fc" id="L1805">        return str;</span>
    }

    @JRubyMethod(name = &quot;upcase!&quot;)
    public IRubyObject upcase_bang19(ThreadContext context) {
<span class="fc" id="L1810">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L1811">        Encoding enc = checkDummyEncoding();</span>

<span class="fc bfc" id="L1813" title="All 2 branches covered.">        if (value.getRealSize() == 0) {</span>
<span class="fc" id="L1814">            modifyCheck();</span>
<span class="fc" id="L1815">            return runtime.getNil();</span>
        }

<span class="fc" id="L1818">        modifyAndKeepCodeRange();</span>

<span class="fc" id="L1820">        int s = value.getBegin();</span>
<span class="fc" id="L1821">        int end = s + value.getRealSize();</span>
<span class="fc" id="L1822">        byte[]bytes = value.getUnsafeBytes();</span>

<span class="fc bfc" id="L1824" title="All 2 branches covered.">        if (singleByteOptimizable(enc)) {</span>
<span class="fc" id="L1825">            return singleByteUpcase(runtime, bytes, s, end);</span>
        } else {
<span class="fc" id="L1827">            return multiByteUpcase(runtime, enc, bytes, s, end);</span>
        }
    }

    private IRubyObject singleByteUpcase(Ruby runtime, byte[]bytes, int s, int end) {
<span class="fc" id="L1832">        boolean modify = false;</span>
<span class="fc bfc" id="L1833" title="All 2 branches covered.">        while (s &lt; end) {</span>
<span class="fc" id="L1834">            int c = bytes[s] &amp; 0xff;</span>
<span class="fc bfc" id="L1835" title="All 2 branches covered.">            if (ASCII.isLower(c)) {</span>
<span class="fc" id="L1836">                bytes[s] = AsciiTables.ToUpperCaseTable[c];</span>
<span class="fc" id="L1837">                modify = true;</span>
            }
<span class="fc" id="L1839">            s++;</span>
<span class="fc" id="L1840">        }</span>
<span class="fc bfc" id="L1841" title="All 2 branches covered.">        return modify ? this : runtime.getNil();</span>
    }

    private IRubyObject multiByteUpcase(Ruby runtime, Encoding enc, byte[]bytes, int s, int end) {
<span class="fc" id="L1845">        boolean modify = false;</span>
        int c;
<span class="fc bfc" id="L1847" title="All 2 branches covered.">        while (s &lt; end) {</span>
<span class="pc bpc" id="L1848" title="1 of 4 branches missed.">            if (enc.isAsciiCompatible() &amp;&amp; Encoding.isAscii(c = bytes[s] &amp; 0xff)) {</span>
<span class="fc bfc" id="L1849" title="All 2 branches covered.">                if (ASCII.isLower(c)) {</span>
<span class="fc" id="L1850">                    bytes[s] = AsciiTables.ToUpperCaseTable[c];</span>
<span class="fc" id="L1851">                    modify = true;</span>
                }
<span class="fc" id="L1853">                s++;</span>
            } else {
<span class="fc" id="L1855">                c = codePoint(runtime, enc, bytes, s, end);</span>
<span class="fc bfc" id="L1856" title="All 2 branches covered.">                if (enc.isLower(c)) {</span>
<span class="fc" id="L1857">                    enc.codeToMbc(toUpper(enc, c), bytes, s);</span>
<span class="fc" id="L1858">                    modify = true;</span>
                }
<span class="fc" id="L1860">                s += codeLength(runtime, enc, c);</span>
            }
        }
<span class="fc bfc" id="L1863" title="All 2 branches covered.">        return modify ? this : runtime.getNil();</span>
    }

    /** rb_str_downcase / rb_str_downcase_bang
     *
     */
    public RubyString downcase(ThreadContext context) {
<span class="nc" id="L1870">        return downcase19(context);</span>
    }

    public IRubyObject downcase_bang(ThreadContext context) {
<span class="nc" id="L1874">        return downcase_bang19(context);</span>
    }

    @JRubyMethod(name = &quot;downcase&quot;)
    public RubyString downcase19(ThreadContext context) {
<span class="fc" id="L1879">        RubyString str = strDup(context.runtime);</span>
<span class="fc" id="L1880">        str.downcase_bang19(context);</span>
<span class="fc" id="L1881">        return str;</span>
    }

    @JRubyMethod(name = &quot;downcase!&quot;)
    public IRubyObject downcase_bang19(ThreadContext context) {
<span class="fc" id="L1886">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L1887">        Encoding enc = checkDummyEncoding();</span>

<span class="fc bfc" id="L1889" title="All 2 branches covered.">        if (value.getRealSize() == 0) {</span>
<span class="fc" id="L1890">            modifyCheck();</span>
<span class="fc" id="L1891">            return runtime.getNil();</span>
        }

<span class="fc" id="L1894">        modifyAndKeepCodeRange();</span>

<span class="fc" id="L1896">        int s = value.getBegin();</span>
<span class="fc" id="L1897">        int end = s + value.getRealSize();</span>
<span class="fc" id="L1898">        byte[]bytes = value.getUnsafeBytes();</span>

<span class="fc bfc" id="L1900" title="All 2 branches covered.">        if (singleByteOptimizable(enc)) {</span>
<span class="fc" id="L1901">            return singleByteDowncase(runtime, bytes, s, end);</span>
        } else {
<span class="fc" id="L1903">            return multiByteDowncase(runtime, enc, bytes, s, end);</span>
        }
    }

    private IRubyObject singleByteDowncase(Ruby runtime, byte[]bytes, int s, int end) {
<span class="fc" id="L1908">        boolean modify = false;</span>
<span class="fc bfc" id="L1909" title="All 2 branches covered.">        while (s &lt; end) {</span>
<span class="fc" id="L1910">            int c = bytes[s] &amp; 0xff;</span>
<span class="fc bfc" id="L1911" title="All 2 branches covered.">            if (ASCII.isUpper(c)) {</span>
<span class="fc" id="L1912">                bytes[s] = AsciiTables.ToLowerCaseTable[c];</span>
<span class="fc" id="L1913">                modify = true;</span>
            }
<span class="fc" id="L1915">            s++;</span>
<span class="fc" id="L1916">        }</span>
<span class="fc bfc" id="L1917" title="All 2 branches covered.">        return modify ? this : runtime.getNil();</span>
    }

    private IRubyObject multiByteDowncase(Ruby runtime, Encoding enc, byte[]bytes, int s, int end) {
<span class="fc" id="L1921">        boolean modify = false;</span>
        int c;
<span class="fc bfc" id="L1923" title="All 2 branches covered.">        while (s &lt; end) {</span>
<span class="pc bpc" id="L1924" title="1 of 4 branches missed.">            if (enc.isAsciiCompatible() &amp;&amp; Encoding.isAscii(c = bytes[s] &amp; 0xff)) {</span>
<span class="fc bfc" id="L1925" title="All 2 branches covered.">                if (ASCII.isUpper(c)) {</span>
<span class="fc" id="L1926">                    bytes[s] = AsciiTables.ToLowerCaseTable[c];</span>
<span class="fc" id="L1927">                    modify = true;</span>
                }
<span class="fc" id="L1929">                s++;</span>
            } else {
<span class="fc" id="L1931">                c = codePoint(runtime, enc, bytes, s, end);</span>
<span class="fc bfc" id="L1932" title="All 2 branches covered.">                if (enc.isUpper(c)) {</span>
<span class="fc" id="L1933">                    enc.codeToMbc(toLower(enc, c), bytes, s);</span>
<span class="fc" id="L1934">                    modify = true;</span>
                }
<span class="fc" id="L1936">                s += codeLength(runtime, enc, c);</span>
            }
        }
<span class="fc bfc" id="L1939" title="All 2 branches covered.">        return modify ? this : runtime.getNil();</span>
    }


    /** rb_str_swapcase / rb_str_swapcase_bang
     *
     */
    public RubyString swapcase(ThreadContext context) {
<span class="nc" id="L1947">        return swapcase19(context);</span>
    }

    public IRubyObject swapcase_bang(ThreadContext context) {
<span class="nc" id="L1951">        return swapcase_bang19(context);</span>
    }

    @JRubyMethod(name = &quot;swapcase&quot;)
    public RubyString swapcase19(ThreadContext context) {
<span class="fc" id="L1956">        RubyString str = strDup(context.runtime);</span>
<span class="fc" id="L1957">        str.swapcase_bang19(context);</span>
<span class="fc" id="L1958">        return str;</span>
    }

    @JRubyMethod(name = &quot;swapcase!&quot;)
    public IRubyObject swapcase_bang19(ThreadContext context) {
<span class="fc" id="L1963">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L1964">        Encoding enc = checkDummyEncoding();</span>
<span class="fc bfc" id="L1965" title="All 2 branches covered.">        if (value.getRealSize() == 0) {</span>
<span class="fc" id="L1966">            modifyCheck();</span>
<span class="fc" id="L1967">            return runtime.getNil();</span>
        }
<span class="fc" id="L1969">        modifyAndKeepCodeRange();</span>

<span class="fc" id="L1971">        int s = value.getBegin();</span>
<span class="fc" id="L1972">        int end = s + value.getRealSize();</span>
<span class="fc" id="L1973">        byte[]bytes = value.getUnsafeBytes();</span>

<span class="pc bpc" id="L1975" title="1 of 2 branches missed.">        if (singleByteOptimizable(enc)) {</span>
<span class="nc" id="L1976">            return singleByteSwapcase(runtime, bytes, s, end);</span>
        } else {
<span class="fc" id="L1978">            return multiByteSwapcase(runtime, enc, bytes, s, end);</span>
        }
    }

    private IRubyObject singleByteSwapcase(Ruby runtime, byte[]bytes, int s, int end) {
<span class="nc" id="L1983">        boolean modify = false;</span>
<span class="nc bnc" id="L1984" title="All 2 branches missed.">        while (s &lt; end) {</span>
<span class="nc" id="L1985">            int c = bytes[s] &amp; 0xff;</span>
<span class="nc bnc" id="L1986" title="All 2 branches missed.">            if (ASCII.isUpper(c)) {</span>
<span class="nc" id="L1987">                bytes[s] = AsciiTables.ToLowerCaseTable[c];</span>
<span class="nc" id="L1988">                modify = true;</span>
<span class="nc bnc" id="L1989" title="All 2 branches missed.">            } else if (ASCII.isLower(c)) {</span>
<span class="nc" id="L1990">                bytes[s] = AsciiTables.ToUpperCaseTable[c];</span>
<span class="nc" id="L1991">                modify = true;</span>
            }
<span class="nc" id="L1993">            s++;</span>
<span class="nc" id="L1994">        }</span>

<span class="nc bnc" id="L1996" title="All 2 branches missed.">        return modify ? this : runtime.getNil();</span>
    }

    private IRubyObject multiByteSwapcase(Ruby runtime, Encoding enc, byte[]bytes, int s, int end) {
<span class="fc" id="L2000">        boolean modify = false;</span>
<span class="fc bfc" id="L2001" title="All 2 branches covered.">        while (s &lt; end) {</span>
<span class="fc" id="L2002">            int c = codePoint(runtime, enc, bytes, s, end);</span>
<span class="fc bfc" id="L2003" title="All 2 branches covered.">            if (enc.isUpper(c)) {</span>
<span class="fc" id="L2004">                enc.codeToMbc(toLower(enc, c), bytes, s);</span>
<span class="fc" id="L2005">                modify = true;</span>
<span class="fc bfc" id="L2006" title="All 2 branches covered.">            } else if (enc.isLower(c)) {</span>
<span class="fc" id="L2007">                enc.codeToMbc(toUpper(enc, c), bytes, s);</span>
<span class="fc" id="L2008">                modify = true;</span>
            }
<span class="fc" id="L2010">            s += codeLength(runtime, enc, c);</span>
<span class="fc" id="L2011">        }</span>

<span class="fc bfc" id="L2013" title="All 2 branches covered.">        return modify ? this : runtime.getNil();</span>
    }

    /** rb_str_dump
     *
     */
    public IRubyObject dump() {
<span class="fc" id="L2020">        return dump19();</span>
    }

    @JRubyMethod(name = &quot;dump&quot;)
    public IRubyObject dump19() {
<span class="fc" id="L2025">        ByteList outBytes = StringSupport.dumpCommon(getRuntime(), value);</span>

<span class="fc" id="L2027">        final RubyString result = new RubyString(getRuntime(), getMetaClass(), outBytes);</span>
<span class="fc" id="L2028">        Encoding enc = value.getEncoding();</span>

<span class="fc bfc" id="L2030" title="All 2 branches covered.">        if (!enc.isAsciiCompatible()) {</span>
<span class="fc" id="L2031">            result.cat(&quot;.force_encoding(\&quot;&quot;.getBytes());</span>
<span class="fc" id="L2032">            result.cat(enc.getName());</span>
<span class="fc" id="L2033">            result.cat((byte)'&quot;').cat((byte)')');</span>
<span class="fc" id="L2034">            enc = ASCII;</span>
        }
<span class="fc" id="L2036">        result.associateEncoding(enc);</span>
<span class="fc" id="L2037">        result.setCodeRange(CR_7BIT);</span>

<span class="fc" id="L2039">        return result.infectBy(this);</span>
    }

    public IRubyObject insert(ThreadContext context, IRubyObject indexArg, IRubyObject stringArg) {
<span class="nc" id="L2043">        return insert19(context, indexArg, stringArg);</span>
    }

    @JRubyMethod(name = &quot;insert&quot;)
    public IRubyObject insert19(ThreadContext context, IRubyObject indexArg, IRubyObject stringArg) {
<span class="fc" id="L2048">        RubyString str = stringArg.convertToString();</span>
<span class="fc" id="L2049">        int index = RubyNumeric.num2int(indexArg);</span>
<span class="fc bfc" id="L2050" title="All 2 branches covered.">        if (index == -1) return append19(stringArg);</span>
<span class="fc bfc" id="L2051" title="All 2 branches covered.">        if (index &lt; 0) index++;</span>
<span class="fc" id="L2052">        replaceInternal19(checkIndex(index, strLength()), 0, str);</span>
<span class="fc" id="L2053">        return this;</span>
    }

    private int checkIndex(int beg, int len) {
<span class="pc bpc" id="L2057" title="1 of 2 branches missed.">        if (beg &gt; len) raiseIndexOutOfString(beg);</span>
<span class="fc bfc" id="L2058" title="All 2 branches covered.">        if (beg &lt; 0) {</span>
<span class="pc bpc" id="L2059" title="1 of 2 branches missed.">            if (-beg &gt; len) raiseIndexOutOfString(beg);</span>
<span class="fc" id="L2060">            beg += len;</span>
        }
<span class="fc" id="L2062">        return beg;</span>
    }

    private int checkIndexForRef(int beg, int len) {
<span class="pc bpc" id="L2066" title="1 of 2 branches missed.">        if (beg &gt;= len) raiseIndexOutOfString(beg);</span>
<span class="fc bfc" id="L2067" title="All 2 branches covered.">        if (beg &lt; 0) {</span>
<span class="pc bpc" id="L2068" title="1 of 2 branches missed.">            if (-beg &gt; len) raiseIndexOutOfString(beg);</span>
<span class="fc" id="L2069">            beg += len;</span>
        }
<span class="fc" id="L2071">        return beg;</span>
    }

    private int checkLength(int len) {
<span class="fc bfc" id="L2075" title="All 2 branches covered.">        if (len &lt; 0) throw getRuntime().newIndexError(&quot;negative length &quot; + len);</span>
<span class="fc" id="L2076">        return len;</span>
    }

    private void raiseIndexOutOfString(int index) {
<span class="fc" id="L2080">        throw getRuntime().newIndexError(&quot;index &quot; + index + &quot; out of string&quot;);</span>
    }

    /** rb_str_inspect
     *
     */
    @Override
    public IRubyObject inspect() {
<span class="fc" id="L2088">        return inspect19();</span>
    }

    @JRubyMethod(name = &quot;inspect&quot;)
    public IRubyObject inspect19() {
<span class="fc" id="L2093">        return inspect19(getRuntime(), value).infectBy(this);</span>
    }

    public static IRubyObject inspect19(Ruby runtime, ByteList byteList) {
<span class="fc" id="L2097">        byte bytes[] = byteList.getUnsafeBytes();</span>
<span class="fc" id="L2098">        int p = byteList.getBegin();</span>
<span class="fc" id="L2099">        int end = p + byteList.getRealSize();</span>
<span class="fc" id="L2100">        RubyString result = new RubyString(runtime, runtime.getString(), new ByteList(end - p));</span>
<span class="fc" id="L2101">        Encoding enc = byteList.getEncoding();</span>

<span class="fc" id="L2103">        Encoding resultEnc = runtime.getDefaultInternalEncoding();</span>
<span class="fc bfc" id="L2104" title="All 2 branches covered.">        if (resultEnc == null) resultEnc = runtime.getDefaultExternalEncoding();</span>
<span class="fc bfc" id="L2105" title="All 2 branches covered.">        if (!resultEnc.isAsciiCompatible()) resultEnc = USASCIIEncoding.INSTANCE;</span>
<span class="fc" id="L2106">        result.associateEncoding(resultEnc);</span>

<span class="fc" id="L2108">        boolean isUnicode = StringSupport.isUnicode(enc);</span>

<span class="fc" id="L2110">        EncodingDB.Entry e = null;</span>
<span class="fc" id="L2111">        CaseInsensitiveBytesHash&lt;EncodingDB.Entry&gt; encodings = runtime.getEncodingService().getEncodings();</span>
<span class="pc bpc" id="L2112" title="3 of 4 branches missed.">        if (enc == encodings.get(&quot;UTF-16&quot;.getBytes()).getEncoding() &amp;&amp; end - p &gt; 1) {</span>
<span class="nc" id="L2113">            int c0 = bytes[p] &amp; 0xff;</span>
<span class="nc" id="L2114">            int c1 = bytes[p + 1] &amp; 0xff;</span>

<span class="nc bnc" id="L2116" title="All 4 branches missed.">            if (c0 == 0xFE &amp;&amp; c1 == 0xFF) {</span>
<span class="nc" id="L2117">                e = encodings.get(&quot;UTF-16BE&quot;.getBytes());</span>
<span class="nc bnc" id="L2118" title="All 4 branches missed.">            } else if (c0 == 0xFF &amp;&amp; c1 == 0xFE) {</span>
<span class="nc" id="L2119">                e = encodings.get(&quot;UTF-16LE&quot;.getBytes());</span>
            } else {
<span class="nc" id="L2121">                isUnicode = false;</span>
            }
<span class="pc bpc" id="L2123" title="3 of 4 branches missed.">        } else if (enc == encodings.get(&quot;UTF-32&quot;.getBytes()).getEncoding() &amp;&amp; end - p &gt; 3) {</span>
<span class="nc" id="L2124">            int c0 = bytes[p] &amp; 0xff;</span>
<span class="nc" id="L2125">            int c1 = bytes[p + 1] &amp; 0xff;</span>
<span class="nc" id="L2126">            int c2 = bytes[p + 2] &amp; 0xff;</span>
<span class="nc" id="L2127">            int c3 = bytes[p + 3] &amp; 0xff;</span>

<span class="nc bnc" id="L2129" title="All 8 branches missed.">            if (c0 == 0 &amp;&amp; c1 == 0 &amp;&amp; c2 == 0xFE &amp;&amp; c3 == 0xFF) {</span>
<span class="nc" id="L2130">                e = encodings.get(&quot;UTF-32BE&quot;.getBytes());</span>
<span class="nc bnc" id="L2131" title="All 8 branches missed.">            } else if (c3 == 0 &amp;&amp; c2 == 0 &amp;&amp; c1 == 0xFE &amp;&amp; c0 == 0xFF) {</span>
<span class="nc" id="L2132">                e = encodings.get(&quot;UTF-32LE&quot;.getBytes());</span>
            } else {
<span class="nc" id="L2134">                isUnicode = false;</span>
            }
        }

<span class="pc bpc" id="L2138" title="1 of 2 branches missed.">        if (e != null) enc = e.getEncoding();</span>

<span class="fc" id="L2140">        result.cat('&quot;');</span>
<span class="fc" id="L2141">        int prev = p;</span>
<span class="fc bfc" id="L2142" title="All 2 branches covered.">        while (p &lt; end) {</span>
<span class="fc" id="L2143">            int cc = 0;</span>

<span class="fc" id="L2145">            int n = StringSupport.preciseLength(enc, bytes, p, end);</span>
<span class="pc bpc" id="L2146" title="1 of 2 branches missed.">            if (n &lt;= 0) {</span>
<span class="nc bnc" id="L2147" title="All 2 branches missed.">                if (p &gt; prev) result.cat(bytes, prev, p - prev);</span>
<span class="nc" id="L2148">                n = enc.minLength();</span>
<span class="nc bnc" id="L2149" title="All 2 branches missed.">                if (end &lt; p + n) n = end - p;</span>
<span class="nc bnc" id="L2150" title="All 2 branches missed.">                while (n-- &gt; 0) {</span>
<span class="nc" id="L2151">                    Sprintf.sprintf(runtime, result.getByteList() ,&quot;\\x%02X&quot;, bytes[p] &amp; 0377);</span>
<span class="nc" id="L2152">                    prev = ++p;</span>
                }
                continue;
            }
<span class="fc" id="L2156">            int c = enc.mbcToCode(bytes, p, end);</span>
<span class="fc" id="L2157">            p += n;</span>
<span class="pc bpc" id="L2158" title="3 of 12 branches missed.">            if ((enc.isAsciiCompatible() || isUnicode) &amp;&amp;</span>
                    (c == '&quot;' || c == '\\' ||
<span class="pc bpc" id="L2160" title="1 of 2 branches missed.">                        (c == '#' &amp;&amp; p &lt; end &amp;&amp; (StringSupport.preciseLength(enc, bytes, p, end) &gt; 0) &amp;&amp;</span>
<span class="fc bfc" id="L2161" title="All 6 branches covered.">                        (cc = codePoint(runtime, enc, bytes, p, end)) == '$' || cc == '@' || cc == '{'))) {</span>
<span class="fc bfc" id="L2162" title="All 2 branches covered.">                if (p - n &gt; prev) result.cat(bytes, prev, p - n - prev);</span>
<span class="fc" id="L2163">                result.cat('\\');</span>
<span class="pc bpc" id="L2164" title="3 of 4 branches missed.">                if (enc.isAsciiCompatible() || enc == resultEnc) {</span>
<span class="fc" id="L2165">                    prev = p - n;</span>
<span class="fc" id="L2166">                    continue;</span>
                }
            }

<span class="fc bfc" id="L2170" title="All 9 branches covered.">            switch (c) {</span>
<span class="fc" id="L2171">            case '\n': cc = 'n'; break;</span>
<span class="fc" id="L2172">            case '\r': cc = 'r'; break;</span>
<span class="fc" id="L2173">            case '\t': cc = 't'; break;</span>
<span class="fc" id="L2174">            case '\f': cc = 'f'; break;</span>
<span class="fc" id="L2175">            case '\013': cc = 'v'; break;</span>
<span class="fc" id="L2176">            case '\010': cc = 'b'; break;</span>
<span class="fc" id="L2177">            case '\007': cc = 'a'; break;</span>
<span class="fc" id="L2178">            case 033: cc = 'e'; break;</span>
<span class="fc" id="L2179">            default: cc = 0; break;</span>
            }

<span class="fc bfc" id="L2182" title="All 2 branches covered.">            if (cc != 0) {</span>
<span class="fc bfc" id="L2183" title="All 2 branches covered.">                if (p - n &gt; prev) result.cat(bytes, prev, p - n - prev);</span>
<span class="fc" id="L2184">                result.cat('\\');</span>
<span class="fc" id="L2185">                result.cat(cc);</span>
<span class="fc" id="L2186">                prev = p;</span>
<span class="fc" id="L2187">                continue;</span>
            }

<span class="pc bpc" id="L2190" title="1 of 10 branches missed.">            if ((enc == resultEnc &amp;&amp; enc.isPrint(c)) || (enc.isAsciiCompatible() &amp;&amp; Encoding.isAscii(c) &amp;&amp; enc.isPrint(c))) {</span>
<span class="fc" id="L2191">                continue;</span>
            } else {
<span class="fc bfc" id="L2193" title="All 2 branches covered.">                if (p - n &gt; prev) result.cat(bytes, prev, p - n - prev);</span>
<span class="fc" id="L2194">                Sprintf.sprintf(runtime, result.getByteList() , StringSupport.escapedCharFormat(c, isUnicode), c);</span>
<span class="fc" id="L2195">                prev = p;</span>
<span class="fc" id="L2196">                continue;</span>
            }
        }

<span class="fc bfc" id="L2200" title="All 2 branches covered.">        if (p &gt; prev) result.cat(bytes, prev, p - prev);</span>
<span class="fc" id="L2201">        result.cat('&quot;');</span>
<span class="fc" id="L2202">        return result;</span>
    }

    public int size() {
<span class="fc" id="L2206">        return value.getRealSize();</span>
    }

    /** rb_str_length
     *
     */
    public RubyFixnum length() {
<span class="fc" id="L2213">        return length19();</span>
    }

    @JRubyMethod(name = {&quot;length&quot;, &quot;size&quot;})
    public RubyFixnum length19() {
<span class="fc" id="L2218">        return getRuntime().newFixnum(strLength());</span>
    }

    @JRubyMethod(name = &quot;bytesize&quot;)
    public RubyFixnum bytesize() {
<span class="fc" id="L2223">        return getRuntime().newFixnum(value.getRealSize());</span>
    }

    private SizeFn eachByteSizeFn() {
<span class="fc" id="L2227">        final RubyString self = this;</span>
<span class="fc" id="L2228">        return new SizeFn() {</span>
            @Override
            public IRubyObject size(IRubyObject[] args) {
<span class="nc" id="L2231">                return self.bytesize();</span>
            }
        };
    }

    /** rb_str_empty
     *
     */
    @JRubyMethod(name = &quot;empty?&quot;)
    public RubyBoolean empty_p(ThreadContext context) {
<span class="fc bfc" id="L2241" title="All 2 branches covered.">        return isEmpty() ? context.runtime.getTrue() : context.runtime.getFalse();</span>
    }

    public boolean isEmpty() {
<span class="fc bfc" id="L2245" title="All 2 branches covered.">        return value.length() == 0;</span>
    }

    /** rb_str_append
     *
     */
    public RubyString append(IRubyObject other) {
<span class="pc bpc" id="L2252" title="1 of 2 branches missed.">        if (other instanceof RubyFixnum) {</span>
<span class="nc" id="L2253">            cat(ConvertBytes.longToByteList(((RubyFixnum)other).getLongValue()));</span>
<span class="nc" id="L2254">            return this;</span>
<span class="pc bpc" id="L2255" title="1 of 2 branches missed.">        } else if (other instanceof RubyFloat) {</span>
<span class="nc" id="L2256">            return cat((RubyString)((RubyFloat)other).to_s());</span>
<span class="pc bpc" id="L2257" title="1 of 2 branches missed.">        } else if (other instanceof RubySymbol) {</span>
<span class="nc" id="L2258">            cat(((RubySymbol)other).getBytes());</span>
<span class="nc" id="L2259">            return this;</span>
        }
<span class="fc" id="L2261">        RubyString otherStr = other.convertToString();</span>
<span class="fc" id="L2262">        infectBy(otherStr);</span>
<span class="fc" id="L2263">        return cat(otherStr.value);</span>
    }

    public RubyString append19(IRubyObject other) {
<span class="pc bpc" id="L2267" title="1 of 2 branches missed.">        if (other instanceof RubyFixnum) {</span>
<span class="nc" id="L2268">            cat19(ConvertBytes.longToByteList(((RubyFixnum)other).getLongValue()), StringSupport.CR_7BIT);</span>
<span class="nc" id="L2269">            return this;</span>
<span class="pc bpc" id="L2270" title="1 of 2 branches missed.">        } else if (other instanceof RubyFloat) {</span>
<span class="nc" id="L2271">            return cat19((RubyString)((RubyFloat)other).to_s());</span>
<span class="pc bpc" id="L2272" title="1 of 2 branches missed.">        } else if (other instanceof RubySymbol) {</span>
<span class="nc" id="L2273">            cat19(((RubySymbol)other).getBytes(), 0);</span>
<span class="nc" id="L2274">            return this;</span>
        }
<span class="fc" id="L2276">        return cat19(other.convertToString());</span>
    }

    /** rb_str_concat
     *
     */
    public RubyString concat(IRubyObject other) {
<span class="nc" id="L2283">        return concat19(getRuntime().getCurrentContext(), other);</span>
    }

    @JRubyMethod(name = {&quot;concat&quot;, &quot;&lt;&lt;&quot;})
    public RubyString concat19(ThreadContext context, IRubyObject other) {
<span class="fc" id="L2288">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L2289" title="All 2 branches covered.">        if (other instanceof RubyFixnum) {</span>
<span class="fc" id="L2290">            int c = RubyNumeric.num2int(other);</span>
<span class="fc bfc" id="L2291" title="All 2 branches covered.">            if (c &lt; 0) {</span>
<span class="fc" id="L2292">                throw runtime.newRangeError(&quot;negative string size (or size too big)&quot;);</span>
            }
<span class="fc" id="L2294">            return concatNumeric(runtime, c);</span>
<span class="pc bpc" id="L2295" title="1 of 2 branches missed.">        } else if (other instanceof RubyBignum) {</span>
<span class="nc bnc" id="L2296" title="All 2 branches missed.">            if (((RubyBignum) other).getBigIntegerValue().signum() &lt; 0) {</span>
<span class="nc" id="L2297">                throw runtime.newRangeError(&quot;negative string size (or size too big)&quot;);</span>
            }
<span class="nc" id="L2299">            long c = ((RubyBignum) other).getLongValue();</span>
<span class="nc" id="L2300">            return concatNumeric(runtime, (int) c);</span>
        }

<span class="pc bpc" id="L2303" title="1 of 2 branches missed.">        if (other instanceof RubySymbol) throw runtime.newTypeError(&quot;can't convert Symbol into String&quot;);</span>
<span class="fc" id="L2304">        return append19(other);</span>
    }

    private RubyString concatNumeric(Ruby runtime, int c) {
<span class="fc" id="L2308">        Encoding enc = value.getEncoding();</span>
        int cl;

        try {
<span class="fc" id="L2312">            cl = codeLength(runtime, enc, c);</span>
<span class="fc" id="L2313">            modify19(value.getRealSize() + cl);</span>

<span class="fc bfc" id="L2315" title="All 2 branches covered.">            if (enc == USASCIIEncoding.INSTANCE) {</span>
<span class="fc bfc" id="L2316" title="All 2 branches covered.">                if (c &gt; 0xff) runtime.newRangeError(c + &quot; out of char range&quot;);</span>
<span class="pc bpc" id="L2317" title="1 of 2 branches missed.">                if (c &gt; 0x79) {</span>
<span class="fc" id="L2318">                    value.setEncoding(ASCIIEncoding.INSTANCE);</span>
<span class="fc" id="L2319">                    enc = value.getEncoding();</span>
                }
            }
<span class="fc" id="L2322">            enc.codeToMbc(c, value.getUnsafeBytes(), value.getBegin() + value.getRealSize());</span>
<span class="fc" id="L2323">        } catch (EncodingException e) {</span>
<span class="fc" id="L2324">            throw runtime.newRangeError(c + &quot; out of char range&quot;);</span>
<span class="fc" id="L2325">        }</span>
<span class="fc" id="L2326">        value.setRealSize(value.getRealSize() + cl);</span>
<span class="fc" id="L2327">        return this;</span>
    }

    /**
     * rb_str_prepend
     */
    @JRubyMethod
    public IRubyObject prepend(ThreadContext context, IRubyObject other) {
<span class="fc" id="L2335">        return replace19(other.convertToString().op_plus19(context, this));</span>
    }

    /** rb_str_crypt
     *
     */
    @JRubyMethod(name = &quot;crypt&quot;)
    public RubyString crypt(ThreadContext context, IRubyObject other) {
<span class="fc" id="L2343">        Encoding ascii8bit = context.runtime.getEncodingService().getAscii8bitEncoding();</span>
<span class="fc" id="L2344">        RubyString otherStr = other.convertToString();</span>
<span class="fc" id="L2345">        otherStr.associateEncoding(ascii8bit);</span>
<span class="fc" id="L2346">        String salt = otherStr.asJavaString();</span>
<span class="fc bfc" id="L2347" title="All 2 branches covered.">        if (otherStr.getByteList().length() &lt; 2) {</span>
<span class="fc" id="L2348">            throw context.runtime.newArgumentError(&quot;salt too short(need &gt;=2 bytes)&quot;);</span>
        }

<span class="fc" id="L2351">        RubyString result = RubyString.newString(context.runtime,</span>
<span class="fc" id="L2352">                context.runtime.getPosix().crypt(asJavaString(), salt).toString());</span>
<span class="fc" id="L2353">        result.associateEncoding(ascii8bit);</span>
<span class="fc" id="L2354">        result.infectBy(this);</span>
<span class="fc" id="L2355">        result.infectBy(otherStr);</span>
<span class="fc" id="L2356">        return result;</span>
    }

    /* RubyString aka rb_string_value */
    public static RubyString stringValue(IRubyObject object) {
<span class="fc bfc" id="L2361" title="All 2 branches covered.">        return (RubyString) (object instanceof RubyString ? object :</span>
<span class="fc" id="L2362">            object.convertToString());</span>
    }

    /** rb_str_sub / rb_str_sub_bang
     *
     */
    public IRubyObject sub(ThreadContext context, IRubyObject arg0, Block block) {
<span class="nc" id="L2369">        return sub19(context, arg0, block);</span>
    }

    public IRubyObject sub(ThreadContext context, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="nc" id="L2373">        return sub19(context, arg0, arg1, block);</span>
    }

    public IRubyObject sub_bang(ThreadContext context, IRubyObject arg0, Block block) {
<span class="nc" id="L2377">        return sub_bang19(context, arg0, block);</span>
    }

    public IRubyObject sub_bang(ThreadContext context, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="nc" id="L2381">        return sub_bang19(context, arg0, arg1, block);</span>
    }

    @JRubyMethod(name = &quot;sub&quot;, reads = BACKREF, writes = BACKREF)
    public IRubyObject sub19(ThreadContext context, IRubyObject arg0, Block block) {
<span class="fc" id="L2386">        RubyString str = strDup(context.runtime);</span>
<span class="fc" id="L2387">        str.sub_bang19(context, arg0, block);</span>
<span class="fc" id="L2388">        return str;</span>
    }

    @JRubyMethod(name = &quot;sub&quot;, reads = BACKREF, writes = BACKREF)
    public IRubyObject sub19(ThreadContext context, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="fc" id="L2393">        RubyString str = strDup(context.runtime);</span>
<span class="fc" id="L2394">        str.sub_bang19(context, arg0, arg1, block);</span>
<span class="fc" id="L2395">        return str;</span>
    }

    @JRubyMethod(name = &quot;sub!&quot;, reads = BACKREF, writes = BACKREF)
    public IRubyObject sub_bang19(ThreadContext context, IRubyObject arg0, Block block) {
<span class="fc" id="L2400">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L2401">        frozenCheck();</span>

        final Regex pattern, prepared;
        final RubyRegexp regexp;
<span class="fc bfc" id="L2405" title="All 2 branches covered.">        if (arg0 instanceof RubyRegexp) {</span>
<span class="fc" id="L2406">            regexp = (RubyRegexp)arg0;</span>
<span class="fc" id="L2407">            pattern = regexp.getPattern();</span>
<span class="fc" id="L2408">            prepared = regexp.preparePattern(this);</span>
        } else {
<span class="fc" id="L2410">            regexp = null;</span>
<span class="fc" id="L2411">            pattern = getStringPattern19(runtime, arg0);</span>
<span class="fc" id="L2412">            prepared = RubyRegexp.preparePattern(runtime, pattern, this);</span>
        }

<span class="pc bpc" id="L2415" title="1 of 2 branches missed.">        if (block.isGiven()) return subBangIter19(runtime, context, pattern, prepared, null, block, regexp);</span>
<span class="nc" id="L2416">        throw context.runtime.newArgumentError(1, 2);</span>
    }

    @JRubyMethod(name = &quot;sub!&quot;, reads = BACKREF, writes = BACKREF)
    public IRubyObject sub_bang19(ThreadContext context, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="fc" id="L2421">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L2422">        IRubyObject hash = TypeConverter.convertToTypeWithCheck(arg1, runtime.getHash(), &quot;to_hash&quot;);</span>
<span class="fc" id="L2423">        frozenCheck();</span>

        final Regex pattern, prepared;
        final RubyRegexp regexp;
<span class="fc bfc" id="L2427" title="All 2 branches covered.">        if (arg0 instanceof RubyRegexp) {</span>
<span class="fc" id="L2428">            regexp = (RubyRegexp)arg0;</span>
<span class="fc" id="L2429">            pattern = regexp.getPattern();</span>
<span class="fc" id="L2430">            prepared = regexp.preparePattern(this);</span>
        } else {
<span class="fc" id="L2432">            regexp = null;</span>
<span class="fc" id="L2433">            pattern = getStringPattern19(runtime, arg0);</span>
<span class="fc" id="L2434">            prepared = RubyRegexp.preparePattern(runtime, pattern, this);</span>
        }

<span class="fc bfc" id="L2437" title="All 2 branches covered.">        if (hash.isNil()) {</span>
<span class="fc" id="L2438">            return subBangNoIter19(runtime, context, pattern, prepared, arg1.convertToString(), regexp);</span>
        } else {
<span class="fc" id="L2440">            return subBangIter19(runtime, context, pattern, prepared, (RubyHash)hash, block, regexp);</span>
        }
    }

    private IRubyObject subBangIter19(Ruby runtime, ThreadContext context, Regex pattern, Regex prepared, RubyHash hash, Block block, RubyRegexp regexp) {
<span class="fc" id="L2445">        int begin = value.getBegin();</span>
<span class="fc" id="L2446">        int len = value.getRealSize();</span>
<span class="fc" id="L2447">        int range = begin + len;</span>
<span class="fc" id="L2448">        byte[]bytes = value.getUnsafeBytes();</span>
<span class="fc" id="L2449">        Encoding enc = value.getEncoding();</span>
<span class="fc" id="L2450">        final Matcher matcher = prepared.matcher(bytes, begin, range);</span>

<span class="fc bfc" id="L2452" title="All 2 branches covered.">        if (RubyRegexp.matcherSearch(runtime, matcher, begin, range, Option.NONE) &gt;= 0) {</span>
<span class="fc" id="L2453">            RubyMatchData match = RubyRegexp.createMatchData19(context, this, matcher, pattern);</span>
<span class="fc" id="L2454">            match.regexp = regexp;</span>
<span class="fc" id="L2455">            context.setBackRef(match);</span>
            final RubyString repl;
            final int tuFlags;
<span class="fc" id="L2458">            IRubyObject subStr = makeShared19(runtime, matcher.getBegin(), matcher.getEnd() - matcher.getBegin());</span>
<span class="fc bfc" id="L2459" title="All 2 branches covered.">            if (hash == null) {</span>
<span class="fc" id="L2460">                tuFlags = 0;</span>
<span class="fc" id="L2461">                repl = objAsString(context, block.yield(context, subStr));</span>
            } else {
<span class="fc" id="L2463">                tuFlags = hash.flags;</span>
<span class="fc" id="L2464">                repl = objAsString(context, hash.op_aref(context, subStr));</span>
            }

<span class="fc" id="L2467">            modifyCheck(bytes, len, enc);</span>
<span class="fc" id="L2468">            frozenCheck();</span>
<span class="fc" id="L2469">            return subBangCommon19(context, pattern, matcher, repl, tuFlags | repl.flags);</span>
        } else {
<span class="fc" id="L2471">            return context.setBackRef(runtime.getNil());</span>
        }
    }

    private IRubyObject subBangNoIter19(Ruby runtime, ThreadContext context, Regex pattern, Regex prepared, RubyString repl, RubyRegexp regexp) {
<span class="fc" id="L2476">        int begin = value.getBegin();</span>
<span class="fc" id="L2477">        int range = begin + value.getRealSize();</span>
<span class="fc" id="L2478">        final Matcher matcher = prepared.matcher(value.getUnsafeBytes(), begin, range);</span>

<span class="fc bfc" id="L2480" title="All 2 branches covered.">        if (RubyRegexp.matcherSearch(runtime, matcher, begin, range, Option.NONE) &gt;= 0) {</span>
<span class="fc" id="L2481">            repl = RubyRegexp.regsub19(context, repl, this, matcher, pattern);</span>
<span class="fc" id="L2482">            RubyMatchData match = RubyRegexp.createMatchData19(context, this, matcher, pattern);</span>
<span class="fc" id="L2483">            match.regexp = regexp;</span>
<span class="fc" id="L2484">            context.setBackRef(match);</span>
<span class="fc" id="L2485">            return subBangCommon19(context, pattern, matcher, repl, repl.flags);</span>
        } else {
<span class="fc" id="L2487">            return context.setBackRef(runtime.getNil());</span>
        }
    }

    private IRubyObject subBangCommon19(ThreadContext context, Regex pattern, Matcher matcher, RubyString repl, int tuFlags) {
<span class="fc" id="L2492">        final int beg = matcher.getBegin();</span>
<span class="fc" id="L2493">        final int end = matcher.getEnd();</span>
<span class="fc" id="L2494">        int cr = getCodeRange();</span>

<span class="fc" id="L2496">        Encoding enc = isCompatibleWith(repl);</span>
<span class="pc bpc" id="L2497" title="1 of 2 branches missed.">        if (enc == null) enc = subBangVerifyEncoding(context, repl, beg, end);</span>

<span class="fc" id="L2499">        final int plen = end - beg;</span>
<span class="fc" id="L2500">        ByteList replValue = repl.value;</span>
<span class="fc bfc" id="L2501" title="All 2 branches covered.">        if (replValue.getRealSize() &gt; plen) {</span>
<span class="fc" id="L2502">            modify19(value.getRealSize() + replValue.getRealSize() - plen);</span>
        } else {
<span class="fc" id="L2504">            modify19();</span>
        }

<span class="fc" id="L2507">        associateEncoding(enc);</span>

<span class="pc bpc" id="L2509" title="2 of 4 branches missed.">        if (cr &gt; CR_UNKNOWN &amp;&amp; cr &lt; CR_BROKEN) {</span>
<span class="fc" id="L2510">            int cr2 = repl.getCodeRange();</span>
<span class="pc bpc" id="L2511" title="4 of 6 branches missed.">            if (cr2 == CR_BROKEN || (cr == CR_VALID &amp;&amp; cr2 == CR_7BIT)) {</span>
<span class="nc" id="L2512">                cr = CR_UNKNOWN;</span>
            } else {
<span class="fc" id="L2514">                cr = cr2;</span>
            }
        }

<span class="fc bfc" id="L2518" title="All 2 branches covered.">        if (replValue.getRealSize() != plen) {</span>
<span class="fc" id="L2519">            int src = value.getBegin() + beg + plen;</span>
<span class="fc" id="L2520">            int dst = value.getBegin() + beg + replValue.getRealSize();</span>
<span class="fc" id="L2521">            int length = value.getRealSize() - beg - plen;</span>
<span class="fc" id="L2522">            System.arraycopy(value.getUnsafeBytes(), src, value.getUnsafeBytes(), dst, length);</span>
        }
<span class="fc" id="L2524">        System.arraycopy(replValue.getUnsafeBytes(), replValue.getBegin(), value.getUnsafeBytes(), value.getBegin() + beg, replValue.getRealSize());</span>
<span class="fc" id="L2525">        value.setRealSize(value.getRealSize() + replValue.getRealSize() - plen);</span>
<span class="fc" id="L2526">        setCodeRange(cr);</span>
<span class="fc" id="L2527">        return infectBy(tuFlags);</span>
    }

    private Encoding subBangVerifyEncoding(ThreadContext context, RubyString repl, int beg, int end) {
<span class="nc" id="L2531">        byte[]bytes = value.getUnsafeBytes();</span>
<span class="nc" id="L2532">        int p = value.getBegin();</span>
<span class="nc" id="L2533">        int len = value.getRealSize();</span>
<span class="nc" id="L2534">        Encoding strEnc = value.getEncoding();</span>
<span class="nc bnc" id="L2535" title="All 2 branches missed.">        if (codeRangeScan(strEnc, bytes, p, beg) != CR_7BIT ||</span>
<span class="nc bnc" id="L2536" title="All 2 branches missed.">            codeRangeScan(strEnc, bytes, p + end, len - end) != CR_7BIT) {</span>
<span class="nc" id="L2537">            throw context.runtime.newArgumentError(</span>
<span class="nc" id="L2538">                    &quot;incompatible character encodings &quot; + strEnc + &quot; and &quot; + repl.value.getEncoding());</span>
        }
<span class="nc" id="L2540">        return repl.value.getEncoding();</span>
    }

    /** rb_str_gsub / rb_str_gsub_bang
     *
     */
    public IRubyObject gsub(ThreadContext context, IRubyObject arg0, Block block) {
<span class="nc" id="L2547">        return gsub19(context, arg0, block);</span>
    }

    public IRubyObject gsub(ThreadContext context, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="nc" id="L2551">        return gsub19(context, arg0, arg1, block);</span>
    }

    public IRubyObject gsub_bang(ThreadContext context, IRubyObject arg0, Block block) {
<span class="nc" id="L2555">        return gsub_bang19(context, arg0, block);</span>
    }

    public IRubyObject gsub_bang(ThreadContext context, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="nc" id="L2559">        return gsub_bang19(context, arg0, arg1, block);</span>
    }

    @JRubyMethod(name = &quot;gsub&quot;, reads = BACKREF, writes = BACKREF)
    public IRubyObject gsub19(ThreadContext context, IRubyObject arg0, Block block) {
<span class="pc bpc" id="L2564" title="1 of 2 branches missed.">        return block.isGiven() ? gsubCommon19(context, block, null, null, arg0, false, 0) : enumeratorize(context.runtime, this, &quot;gsub&quot;, arg0);</span>
    }

    @JRubyMethod(name = &quot;gsub&quot;, reads = BACKREF, writes = BACKREF)
    public IRubyObject gsub19(ThreadContext context, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="fc" id="L2569">        return gsub19(context, arg0, arg1, block, false);</span>
    }

    @JRubyMethod(name = &quot;gsub!&quot;, reads = BACKREF, writes = BACKREF)
    public IRubyObject gsub_bang19(ThreadContext context, IRubyObject arg0, Block block) {
<span class="fc" id="L2574">        checkFrozen();</span>
<span class="pc bpc" id="L2575" title="1 of 2 branches missed.">        return block.isGiven() ? gsubCommon19(context, block, null, null, arg0, true, 0) : enumeratorize(context.runtime, this, &quot;gsub!&quot;, arg0);</span>
    }

    @JRubyMethod(name = &quot;gsub!&quot;, reads = BACKREF, writes = BACKREF)
    public IRubyObject gsub_bang19(ThreadContext context, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="fc" id="L2580">        checkFrozen();</span>
<span class="fc" id="L2581">        return gsub19(context, arg0, arg1, block, true);</span>
    }

    private IRubyObject gsub19(ThreadContext context, IRubyObject arg0, IRubyObject arg1, Block block, final boolean bang) {
<span class="fc" id="L2585">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L2586">        IRubyObject tryHash = TypeConverter.convertToTypeWithCheck(arg1, runtime.getHash(), &quot;to_hash&quot;);</span>

        final RubyHash hash;
        final RubyString str;
        final int tuFlags;
<span class="fc bfc" id="L2591" title="All 2 branches covered.">        if (tryHash.isNil()) {</span>
<span class="fc" id="L2592">            hash = null;</span>
<span class="fc" id="L2593">            str = arg1.convertToString();</span>
<span class="fc" id="L2594">            tuFlags = str.flags;</span>
        } else {
<span class="fc" id="L2596">            hash = (RubyHash)tryHash;</span>
<span class="fc" id="L2597">            str = null;</span>
<span class="fc" id="L2598">            tuFlags = hash.flags &amp; TAINTED_F;</span>
        }

<span class="fc" id="L2601">        return gsubCommon19(context, block, str, hash, arg0, bang, tuFlags);</span>
    }

    private IRubyObject gsubCommon19(ThreadContext context, Block block, RubyString repl,
            RubyHash hash, IRubyObject arg0, final boolean bang, int tuFlags) {
<span class="fc" id="L2606">        return gsubCommon19(context, block, repl, hash, arg0, bang, tuFlags, true);</span>
    }

    // MRI: str_gsub, roughly
    private IRubyObject gsubCommon19(ThreadContext context, Block block, RubyString repl,
            RubyHash hash, IRubyObject arg0, final boolean bang, int tuFlags, boolean useBackref) {
<span class="fc" id="L2612">        Ruby runtime = context.runtime;</span>

        final Regex pattern, prepared;
        final RubyRegexp regexp;
<span class="fc bfc" id="L2616" title="All 2 branches covered.">        if (arg0 instanceof RubyRegexp) {</span>
<span class="fc" id="L2617">            regexp = (RubyRegexp)arg0;</span>
<span class="fc" id="L2618">            pattern = regexp.getPattern();</span>
<span class="fc" id="L2619">            prepared = regexp.preparePattern(this);</span>
        } else {
<span class="fc" id="L2621">            regexp = null;</span>
<span class="fc" id="L2622">            pattern = getStringPattern19(runtime, arg0);</span>
<span class="fc" id="L2623">            prepared = RubyRegexp.preparePattern(runtime, pattern, this);</span>
        }

        int offset, cp, n, blen;

<span class="fc" id="L2628">        final byte[] spBytes = value.getUnsafeBytes();</span>
<span class="fc" id="L2629">        final int sp = value.getBegin();</span>
<span class="fc" id="L2630">        final int spLen = value.getRealSize();</span>

<span class="fc" id="L2632">        final Matcher matcher = prepared.matcher(spBytes, sp, sp + spLen);</span>

<span class="fc" id="L2634">        int beg = RubyRegexp.matcherSearch(runtime, matcher, sp, sp + spLen, Option.NONE);</span>
<span class="fc bfc" id="L2635" title="All 2 branches covered.">        if (beg &lt; 0) {</span>
<span class="fc bfc" id="L2636" title="All 2 branches covered.">            if (useBackref) context.setBackRef(runtime.getNil());</span>
<span class="fc bfc" id="L2637" title="All 2 branches covered.">            return bang ? runtime.getNil() : strDup(runtime); /* bang: true, no match, no substitution */</span>
        }

<span class="fc" id="L2640">        offset = 0;</span>
<span class="fc" id="L2641">        n = 0;</span>
<span class="fc" id="L2642">        blen = value.getRealSize() + 30;</span>
<span class="fc" id="L2643">        RubyString dest = new RubyString(runtime, getMetaClass(), new ByteList(blen));</span>
<span class="fc" id="L2644">        int slen = value.getRealSize();</span>
<span class="fc" id="L2645">        cp = sp;</span>
<span class="fc" id="L2646">        Encoding str_enc = value.getEncoding();</span>
<span class="fc" id="L2647">        dest.setEncoding(str_enc);</span>
<span class="pc bpc" id="L2648" title="1 of 2 branches missed.">        dest.setCodeRange(str_enc.isAsciiCompatible() ? CR_7BIT : CR_VALID);</span>

<span class="fc" id="L2650">        RubyMatchData match = null;</span>
        do {
<span class="fc" id="L2652">            n++;</span>
            final RubyString val;
<span class="fc" id="L2654">            int begz = matcher.getBegin();</span>
<span class="fc" id="L2655">            int endz = matcher.getEnd();</span>

<span class="fc bfc" id="L2657" title="All 2 branches covered.">            if (repl != null) {     // string given</span>
<span class="fc" id="L2658">                val = RubyRegexp.regsub19(context, repl, this, matcher, pattern);</span>
            } else {
<span class="fc" id="L2660">                final RubyString substr = makeShared19(runtime, begz, endz - begz);</span>
<span class="fc bfc" id="L2661" title="All 2 branches covered.">                if (hash != null) { // hash given</span>
<span class="fc" id="L2662">                    val = objAsString(context, hash.op_aref(context, substr));</span>
                } else {            // block given
<span class="fc" id="L2664">                    match = RubyRegexp.createMatchData19(context, this, matcher, pattern);</span>
<span class="fc" id="L2665">                    match.regexp = regexp;</span>
<span class="pc bpc" id="L2666" title="1 of 2 branches missed.">                    if (useBackref) context.setBackRef(match);</span>
<span class="fc" id="L2667">                    val = objAsString(context, block.yield(context, substr));</span>
                }
<span class="fc" id="L2669">                modifyCheck(spBytes, slen, str_enc);</span>
<span class="fc bfc" id="L2670" title="All 2 branches covered.">                if (bang) frozenCheck();</span>
            }

<span class="fc" id="L2673">            tuFlags |= val.flags;</span>

<span class="fc" id="L2675">            int len = beg - offset;</span>
<span class="fc bfc" id="L2676" title="All 2 branches covered.">            if (len != 0) dest.cat(spBytes, cp, len, str_enc);</span>
<span class="fc" id="L2677">            dest.cat19(val);</span>
<span class="fc" id="L2678">            offset = endz;</span>
<span class="fc bfc" id="L2679" title="All 2 branches covered.">            if (begz == endz) {</span>
<span class="fc bfc" id="L2680" title="All 2 branches covered.">                if (slen &lt;= endz) break;</span>
<span class="fc" id="L2681">                len = StringSupport.encFastMBCLen(spBytes, sp + endz, sp + spLen, str_enc);</span>
<span class="fc" id="L2682">                dest.cat(spBytes, sp + endz, len, str_enc);</span>
<span class="fc" id="L2683">                offset = endz + len;</span>
            }
<span class="fc" id="L2685">            cp = sp + offset;</span>
<span class="pc bpc" id="L2686" title="1 of 2 branches missed.">            if (offset &gt; slen) break;</span>
<span class="fc" id="L2687">            beg = RubyRegexp.matcherSearch(runtime, matcher, cp, sp + spLen, Option.NONE);</span>
<span class="fc bfc" id="L2688" title="All 2 branches covered.">        } while (beg &gt;= 0);</span>

<span class="fc bfc" id="L2690" title="All 2 branches covered.">        if (slen &gt; offset) dest.cat(spBytes, cp, slen - offset, str_enc);</span>

<span class="fc bfc" id="L2692" title="All 2 branches covered.">        if (match != null) { // block given</span>
<span class="pc bpc" id="L2693" title="1 of 2 branches missed.">            if (useBackref) context.setBackRef(match);</span>
        } else {
<span class="fc" id="L2695">            match = RubyRegexp.createMatchData19(context, this, matcher, pattern);</span>
<span class="fc" id="L2696">            match.regexp = regexp;</span>
<span class="fc bfc" id="L2697" title="All 2 branches covered.">            if (useBackref) context.setBackRef(match);</span>
        }

<span class="fc bfc" id="L2700" title="All 2 branches covered.">        if (bang) {</span>
<span class="fc" id="L2701">            view(dest.value);</span>
<span class="fc" id="L2702">            setCodeRange(dest.getCodeRange());</span>
<span class="fc" id="L2703">            return infectBy(tuFlags);</span>
        } else {
<span class="fc" id="L2705">            return dest.infectBy(tuFlags | flags);</span>
        }
    }

    /** rb_str_index_m
     *
     */
    public IRubyObject index(ThreadContext context, IRubyObject arg0) {
<span class="nc" id="L2713">        return index19(context, arg0);</span>
    }

    public IRubyObject index(ThreadContext context, IRubyObject arg0, IRubyObject arg1) {
<span class="nc" id="L2717">        return index19(context, arg0, arg1);</span>
    }

    @JRubyMethod(name = &quot;index&quot;, reads = BACKREF, writes = BACKREF)
    public IRubyObject index19(ThreadContext context, IRubyObject arg0) {
<span class="fc" id="L2722">        return indexCommon19(context.runtime, context, arg0, 0);</span>
    }

    @JRubyMethod(name = &quot;index&quot;, reads = BACKREF, writes = BACKREF)
    public IRubyObject index19(ThreadContext context, IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L2727">        int pos = RubyNumeric.num2int(arg1);</span>
<span class="fc" id="L2728">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L2729" title="All 2 branches covered.">        if (pos &lt; 0) {</span>
<span class="fc" id="L2730">            pos += strLength();</span>
<span class="fc bfc" id="L2731" title="All 2 branches covered.">            if (pos &lt; 0) {</span>
<span class="fc bfc" id="L2732" title="All 2 branches covered.">                if (arg0 instanceof RubyRegexp) context.setBackRef(runtime.getNil());</span>
<span class="fc" id="L2733">                return runtime.getNil();</span>
            }
        }
<span class="fc" id="L2736">        return indexCommon19(runtime, context, arg0, pos);</span>
    }

    private IRubyObject indexCommon19(Ruby runtime, ThreadContext context, IRubyObject sub, int pos) {
<span class="fc bfc" id="L2740" title="All 2 branches covered.">        if (sub instanceof RubyRegexp) {</span>
<span class="fc bfc" id="L2741" title="All 2 branches covered.">            if (pos &gt; strLength()) return context.nil;</span>
<span class="fc" id="L2742">            RubyRegexp regSub = (RubyRegexp) sub;</span>
<span class="fc bfc" id="L2743" title="All 2 branches covered.">            pos = singleByteOptimizable() ? pos :</span>
<span class="fc" id="L2744">                    StringSupport.nth(checkEncoding(regSub), value.getUnsafeBytes(), value.getBegin(),</span>
<span class="fc" id="L2745">                            value.getBegin() + value.getRealSize(),</span>
<span class="fc" id="L2746">                                      pos) - value.getBegin();</span>
<span class="fc" id="L2747">            pos = regSub.adjustStartPos19(this, pos, false);</span>
<span class="fc" id="L2748">            IRubyObject[] holder = {context.nil};</span>
<span class="fc" id="L2749">            pos = regSub.search19(context, this, pos, false, holder);</span>
<span class="fc" id="L2750">            context.setBackRef(holder[0]);</span>
<span class="fc" id="L2751">            pos = subLength(pos);</span>
<span class="fc bfc" id="L2752" title="All 2 branches covered.">        } else if (sub instanceof RubyString) {</span>
<span class="fc" id="L2753">            pos = StringSupport.index(this, this.value, this.strLength(this.checkEncoding((RubyString) sub)), (RubyString) sub, ((RubyString) sub).value, ((RubyString) sub).strLength(this.checkEncoding((RubyString) sub)), pos, this.checkEncoding((RubyString) sub));</span>
<span class="fc" id="L2754">            pos = subLength(pos);</span>
        } else {
<span class="fc" id="L2756">            IRubyObject tmp = sub.checkStringType();</span>
<span class="fc bfc" id="L2757" title="All 2 branches covered.">            if (tmp.isNil()) throw runtime.newTypeError(&quot;type mismatch: &quot; + sub.getMetaClass().getName() + &quot; given&quot;);</span>
<span class="fc" id="L2758">            pos = StringSupport.index(this, this.value, this.strLength(this.checkEncoding((RubyString) tmp)), (RubyString) tmp, ((RubyString) tmp).value, ((RubyString) tmp).strLength(this.checkEncoding((RubyString) tmp)), pos, this.checkEncoding((RubyString) tmp));</span>
<span class="fc" id="L2759">            pos = subLength(pos);</span>
        }

<span class="fc bfc" id="L2762" title="All 2 branches covered.">        return pos == -1 ? runtime.getNil() : RubyFixnum.newFixnum(runtime, pos);</span>
    }

    /** rb_str_rindex_m
     *
     */
    public IRubyObject rindex(ThreadContext context, IRubyObject arg0) {
<span class="nc" id="L2769">        return rindex19(context, arg0);</span>
    }

    public IRubyObject rindex(ThreadContext context, IRubyObject arg0, IRubyObject arg1) {
<span class="nc" id="L2773">        return rindex19(context, arg0, arg1);</span>
    }

    @JRubyMethod(name = &quot;rindex&quot;, reads = BACKREF, writes = BACKREF)
    public IRubyObject rindex19(ThreadContext context, IRubyObject arg0) {
<span class="fc" id="L2778">        return rindexCommon19(context.runtime, context, arg0, strLength());</span>
    }

    @JRubyMethod(name = &quot;rindex&quot;, reads = BACKREF, writes = BACKREF)
    public IRubyObject rindex19(ThreadContext context, IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L2783">        int pos = RubyNumeric.num2int(arg1);</span>
<span class="fc" id="L2784">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L2785">        int length = strLength();</span>
<span class="fc bfc" id="L2786" title="All 2 branches covered.">        if (pos &lt; 0) {</span>
<span class="fc" id="L2787">            pos += length;</span>
<span class="fc bfc" id="L2788" title="All 2 branches covered.">            if (pos &lt; 0) {</span>
<span class="fc bfc" id="L2789" title="All 2 branches covered.">                if (arg0 instanceof RubyRegexp) context.setBackRef(runtime.getNil());</span>
<span class="fc" id="L2790">                return runtime.getNil();</span>
            }
        }
<span class="fc bfc" id="L2793" title="All 2 branches covered.">        if (pos &gt; length) pos = length;</span>
<span class="fc" id="L2794">        return rindexCommon19(runtime, context, arg0, pos);</span>
    }

    private IRubyObject rindexCommon19(Ruby runtime, ThreadContext context, final IRubyObject sub, int pos) {
<span class="fc bfc" id="L2798" title="All 2 branches covered.">        if (sub instanceof RubyRegexp) {</span>
<span class="fc" id="L2799">            RubyRegexp regSub = (RubyRegexp) sub;</span>
<span class="fc bfc" id="L2800" title="All 2 branches covered.">            pos = singleByteOptimizable() ? pos :</span>
<span class="fc" id="L2801">                    StringSupport.nth(value.getEncoding(), value.getUnsafeBytes(), value.getBegin(),</span>
<span class="fc" id="L2802">                            value.getBegin() + value.getRealSize(),</span>
<span class="fc" id="L2803">                                      pos) - value.getBegin();</span>
<span class="fc bfc" id="L2804" title="All 2 branches covered.">            if (regSub.length() &gt; 0) {</span>
<span class="fc" id="L2805">                pos = regSub.adjustStartPos19(this, pos, true);</span>
<span class="fc" id="L2806">                IRubyObject[] holder = {context.nil};</span>
<span class="fc" id="L2807">                pos = regSub.search19(context, this, pos, true, holder);</span>
<span class="fc" id="L2808">                context.setBackRef(holder[0]);</span>
<span class="fc" id="L2809">                pos = subLength(pos);</span>
            }
<span class="fc bfc" id="L2811" title="All 2 branches covered.">        } else if (sub instanceof RubyString) {</span>
<span class="fc" id="L2812">            pos = StringSupport.rindex(value, this.strLength(this.checkEncoding((RubyString) sub)), ((RubyString) sub).value, ((RubyString) sub).strLength(this.checkEncoding((RubyString) sub)), pos, (RubyString) sub, this.checkEncoding((RubyString) sub));</span>
        } else {
<span class="fc" id="L2814">            IRubyObject tmp = sub.checkStringType();</span>
<span class="fc bfc" id="L2815" title="All 2 branches covered.">            if (tmp.isNil()) throw runtime.newTypeError(&quot;type mismatch: &quot; + sub.getMetaClass().getName() + &quot; given&quot;);</span>
<span class="fc" id="L2816">            pos = StringSupport.rindex(value, this.strLength(this.checkEncoding((RubyString) tmp)), ((RubyString) tmp).value, ((RubyString) tmp).strLength(this.checkEncoding((RubyString) tmp)), pos, (RubyString) tmp, this.checkEncoding((RubyString) tmp));</span>
        }
<span class="fc bfc" id="L2818" title="All 2 branches covered.">        if (pos &gt;= 0) return RubyFixnum.newFixnum(runtime, pos);</span>
<span class="fc" id="L2819">        return runtime.getNil();</span>
    }

    @Deprecated
    public final IRubyObject substr(int beg, int len) {
<span class="nc" id="L2824">        return substr(getRuntime(), beg, len);</span>
    }

    /* rb_str_substr */
    public final IRubyObject substr(Ruby runtime, int beg, int len) {
<span class="fc" id="L2829">        int length = value.length();</span>
<span class="pc bpc" id="L2830" title="2 of 4 branches missed.">        if (len &lt; 0 || beg &gt; length) return runtime.getNil();</span>

<span class="pc bpc" id="L2832" title="1 of 2 branches missed.">        if (beg &lt; 0) {</span>
<span class="nc" id="L2833">            beg += length;</span>
<span class="nc bnc" id="L2834" title="All 2 branches missed.">            if (beg &lt; 0) return runtime.getNil();</span>
        }

<span class="fc" id="L2837">        int end = Math.min(length, beg + len);</span>
<span class="fc" id="L2838">        return makeShared19(runtime, beg, end - beg);</span>
    }

    /* str_byte_substr */
    private IRubyObject byteSubstr(Ruby runtime, int beg, int len) {
<span class="fc" id="L2843">        int length = value.length();</span>

<span class="fc bfc" id="L2845" title="All 4 branches covered.">        if (len &lt; 0 || beg &gt; length) return runtime.getNil();</span>

<span class="fc bfc" id="L2847" title="All 2 branches covered.">        if (beg &lt; 0) {</span>
<span class="fc" id="L2848">            beg += length;</span>
<span class="fc bfc" id="L2849" title="All 2 branches covered.">            if (beg &lt; 0) return runtime.getNil();</span>
        }
<span class="fc bfc" id="L2851" title="All 2 branches covered.">        if (beg + len &gt; length) len = length - beg;</span>

<span class="fc bfc" id="L2853" title="All 2 branches covered.">        if (len &lt;= 0) {</span>
<span class="fc" id="L2854">            len = 0;</span>
        }

<span class="fc" id="L2857">        return makeShared19(runtime, beg, len);</span>
    }

    /* str_byte_aref */
    private IRubyObject byteARef(Ruby runtime, IRubyObject idx) {
        final int index;

<span class="fc bfc" id="L2864" title="All 2 branches covered.">        if (idx instanceof RubyRange){</span>
<span class="fc" id="L2865">            int[] begLen = ((RubyRange) idx).begLenInt(getByteList().length(), 0);</span>
<span class="fc bfc" id="L2866" title="All 2 branches covered.">            return begLen == null ? runtime.getNil() : byteSubstr(runtime, begLen[0], begLen[1]);</span>
<span class="fc bfc" id="L2867" title="All 2 branches covered.">        } else if (idx instanceof RubyFixnum) {</span>
<span class="fc" id="L2868">            index = RubyNumeric.fix2int((RubyFixnum)idx);</span>
<span class="pc bpc" id="L2869" title="3 of 4 branches missed.">        } else if (idx.respondsTo(&quot;begin&quot;) &amp;&amp; idx.respondsTo(&quot;end&quot;)) {</span>
<span class="nc" id="L2870">            ThreadContext context = runtime.getCurrentContext();</span>
<span class="nc" id="L2871">            IRubyObject begin = idx.callMethod(context, &quot;begin&quot;);</span>
<span class="nc" id="L2872">            IRubyObject end   = idx.callMethod(context, &quot;end&quot;);</span>
<span class="nc" id="L2873">            IRubyObject excl  = idx.callMethod(context, &quot;exclude_end?&quot;);</span>
<span class="nc" id="L2874">            RubyRange range = RubyRange.newRange(context, begin, end, excl.isTrue());</span>

<span class="nc" id="L2876">            int[] begLen = range.begLenInt(getByteList().length(), 0);</span>
<span class="nc bnc" id="L2877" title="All 2 branches missed.">            return begLen == null ? runtime.getNil() : byteSubstr(runtime, begLen[0], begLen[1]);</span>
        } else {
<span class="fc" id="L2879">            index = RubyNumeric.num2int(idx);</span>
        }

<span class="fc" id="L2882">        IRubyObject obj = byteSubstr(runtime, index, 1);</span>
<span class="fc bfc" id="L2883" title="All 4 branches covered.">        if (obj.isNil() || ((RubyString)obj).getByteList().length() == 0) return runtime.getNil();</span>
<span class="fc" id="L2884">        return obj;</span>
    }

    public final IRubyObject substr19(Ruby runtime, int beg, int len) {
<span class="fc bfc" id="L2888" title="All 2 branches covered.">        if (len &lt; 0) return runtime.getNil();</span>
<span class="fc" id="L2889">        int length = value.getRealSize();</span>
<span class="fc bfc" id="L2890" title="All 2 branches covered.">        if (length == 0) len = 0;</span>

<span class="fc" id="L2892">        Encoding enc = value.getEncoding();</span>
<span class="fc bfc" id="L2893" title="All 2 branches covered.">        if (singleByteOptimizable(enc)) {</span>
<span class="fc bfc" id="L2894" title="All 2 branches covered.">            if (beg &gt; length) return runtime.getNil();</span>
<span class="fc bfc" id="L2895" title="All 2 branches covered.">            if (beg &lt; 0) {</span>
<span class="fc" id="L2896">                beg += length;</span>
<span class="fc bfc" id="L2897" title="All 2 branches covered.">                if (beg &lt; 0) return runtime.getNil();</span>
            }
<span class="fc bfc" id="L2899" title="All 2 branches covered.">            if (beg + len &gt; length) len = length - beg;</span>
<span class="fc bfc" id="L2900" title="All 2 branches covered.">            if (len &lt;= 0) len = beg = 0;</span>
<span class="fc" id="L2901">            return makeShared19(runtime, beg, len);</span>
        } else {
<span class="fc bfc" id="L2903" title="All 2 branches covered.">            if (beg + len &gt; length) len = length - beg;</span>
<span class="fc" id="L2904">            return multibyteSubstr19(runtime, enc, len, beg, length);</span>
        }
    }

    private IRubyObject multibyteSubstr19(Ruby runtime, Encoding enc, int len, int beg, int length) {
        int p;
<span class="fc" id="L2910">        int s = value.getBegin();</span>
<span class="fc" id="L2911">        int end = s + length;</span>
<span class="fc" id="L2912">        byte[]bytes = value.getUnsafeBytes();</span>

<span class="fc bfc" id="L2914" title="All 2 branches covered.">        if (beg &lt; 0) {</span>
<span class="fc bfc" id="L2915" title="All 2 branches covered.">            if (len &gt; -beg) len = -beg;</span>
<span class="fc bfc" id="L2916" title="All 2 branches covered.">            if (-beg * enc.maxLength() &lt; length &gt;&gt;&gt; 3) {</span>
<span class="fc" id="L2917">                beg = -beg;</span>
<span class="fc" id="L2918">                int e = end;</span>
<span class="pc bpc" id="L2919" title="3 of 4 branches missed.">                while (beg-- &gt; len &amp;&amp; (e = enc.prevCharHead(bytes, s, e, e)) != -1) {} // nothing</span>
<span class="fc" id="L2920">                p = e;</span>
<span class="pc bpc" id="L2921" title="1 of 2 branches missed.">                if (p == -1) return runtime.getNil();</span>
<span class="pc bpc" id="L2922" title="1 of 4 branches missed.">                while (len-- &gt; 0 &amp;&amp; (p = enc.prevCharHead(bytes, s, p, e)) != -1) {} // nothing</span>
<span class="pc bpc" id="L2923" title="1 of 2 branches missed.">                if (p == -1) return runtime.getNil();</span>
<span class="fc" id="L2924">                return makeShared19(runtime, p - s, e - p);</span>
            } else {
<span class="fc" id="L2926">                beg += strLength(enc);</span>
<span class="fc bfc" id="L2927" title="All 2 branches covered.">                if (beg &lt; 0) return runtime.getNil();</span>
            }
<span class="fc bfc" id="L2929" title="All 4 branches covered.">        } else if (beg &gt; 0 &amp;&amp; beg &gt; strLength(enc)) {</span>
<span class="fc" id="L2930">            return runtime.getNil();</span>
        }
<span class="fc bfc" id="L2932" title="All 2 branches covered.">        if (len == 0) {</span>
<span class="fc" id="L2933">            p = 0;</span>
<span class="pc bpc" id="L2934" title="1 of 4 branches missed.">        } else if (isCodeRangeValid() &amp;&amp; enc instanceof UTF8Encoding) {</span>
<span class="fc" id="L2935">            p = StringSupport.utf8Nth(bytes, s, end, beg);</span>
<span class="fc" id="L2936">            len = StringSupport.utf8Offset(bytes, p, end, len);</span>
<span class="pc bpc" id="L2937" title="1 of 2 branches missed.">        } else if (enc.isFixedWidth()) {</span>
<span class="nc" id="L2938">            int w = enc.maxLength();</span>
<span class="nc" id="L2939">            p = s + beg * w;</span>
<span class="nc bnc" id="L2940" title="All 2 branches missed.">            if (p &gt; end) {</span>
<span class="nc" id="L2941">                p = end;</span>
<span class="nc" id="L2942">                len = 0;</span>
<span class="nc bnc" id="L2943" title="All 2 branches missed.">            } else if (len * w &gt; end - p) {</span>
<span class="nc" id="L2944">                len = end - p;</span>
            } else {
<span class="nc" id="L2946">                len *= w;</span>
            }
<span class="pc bpc" id="L2948" title="1 of 2 branches missed.">        } else if ((p = StringSupport.nth(enc, bytes, s, end, beg)) == end) {</span>
<span class="nc" id="L2949">            len = 0;</span>
        } else {
<span class="fc" id="L2951">            len = StringSupport.offset(enc, bytes, p, end, len);</span>
        }
<span class="fc" id="L2953">        return makeShared19(runtime, p - s, len);</span>
    }

    /* rb_str_splice */
    private IRubyObject replaceInternal(int beg, int len, RubyString repl) {
<span class="fc" id="L2958">        int oldLength = value.getRealSize();</span>
<span class="fc bfc" id="L2959" title="All 2 branches covered.">        if (beg + len &gt;= oldLength) len = oldLength - beg;</span>
<span class="fc" id="L2960">        ByteList replBytes = repl.value;</span>
<span class="fc" id="L2961">        int replLength = replBytes.getRealSize();</span>
<span class="fc" id="L2962">        int newLength = oldLength + replLength - len;</span>

<span class="fc" id="L2964">        byte[]oldBytes = value.getUnsafeBytes();</span>
<span class="fc" id="L2965">        int oldBegin = value.getBegin();</span>

<span class="fc" id="L2967">        modify(newLength);</span>
<span class="fc bfc" id="L2968" title="All 2 branches covered.">        if (replLength != len) {</span>
<span class="fc" id="L2969">            System.arraycopy(oldBytes, oldBegin + beg + len, value.getUnsafeBytes(), beg + replLength, oldLength - (beg + len));</span>
        }

<span class="fc bfc" id="L2972" title="All 2 branches covered.">        if (replLength &gt; 0) System.arraycopy(replBytes.getUnsafeBytes(), replBytes.getBegin(), value.getUnsafeBytes(), beg, replLength);</span>
<span class="fc" id="L2973">        value.setRealSize(newLength);</span>
<span class="fc" id="L2974">        return infectBy(repl);</span>
    }

    private void replaceInternal19(int beg, int len, RubyString repl) {
<span class="fc" id="L2978">        Encoding enc = checkEncoding(repl);</span>
<span class="fc" id="L2979">        int p = value.getBegin();</span>
        int e;
<span class="fc bfc" id="L2981" title="All 2 branches covered.">        if (singleByteOptimizable()) {</span>
<span class="fc" id="L2982">            p += beg;</span>
<span class="fc" id="L2983">            e = p + len;</span>
        } else {
<span class="fc" id="L2985">            int end = p + value.getRealSize();</span>
<span class="fc" id="L2986">            byte[]bytes = value.getUnsafeBytes();</span>
<span class="fc" id="L2987">            p = StringSupport.nth(enc, bytes, p, end, beg);</span>
<span class="pc bpc" id="L2988" title="1 of 2 branches missed.">            if (p == -1) p = end;</span>
<span class="fc" id="L2989">            e = StringSupport.nth(enc, bytes, p, end, len);</span>
<span class="pc bpc" id="L2990" title="1 of 2 branches missed.">            if (e == -1) e = end;</span>
        }

<span class="fc" id="L2993">        int cr = getCodeRange();</span>
<span class="pc bpc" id="L2994" title="1 of 2 branches missed.">        if (cr == CR_BROKEN) clearCodeRange();</span>
<span class="fc" id="L2995">        replaceInternal(p - value.getBegin(), e - p, repl);</span>
<span class="fc" id="L2996">        associateEncoding(enc);</span>
<span class="fc" id="L2997">        cr = codeRangeAnd(cr, repl.getCodeRange());</span>
<span class="pc bpc" id="L2998" title="1 of 2 branches missed.">        if (cr != CR_BROKEN) setCodeRange(cr);</span>
<span class="fc" id="L2999">    }</span>

    /** rb_str_aref, rb_str_aref_m
     *
     */
    public IRubyObject op_aref(ThreadContext context, IRubyObject arg1, IRubyObject arg2) {
<span class="nc" id="L3005">        return op_aref19(context, arg1, arg2);</span>
    }

    public IRubyObject op_aref(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L3009">        return op_aref19(context, arg);</span>
    }

    @JRubyMethod(name = {&quot;[]&quot;, &quot;slice&quot;}, reads = BACKREF, writes = BACKREF)
    public IRubyObject op_aref19(ThreadContext context, IRubyObject arg1, IRubyObject arg2) {
<span class="fc" id="L3014">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L3015" title="All 2 branches covered.">        if (arg1 instanceof RubyRegexp) return subpat19(runtime, context, (RubyRegexp)arg1, arg2);</span>
<span class="fc" id="L3016">        return substr19(runtime, RubyNumeric.num2int(arg1), RubyNumeric.num2int(arg2));</span>
    }

    @JRubyMethod(name = {&quot;[]&quot;, &quot;slice&quot;}, reads = BACKREF, writes = BACKREF)
    public IRubyObject op_aref19(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L3021">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L3022" title="All 2 branches covered.">        if (arg instanceof RubyFixnum) {</span>
<span class="fc" id="L3023">            return op_aref19(runtime, RubyNumeric.fix2int((RubyFixnum)arg));</span>
<span class="fc bfc" id="L3024" title="All 2 branches covered.">        } else if (arg instanceof RubyRegexp) {</span>
<span class="fc" id="L3025">            return subpat19(runtime, context, (RubyRegexp)arg);</span>
<span class="fc bfc" id="L3026" title="All 2 branches covered.">        } else if (arg instanceof RubyString) {</span>
<span class="fc" id="L3027">            RubyString str = (RubyString)arg;</span>
<span class="fc bfc" id="L3028" title="All 2 branches covered.">            return StringSupport.index(this, this.value, this.strLength(this.checkEncoding(str)), str, str.value, str.strLength(this.checkEncoding(str)), 0, this.checkEncoding(str)) != -1 ? str.strDup(runtime) : runtime.getNil();</span>
<span class="fc bfc" id="L3029" title="All 2 branches covered.">        } else if (arg instanceof RubyRange) {</span>
<span class="fc" id="L3030">            int len = strLength();</span>
<span class="fc" id="L3031">            int[] begLen = ((RubyRange) arg).begLenInt(len, 0);</span>
<span class="fc bfc" id="L3032" title="All 2 branches covered.">            return begLen == null ? runtime.getNil() : substr19(runtime, begLen[0], begLen[1]);</span>
<span class="pc bpc" id="L3033" title="3 of 4 branches missed.">        } else if (arg.respondsTo(&quot;begin&quot;) &amp;&amp; arg.respondsTo(&quot;end&quot;)) {</span>
<span class="nc" id="L3034">            int len = strLength();</span>
<span class="nc" id="L3035">            IRubyObject begin = arg.callMethod(context, &quot;begin&quot;);</span>
<span class="nc" id="L3036">            IRubyObject end   = arg.callMethod(context, &quot;end&quot;);</span>
<span class="nc" id="L3037">            IRubyObject excl  = arg.callMethod(context, &quot;exclude_end?&quot;);</span>
<span class="nc" id="L3038">            RubyRange range = RubyRange.newRange(context, begin, end, excl.isTrue());</span>

<span class="nc" id="L3040">            int[] begLen = range.begLenInt(len, 0);</span>
<span class="nc bnc" id="L3041" title="All 2 branches missed.">            return begLen == null ? runtime.getNil() : substr19(runtime, begLen[0], begLen[1]);</span>
        }
<span class="fc" id="L3043">        return op_aref19(runtime, RubyNumeric.num2int(arg));</span>
    }

    @JRubyMethod
    public IRubyObject byteslice(ThreadContext context, IRubyObject arg1, IRubyObject arg2) {
<span class="fc" id="L3048">        return byteSubstr(context.runtime, RubyNumeric.num2int(arg1), RubyNumeric.num2int(arg2));</span>
    }

    @JRubyMethod
    public IRubyObject byteslice(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L3053">        return byteARef(context.runtime, arg);</span>
    }

    private IRubyObject op_aref19(Ruby runtime, int idx) {
<span class="fc" id="L3057">        IRubyObject str = substr19(runtime, idx, 1);</span>
<span class="fc bfc" id="L3058" title="All 4 branches covered.">        return !str.isNil() &amp;&amp; ((RubyString) str).value.getRealSize() == 0 ? runtime.getNil() : str;</span>
    }

    private int subpatSetCheck(Ruby runtime, int nth, Region regs) {
<span class="fc bfc" id="L3062" title="All 2 branches covered.">        int numRegs = regs == null ? 1 : regs.numRegs;</span>
<span class="fc bfc" id="L3063" title="All 2 branches covered.">        if (nth &lt; numRegs) {</span>
<span class="fc bfc" id="L3064" title="All 2 branches covered.">            if (nth &lt; 0) {</span>
<span class="fc bfc" id="L3065" title="All 2 branches covered.">                if (-nth &lt; numRegs) return nth + numRegs;</span>
            } else {
<span class="fc" id="L3067">                return nth;</span>
            }
        }
<span class="fc" id="L3070">        throw runtime.newIndexError(&quot;index &quot; + nth + &quot; out of regexp&quot;);</span>
    }

    private void subpatSet19(ThreadContext context, RubyRegexp regexp, IRubyObject backref, IRubyObject repl) {
<span class="fc" id="L3074">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L3075">        IRubyObject[] holder = {context.nil};</span>

<span class="fc" id="L3077">        int result = regexp.search19(context, this, 0, false, holder);</span>
<span class="fc" id="L3078">        context.setBackRef(holder[0]);</span>

<span class="fc bfc" id="L3080" title="All 2 branches covered.">        if (result &lt; 0) throw runtime.newIndexError(&quot;regexp not matched&quot;);</span>

        // this cast should be ok, since nil matchdata will be &lt; 0 above
<span class="fc" id="L3083">        RubyMatchData match = (RubyMatchData)holder[0];</span>

<span class="fc bfc" id="L3085" title="All 2 branches covered.">        int nth = backref == null ? 0 : subpatSetCheck(runtime, match.backrefNumber(backref), match.regs);</span>

        final int start, end;
<span class="fc bfc" id="L3088" title="All 2 branches covered.">        if (match.regs == null) {</span>
<span class="fc" id="L3089">            start = match.begin;</span>
<span class="fc" id="L3090">            end = match.end;</span>
        } else {
<span class="fc" id="L3092">            start = match.regs.beg[nth];</span>
<span class="fc" id="L3093">            end = match.regs.end[nth];</span>
        }
<span class="fc bfc" id="L3095" title="All 2 branches covered.">        if (start == -1) throw runtime.newIndexError(&quot;regexp group &quot; + nth + &quot; not matched&quot;);</span>
<span class="fc" id="L3096">        RubyString replStr =  repl.convertToString();</span>
<span class="fc" id="L3097">        Encoding enc = checkEncoding(replStr);</span>
        // TODO: keep cr
<span class="fc" id="L3099">        replaceInternal(start, end - start, replStr); // TODO: rb_str_splice_0</span>
<span class="fc" id="L3100">        associateEncoding(enc);</span>
<span class="fc" id="L3101">    }</span>

    private IRubyObject subpat19(Ruby runtime, ThreadContext context, RubyRegexp regex, IRubyObject backref) {
<span class="fc" id="L3104">        IRubyObject[] holder = {context.nil};</span>

<span class="fc" id="L3106">        int result = regex.search19(context, this, 0, false, holder);</span>
<span class="fc" id="L3107">        context.setBackRef(holder[0]);</span>

<span class="fc bfc" id="L3109" title="All 2 branches covered.">        if (result &gt;= 0) {</span>
<span class="fc" id="L3110">            RubyMatchData match = (RubyMatchData)holder[0];</span>
<span class="fc" id="L3111">            return RubyRegexp.nth_match(match.backrefNumber(backref), match);</span>
        }

<span class="fc" id="L3114">        return runtime.getNil();</span>
    }

    private IRubyObject subpat19(Ruby runtime, ThreadContext context, RubyRegexp regex) {
<span class="fc" id="L3118">        IRubyObject[] holder = {context.nil};</span>

<span class="fc" id="L3120">        int result = regex.search19(context, this, 0, false, holder);</span>
<span class="fc" id="L3121">        context.setBackRef(holder[0]);</span>

<span class="fc bfc" id="L3123" title="All 2 branches covered.">        if (result &gt;= 0) {</span>
<span class="fc" id="L3124">            return RubyRegexp.nth_match(0, holder[0]);</span>
        }

<span class="fc" id="L3127">        return runtime.getNil();</span>
    }

    /** rb_str_aset, rb_str_aset_m
     *
     */
    public IRubyObject op_aset(ThreadContext context, IRubyObject arg0, IRubyObject arg1) {
<span class="nc" id="L3134">        return op_aset19(context, arg0, arg1);</span>
    }

    public IRubyObject op_aset(ThreadContext context, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {
<span class="nc" id="L3138">        return op_aset19(context, arg0, arg1, arg2);</span>
    }

    @JRubyMethod(name = &quot;[]=&quot;, reads = BACKREF)
    public IRubyObject op_aset19(ThreadContext context, IRubyObject arg0, IRubyObject arg1) {
<span class="fc bfc" id="L3143" title="All 2 branches covered.">        if (arg0 instanceof RubyFixnum) {</span>
<span class="fc" id="L3144">            return op_aset19(context, RubyNumeric.fix2int((RubyFixnum)arg0), arg1);</span>
<span class="fc bfc" id="L3145" title="All 2 branches covered.">        } else if (arg0 instanceof RubyRegexp) {</span>
<span class="fc" id="L3146">            subpatSet19(context, (RubyRegexp)arg0, null, arg1);</span>
<span class="fc" id="L3147">            return arg1;</span>
<span class="fc bfc" id="L3148" title="All 2 branches covered.">        } else if (arg0 instanceof RubyString) {</span>
<span class="fc" id="L3149">            RubyString orig = (RubyString)arg0;</span>
<span class="fc" id="L3150">            int beg = StringSupport.index(this, this.value, this.strLength(this.checkEncoding(orig)), orig, orig.value, orig.strLength(this.checkEncoding(orig)), 0, this.checkEncoding(orig));</span>
<span class="fc bfc" id="L3151" title="All 2 branches covered.">            if (beg &lt; 0) throw context.runtime.newIndexError(&quot;string not matched&quot;);</span>
<span class="fc" id="L3152">            beg = subLength(beg);</span>
<span class="fc" id="L3153">            replaceInternal19(beg, orig.strLength(), arg1.convertToString());</span>
<span class="fc" id="L3154">            return arg1;</span>
<span class="fc bfc" id="L3155" title="All 2 branches covered.">        } else if (arg0 instanceof RubyRange) {</span>
<span class="fc" id="L3156">            int[] begLen = ((RubyRange) arg0).begLenInt(strLength(), 2);</span>
<span class="fc" id="L3157">            replaceInternal19(begLen[0], begLen[1], arg1.convertToString());</span>
<span class="fc" id="L3158">            return arg1;</span>
<span class="pc bpc" id="L3159" title="3 of 4 branches missed.">        } else if (arg0.respondsTo(&quot;begin&quot;) &amp;&amp; arg0.respondsTo(&quot;end&quot;)) {</span>
<span class="nc" id="L3160">            IRubyObject begin = arg0.callMethod(context, &quot;begin&quot;);</span>
<span class="nc" id="L3161">            IRubyObject end   = arg0.callMethod(context, &quot;end&quot;);</span>
<span class="nc" id="L3162">            IRubyObject excl  = arg0.callMethod(context, &quot;exclude_end?&quot;);</span>
<span class="nc" id="L3163">            RubyRange rng = RubyRange.newRange(context, begin, end, excl.isTrue());</span>

<span class="nc" id="L3165">            int[] begLen = rng.begLenInt(strLength(), 2);</span>
<span class="nc" id="L3166">            replaceInternal19(begLen[0], begLen[1], arg1.convertToString());</span>

<span class="nc" id="L3168">            return arg1;</span>
        }
<span class="fc" id="L3170">        return op_aset19(context, RubyNumeric.num2int(arg0), arg1);</span>
    }

    private IRubyObject op_aset19(ThreadContext context, int idx, IRubyObject arg1) {
<span class="fc" id="L3174">        replaceInternal19(checkIndex(idx, strLength()), 1, arg1.convertToString());</span>
<span class="fc" id="L3175">        return arg1;</span>
    }

    @JRubyMethod(name = &quot;[]=&quot;, reads = BACKREF)
    public IRubyObject op_aset19(ThreadContext context, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {
<span class="fc bfc" id="L3180" title="All 2 branches covered.">        if (arg0 instanceof RubyRegexp) {</span>
<span class="fc" id="L3181">            subpatSet19(context, (RubyRegexp)arg0, arg1, arg2);</span>
        } else {
<span class="fc" id="L3183">            int beg = RubyNumeric.num2int(arg0);</span>
<span class="fc" id="L3184">            int len = RubyNumeric.num2int(arg1);</span>
<span class="fc" id="L3185">            checkLength(len);</span>
<span class="fc" id="L3186">            RubyString repl = arg2.convertToString();</span>
<span class="fc" id="L3187">            replaceInternal19(checkIndex(beg, strLength()), len, repl);</span>
        }
<span class="fc" id="L3189">        return arg2;</span>
    }

    /** rb_str_slice_bang
     *
     */
    public IRubyObject slice_bang(ThreadContext context, IRubyObject arg0) {
<span class="nc" id="L3196">        return slice_bang19(context, arg0);</span>
    }

    public IRubyObject slice_bang(ThreadContext context, IRubyObject arg0, IRubyObject arg1) {
<span class="nc" id="L3200">        return slice_bang19(context, arg0, arg1);</span>
    }

    @JRubyMethod(name = &quot;slice!&quot;, reads = BACKREF, writes = BACKREF)
    public IRubyObject slice_bang19(ThreadContext context, IRubyObject arg0) {
<span class="fc" id="L3205">        IRubyObject result = op_aref19(context, arg0);</span>
<span class="fc bfc" id="L3206" title="All 2 branches covered.">        if (result.isNil()) {</span>
<span class="fc" id="L3207">            modifyCheck(); // keep cr ?</span>
        } else {
<span class="fc" id="L3209">            op_aset19(context, arg0, RubyString.newEmptyString(context.runtime));</span>
        }
<span class="fc" id="L3211">        return result;</span>
    }

    @JRubyMethod(name = &quot;slice!&quot;, reads = BACKREF, writes = BACKREF)
    public IRubyObject slice_bang19(ThreadContext context, IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L3216">        IRubyObject result = op_aref19(context, arg0, arg1);</span>
<span class="fc bfc" id="L3217" title="All 2 branches covered.">        if (result.isNil()) {</span>
<span class="fc" id="L3218">            modifyCheck(); // keep cr ?</span>
        } else {
<span class="fc" id="L3220">            op_aset19(context, arg0, arg1, RubyString.newEmptyString(context.runtime));</span>
        }
<span class="fc" id="L3222">        return result;</span>
    }

    public IRubyObject succ(ThreadContext context) {
<span class="nc" id="L3226">        return succ19(context);</span>
    }

    public IRubyObject succ_bang() {
<span class="nc" id="L3230">        return succ_bang19();</span>
    }

    @JRubyMethod(name = {&quot;succ&quot;, &quot;next&quot;})
    public IRubyObject succ19(ThreadContext context) {
<span class="fc" id="L3235">        Ruby runtime = context.runtime;</span>
        final RubyString str;
<span class="fc bfc" id="L3237" title="All 2 branches covered.">        if (value.getRealSize() &gt; 0) {</span>
<span class="fc" id="L3238">            str = new RubyString(runtime, getMetaClass(), StringSupport.succCommon(value));</span>
            // TODO: rescan code range ?
        } else {
<span class="fc" id="L3241">            str = newEmptyString(runtime, getType(), value.getEncoding());</span>
        }
<span class="fc" id="L3243">        return str.infectBy(this);</span>
    }

    @JRubyMethod(name = {&quot;succ!&quot;, &quot;next!&quot;})
    public IRubyObject succ_bang19() {
<span class="fc" id="L3248">        modifyCheck();</span>
<span class="fc bfc" id="L3249" title="All 2 branches covered.">        if (value.getRealSize() &gt; 0) {</span>
<span class="fc" id="L3250">            value = StringSupport.succCommon(value);</span>
<span class="fc" id="L3251">            shareLevel = SHARE_LEVEL_NONE;</span>
            // TODO: rescan code range ?
        }
<span class="fc" id="L3254">        return this;</span>
    }

    /** rb_str_upto_m
     *
     */
    @JRubyMethod(name = &quot;upto&quot;)
    public IRubyObject upto19(ThreadContext context, IRubyObject end, Block block) {
<span class="fc" id="L3262">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L3263" title="All 2 branches covered.">        return block.isGiven() ? uptoCommon19(context, end, false, block) : enumeratorize(runtime, this, &quot;upto&quot;, end);</span>
    }

    @JRubyMethod(name = &quot;upto&quot;)
    public IRubyObject upto19(ThreadContext context, IRubyObject end, IRubyObject excl, Block block) {
<span class="fc bfc" id="L3268" title="All 2 branches covered.">        return block.isGiven() ? uptoCommon19(context, end, excl.isTrue(), block) :</span>
<span class="fc" id="L3269">            enumeratorize(context.runtime, this, &quot;upto&quot;, new IRubyObject[]{end, excl});</span>
    }

    final IRubyObject uptoCommon19(ThreadContext context, IRubyObject arg, boolean excl, Block block) {
<span class="fc" id="L3273">        return uptoCommon19(context, arg, excl, block, false);</span>
    }

    final IRubyObject uptoCommon19(ThreadContext context, IRubyObject arg, boolean excl, Block block, boolean asSymbol) {
<span class="fc" id="L3277">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L3278" title="All 2 branches covered.">        if (arg instanceof RubySymbol) throw runtime.newTypeError(&quot;can't convert Symbol into String&quot;);</span>

<span class="fc" id="L3280">        RubyString end = arg.convertToString();</span>
<span class="fc" id="L3281">        Encoding enc = checkEncoding(end);</span>
<span class="pc bpc" id="L3282" title="1 of 4 branches missed.">        boolean isAscii = scanForCodeRange() == CR_7BIT &amp;&amp; end.scanForCodeRange() == CR_7BIT;</span>
<span class="pc bpc" id="L3283" title="1 of 6 branches missed.">        if (value.getRealSize() == 1 &amp;&amp; end.value.getRealSize() == 1 &amp;&amp; isAscii) {</span>
<span class="fc" id="L3284">            byte c = value.getUnsafeBytes()[value.getBegin()];</span>
<span class="fc" id="L3285">            byte e = end.value.getUnsafeBytes()[end.value.getBegin()];</span>
<span class="pc bpc" id="L3286" title="1 of 6 branches missed.">            if (c &gt; e || (excl &amp;&amp; c == e)) return this;</span>
            while (true) {
<span class="fc" id="L3288">                RubyString s = new RubyString(runtime, runtime.getString(), RubyInteger.SINGLE_CHAR_BYTELISTS[c &amp; 0xff],</span>
                                                                            enc, CR_7BIT);
<span class="fc" id="L3290">                s.shareLevel = SHARE_LEVEL_BYTELIST;</span>
<span class="fc bfc" id="L3291" title="All 2 branches covered.">                block.yield(context, asSymbol ? runtime.newSymbol(s.toString()) : s);</span>

<span class="fc bfc" id="L3293" title="All 4 branches covered.">                if (!excl &amp;&amp; c == e) break;</span>
<span class="fc" id="L3294">                c++;</span>
<span class="fc bfc" id="L3295" title="All 4 branches covered.">                if (excl &amp;&amp; c == e) break;</span>
<span class="fc" id="L3296">            }</span>
<span class="fc" id="L3297">            return this;</span>
<span class="fc bfc" id="L3298" title="All 6 branches covered.">        } else if (isAscii &amp;&amp; ASCII.isDigit(value.getUnsafeBytes()[value.getBegin()]) &amp;&amp; ASCII.isDigit(end.value.getUnsafeBytes()[end.value.getBegin()])) {</span>
<span class="fc" id="L3299">            int s = value.getBegin();</span>
<span class="fc" id="L3300">            int send = s + value.getRealSize();</span>
<span class="fc" id="L3301">            byte[]bytes = value.getUnsafeBytes();</span>

<span class="fc bfc" id="L3303" title="All 2 branches covered.">            while (s &lt; send) {</span>
<span class="pc bpc" id="L3304" title="1 of 2 branches missed.">                if (!ASCII.isDigit(bytes[s] &amp; 0xff)) return uptoCommon19NoDigits(context, end, excl, block, asSymbol);</span>
<span class="fc" id="L3305">                s++;</span>
            }
<span class="fc" id="L3307">            s = end.value.getBegin();</span>
<span class="fc" id="L3308">            send = s + end.value.getRealSize();</span>
<span class="fc" id="L3309">            bytes = end.value.getUnsafeBytes();</span>

<span class="fc bfc" id="L3311" title="All 2 branches covered.">            while (s &lt; send) {</span>
<span class="pc bpc" id="L3312" title="1 of 2 branches missed.">                if (!ASCII.isDigit(bytes[s] &amp; 0xff)) return uptoCommon19NoDigits(context, end, excl, block, asSymbol);</span>
<span class="fc" id="L3313">                s++;</span>
            }

<span class="fc" id="L3316">            IRubyObject b = stringToInum19(10, false);</span>
<span class="fc" id="L3317">            IRubyObject e = end.stringToInum19(10, false);</span>

<span class="fc" id="L3319">            IRubyObject[]args = new IRubyObject[2];</span>
<span class="fc" id="L3320">            args[0] = RubyFixnum.newFixnum(runtime, value.length());</span>
<span class="fc" id="L3321">            RubyArray argsArr = runtime.newArrayNoCopy(args);</span>

<span class="pc bpc" id="L3323" title="2 of 4 branches missed.">            if (b instanceof RubyFixnum &amp;&amp; e instanceof RubyFixnum) {</span>
<span class="fc" id="L3324">                int bi = RubyNumeric.fix2int(b);</span>
<span class="fc" id="L3325">                int ei = RubyNumeric.fix2int(e);</span>

<span class="fc bfc" id="L3327" title="All 2 branches covered.">                while (bi &lt;= ei) {</span>
<span class="pc bpc" id="L3328" title="3 of 4 branches missed.">                    if (excl &amp;&amp; bi == ei) break;</span>
<span class="fc" id="L3329">                    args[1] = RubyFixnum.newFixnum(runtime, bi);</span>
<span class="fc" id="L3330">                    ByteList to = new ByteList(value.length() + 5);</span>
<span class="fc" id="L3331">                    Sprintf.sprintf(to, &quot;%.*d&quot;, argsArr);</span>
<span class="fc" id="L3332">                    RubyString str = RubyString.newStringNoCopy(runtime, to, USASCIIEncoding.INSTANCE, CR_7BIT);</span>
<span class="pc bpc" id="L3333" title="1 of 2 branches missed.">                    block.yield(context, asSymbol ? runtime.newSymbol(str.toString()) : str);</span>
<span class="fc" id="L3334">                    bi++;</span>
<span class="fc" id="L3335">                }</span>
<span class="fc" id="L3336">            } else {</span>
<span class="nc bnc" id="L3337" title="All 2 branches missed.">                String op = excl ? &quot;&lt;&quot; : &quot;&lt;=&quot;;</span>

<span class="nc bnc" id="L3339" title="All 2 branches missed.">                while (b.callMethod(context, op, e).isTrue()) {</span>
<span class="nc" id="L3340">                    args[1] = b;</span>
<span class="nc" id="L3341">                    ByteList to = new ByteList(value.length() + 5);</span>
<span class="nc" id="L3342">                    Sprintf.sprintf(to, &quot;%.*d&quot;, argsArr);</span>
<span class="nc" id="L3343">                    RubyString str = RubyString.newStringNoCopy(runtime, to, USASCIIEncoding.INSTANCE, CR_7BIT);</span>
<span class="nc bnc" id="L3344" title="All 2 branches missed.">                    block.yield(context, asSymbol ? runtime.newSymbol(str.toString()) : str);</span>
<span class="nc" id="L3345">                    b = b.callMethod(context, &quot;succ&quot;);</span>
<span class="nc" id="L3346">                }</span>
            }
<span class="fc" id="L3348">            return this;</span>
        }

<span class="fc" id="L3351">        return uptoCommon19NoDigits(context, end, excl, block, asSymbol);</span>
    }

    private IRubyObject uptoCommon19NoDigits(ThreadContext context, RubyString end, boolean excl, Block block, boolean asSymbol) {
<span class="fc" id="L3355">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L3356">        int n = op_cmp(end);</span>
<span class="pc bpc" id="L3357" title="2 of 6 branches missed.">        if (n &gt; 0 || (excl &amp;&amp; n == 0)) return this;</span>
<span class="fc" id="L3358">        IRubyObject afterEnd = end.callMethod(context, &quot;succ&quot;);</span>
<span class="fc" id="L3359">        RubyString current = strDup(context.runtime);</span>

<span class="pc bpc" id="L3361" title="1 of 2 branches missed.">        while (!current.op_equal19(context, afterEnd).isTrue()) {</span>
<span class="fc" id="L3362">            IRubyObject next = null;</span>
<span class="fc bfc" id="L3363" title="All 4 branches covered.">            if (excl || !current.op_equal19(context, end).isTrue()) next = current.callMethod(context, &quot;succ&quot;);</span>
<span class="fc bfc" id="L3364" title="All 2 branches covered.">            block.yield(context, asSymbol ? runtime.newSymbol(current.toString()) : current);</span>
<span class="fc bfc" id="L3365" title="All 2 branches covered.">            if (next == null) break;</span>
<span class="fc" id="L3366">            current = next.convertToString();</span>
<span class="fc bfc" id="L3367" title="All 4 branches covered.">            if (excl &amp;&amp; current.op_equal19(context, end).isTrue()) break;</span>
<span class="pc bpc" id="L3368" title="1 of 4 branches missed.">            if (current.getByteList().length() &gt; end.getByteList().length() || current.getByteList().length() == 0) break;</span>
<span class="fc" id="L3369">        }</span>
<span class="fc" id="L3370">        return this;</span>
    }

    /** rb_str_include
     *
     */
    public RubyBoolean include_p(ThreadContext context, IRubyObject obj) {
<span class="nc" id="L3377">        return include_p19(context, obj);</span>
    }

    @JRubyMethod(name = &quot;include?&quot;)
    public RubyBoolean include_p19(ThreadContext context, IRubyObject obj) {
<span class="fc" id="L3382">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L3383">        RubyString coerced = obj.convertToString();</span>
<span class="fc bfc" id="L3384" title="All 2 branches covered.">        return StringSupport.index(this, this.value, this.strLength(this.checkEncoding(coerced)), coerced, coerced.value, coerced.strLength(this.checkEncoding(coerced)), 0, this.checkEncoding(coerced)) == -1 ? runtime.getFalse() : runtime.getTrue();</span>
    }

    @JRubyMethod
    public IRubyObject chr(ThreadContext context) {
<span class="fc" id="L3389">        return substr19(context.runtime, 0, 1);</span>
    }

    @JRubyMethod
    public IRubyObject getbyte(ThreadContext context, IRubyObject index) {
<span class="fc" id="L3394">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L3395">        int i = RubyNumeric.num2int(index);</span>
<span class="fc bfc" id="L3396" title="All 2 branches covered.">        if (i &lt; 0) i += value.getRealSize();</span>
<span class="pc bpc" id="L3397" title="1 of 4 branches missed.">        if (i &lt; 0 || i &gt;= value.getRealSize()) return runtime.getNil();</span>
<span class="fc" id="L3398">        return RubyFixnum.newFixnum(runtime, value.getUnsafeBytes()[value.getBegin() + i] &amp; 0xff);</span>
    }

    @JRubyMethod
    public IRubyObject setbyte(ThreadContext context, IRubyObject index, IRubyObject val) {
<span class="fc" id="L3403">        modifyAndKeepCodeRange();</span>
<span class="fc" id="L3404">        int i = RubyNumeric.num2int(index);</span>
<span class="fc" id="L3405">        int b = RubyNumeric.num2int(val);</span>
<span class="fc" id="L3406">        value.getUnsafeBytes()[checkIndexForRef(i, value.getRealSize())] = (byte)b;</span>
<span class="fc" id="L3407">        return val;</span>
    }

    /** rb_str_to_i
     *
     */
    public IRubyObject to_i() {
<span class="nc" id="L3414">        return to_i19();</span>
    }

    /** rb_str_to_i
     *
     */
    public IRubyObject to_i(IRubyObject arg0) {
<span class="nc" id="L3421">        return to_i19(arg0);</span>
    }

    @JRubyMethod(name = &quot;to_i&quot;)
    public IRubyObject to_i19() {
<span class="fc" id="L3426">        return stringToInum19(10, false);</span>
    }

    @JRubyMethod(name = &quot;to_i&quot;)
    public IRubyObject to_i19(IRubyObject arg0) {
<span class="fc" id="L3431">        long base = checkBase(arg0);</span>
<span class="fc" id="L3432">        return stringToInum19((int)base, false);</span>
    }

    private long checkBase(IRubyObject arg0) {
<span class="fc" id="L3436">        long base = arg0.convertToInteger().getLongValue();</span>
<span class="fc bfc" id="L3437" title="All 2 branches covered.">        if(base &lt; 0) {</span>
<span class="fc" id="L3438">            throw getRuntime().newArgumentError(&quot;illegal radix &quot; + base);</span>
        }
<span class="fc" id="L3440">        return base;</span>
    }

    /** rb_str_to_inum
     *
     */
    public IRubyObject stringToInum(int base, boolean badcheck) {
<span class="fc" id="L3447">        ByteList s = this.value;</span>
<span class="fc" id="L3448">        return ConvertBytes.byteListToInum(getRuntime(), s, base, badcheck);</span>
    }

    public IRubyObject stringToInum19(int base, boolean badcheck) {
<span class="fc" id="L3452">        ByteList s = this.value;</span>
<span class="fc" id="L3453">        return ConvertBytes.byteListToInum19(getRuntime(), s, base, badcheck);</span>
    }

    /** rb_str_oct
     *
     */
    public IRubyObject oct(ThreadContext context) {
<span class="nc" id="L3460">        return oct19(context);</span>
    }

    @JRubyMethod(name = &quot;oct&quot;)
    public IRubyObject oct19(ThreadContext context) {
<span class="pc bpc" id="L3465" title="1 of 2 branches missed.">        if (!value.getEncoding().isAsciiCompatible()) {</span>
<span class="nc" id="L3466">            throw context.runtime.newEncodingCompatibilityError(&quot;ASCII incompatible encoding: &quot; + value.getEncoding());</span>
        }
<span class="fc" id="L3468">        return stringToInum(-8, false);</span>
    }

    /** rb_str_hex
     *
     */
    public IRubyObject hex(ThreadContext context) {
<span class="nc" id="L3475">        return hex19(context);</span>
    }

    @JRubyMethod(name = &quot;hex&quot;)
    public IRubyObject hex19(ThreadContext context) {
<span class="pc bpc" id="L3480" title="1 of 2 branches missed.">        if (!value.getEncoding().isAsciiCompatible()) {</span>
<span class="nc" id="L3481">            throw context.runtime.newEncodingCompatibilityError(&quot;ASCII incompatible encoding: &quot; + value.getEncoding());</span>
        }
<span class="fc" id="L3483">        return stringToInum19(16, false);</span>
    }

    /** rb_str_to_f
     *
     */
    public IRubyObject to_f() {
<span class="nc" id="L3490">        return to_f19();</span>
    }

    @JRubyMethod(name = &quot;to_f&quot;)
    public IRubyObject to_f19() {
<span class="fc" id="L3495">        return RubyNumeric.str2fnum19(getRuntime(), this, false);</span>
    }

    /** rb_str_split_m
     *
     */
    public RubyArray split(ThreadContext context) {
<span class="nc" id="L3502">        return split19(context);</span>
    }

    public RubyArray split(ThreadContext context, IRubyObject arg0) {
<span class="nc" id="L3506">        return split19(context, arg0);</span>
    }

    public RubyArray split(ThreadContext context, IRubyObject arg0, IRubyObject arg1) {
<span class="nc" id="L3510">        return split19(context, arg0, arg1);</span>
    }

    private void populateCapturesForSplit(Ruby runtime, RubyArray result, Matcher matcher, boolean is19) {
<span class="fc" id="L3514">        Region region = matcher.getRegion();</span>
<span class="fc bfc" id="L3515" title="All 2 branches covered.">        for (int i = 1; i &lt; region.numRegs; i++) {</span>
<span class="fc" id="L3516">            int beg = region.beg[i];</span>
<span class="fc bfc" id="L3517" title="All 2 branches covered.">            if (beg == -1) continue;</span>
<span class="pc bpc" id="L3518" title="1 of 2 branches missed.">            result.append(is19 ? makeShared19(runtime, beg, region.end[i] - beg) : makeShared(runtime, beg, region.end[i] - beg));</span>
        }
<span class="fc" id="L3520">    }</span>

    @JRubyMethod(name = &quot;split&quot;, writes = BACKREF)
    public RubyArray split19(ThreadContext context) {
<span class="fc" id="L3524">        return split19(context, context.runtime.getNil());</span>
    }

    @JRubyMethod(name = &quot;split&quot;, writes = BACKREF)
    public RubyArray split19(ThreadContext context, IRubyObject arg0) {
<span class="fc" id="L3529">        return splitCommon19(arg0, false, 0, 0, context, true);</span>
    }

    @JRubyMethod(name = &quot;split&quot;, writes = BACKREF)
    public RubyArray split19(ThreadContext context, IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L3534">        final int lim = RubyNumeric.num2int(arg1);</span>
<span class="fc bfc" id="L3535" title="All 2 branches covered.">        if (lim &lt;= 0) {</span>
<span class="fc" id="L3536">            return splitCommon19(arg0, false, lim, 1, context, true);</span>
        } else {
<span class="fc bfc" id="L3538" title="All 4 branches covered.">            if (lim == 1) return value.getRealSize() == 0 ? context.runtime.newArray() : context.runtime.newArray(this);</span>
<span class="fc" id="L3539">            return splitCommon19(arg0, true, lim, 1, context, true);</span>
        }
    }

    public RubyArray split19(ThreadContext context, IRubyObject arg0, boolean useBackref) {
<span class="fc" id="L3544">        return splitCommon19(arg0, useBackref, flags, flags, context, useBackref);</span>
    }

    private RubyArray splitCommon19(IRubyObject spat, final boolean limit, final int lim, final int i, ThreadContext context, boolean useBackref) {
        final RubyArray result;
<span class="fc bfc" id="L3549" title="All 4 branches covered.">        if (spat.isNil() &amp;&amp; (spat = context.runtime.getGlobalVariables().get(&quot;$;&quot;)).isNil()) {</span>
<span class="fc" id="L3550">            result = awkSplit19(limit, lim, i);</span>
        } else {
<span class="fc bfc" id="L3552" title="All 2 branches covered.">            if (spat instanceof RubyString) {</span>
<span class="fc" id="L3553">                ByteList spatValue = ((RubyString)spat).value;</span>
<span class="fc" id="L3554">                int len = spatValue.getRealSize();</span>
<span class="fc" id="L3555">                Encoding spatEnc = spatValue.getEncoding();</span>
<span class="fc bfc" id="L3556" title="All 2 branches covered.">                if (len == 0) {</span>
<span class="fc" id="L3557">                    Regex pattern = RubyRegexp.getRegexpFromCache(context.runtime, spatValue, spatEnc, new RegexpOptions());</span>
<span class="fc" id="L3558">                    result = regexSplit19(context, pattern, pattern, limit, lim, i, useBackref);</span>
<span class="fc" id="L3559">                } else {</span>
                    final int c;
<span class="fc" id="L3561">                    byte[]bytes = spatValue.getUnsafeBytes();</span>
<span class="fc" id="L3562">                    int p = spatValue.getBegin();</span>
<span class="pc bpc" id="L3563" title="1 of 2 branches missed.">                    if (spatEnc.isAsciiCompatible()) {</span>
<span class="fc bfc" id="L3564" title="All 2 branches covered.">                        c = len == 1 ? bytes[p] &amp; 0xff : -1;</span>
                    } else {
<span class="nc bnc" id="L3566" title="All 2 branches missed.">                        c = len == StringSupport.preciseLength(spatEnc, bytes, p, p + len) ? spatEnc.mbcToCode(bytes, p, p + len) : -1;</span>
                    }
<span class="fc bfc" id="L3568" title="All 2 branches covered.">                    result = c == ' ' ? awkSplit19(limit, lim, i) : stringSplit19(context, (RubyString)spat, limit, lim, i);</span>
                }
<span class="fc" id="L3570">            } else {</span>
                final Regex pattern, prepared;

<span class="fc" id="L3573">                Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L3574" title="All 2 branches covered.">                if (spat instanceof RubyRegexp) {</span>
<span class="fc" id="L3575">                    RubyRegexp regexp = (RubyRegexp)spat;</span>
<span class="fc" id="L3576">                    pattern = regexp.getPattern();</span>
<span class="fc" id="L3577">                    prepared = regexp.preparePattern(this);</span>
<span class="fc" id="L3578">                } else {</span>
<span class="fc" id="L3579">                    pattern = getStringPattern19(runtime, spat);</span>
<span class="fc" id="L3580">                    prepared = RubyRegexp.preparePattern(runtime, pattern, this);</span>
                }
<span class="fc" id="L3582">                result = regexSplit19(context, pattern, prepared, limit, lim, i, useBackref);</span>
            }
        }

<span class="fc bfc" id="L3586" title="All 4 branches covered.">        if (!limit &amp;&amp; lim == 0) {</span>
<span class="fc bfc" id="L3587" title="All 4 branches covered.">            while (result.size() &gt; 0 &amp;&amp; ((RubyString) result.eltInternal(result.size() - 1)).value.getRealSize() == 0) {</span>
<span class="fc" id="L3588">                result.pop(context);</span>
            }
        }

<span class="fc" id="L3592">        return result;</span>
    }

    private RubyArray regexSplit19(ThreadContext context, Regex pattern, Regex prepared, boolean limit, int lim, int i, boolean useBackref) {
<span class="fc" id="L3596">        Ruby runtime = context.runtime;</span>

<span class="fc" id="L3598">        int begin = value.getBegin();</span>
<span class="fc" id="L3599">        int len = value.getRealSize();</span>
<span class="fc" id="L3600">        int range = begin + len;</span>
<span class="fc" id="L3601">        byte[]bytes = value.getUnsafeBytes();</span>

<span class="fc" id="L3603">        final Matcher matcher = prepared.matcher(bytes, begin, range);</span>

<span class="fc" id="L3605">        RubyArray result = runtime.newArray();</span>
<span class="fc" id="L3606">        Encoding enc = value.getEncoding();</span>
<span class="fc bfc" id="L3607" title="All 2 branches covered.">        boolean captures = pattern.numberOfCaptures() != 0;</span>

<span class="fc" id="L3609">        int end, beg = 0;</span>
<span class="fc" id="L3610">        boolean lastNull = false;</span>
<span class="fc" id="L3611">        int start = begin;</span>
<span class="fc bfc" id="L3612" title="All 2 branches covered.">        while ((end = RubyRegexp.matcherSearch(runtime, matcher, start, range, Option.NONE)) &gt;= 0) {</span>
<span class="fc bfc" id="L3613" title="All 4 branches covered.">            if (start == end + begin &amp;&amp; matcher.getBegin() == matcher.getEnd()) {</span>
<span class="fc bfc" id="L3614" title="All 2 branches covered.">                if (len == 0) {</span>
<span class="fc" id="L3615">                    result.append(newEmptyString(runtime, getMetaClass()).infectBy(this));</span>
<span class="fc" id="L3616">                    break;</span>
<span class="fc bfc" id="L3617" title="All 2 branches covered.">                } else if (lastNull) {</span>
<span class="fc" id="L3618">                    result.append(makeShared19(runtime, beg, StringSupport.length(enc, bytes, begin + beg, range)));</span>
<span class="fc" id="L3619">                    beg = start - begin;</span>
                } else {
<span class="fc bfc" id="L3621" title="All 2 branches covered.">                    start += start == range ? 1 : StringSupport.length(enc, bytes, start, range);</span>
<span class="fc" id="L3622">                    lastNull = true;</span>
<span class="fc" id="L3623">                    continue;</span>
                }
            } else {
<span class="fc" id="L3626">                result.append(makeShared19(runtime, beg, end - beg));</span>
<span class="fc" id="L3627">                beg = matcher.getEnd();</span>
<span class="fc" id="L3628">                start = begin + beg;</span>
            }
<span class="fc" id="L3630">            lastNull = false;</span>

<span class="fc bfc" id="L3632" title="All 2 branches covered.">            if (captures) populateCapturesForSplit(runtime, result, matcher, true);</span>
<span class="fc bfc" id="L3633" title="All 4 branches covered.">            if (limit &amp;&amp; lim &lt;= ++i) break;</span>
        }

        // only this case affects backrefs
<span class="fc bfc" id="L3637" title="All 2 branches covered.">        if (useBackref) context.setBackRef(runtime.getNil());</span>

<span class="fc bfc" id="L3639" title="All 8 branches covered.">        if (len &gt; 0 &amp;&amp; (limit || len &gt; beg || lim &lt; 0)) result.append(makeShared19(runtime, beg, len - beg));</span>
<span class="fc" id="L3640">        return result;</span>
    }

    private RubyArray awkSplit19(boolean limit, int lim, int i) {
<span class="fc" id="L3644">        Ruby runtime = getRuntime();</span>
<span class="fc" id="L3645">        RubyArray result = runtime.newArray();</span>

<span class="fc" id="L3647">        byte[]bytes = value.getUnsafeBytes();</span>
<span class="fc" id="L3648">        int p = value.getBegin();</span>
<span class="fc" id="L3649">        int ptr = p;</span>
<span class="fc" id="L3650">        int len = value.getRealSize();</span>
<span class="fc" id="L3651">        int end = p + len;</span>
<span class="fc" id="L3652">        Encoding enc = value.getEncoding();</span>
<span class="fc" id="L3653">        boolean skip = true;</span>

<span class="fc" id="L3655">        int e = 0, b = 0;</span>
<span class="fc" id="L3656">        boolean singlebyte = singleByteOptimizable(enc);</span>
<span class="fc bfc" id="L3657" title="All 2 branches covered.">        while (p &lt; end) {</span>
            final int c;
<span class="fc bfc" id="L3659" title="All 2 branches covered.">            if (singlebyte) {</span>
<span class="fc" id="L3660">                c = bytes[p++] &amp; 0xff;</span>
            } else {
<span class="fc" id="L3662">                c = StringSupport.codePoint(runtime, enc, bytes, p, end);</span>
<span class="fc" id="L3663">                p += StringSupport.length(enc, bytes, p, end);</span>
            }

<span class="fc bfc" id="L3666" title="All 2 branches covered.">            if (skip) {</span>
<span class="fc bfc" id="L3667" title="All 2 branches covered.">                if (enc.isSpace(c)) {</span>
<span class="fc" id="L3668">                    b = p - ptr;</span>
                } else {
<span class="fc" id="L3670">                    e = p - ptr;</span>
<span class="fc" id="L3671">                    skip = false;</span>
<span class="fc bfc" id="L3672" title="All 4 branches covered.">                    if (limit &amp;&amp; lim &lt;= i) break;</span>
                }
            } else {
<span class="fc bfc" id="L3675" title="All 2 branches covered.">                if (enc.isSpace(c)) {</span>
<span class="fc" id="L3676">                    result.append(makeShared19(runtime, b, e - b));</span>
<span class="fc" id="L3677">                    skip = true;</span>
<span class="fc" id="L3678">                    b = p - ptr;</span>
<span class="fc bfc" id="L3679" title="All 2 branches covered.">                    if (limit) i++;</span>
                } else {
<span class="fc" id="L3681">                    e = p - ptr;</span>
                }
            }
<span class="fc" id="L3684">        }</span>

<span class="fc bfc" id="L3686" title="All 8 branches covered.">        if (len &gt; 0 &amp;&amp; (limit || len &gt; b || lim &lt; 0)) result.append(makeShared19(runtime, b, len - b));</span>
<span class="fc" id="L3687">        return result;</span>
    }

    private RubyArray stringSplit19(ThreadContext context, RubyString spat, boolean limit, int lim, int i) {
<span class="fc" id="L3691">        Ruby runtime = context.runtime;</span>
<span class="pc bpc" id="L3692" title="1 of 2 branches missed.">        if (scanForCodeRange() == CR_BROKEN) throw runtime.newArgumentError(&quot;invalid byte sequence in &quot; + value.getEncoding());</span>
<span class="fc bfc" id="L3693" title="All 2 branches covered.">        if (spat.scanForCodeRange() == CR_BROKEN) throw runtime.newArgumentError(&quot;invalid byte sequence in &quot; + spat.value.getEncoding());</span>

<span class="fc" id="L3695">        RubyArray result = runtime.newArray();</span>
<span class="fc" id="L3696">        Encoding enc = checkEncoding(spat);</span>
<span class="fc" id="L3697">        ByteList pattern = spat.value;</span>

<span class="fc" id="L3699">        byte[] patternBytes = pattern.getUnsafeBytes();</span>
<span class="fc" id="L3700">        int patternBegin = pattern.getBegin();</span>
<span class="fc" id="L3701">        int patternRealSize = pattern.getRealSize();</span>

<span class="fc" id="L3703">        byte[] bytes = value.getUnsafeBytes();</span>
<span class="fc" id="L3704">        int begin = value.getBegin();</span>
<span class="fc" id="L3705">        int realSize = value.getRealSize();</span>

<span class="fc" id="L3707">        int e, p = 0;</span>

<span class="fc bfc" id="L3709" title="All 4 branches covered.">        while (p &lt; realSize &amp;&amp; (e = indexOf(bytes, begin, realSize, patternBytes, patternBegin, patternRealSize, p)) &gt;= 0) {</span>
<span class="fc" id="L3710">            int t = enc.rightAdjustCharHead(bytes, p + begin, e + begin, begin + realSize) - begin;</span>
<span class="pc bpc" id="L3711" title="1 of 2 branches missed.">            if (t != e) {</span>
<span class="nc" id="L3712">                p = t;</span>
<span class="nc" id="L3713">                continue;</span>
            }
<span class="fc" id="L3715">            result.append(makeShared19(runtime, p, e - p));</span>
<span class="fc" id="L3716">            p = e + pattern.getRealSize();</span>
<span class="fc bfc" id="L3717" title="All 4 branches covered.">            if (limit &amp;&amp; lim &lt;= ++i) break;</span>
<span class="fc" id="L3718">        }</span>

<span class="fc bfc" id="L3720" title="All 8 branches covered.">        if (value.getRealSize() &gt; 0 &amp;&amp; (limit || value.getRealSize() &gt; p || lim &lt; 0)) {</span>
<span class="fc" id="L3721">            result.append(makeShared19(runtime, p, value.getRealSize() - p));</span>
        }

<span class="fc" id="L3724">        return result;</span>
    }

    // TODO: make the ByteList version public and use it, rather than copying here
    static int indexOf(byte[] source, int sourceOffset, int sourceCount, byte[] target, int targetOffset, int targetCount, int fromIndex) {
<span class="pc bpc" id="L3729" title="3 of 4 branches missed.">        if (fromIndex &gt;= sourceCount) return (targetCount == 0 ? sourceCount : -1);</span>
<span class="pc bpc" id="L3730" title="1 of 2 branches missed.">        if (fromIndex &lt; 0) fromIndex = 0;</span>
<span class="pc bpc" id="L3731" title="1 of 2 branches missed.">        if (targetCount == 0) return fromIndex;</span>

<span class="fc" id="L3733">        byte first  = target[targetOffset];</span>
<span class="fc" id="L3734">        int max = sourceOffset + (sourceCount - targetCount);</span>

<span class="fc bfc" id="L3736" title="All 2 branches covered.">        for (int i = sourceOffset + fromIndex; i &lt;= max; i++) {</span>
<span class="fc bfc" id="L3737" title="All 6 branches covered.">            if (source[i] != first) while (++i &lt;= max &amp;&amp; source[i] != first);</span>

<span class="fc bfc" id="L3739" title="All 2 branches covered.">            if (i &lt;= max) {</span>
<span class="fc" id="L3740">                int j = i + 1;</span>
<span class="fc" id="L3741">                int end = j + targetCount - 1;</span>
<span class="fc bfc" id="L3742" title="All 4 branches covered.">                for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++);</span>

<span class="fc bfc" id="L3744" title="All 2 branches covered.">                if (j == end) return i - sourceOffset;</span>
            }
        }
<span class="fc" id="L3747">        return -1;</span>
    }

    private RubyString getStringForPattern(IRubyObject obj) {
<span class="fc bfc" id="L3751" title="All 2 branches covered.">        if (obj instanceof RubyString) return (RubyString)obj;</span>
<span class="fc" id="L3752">        IRubyObject val = obj.checkStringType();</span>
<span class="fc bfc" id="L3753" title="All 2 branches covered.">        if (val.isNil()) throw getRuntime().newTypeError(&quot;wrong argument type &quot; + obj.getMetaClass() + &quot; (expected Regexp)&quot;);</span>
<span class="fc" id="L3754">        return (RubyString)val;</span>
    }

    /** get_pat (used by match/match19)
     *
     */
    private RubyRegexp getPattern(IRubyObject obj) {
<span class="fc bfc" id="L3761" title="All 2 branches covered.">        if (obj instanceof RubyRegexp) return (RubyRegexp)obj;</span>
<span class="fc" id="L3762">        return RubyRegexp.newRegexp(getRuntime(), getStringForPattern(obj).value);</span>
    }

    private Regex getStringPattern19(Ruby runtime, IRubyObject obj) {
<span class="fc" id="L3766">        RubyString str = getStringForPattern(obj);</span>
<span class="pc bpc" id="L3767" title="1 of 2 branches missed.">        if (str.scanForCodeRange() == CR_BROKEN) {</span>
<span class="nc" id="L3768">            throw runtime.newRegexpError(&quot;invalid multybyte character: &quot; +</span>
<span class="nc" id="L3769">                    RubyRegexp.regexpDescription19(runtime, str.value, new RegexpOptions(), str.value.getEncoding()).toString());</span>
        }
<span class="pc bpc" id="L3771" title="1 of 2 branches missed.">        if (str.value.getEncoding().isDummy()) {</span>
<span class="nc" id="L3772">            throw runtime.newArgumentError(&quot;can't make regexp with dummy encoding&quot;);</span>
        }

<span class="fc" id="L3775">        return RubyRegexp.getQuotedRegexpFromCache19(runtime, str.value, new RegexpOptions(), str.isAsciiOnly());</span>
    }

    /** rb_str_scan
     *
     */
    public IRubyObject scan(ThreadContext context, IRubyObject arg, Block block) {
<span class="nc" id="L3782">        return scan19(context, arg, block);</span>
    }

    private IRubyObject populateCapturesForScan(Ruby runtime, Matcher matcher, int range, int tuFlags, boolean is19) {
<span class="fc" id="L3786">        Region region = matcher.getRegion();</span>
<span class="fc" id="L3787">        RubyArray result = getRuntime().newArray(region.numRegs);</span>
<span class="fc bfc" id="L3788" title="All 2 branches covered.">        for (int i=1; i&lt;region.numRegs; i++) {</span>
<span class="fc" id="L3789">            int beg = region.beg[i];</span>
<span class="pc bpc" id="L3790" title="1 of 2 branches missed.">            if (beg == -1) {</span>
<span class="nc" id="L3791">                result.append(runtime.getNil());</span>
            } else {
<span class="pc bpc" id="L3793" title="1 of 2 branches missed.">                RubyString substr = is19 ? makeShared19(runtime, beg, region.end[i] - beg) : makeShared(runtime, beg, region.end[i] - beg);</span>
<span class="fc" id="L3794">                substr.infectBy(tuFlags);</span>
<span class="fc" id="L3795">                result.append(substr);</span>
            }
        }
<span class="fc" id="L3798">        return result;</span>
    }

    @JRubyMethod(name = &quot;scan&quot;, reads = BACKREF, writes = BACKREF)
    public IRubyObject scan19(ThreadContext context, IRubyObject arg, Block block) {
<span class="fc" id="L3803">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L3804">        Encoding enc = value.getEncoding();</span>
        final Regex pattern, prepared;
        final RubyRegexp regexp;
        final int tuFlags;
<span class="fc bfc" id="L3808" title="All 2 branches covered.">        if (arg instanceof RubyRegexp) {</span>
<span class="fc" id="L3809">            regexp = (RubyRegexp)arg;</span>
<span class="fc" id="L3810">            tuFlags = regexp.flags;</span>
<span class="fc" id="L3811">            pattern = regexp.getPattern();</span>
<span class="fc" id="L3812">            prepared = regexp.preparePattern(this);</span>
        } else {
<span class="fc" id="L3814">            regexp = null;</span>
<span class="fc bfc" id="L3815" title="All 2 branches covered.">            tuFlags = arg.isTaint() ? RubyBasicObject.TAINTED_F : 0;</span>
<span class="fc" id="L3816">            pattern = getStringPattern19(runtime, arg);</span>
<span class="fc" id="L3817">            prepared = RubyRegexp.preparePattern(runtime, pattern, this);</span>
        }

<span class="fc bfc" id="L3820" title="All 2 branches covered.">        if (block.isGiven()) {</span>
<span class="fc" id="L3821">            return scanIter19(context, pattern, prepared, enc, block, regexp, tuFlags);</span>
        } else {
<span class="fc" id="L3823">            return scanNoIter19(context, pattern, prepared, enc, regexp, tuFlags);</span>
        }
    }

    private IRubyObject scanIter19(ThreadContext context, Regex pattern, Regex prepared, Encoding enc, Block block, RubyRegexp regexp, int tuFlags) {
<span class="fc" id="L3828">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L3829">        byte[]bytes = value.getUnsafeBytes();</span>
<span class="fc" id="L3830">        int begin = value.getBegin();</span>
<span class="fc" id="L3831">        int len = value.getRealSize();</span>
<span class="fc" id="L3832">        int range = begin + len;</span>
<span class="fc" id="L3833">        final Matcher matcher = prepared.matcher(bytes, begin, range);</span>

<span class="fc" id="L3835">        int end = 0;</span>
<span class="fc" id="L3836">        RubyMatchData match = null;</span>
<span class="fc bfc" id="L3837" title="All 2 branches covered.">        if (pattern.numberOfCaptures() == 0) {</span>
<span class="fc bfc" id="L3838" title="All 2 branches covered.">            while (RubyRegexp.matcherSearch(runtime, matcher, begin + end, range, Option.NONE) &gt;= 0) {</span>
<span class="fc" id="L3839">                end = StringSupport.positionEndForScan(value, matcher, enc, begin, range);</span>
<span class="fc" id="L3840">                match = RubyRegexp.createMatchData19(context, this, matcher, pattern);</span>
<span class="fc" id="L3841">                match.regexp = regexp;</span>
<span class="fc" id="L3842">                RubyString substr = makeShared19(runtime, matcher.getBegin(), matcher.getEnd() - matcher.getBegin());</span>
<span class="fc" id="L3843">                substr.infectBy(tuFlags);</span>
<span class="fc" id="L3844">                match.infectBy(tuFlags);</span>
<span class="fc" id="L3845">                context.setBackRef(match);</span>
<span class="fc" id="L3846">                block.yield(context, substr);</span>
<span class="fc" id="L3847">                modifyCheck(bytes, len, enc);</span>
<span class="fc" id="L3848">            }</span>
        } else {
<span class="fc bfc" id="L3850" title="All 2 branches covered.">            while (RubyRegexp.matcherSearch(runtime, matcher, begin + end, range, Option.NONE) &gt;= 0) {</span>
<span class="fc" id="L3851">                end = StringSupport.positionEndForScan(value, matcher, enc, begin, range);</span>
<span class="fc" id="L3852">                match = RubyRegexp.createMatchData19(context, this, matcher, pattern);</span>
<span class="fc" id="L3853">                match.regexp = regexp;</span>
<span class="fc" id="L3854">                match.infectBy(tuFlags);</span>
<span class="fc" id="L3855">                context.setBackRef(match);</span>
<span class="fc" id="L3856">                block.yield(context, populateCapturesForScan(runtime, matcher, range, tuFlags, true));</span>
<span class="fc" id="L3857">                modifyCheck(bytes, len, enc);</span>
            }
        }
<span class="fc bfc" id="L3860" title="All 2 branches covered.">        context.setBackRef(match == null ? runtime.getNil() : match);</span>
<span class="fc" id="L3861">        return this;</span>
    }

    private IRubyObject scanNoIter19(ThreadContext context, Regex pattern, Regex prepared, Encoding enc, RubyRegexp regexp, int tuFlags) {
<span class="fc" id="L3865">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L3866">        byte[]bytes = value.getUnsafeBytes();</span>
<span class="fc" id="L3867">        int begin = value.getBegin();</span>
<span class="fc" id="L3868">        int range = begin + value.getRealSize();</span>
<span class="fc" id="L3869">        final Matcher matcher = prepared.matcher(bytes, begin, range);</span>

<span class="fc" id="L3871">        RubyArray ary = runtime.newArray();</span>

<span class="fc" id="L3873">        int end = 0;</span>
<span class="fc bfc" id="L3874" title="All 2 branches covered.">        if (pattern.numberOfCaptures() == 0) {</span>
<span class="fc bfc" id="L3875" title="All 2 branches covered.">            while (RubyRegexp.matcherSearch(runtime, matcher, begin + end, range, Option.NONE) &gt;= 0) {</span>
<span class="fc" id="L3876">                end = StringSupport.positionEndForScan(value, matcher, enc, begin, range);</span>
<span class="fc" id="L3877">                RubyString substr = makeShared19(runtime, matcher.getBegin(), matcher.getEnd() - matcher.getBegin());</span>
<span class="fc" id="L3878">                substr.infectBy(tuFlags);</span>
<span class="fc" id="L3879">                ary.append(substr);</span>
<span class="fc" id="L3880">            }</span>
        } else {
<span class="fc bfc" id="L3882" title="All 2 branches covered.">            while (RubyRegexp.matcherSearch(runtime, matcher, begin + end, range, Option.NONE) &gt;= 0) {</span>
<span class="fc" id="L3883">                end = StringSupport.positionEndForScan(value, matcher, enc, begin, range);</span>
<span class="fc" id="L3884">                ary.append(populateCapturesForScan(runtime, matcher, range, tuFlags, true));</span>
            }
        }

<span class="fc bfc" id="L3888" title="All 2 branches covered.">        if (ary.size() &gt; 0) {</span>
<span class="fc" id="L3889">            RubyMatchData match = RubyRegexp.createMatchData19(context, this, matcher, pattern);</span>
<span class="fc" id="L3890">            match.regexp = regexp;</span>
<span class="fc" id="L3891">            match.infectBy(tuFlags);</span>
<span class="fc" id="L3892">            context.setBackRef(match);</span>
<span class="fc" id="L3893">        } else {</span>
<span class="fc" id="L3894">            context.setBackRef(runtime.getNil());</span>
        }
<span class="fc" id="L3896">        return ary;</span>
    }

    @JRubyMethod(name = &quot;start_with?&quot;)
    public IRubyObject start_with_p(ThreadContext context) {
<span class="nc" id="L3901">        return context.runtime.getFalse();</span>
    }

    @JRubyMethod(name = &quot;start_with?&quot;)
    public IRubyObject start_with_p(ThreadContext context, IRubyObject arg) {
<span class="fc bfc" id="L3906" title="All 2 branches covered.">        return start_with_pCommon(arg) ? context.runtime.getTrue() : context.runtime.getFalse();</span>
    }

    @JRubyMethod(name = &quot;start_with?&quot;, rest = true)
    public IRubyObject start_with_p(ThreadContext context, IRubyObject[]args) {
<span class="pc bpc" id="L3911" title="1 of 2 branches missed.">        for (int i = 0; i &lt; args.length; i++) {</span>
<span class="fc bfc" id="L3912" title="All 2 branches covered.">            if (start_with_pCommon(args[i])) return context.runtime.getTrue();</span>
        }
<span class="nc" id="L3914">        return context.runtime.getFalse();</span>
    }

    private boolean start_with_pCommon(IRubyObject arg) {
<span class="fc" id="L3918">        IRubyObject tmp = arg.checkStringType();</span>
<span class="pc bpc" id="L3919" title="1 of 2 branches missed.">        if (tmp.isNil()) return false;</span>
<span class="fc" id="L3920">        RubyString otherString = (RubyString)tmp;</span>
<span class="fc" id="L3921">        checkEncoding(otherString);</span>
<span class="pc bpc" id="L3922" title="1 of 2 branches missed.">        if (value.getRealSize() &lt; otherString.value.getRealSize()) return false;</span>
<span class="fc" id="L3923">        return value.startsWith(otherString.value);</span>
    }

    @JRubyMethod(name = &quot;end_with?&quot;)
    public IRubyObject end_with_p(ThreadContext context) {
<span class="nc" id="L3928">        return context.runtime.getFalse();</span>
    }

    @JRubyMethod(name = &quot;end_with?&quot;)
    public IRubyObject end_with_p(ThreadContext context, IRubyObject arg) {
<span class="fc bfc" id="L3933" title="All 2 branches covered.">        return end_with_pCommon(arg) ? context.runtime.getTrue() : context.runtime.getFalse();</span>
    }

    @JRubyMethod(name = &quot;end_with?&quot;, rest = true)
    public IRubyObject end_with_p(ThreadContext context, IRubyObject[]args) {
<span class="pc bpc" id="L3938" title="1 of 2 branches missed.">        for (int i = 0; i &lt; args.length; i++) {</span>
<span class="fc bfc" id="L3939" title="All 2 branches covered.">            if (end_with_pCommon(args[i])) return context.runtime.getTrue();</span>
        }
<span class="nc" id="L3941">        return context.runtime.getFalse();</span>
    }

    private boolean end_with_pCommon(IRubyObject arg) {
<span class="fc" id="L3945">        IRubyObject tmp = arg.checkStringType();</span>
<span class="pc bpc" id="L3946" title="1 of 2 branches missed.">        if (tmp.isNil()) return false;</span>
<span class="fc" id="L3947">        RubyString otherString = (RubyString)tmp;</span>
<span class="fc" id="L3948">        int otherLength = otherString.value.getRealSize();</span>
<span class="fc" id="L3949">        Encoding enc = checkEncoding(otherString);</span>
<span class="pc bpc" id="L3950" title="1 of 2 branches missed.">        if (value.getRealSize() &lt; otherLength) return false;</span>
<span class="fc" id="L3951">        int p = value.getBegin();</span>
<span class="fc" id="L3952">        int end = p + value.getRealSize();</span>
<span class="fc bfc" id="L3953" title="All 2 branches covered.">        if (otherLength == 0) {</span>
            // other is '', so return true
<span class="fc" id="L3955">            return true;</span>
        }
<span class="fc" id="L3957">        int s = end - otherLength;</span>
<span class="pc bpc" id="L3958" title="1 of 2 branches missed.">        if (enc.leftAdjustCharHead(value.getUnsafeBytes(), p, s, end) != s) return false;</span>
<span class="fc" id="L3959">        return value.endsWith(otherString.value);</span>
    }

<span class="fc" id="L3962">    private static final ByteList SPACE_BYTELIST = new ByteList(ByteList.plain(&quot; &quot;));</span>

    private IRubyObject justify19(IRubyObject arg0, int jflag) {
<span class="fc" id="L3965">        Ruby runtime = getRuntime();</span>
<span class="fc" id="L3966">        RubyString result = justifyCommon(runtime, SPACE_BYTELIST,</span>
                                                   1,
<span class="fc" id="L3968">                                                   true, value.getEncoding(), RubyFixnum.num2int(arg0), jflag);</span>
<span class="pc bpc" id="L3969" title="1 of 2 branches missed.">        if (getCodeRange() != CR_BROKEN) result.setCodeRange(getCodeRange());</span>
<span class="fc" id="L3970">        return result;</span>
    }

    private IRubyObject justify19(IRubyObject arg0, IRubyObject arg1, int jflag) {
<span class="fc" id="L3974">        Ruby runtime = getRuntime();</span>
<span class="fc" id="L3975">        RubyString padStr = arg1.convertToString();</span>
<span class="fc" id="L3976">        ByteList pad = padStr.value;</span>
<span class="fc" id="L3977">        Encoding enc = checkEncoding(padStr);</span>
<span class="fc" id="L3978">        int padCharLen = padStr.strLength(enc);</span>
<span class="pc bpc" id="L3979" title="1 of 4 branches missed.">        if (pad.getRealSize() == 0 || padCharLen == 0) throw runtime.newArgumentError(&quot;zero width padding&quot;);</span>
<span class="fc" id="L3980">        int width = RubyFixnum.num2int(arg0);</span>
<span class="fc" id="L3981">        RubyString result = justifyCommon(runtime, pad,</span>
                                                   padCharLen,
<span class="fc" id="L3983">                                                   padStr.singleByteOptimizable(),</span>
                                                   enc, width, jflag);
<span class="fc bfc" id="L3985" title="All 2 branches covered.">        if (RubyFixnum.num2int(result.length19()) &gt; RubyFixnum.num2int(length19())) result.infectBy(padStr);</span>
<span class="fc" id="L3986">        int cr = codeRangeAnd(getCodeRange(), padStr.getCodeRange());</span>
<span class="pc bpc" id="L3987" title="1 of 2 branches missed.">        if (cr != CR_BROKEN) result.setCodeRange(cr);</span>
<span class="fc" id="L3988">        return result;</span>
    }

    private RubyString justifyCommon(Ruby runtime, ByteList pad, int padCharLen, boolean padSinglebyte, Encoding enc, int width, int jflag) {
<span class="fc" id="L3992">        int len = strLength(enc);</span>
<span class="fc bfc" id="L3993" title="All 4 branches covered.">        if (width &lt; 0 || len &gt;= width) return strDup(runtime);</span>
<span class="fc" id="L3994">        int n = width - len;</span>

<span class="fc bfc" id="L3996" title="All 4 branches covered.">        int llen = (jflag == 'l') ? 0 : ((jflag == 'r') ? n : n / 2);</span>
<span class="fc" id="L3997">        int rlen = n - llen;</span>

<span class="fc" id="L3999">        int padP = pad.getBegin();</span>
<span class="fc" id="L4000">        int padLen = pad.getRealSize();</span>
<span class="fc" id="L4001">        byte padBytes[] = pad.getUnsafeBytes();</span>

<span class="fc" id="L4003">        ByteList res = new ByteList(value.getRealSize() + n * padLen / padCharLen + 2);</span>

<span class="fc" id="L4005">        int p = res.getBegin();</span>
<span class="fc" id="L4006">        byte bytes[] = res.getUnsafeBytes();</span>

<span class="fc bfc" id="L4008" title="All 2 branches covered.">        while (llen &gt; 0) {</span>
<span class="fc bfc" id="L4009" title="All 2 branches covered.">            if (padLen &lt;= 1) {</span>
<span class="fc" id="L4010">                bytes[p++] = padBytes[padP];</span>
<span class="fc" id="L4011">                llen--;</span>
<span class="fc bfc" id="L4012" title="All 2 branches covered.">            } else if (llen &gt; padCharLen) {</span>
<span class="fc" id="L4013">                System.arraycopy(padBytes, padP, bytes, p, padLen);</span>
<span class="fc" id="L4014">                p += padLen;</span>
<span class="fc" id="L4015">                llen -= padCharLen;</span>
            } else {
<span class="fc bfc" id="L4017" title="All 2 branches covered.">                int padPP = padSinglebyte ? padP + llen : StringSupport.nth(enc, padBytes, padP, padP + padLen, llen);</span>
<span class="fc" id="L4018">                n = padPP - padP;</span>
<span class="fc" id="L4019">                System.arraycopy(padBytes, padP, bytes, p, n);</span>
<span class="fc" id="L4020">                p += n;</span>
<span class="fc" id="L4021">                break;</span>
            }
        }

<span class="fc" id="L4025">        System.arraycopy(value.getUnsafeBytes(), value.getBegin(), bytes, p, value.getRealSize());</span>
<span class="fc" id="L4026">        p += value.getRealSize();</span>

<span class="fc bfc" id="L4028" title="All 2 branches covered.">        while (rlen &gt; 0) {</span>
<span class="fc bfc" id="L4029" title="All 2 branches covered.">            if (padLen &lt;= 1) {</span>
<span class="fc" id="L4030">                bytes[p++] = padBytes[padP];</span>
<span class="fc" id="L4031">                rlen--;</span>
<span class="fc bfc" id="L4032" title="All 2 branches covered.">            } else if (rlen &gt; padCharLen) {</span>
<span class="fc" id="L4033">                System.arraycopy(padBytes, padP, bytes, p, padLen);</span>
<span class="fc" id="L4034">                p += padLen;</span>
<span class="fc" id="L4035">                rlen -= padCharLen;</span>
            } else {
<span class="fc bfc" id="L4037" title="All 2 branches covered.">                int padPP = padSinglebyte ? padP + rlen : StringSupport.nth(enc, padBytes, padP, padP + padLen, rlen);</span>
<span class="fc" id="L4038">                n = padPP - padP;</span>
<span class="fc" id="L4039">                System.arraycopy(padBytes, padP, bytes, p, n);</span>
<span class="fc" id="L4040">                p += n;</span>
<span class="fc" id="L4041">                break;</span>
            }
        }

<span class="fc" id="L4045">        res.setRealSize(p);</span>

<span class="fc" id="L4047">        RubyString result = new RubyString(runtime, getMetaClass(), res);</span>
<span class="pc bpc" id="L4048" title="1 of 2 branches missed.">        if (RubyFixnum.num2int(result.length19()) &gt; RubyFixnum.num2int(length19())) {</span>
<span class="fc" id="L4049">                 result.infectBy(this);</span>
             }
<span class="fc" id="L4051">        result.associateEncoding(enc);</span>
<span class="fc" id="L4052">        return result;</span>
    }

    /** rb_str_ljust
     *
     */
    public IRubyObject ljust(IRubyObject arg0) {
<span class="nc" id="L4059">        return ljust19(arg0);</span>
    }

    public IRubyObject ljust(IRubyObject arg0, IRubyObject arg1) {
<span class="nc" id="L4063">        return ljust19(arg0, arg1);</span>
    }

    @JRubyMethod(name = &quot;ljust&quot;)
    public IRubyObject ljust19(IRubyObject arg0) {
<span class="fc" id="L4068">        return justify19(arg0, 'l');</span>
    }

    @JRubyMethod(name = &quot;ljust&quot;)
    public IRubyObject ljust19(IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L4073">        return justify19(arg0, arg1, 'l');</span>
    }

    /** rb_str_rjust
     *
     */
    public IRubyObject rjust(IRubyObject arg0) {
<span class="nc" id="L4080">        return rjust19(arg0);</span>
    }

    public IRubyObject rjust(IRubyObject arg0, IRubyObject arg1) {
<span class="nc" id="L4084">        return rjust19(arg0, arg1);</span>
    }

    @JRubyMethod(name = &quot;rjust&quot;)
    public IRubyObject rjust19(IRubyObject arg0) {
<span class="fc" id="L4089">        return justify19(arg0, 'r');</span>
    }

    @JRubyMethod(name = &quot;rjust&quot;)
    public IRubyObject rjust19(IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L4094">        return justify19(arg0, arg1, 'r');</span>
    }

    /** rb_str_center
     *
     */
    public IRubyObject center(IRubyObject arg0) {
<span class="nc" id="L4101">        return center19(arg0);</span>
    }

    public IRubyObject center(IRubyObject arg0, IRubyObject arg1) {
<span class="nc" id="L4105">        return center19(arg0, arg1);</span>
    }

    @JRubyMethod(name = &quot;center&quot;)
    public IRubyObject center19(IRubyObject arg0) {
<span class="fc" id="L4110">        return justify19(arg0, 'c');</span>
    }

    @JRubyMethod(name = &quot;center&quot;)
    public IRubyObject center19(IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L4115">        return justify19(arg0, arg1, 'c');</span>
    }

    @JRubyMethod(reads = BACKREF, writes = BACKREF)
    public IRubyObject partition(ThreadContext context, Block block) {
<span class="nc" id="L4120">        return RubyEnumerable.partition(context, this, block);</span>
    }

    @JRubyMethod(reads = BACKREF, writes = BACKREF)
    public IRubyObject partition(ThreadContext context, IRubyObject arg, Block block) {
<span class="fc" id="L4125">        Ruby runtime = context.runtime;</span>
        final int pos;
        final RubyString sep;
<span class="fc bfc" id="L4128" title="All 2 branches covered.">        if (arg instanceof RubyRegexp) {</span>
<span class="fc" id="L4129">            RubyRegexp regex = (RubyRegexp)arg;</span>
<span class="fc" id="L4130">            IRubyObject[] holder = {context.nil};</span>

<span class="fc" id="L4132">            pos = regex.search19(context, this, 0, false, holder);</span>
<span class="fc" id="L4133">            context.setBackRef(holder[0]);</span>
<span class="pc bpc" id="L4134" title="1 of 2 branches missed.">            if (pos &lt; 0) return partitionMismatch(runtime);</span>
<span class="fc" id="L4135">            sep = (RubyString)subpat19(runtime, context, regex);</span>
<span class="pc bpc" id="L4136" title="3 of 4 branches missed.">            if (pos == 0 &amp;&amp; sep.value.getRealSize() == 0) return partitionMismatch(runtime);</span>
<span class="fc" id="L4137">        } else {</span>
<span class="fc" id="L4138">            IRubyObject tmp = arg.checkStringType();</span>
<span class="fc bfc" id="L4139" title="All 2 branches covered.">            if (tmp.isNil()) throw runtime.newTypeError(&quot;type mismatch: &quot; + arg.getMetaClass().getName() + &quot; given&quot;);</span>
<span class="fc" id="L4140">            sep = (RubyString)tmp;</span>
<span class="fc" id="L4141">            pos = StringSupport.index(this, this.value, this.strLength(this.checkEncoding(sep)), sep, sep.value, sep.strLength(this.checkEncoding(sep)), 0, this.checkEncoding(sep));</span>
<span class="fc bfc" id="L4142" title="All 2 branches covered.">            if (pos &lt; 0) return partitionMismatch(runtime);</span>
        }

<span class="fc" id="L4145">        return RubyArray.newArray(runtime, new IRubyObject[]{</span>
<span class="fc" id="L4146">                makeShared19(runtime, 0, pos),</span>
                sep,
<span class="fc" id="L4148">                makeShared19(runtime, pos + sep.value.getRealSize(), value.getRealSize() - pos - sep.value.getRealSize())});</span>
    }

    private IRubyObject partitionMismatch(Ruby runtime) {
<span class="fc" id="L4152">        return RubyArray.newArray(runtime, new IRubyObject[]{this, newEmptyString(runtime), newEmptyString(runtime)});</span>
    }

    @JRubyMethod(name = &quot;rpartition&quot;, reads = BACKREF, writes = BACKREF)
    public IRubyObject rpartition(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L4157">        Ruby runtime = context.runtime;</span>
        final int pos;
        final RubyString sep;
<span class="fc bfc" id="L4160" title="All 2 branches covered.">        if (arg instanceof RubyRegexp) {</span>
<span class="fc" id="L4161">            RubyRegexp regex = (RubyRegexp)arg;</span>
<span class="fc" id="L4162">            IRubyObject[] holder = {context.nil};</span>

<span class="fc" id="L4164">            pos = regex.search19(context, this, value.getRealSize(), true, holder);</span>
<span class="fc" id="L4165">            context.setBackRef(holder[0]);</span>

<span class="pc bpc" id="L4167" title="1 of 2 branches missed.">            if (pos &lt; 0) return rpartitionMismatch(runtime);</span>
<span class="fc" id="L4168">            sep = (RubyString)RubyRegexp.nth_match(0, holder[0]);</span>
<span class="fc" id="L4169">        } else {</span>
<span class="fc" id="L4170">            IRubyObject tmp = arg.checkStringType();</span>
<span class="fc bfc" id="L4171" title="All 2 branches covered.">            if (tmp.isNil()) throw runtime.newTypeError(&quot;type mismatch: &quot; + arg.getMetaClass().getName() + &quot; given&quot;);</span>
<span class="fc" id="L4172">            sep = (RubyString)tmp;</span>
<span class="fc" id="L4173">            pos = StringSupport.rindex(value, this.strLength(this.checkEncoding(sep)), sep.value, sep.strLength(this.checkEncoding(sep)), subLength(value.getRealSize()), sep, this.checkEncoding(sep));</span>
<span class="fc bfc" id="L4174" title="All 2 branches covered.">            if (pos &lt; 0) return rpartitionMismatch(runtime);</span>
        }

<span class="fc" id="L4177">        return RubyArray.newArray(runtime, new IRubyObject[]{</span>
<span class="fc" id="L4178">                substr19(runtime, 0, pos),</span>
                sep,
<span class="fc" id="L4180">                substr19(runtime, pos + sep.strLength(), value.getRealSize())});</span>
    }

    private IRubyObject rpartitionMismatch(Ruby runtime) {
<span class="fc" id="L4184">        return RubyArray.newArray(runtime, new IRubyObject[]{newEmptyString(runtime), newEmptyString(runtime), this});</span>
    }

    /** rb_str_chop / rb_str_chop_bang
     *
     */
    public IRubyObject chop(ThreadContext context) {
<span class="nc" id="L4191">        return chop19(context);</span>
    }

    public IRubyObject chop_bang(ThreadContext context) {
<span class="nc" id="L4195">        return chop_bang19(context);</span>
    }

    @JRubyMethod(name = &quot;chop&quot;)
    public IRubyObject chop19(ThreadContext context) {
<span class="fc" id="L4200">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L4201" title="All 2 branches covered.">        if (value.getRealSize() == 0) return newEmptyString(runtime, getMetaClass(), value.getEncoding()).infectBy(this);</span>
<span class="fc" id="L4202">        return makeShared19(runtime, 0, choppedLength19(runtime));</span>
    }

    @JRubyMethod(name = &quot;chop!&quot;)
    public IRubyObject chop_bang19(ThreadContext context) {
<span class="fc" id="L4207">        modifyCheck();</span>
<span class="fc" id="L4208">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L4209" title="All 2 branches covered.">        if (value.getRealSize() == 0) return runtime.getNil();</span>
<span class="fc" id="L4210">        view(0, choppedLength19(runtime));</span>
<span class="pc bpc" id="L4211" title="1 of 2 branches missed.">        if (getCodeRange() != CR_7BIT) clearCodeRange();</span>
<span class="fc" id="L4212">        return this;</span>
    }

    private int choppedLength19(Ruby runtime) {
<span class="fc" id="L4216">        int p = value.getBegin();</span>
<span class="fc" id="L4217">        int end = p + value.getRealSize();</span>

<span class="pc bpc" id="L4219" title="1 of 2 branches missed.">        if (p &gt; end) return 0;</span>
<span class="fc" id="L4220">        byte bytes[] = value.getUnsafeBytes();</span>
<span class="fc" id="L4221">        Encoding enc = value.getEncoding();</span>

<span class="fc" id="L4223">        int s = enc.prevCharHead(bytes, p, end, end);</span>
<span class="pc bpc" id="L4224" title="1 of 2 branches missed.">        if (s == -1) return 0;</span>
<span class="pc bpc" id="L4225" title="1 of 4 branches missed.">        if (s &gt; p &amp;&amp; codePoint(runtime, enc, bytes, s, end) == '\n') {</span>
<span class="fc" id="L4226">            int s2 = enc.prevCharHead(bytes, p, s, end);</span>
<span class="pc bpc" id="L4227" title="1 of 4 branches missed.">            if (s2 != -1 &amp;&amp; codePoint(runtime, enc, bytes, s2, end) == '\r') s = s2;</span>
        }
<span class="fc" id="L4229">        return s - p;</span>
    }

    /** rb_str_chop
     *
     */
    public RubyString chomp(ThreadContext context) {
<span class="nc" id="L4236">        return chomp19(context);</span>
    }

    public RubyString chomp(ThreadContext context, IRubyObject arg0) {
<span class="nc" id="L4240">        return chomp19(context, arg0);</span>
    }

    /**
     * rb_str_chomp_bang
     *
     * In the common case, removes CR and LF characters in various ways depending on the value of
     *   the optional args[0].
     * If args.length==0 removes one instance of CR, CRLF or LF from the end of the string.
     * If args.length&gt;0 and args[0] is &quot;\n&quot; then same behaviour as args.length==0 .
     * If args.length&gt;0 and args[0] is &quot;&quot; then removes trailing multiple LF or CRLF (but no CRs at
     *   all(!)).
     */
    public IRubyObject chomp_bang(ThreadContext context) {
<span class="nc" id="L4254">        return chomp_bang19(context);</span>
    }

    public IRubyObject chomp_bang(ThreadContext context, IRubyObject arg0) {
<span class="nc" id="L4258">        return chomp_bang19(context, arg0);</span>
    }

    @JRubyMethod(name = &quot;chomp&quot;)
    public RubyString chomp19(ThreadContext context) {
<span class="fc" id="L4263">        RubyString str = strDup(context.runtime);</span>
<span class="fc" id="L4264">        str.chomp_bang19(context);</span>
<span class="fc" id="L4265">        return str;</span>
    }

    @JRubyMethod(name = &quot;chomp&quot;)
    public RubyString chomp19(ThreadContext context, IRubyObject arg0) {
<span class="fc" id="L4270">        RubyString str = strDup(context.runtime);</span>
<span class="fc" id="L4271">        str.chomp_bang19(context, arg0);</span>
<span class="fc" id="L4272">        return str;</span>
    }

    @JRubyMethod(name = &quot;chomp!&quot;)
    public IRubyObject chomp_bang19(ThreadContext context) {
<span class="fc" id="L4277">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L4278" title="All 2 branches covered.">        if (value.getRealSize() == 0) return runtime.getNil();</span>

<span class="fc" id="L4280">        IRubyObject rsObj = runtime.getGlobalVariables().get(&quot;$/&quot;);</span>

<span class="fc bfc" id="L4282" title="All 2 branches covered.">        if (rsObj == runtime.getGlobalVariables().getDefaultSeparator()) return smartChopBangCommon19(runtime);</span>
<span class="fc" id="L4283">        return chompBangCommon19(runtime, rsObj);</span>
    }

    @JRubyMethod(name = &quot;chomp!&quot;)
    public IRubyObject chomp_bang19(ThreadContext context, IRubyObject arg0) {
<span class="fc" id="L4288">        modifyCheck();</span>
<span class="fc" id="L4289">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L4290" title="All 2 branches covered.">        if (value.getRealSize() == 0) return runtime.getNil();</span>
<span class="fc" id="L4291">        return chompBangCommon19(runtime, arg0);</span>
    }

    private IRubyObject chompBangCommon19(Ruby runtime, IRubyObject rsObj) {
<span class="fc bfc" id="L4295" title="All 2 branches covered.">        if (rsObj.isNil()) return rsObj;</span>

<span class="fc" id="L4297">        RubyString rs = rsObj.convertToString();</span>
<span class="fc" id="L4298">        int p = value.getBegin();</span>
<span class="fc" id="L4299">        int len = value.getRealSize();</span>
<span class="fc" id="L4300">        int end = p + len;</span>
<span class="fc" id="L4301">        byte[] bytes = value.getUnsafeBytes();</span>

<span class="fc" id="L4303">        int rslen = rs.value.getRealSize();</span>
<span class="fc bfc" id="L4304" title="All 2 branches covered.">        if (rslen == 0) {</span>
<span class="pc bpc" id="L4305" title="1 of 4 branches missed.">            while (len &gt; 0 &amp;&amp; bytes[p + len - 1] == (byte)'\n') {</span>
<span class="fc" id="L4306">                len--;</span>
<span class="pc bpc" id="L4307" title="1 of 4 branches missed.">                if (len &gt; 0 &amp;&amp; bytes[p + len - 1] == (byte)'\r') len--;</span>
            }
<span class="fc bfc" id="L4309" title="All 2 branches covered.">            if (len &lt; value.getRealSize()) {</span>
<span class="fc" id="L4310">                keepCodeRange();</span>
<span class="fc" id="L4311">                view(0, len);</span>
<span class="fc" id="L4312">                return this;</span>
            }
<span class="fc" id="L4314">            return runtime.getNil();</span>
        }

<span class="pc bpc" id="L4317" title="1 of 2 branches missed.">        if (rslen &gt; len) return runtime.getNil();</span>
<span class="fc" id="L4318">        byte newline = rs.value.getUnsafeBytes()[rslen - 1];</span>
<span class="fc bfc" id="L4319" title="All 4 branches covered.">        if (rslen == 1 &amp;&amp; newline == (byte)'\n') return smartChopBangCommon19(runtime);</span>

<span class="fc" id="L4321">        Encoding enc = checkEncoding(rs);</span>
<span class="pc bpc" id="L4322" title="1 of 2 branches missed.">        if (rs.scanForCodeRange() == CR_BROKEN) return runtime.getNil();</span>

<span class="fc" id="L4324">        int pp = end - rslen;</span>
<span class="pc bpc" id="L4325" title="1 of 6 branches missed.">        if (bytes[p + len - 1] == newline &amp;&amp; rslen &lt;= 1 || value.endsWith(rs.value)) {</span>
<span class="pc bpc" id="L4326" title="1 of 2 branches missed.">            if (enc.leftAdjustCharHead(bytes, p, pp, end) != pp) return runtime.getNil();</span>
<span class="pc bpc" id="L4327" title="1 of 2 branches missed.">            if (getCodeRange() != CR_7BIT) clearCodeRange();</span>
<span class="fc" id="L4328">            view(0, value.getRealSize() - rslen);</span>
<span class="fc" id="L4329">            return this;</span>
        }
<span class="fc" id="L4331">        return runtime.getNil();</span>
    }

    private IRubyObject smartChopBangCommon19(Ruby runtime) {
<span class="fc" id="L4335">        final int p = value.getBegin();</span>
<span class="fc" id="L4336">        int len = value.getRealSize();</span>
<span class="fc" id="L4337">        int end = p + len;</span>
<span class="fc" id="L4338">        byte bytes[] = value.getUnsafeBytes();</span>
<span class="fc" id="L4339">        Encoding enc = value.getEncoding();</span>

<span class="fc" id="L4341">        keepCodeRange();</span>
<span class="fc bfc" id="L4342" title="All 2 branches covered.">        if (enc.minLength() &gt; 1) {</span>
<span class="fc" id="L4343">            int pp = enc.leftAdjustCharHead(bytes, p, end - enc.minLength(), end);</span>
<span class="pc bpc" id="L4344" title="1 of 2 branches missed.">            if (enc.isNewLine(bytes, pp, end)) end = pp;</span>
<span class="fc" id="L4345">            pp = end - enc.minLength();</span>
<span class="pc bpc" id="L4346" title="1 of 2 branches missed.">            if (pp &gt;= p) {</span>
<span class="fc" id="L4347">                pp = enc.leftAdjustCharHead(bytes, p, pp, end);</span>
<span class="pc bpc" id="L4348" title="1 of 2 branches missed.">                if (StringSupport.preciseLength(enc, bytes, pp, end) &gt; 0 &amp;&amp;</span>
<span class="pc bpc" id="L4349" title="1 of 2 branches missed.">                        enc.mbcToCode(bytes, pp, end) == '\r') end = pp;</span>
            }
<span class="pc bpc" id="L4351" title="1 of 2 branches missed.">            if (end == p + value.getRealSize()) {</span>
<span class="nc" id="L4352">                modifyCheck();</span>
<span class="nc" id="L4353">                return runtime.getNil();</span>
            }
<span class="fc" id="L4355">            len = end - p;</span>
<span class="fc" id="L4356">            view(0, len);</span>
<span class="fc" id="L4357">        } else {</span>
<span class="fc bfc" id="L4358" title="All 2 branches covered.">            if (bytes[p + len - 1] == (byte)'\n') {</span>
<span class="fc" id="L4359">                len--;</span>
<span class="fc bfc" id="L4360" title="All 4 branches covered.">                if (len &gt; 0 &amp;&amp; bytes[p + len - 1] == (byte)'\r') len--;</span>
<span class="fc" id="L4361">                view(0, len);</span>
<span class="fc bfc" id="L4362" title="All 2 branches covered.">            } else if (bytes[p + len - 1] == (byte)'\r') {</span>
<span class="fc" id="L4363">                len--;</span>
<span class="fc" id="L4364">                view(0, len);</span>
            } else {
<span class="fc" id="L4366">                modifyCheck();</span>
<span class="fc" id="L4367">                return runtime.getNil();</span>
            }
        }
<span class="fc" id="L4370">        return this;</span>
    }

    /** rb_str_lstrip / rb_str_lstrip_bang
     *
     */
    public IRubyObject lstrip(ThreadContext context) {
<span class="nc" id="L4377">        return lstrip19(context);</span>
    }

    public IRubyObject lstrip_bang(ThreadContext context) {
<span class="nc" id="L4381">        return lstrip_bang19(context);</span>
    }

    @JRubyMethod(name = &quot;lstrip&quot;)
    public IRubyObject lstrip19(ThreadContext context) {
<span class="fc" id="L4386">        RubyString str = strDup(context.runtime);</span>
<span class="fc" id="L4387">        str.lstrip_bang19(context);</span>
<span class="fc" id="L4388">        return str;</span>
    }

    @JRubyMethod(name = &quot;lstrip!&quot;)
    public IRubyObject lstrip_bang19(ThreadContext context) {
<span class="fc" id="L4393">        modifyCheck();</span>
<span class="fc" id="L4394">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L4395" title="All 2 branches covered.">        if (value.getRealSize() == 0) {</span>
<span class="fc" id="L4396">            return runtime.getNil();</span>
        }

<span class="fc" id="L4399">        Encoding enc = value.getEncoding();</span>
<span class="fc" id="L4400">        int s = value.getBegin();</span>
<span class="fc" id="L4401">        int end = s + value.getRealSize();</span>
<span class="fc" id="L4402">        byte[]bytes = value.getUnsafeBytes();</span>

        final IRubyObject result;
<span class="fc bfc" id="L4405" title="All 2 branches covered.">        if (singleByteOptimizable(enc)) {</span>
<span class="fc" id="L4406">            result = singleByteLStrip(runtime, bytes, s, end);</span>
        } else {
<span class="fc" id="L4408">            result = multiByteLStrip(runtime, enc, bytes, s, end);</span>
        }
<span class="fc" id="L4410">        keepCodeRange();</span>
<span class="fc" id="L4411">        return result;</span>
    }

    private IRubyObject singleByteLStrip(Ruby runtime, byte[]bytes, int s, int end) {
<span class="fc" id="L4415">        int p = s;</span>
<span class="pc bpc" id="L4416" title="2 of 4 branches missed.">        while (p &lt; end &amp;&amp; ASCII.isSpace(bytes[p] &amp; 0xff)) p++;</span>
<span class="pc bpc" id="L4417" title="1 of 2 branches missed.">        if (p &gt; s) {</span>
<span class="nc" id="L4418">            view(p - s, end - p);</span>
<span class="nc" id="L4419">            return this;</span>
        }
<span class="fc" id="L4421">        return runtime.getNil();</span>
    }

    private IRubyObject multiByteLStrip(Ruby runtime, Encoding enc, byte[]bytes, int s, int end) {
<span class="fc" id="L4425">        int p = s;</span>

<span class="pc bpc" id="L4427" title="1 of 2 branches missed.">        while (p &lt; end) {</span>
<span class="fc" id="L4428">            int c = codePoint(runtime, enc, bytes, p, end);</span>
<span class="fc bfc" id="L4429" title="All 2 branches covered.">            if (!ASCII.isSpace(c)) break;</span>
<span class="fc" id="L4430">            p += codeLength(runtime, enc, c);</span>
<span class="fc" id="L4431">        }</span>

<span class="fc bfc" id="L4433" title="All 2 branches covered.">        if (p &gt; s) {</span>
<span class="fc" id="L4434">            view(p - s, end - p);</span>
<span class="fc" id="L4435">            return this;</span>
        }

<span class="fc" id="L4438">        return runtime.getNil();</span>
    }

    /** rb_str_rstrip / rb_str_rstrip_bang
     *
     */
    public IRubyObject rstrip(ThreadContext context) {
<span class="nc" id="L4445">        return rstrip19(context);</span>
    }

    public IRubyObject rstrip_bang(ThreadContext context) {
<span class="nc" id="L4449">        return rstrip_bang19(context);</span>
    }

    @JRubyMethod(name = &quot;rstrip&quot;)
    public IRubyObject rstrip19(ThreadContext context) {
<span class="fc" id="L4454">        RubyString str = strDup(context.runtime);</span>
<span class="fc" id="L4455">        str.rstrip_bang19(context);</span>
<span class="fc" id="L4456">        return str;</span>
    }

    @JRubyMethod(name = &quot;rstrip!&quot;)
    public IRubyObject rstrip_bang19(ThreadContext context) {
<span class="fc" id="L4461">        modifyCheck();</span>
<span class="fc" id="L4462">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L4463" title="All 2 branches covered.">        if (value.getRealSize() == 0) {</span>
<span class="fc" id="L4464">            return runtime.getNil();</span>
        }

<span class="fc bfc" id="L4467" title="All 2 branches covered.">        IRubyObject result = singleByteOptimizable(value.getEncoding()) ?</span>
<span class="fc" id="L4468">            singleByteRStrip19(runtime) : multiByteRStrip19(runtime);</span>

<span class="fc" id="L4470">        keepCodeRange();</span>
<span class="fc" id="L4471">        return result;</span>
    }

    // In 1.9 we strip any combination of \0 and \s
    private IRubyObject singleByteRStrip19(Ruby runtime) {
<span class="fc" id="L4476">        byte[] bytes = value.getUnsafeBytes();</span>
<span class="fc" id="L4477">        int start = value.getBegin();</span>
<span class="fc" id="L4478">        int end = start + value.getRealSize();</span>
<span class="fc" id="L4479">        int endp = end - 1;</span>
<span class="pc bpc" id="L4480" title="2 of 4 branches missed.">        while (endp &gt;= start &amp;&amp; (bytes[endp] == 0 ||</span>
<span class="fc bfc" id="L4481" title="All 2 branches covered.">                ASCII.isSpace(bytes[endp] &amp; 0xff))) endp--;</span>

<span class="fc bfc" id="L4483" title="All 2 branches covered.">        if (endp &lt; end - 1) {</span>
<span class="fc" id="L4484">            view(0, endp - start + 1);</span>
<span class="fc" id="L4485">            return this;</span>
        }

<span class="fc" id="L4488">        return runtime.getNil();</span>
    }

    // In 1.9 we strip any combination of \0 and \s
    private IRubyObject multiByteRStrip19(Ruby runtime) {
<span class="fc" id="L4493">        byte[] bytes = value.getUnsafeBytes();</span>
<span class="fc" id="L4494">        int start = value.getBegin();</span>
<span class="fc" id="L4495">        int end = start + value.getRealSize();</span>
<span class="fc" id="L4496">        Encoding enc = value.getEncoding();</span>
<span class="fc" id="L4497">        int endp = end;</span>
        int prev;
<span class="pc bpc" id="L4499" title="1 of 2 branches missed.">        while ((prev = enc.prevCharHead(bytes, start, endp, end)) != -1) {</span>
<span class="fc" id="L4500">            int point = codePoint(runtime, enc, bytes, prev, end);</span>
<span class="fc bfc" id="L4501" title="All 4 branches covered.">            if (point != 0 &amp;&amp; !ASCII.isSpace(point)) break;</span>
<span class="fc" id="L4502">            endp = prev;</span>
<span class="fc" id="L4503">        }</span>

<span class="fc bfc" id="L4505" title="All 2 branches covered.">        if (endp &lt; end) {</span>
<span class="fc" id="L4506">            view(0, endp - start);</span>
<span class="fc" id="L4507">            return this;</span>
        }
<span class="fc" id="L4509">        return runtime.getNil();</span>
    }

    /** rb_str_strip / rb_str_strip_bang
     *
     */
    public IRubyObject strip(ThreadContext context) {
<span class="nc" id="L4516">        return strip19(context);</span>
    }

    public IRubyObject strip_bang(ThreadContext context) {
<span class="nc" id="L4520">        return strip_bang19(context);</span>
    }

    @JRubyMethod(name = &quot;strip&quot;)
    public IRubyObject strip19(ThreadContext context) {
<span class="fc" id="L4525">        RubyString str = strDup(context.runtime);</span>
<span class="fc" id="L4526">        str.strip_bang19(context);</span>
<span class="fc" id="L4527">        return str;</span>
    }

    @JRubyMethod(name = &quot;strip!&quot;)
    public IRubyObject strip_bang19(ThreadContext context) {
<span class="fc" id="L4532">        modifyCheck();</span>

<span class="fc" id="L4534">        IRubyObject left = lstrip_bang19(context);</span>
<span class="fc" id="L4535">        IRubyObject right = rstrip_bang19(context);</span>

<span class="fc bfc" id="L4537" title="All 4 branches covered.">        return left.isNil() &amp;&amp; right.isNil() ? context.runtime.getNil() : this;</span>
    }

    /** rb_str_count
     *
     */
    public IRubyObject count(ThreadContext context) {
<span class="nc" id="L4544">        return count19(context);</span>
    }

    public IRubyObject count(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L4548">        return count19(context, arg);</span>
    }

    public IRubyObject count(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L4552">        return count19(context, args);</span>
    }

    @JRubyMethod(name = &quot;count&quot;)
    public IRubyObject count19(ThreadContext context) {
<span class="fc" id="L4557">        throw context.runtime.newArgumentError(&quot;wrong number of arguments&quot;);</span>
    }

    @JRubyMethod(name = &quot;count&quot;)
    public IRubyObject count19(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L4562">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L4563" title="All 2 branches covered.">        if (value.getRealSize() == 0) return RubyFixnum.zero(runtime);</span>

<span class="fc" id="L4565">        RubyString otherStr = arg.convertToString();</span>
<span class="fc" id="L4566">        Encoding enc = checkEncoding(otherStr);</span>

        int c;
<span class="pc bpc" id="L4569" title="1 of 4 branches missed.">        if (otherStr.value.length() == 1 &amp;&amp; enc.isAsciiCompatible() &amp;&amp;</span>
<span class="pc bpc" id="L4570" title="2 of 4 branches missed.">                ((c = otherStr.value.unsafeBytes()[otherStr.value.getBegin()] &amp; 0xff)) &lt; 0x80 &amp;&amp; scanForCodeRange() != CR_BROKEN) {</span>

<span class="pc bpc" id="L4572" title="1 of 2 branches missed.">            if (value.length() ==0) return RubyFixnum.zero(runtime);</span>
<span class="fc" id="L4573">            byte[]bytes = value.unsafeBytes();</span>
<span class="fc" id="L4574">            int p = value.getBegin();</span>
<span class="fc" id="L4575">            int end = p + value.length();</span>
<span class="fc" id="L4576">            int n = 0;</span>
<span class="fc bfc" id="L4577" title="All 2 branches covered.">            while (p &lt; end) {</span>
<span class="fc bfc" id="L4578" title="All 2 branches covered.">                if ((bytes[p++] &amp; 0xff) == c) n++;</span>
            }
<span class="fc" id="L4580">            return RubyFixnum.newFixnum(runtime, n);</span>
        }

<span class="fc" id="L4583">        final boolean[]table = new boolean[StringSupport.TRANS_SIZE + 1];</span>
<span class="fc" id="L4584">        StringSupport.TrTables tables = StringSupport.trSetupTable(otherStr.value, context.runtime, table, null, true, enc);</span>
<span class="fc" id="L4585">        return runtime.newFixnum(StringSupport.countCommon19(value, runtime, table, tables, enc));</span>
    }

    @JRubyMethod(name = &quot;count&quot;, required = 1, rest = true)
    public IRubyObject count19(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L4590">        Ruby runtime = context.runtime;</span>
<span class="pc bpc" id="L4591" title="1 of 2 branches missed.">        if (value.getRealSize() == 0) return RubyFixnum.zero(runtime);</span>

<span class="fc" id="L4593">        RubyString otherStr = args[0].convertToString();</span>
<span class="fc" id="L4594">        Encoding enc = checkEncoding(otherStr);</span>
<span class="fc" id="L4595">        final boolean[]table = new boolean[StringSupport.TRANS_SIZE + 1];</span>
<span class="fc" id="L4596">        StringSupport.TrTables tables = StringSupport.trSetupTable(otherStr.value, runtime, table, null, true, enc);</span>
<span class="fc bfc" id="L4597" title="All 2 branches covered.">        for (int i = 1; i&lt;args.length; i++) {</span>
<span class="fc" id="L4598">            otherStr = args[i].convertToString();</span>
<span class="fc" id="L4599">            enc = checkEncoding(otherStr);</span>
<span class="fc" id="L4600">            tables = StringSupport.trSetupTable(otherStr.value, runtime, table, tables, false, enc);</span>
        }

<span class="fc" id="L4603">        return runtime.newFixnum(StringSupport.countCommon19(value, runtime, table, tables, enc));</span>
    }

    /** rb_str_delete / rb_str_delete_bang
     *
     */
    public IRubyObject delete(ThreadContext context) {
<span class="nc" id="L4610">        return delete19(context);</span>
    }

    public IRubyObject delete(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L4614">        return delete19(context, arg);</span>
    }

    public IRubyObject delete(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L4618">        return delete19(context, args);</span>
    }

    public IRubyObject delete_bang(ThreadContext context) {
<span class="nc" id="L4622">        return delete_bang19(context);</span>
    }

    public IRubyObject delete_bang(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L4626">        return delete_bang19(context, arg);</span>
    }

    public IRubyObject delete_bang(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L4630">        return delete_bang19(context, args);</span>
    }

    @JRubyMethod(name = &quot;delete&quot;)
    public IRubyObject delete19(ThreadContext context) {
<span class="fc" id="L4635">        throw context.runtime.newArgumentError(&quot;wrong number of arguments&quot;);</span>
    }

    @JRubyMethod(name = &quot;delete&quot;)
    public IRubyObject delete19(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L4640">        RubyString str = strDup(context.runtime);</span>
<span class="fc" id="L4641">        str.delete_bang19(context, arg);</span>
<span class="fc" id="L4642">        return str;</span>
    }

    @JRubyMethod(name = &quot;delete&quot;, required = 1, rest = true)
    public IRubyObject delete19(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L4647">        RubyString str = strDup(context.runtime);</span>
<span class="fc" id="L4648">        str.delete_bang19(context, args);</span>
<span class="fc" id="L4649">        return str;</span>
    }

    @JRubyMethod(name = &quot;delete!&quot;)
    public IRubyObject delete_bang19(ThreadContext context) {
<span class="nc" id="L4654">        throw context.runtime.newArgumentError(&quot;wrong number of arguments&quot;);</span>
    }

    @JRubyMethod(name = &quot;delete!&quot;)
    public IRubyObject delete_bang19(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L4659">        Ruby runtime = context.runtime;</span>
<span class="pc bpc" id="L4660" title="1 of 2 branches missed.">        if (value.getRealSize() == 0) return runtime.getNil();</span>

<span class="fc" id="L4662">        RubyString otherStr = arg.convertToString();</span>
<span class="fc" id="L4663">        Encoding enc = checkEncoding(otherStr);</span>
<span class="fc" id="L4664">        final boolean[]squeeze = new boolean[StringSupport.TRANS_SIZE + 1];</span>
<span class="fc" id="L4665">        StringSupport.TrTables tables = StringSupport.trSetupTable(otherStr.value, runtime, squeeze, null, true, enc);</span>
<span class="fc" id="L4666">        return delete_bangCommon19(runtime, squeeze, tables, enc);</span>
    }

    @JRubyMethod(name = &quot;delete!&quot;, required = 1, rest = true)
    public IRubyObject delete_bang19(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L4671">        Ruby runtime = context.runtime;</span>
<span class="pc bpc" id="L4672" title="1 of 2 branches missed.">        if (value.getRealSize() == 0) return runtime.getNil();</span>

<span class="fc" id="L4674">        RubyString otherStr = args[0].convertToString();</span>
<span class="fc" id="L4675">        Encoding enc = checkEncoding(otherStr);</span>
<span class="fc" id="L4676">        boolean[]squeeze = new boolean[StringSupport.TRANS_SIZE + 1];</span>
<span class="fc" id="L4677">        StringSupport.TrTables tables = StringSupport.trSetupTable(otherStr.value, runtime, squeeze, null, true, enc);</span>
<span class="fc bfc" id="L4678" title="All 2 branches covered.">        for (int i=1; i&lt;args.length; i++) {</span>
<span class="fc" id="L4679">            otherStr = args[i].convertToString();</span>
<span class="fc" id="L4680">            enc = checkEncoding(otherStr);</span>
<span class="fc" id="L4681">            tables = StringSupport.trSetupTable(otherStr.value, runtime, squeeze, tables, false, enc);</span>
        }

<span class="fc" id="L4684">        return delete_bangCommon19(runtime, squeeze, tables, enc);</span>
    }

    private IRubyObject delete_bangCommon19(Ruby runtime, boolean[]squeeze, StringSupport.TrTables tables, Encoding enc) {
<span class="fc" id="L4688">        modifyAndKeepCodeRange();</span>

<span class="fc" id="L4690">        int s = value.getBegin();</span>
<span class="fc" id="L4691">        int t = s;</span>
<span class="fc" id="L4692">        int send = s + value.getRealSize();</span>
<span class="fc" id="L4693">        byte[]bytes = value.getUnsafeBytes();</span>
<span class="fc" id="L4694">        boolean modify = false;</span>
<span class="fc" id="L4695">        boolean asciiCompatible = enc.isAsciiCompatible();</span>
<span class="pc bpc" id="L4696" title="1 of 2 branches missed.">        int cr = asciiCompatible ? CR_7BIT : CR_VALID;</span>
<span class="fc bfc" id="L4697" title="All 2 branches covered.">        while (s &lt; send) {</span>
            int c;
<span class="pc bpc" id="L4699" title="2 of 4 branches missed.">            if (asciiCompatible &amp;&amp; Encoding.isAscii(c = bytes[s] &amp; 0xff)) {</span>
<span class="fc bfc" id="L4700" title="All 2 branches covered.">                if (squeeze[c]) {</span>
<span class="fc" id="L4701">                    modify = true;</span>
                } else {
<span class="fc bfc" id="L4703" title="All 2 branches covered.">                    if (t != s) bytes[t] = (byte)c;</span>
<span class="fc" id="L4704">                    t++;</span>
                }
<span class="fc" id="L4706">                s++;</span>
            } else {
<span class="nc" id="L4708">                c = codePoint(runtime, enc, bytes, s, send);</span>
<span class="nc" id="L4709">                int cl = codeLength(runtime, enc, c);</span>
<span class="nc bnc" id="L4710" title="All 2 branches missed.">                if (StringSupport.trFind(c, squeeze, tables)) {</span>
<span class="nc" id="L4711">                    modify = true;</span>
                } else {
<span class="nc bnc" id="L4713" title="All 2 branches missed.">                    if (t != s) enc.codeToMbc(c, bytes, t);</span>
<span class="nc" id="L4714">                    t += cl;</span>
<span class="nc bnc" id="L4715" title="All 2 branches missed.">                    if (cr == CR_7BIT) cr = CR_VALID;</span>
                }
<span class="nc" id="L4717">                s += cl;</span>
            }
<span class="fc" id="L4719">        }</span>
<span class="fc" id="L4720">        value.setRealSize(t - value.getBegin());</span>
<span class="fc" id="L4721">        setCodeRange(cr);</span>

<span class="fc bfc" id="L4723" title="All 2 branches covered.">        return modify ? this : runtime.getNil();</span>
    }

    /** rb_str_squeeze / rb_str_squeeze_bang
     *
     */
    public IRubyObject squeeze(ThreadContext context) {
<span class="nc" id="L4730">        return squeeze19(context);</span>
    }

    public IRubyObject squeeze(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L4734">        return squeeze19(context, arg);</span>
    }

    public IRubyObject squeeze(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L4738">        return squeeze19(context, args);</span>
    }

    public IRubyObject squeeze_bang(ThreadContext context) {
<span class="nc" id="L4742">        return squeeze_bang19(context);</span>
    }

    public IRubyObject squeeze_bang(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L4746">        return squeeze_bang19(context, arg);</span>
    }

    public IRubyObject squeeze_bang(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L4750">        return squeeze_bang19(context, args);</span>
    }

    private IRubyObject squeezeCommon(Ruby runtime, boolean squeeze[]) {
<span class="fc" id="L4754">        int s = value.getBegin();</span>
<span class="fc" id="L4755">        int t = s;</span>
<span class="fc" id="L4756">        int send = s + value.getRealSize();</span>
<span class="fc" id="L4757">        byte[]bytes = value.getUnsafeBytes();</span>
<span class="fc" id="L4758">        int save = -1;</span>

<span class="fc bfc" id="L4760" title="All 2 branches covered.">        while (s &lt; send) {</span>
<span class="fc" id="L4761">            int c = bytes[s++] &amp; 0xff;</span>
<span class="fc bfc" id="L4762" title="All 4 branches covered.">            if (c != save || !squeeze[c]) bytes[t++] = (byte)(save = c);</span>
<span class="fc" id="L4763">        }</span>

<span class="fc bfc" id="L4765" title="All 2 branches covered.">        if (t - value.getBegin() != value.getRealSize()) { // modified</span>
<span class="fc" id="L4766">            value.setRealSize(t - value.getBegin());</span>
<span class="fc" id="L4767">            return this;</span>
        }

<span class="fc" id="L4770">        return runtime.getNil();</span>
    }

    @JRubyMethod(name = &quot;squeeze&quot;)
    public IRubyObject squeeze19(ThreadContext context) {
<span class="fc" id="L4775">        RubyString str = strDup(context.runtime);</span>
<span class="fc" id="L4776">        str.squeeze_bang19(context);</span>
<span class="fc" id="L4777">        return str;</span>
    }

    @JRubyMethod(name = &quot;squeeze&quot;)
    public IRubyObject squeeze19(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L4782">        RubyString str = strDup(context.runtime);</span>
<span class="fc" id="L4783">        str.squeeze_bang19(context, arg);</span>
<span class="fc" id="L4784">        return str;</span>
    }

    @JRubyMethod(name = &quot;squeeze&quot;, rest = true)
    public IRubyObject squeeze19(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L4789">        RubyString str = strDup(context.runtime);</span>
<span class="fc" id="L4790">        str.squeeze_bang19(context, args);</span>
<span class="fc" id="L4791">        return str;</span>
    }

    @JRubyMethod(name = &quot;squeeze!&quot;)
    public IRubyObject squeeze_bang19(ThreadContext context) {
<span class="fc" id="L4796">        Ruby runtime = context.runtime;</span>
<span class="pc bpc" id="L4797" title="1 of 2 branches missed.">        if (value.getRealSize() == 0) {</span>
<span class="nc" id="L4798">            modifyCheck();</span>
<span class="nc" id="L4799">            return runtime.getNil();</span>
        }
<span class="fc" id="L4801">        final boolean squeeze[] = new boolean[StringSupport.TRANS_SIZE];</span>
<span class="fc bfc" id="L4802" title="All 2 branches covered.">        for (int i=0; i&lt; StringSupport.TRANS_SIZE; i++) squeeze[i] = true;</span>

<span class="fc" id="L4804">        modifyAndKeepCodeRange();</span>
<span class="pc bpc" id="L4805" title="1 of 2 branches missed.">        if (singleByteOptimizable()) {</span>
<span class="fc" id="L4806">            return squeezeCommon(runtime, squeeze); // 1.8</span>
        } else {
<span class="nc" id="L4808">            return squeezeCommon19(runtime, squeeze, null, value.getEncoding(), false);</span>
        }
    }

    @JRubyMethod(name = &quot;squeeze!&quot;)
    public IRubyObject squeeze_bang19(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L4814">        Ruby runtime = context.runtime;</span>
<span class="pc bpc" id="L4815" title="1 of 2 branches missed.">        if (value.getRealSize() == 0) {</span>
<span class="nc" id="L4816">            modifyCheck();</span>
<span class="nc" id="L4817">            return runtime.getNil();</span>
        }

<span class="fc" id="L4820">        RubyString otherStr = arg.convertToString();</span>
<span class="fc" id="L4821">        final boolean squeeze[] = new boolean[StringSupport.TRANS_SIZE + 1];</span>
<span class="fc" id="L4822">        StringSupport.TrTables tables = StringSupport.trSetupTable(otherStr.value, runtime, squeeze, null, true, checkEncoding(otherStr));</span>

<span class="fc" id="L4824">        modifyAndKeepCodeRange();</span>
<span class="pc bpc" id="L4825" title="2 of 4 branches missed.">        if (singleByteOptimizable() &amp;&amp; otherStr.singleByteOptimizable()) {</span>
<span class="fc" id="L4826">            return squeezeCommon(runtime, squeeze); // 1.8</span>
        } else {
<span class="nc" id="L4828">            return squeezeCommon19(runtime, squeeze, tables, value.getEncoding(), true);</span>
        }

    }

    @JRubyMethod(name = &quot;squeeze!&quot;, rest = true)
    public IRubyObject squeeze_bang19(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L4835">        Ruby runtime = context.runtime;</span>
<span class="pc bpc" id="L4836" title="1 of 2 branches missed.">        if (value.getRealSize() == 0) {</span>
<span class="nc" id="L4837">            modifyCheck();</span>
<span class="nc" id="L4838">            return runtime.getNil();</span>
        }

<span class="fc" id="L4841">        RubyString otherStr = args[0].convertToString();</span>
<span class="fc" id="L4842">        Encoding enc = checkEncoding(otherStr);</span>
<span class="fc" id="L4843">        final boolean squeeze[] = new boolean[StringSupport.TRANS_SIZE + 1];</span>
<span class="fc" id="L4844">        StringSupport.TrTables tables = StringSupport.trSetupTable(otherStr.value, runtime, squeeze, null, true, enc);</span>

<span class="pc bpc" id="L4846" title="2 of 4 branches missed.">        boolean singlebyte = singleByteOptimizable() &amp;&amp; otherStr.singleByteOptimizable();</span>
<span class="fc bfc" id="L4847" title="All 2 branches covered.">        for (int i=1; i&lt;args.length; i++) {</span>
<span class="fc" id="L4848">            otherStr = args[i].convertToString();</span>
<span class="fc" id="L4849">            enc = checkEncoding(otherStr);</span>
<span class="pc bpc" id="L4850" title="2 of 4 branches missed.">            singlebyte = singlebyte &amp;&amp; otherStr.singleByteOptimizable();</span>
<span class="fc" id="L4851">            tables = StringSupport.trSetupTable(otherStr.value, runtime, squeeze, tables, false, enc);</span>
        }

<span class="fc" id="L4854">        modifyAndKeepCodeRange();</span>
<span class="pc bpc" id="L4855" title="1 of 2 branches missed.">        if (singlebyte) {</span>
<span class="fc" id="L4856">            return squeezeCommon(runtime, squeeze); // 1.8</span>
        } else {
<span class="nc" id="L4858">            return squeezeCommon19(runtime, squeeze, tables, enc, true);</span>
        }
    }

    private IRubyObject squeezeCommon19(Ruby runtime, boolean squeeze[], StringSupport.TrTables tables, Encoding enc, boolean isArg) {
<span class="nc" id="L4863">        int s = value.getBegin();</span>
<span class="nc" id="L4864">        int t = s;</span>
<span class="nc" id="L4865">        int send = s + value.getRealSize();</span>
<span class="nc" id="L4866">        byte[]bytes = value.getUnsafeBytes();</span>
<span class="nc" id="L4867">        int save = -1;</span>
        int c;

<span class="nc bnc" id="L4870" title="All 2 branches missed.">        while (s &lt; send) {</span>
<span class="nc bnc" id="L4871" title="All 4 branches missed.">            if (enc.isAsciiCompatible() &amp;&amp; (c = bytes[s] &amp; 0xff) &lt; 0x80) {</span>
<span class="nc bnc" id="L4872" title="All 6 branches missed.">                if (c != save || (isArg &amp;&amp; !squeeze[c])) bytes[t++] = (byte)(save = c);</span>
<span class="nc" id="L4873">                s++;</span>
            } else {
<span class="nc" id="L4875">                c = codePoint(runtime, enc, bytes, s, send);</span>
<span class="nc" id="L4876">                int cl = codeLength(runtime, enc, c);</span>
<span class="nc bnc" id="L4877" title="All 6 branches missed.">                if (c != save || (isArg &amp;&amp; !StringSupport.trFind(c, squeeze, tables))) {</span>
<span class="nc bnc" id="L4878" title="All 2 branches missed.">                    if (t != s) enc.codeToMbc(c, bytes, t);</span>
<span class="nc" id="L4879">                    save = c;</span>
<span class="nc" id="L4880">                    t += cl;</span>
                }
<span class="nc" id="L4882">                s += cl;</span>
<span class="nc" id="L4883">            }</span>
        }

<span class="nc bnc" id="L4886" title="All 2 branches missed.">        if (t - value.getBegin() != value.getRealSize()) { // modified</span>
<span class="nc" id="L4887">            value.setRealSize(t - value.getBegin());</span>
<span class="nc" id="L4888">            return this;</span>
        }

<span class="nc" id="L4891">        return runtime.getNil();</span>
    }

    /** rb_str_tr / rb_str_tr_bang
     *
     */
    public IRubyObject tr(ThreadContext context, IRubyObject src, IRubyObject repl) {
<span class="nc" id="L4898">        return tr19(context, src, repl);</span>
    }

    public IRubyObject tr_bang(ThreadContext context, IRubyObject src, IRubyObject repl) {
<span class="nc" id="L4902">        return tr_bang19(context, src, repl);</span>
    }

    @JRubyMethod(name = &quot;tr&quot;)
    public IRubyObject tr19(ThreadContext context, IRubyObject src, IRubyObject repl) {
<span class="fc" id="L4907">        RubyString str = strDup(context.runtime);</span>
<span class="fc" id="L4908">        str.trTrans19(context, src, repl, false);</span>
<span class="fc" id="L4909">        return str;</span>
    }

    @JRubyMethod(name = &quot;tr!&quot;)
    public IRubyObject tr_bang19(ThreadContext context, IRubyObject src, IRubyObject repl) {
<span class="fc" id="L4914">        return trTrans19(context, src, repl, false);</span>
    }

    private IRubyObject trTrans19(ThreadContext context, IRubyObject src, IRubyObject repl, boolean sflag) {
<span class="fc" id="L4918">        Ruby runtime = context.runtime;</span>
<span class="pc bpc" id="L4919" title="1 of 2 branches missed.">        if (value.getRealSize() == 0) return runtime.getNil();</span>

<span class="fc" id="L4921">        RubyString replStr = repl.convertToString();</span>
<span class="fc" id="L4922">        ByteList replList = replStr.value;</span>
<span class="fc bfc" id="L4923" title="All 2 branches covered.">        if (replList.getRealSize() == 0) return delete_bang19(context, src);</span>

<span class="fc" id="L4925">        RubyString srcStr = src.convertToString();</span>
<span class="fc" id="L4926">        ByteList srcList = srcStr.value;</span>
<span class="fc" id="L4927">        Encoding e1 = checkEncoding(srcStr);</span>
<span class="fc" id="L4928">        Encoding e2 = checkEncoding(replStr);</span>
<span class="pc bpc" id="L4929" title="1 of 2 branches missed.">        Encoding enc = e1 == e2 ? e1 : srcStr.checkEncoding(replStr);</span>

<span class="fc" id="L4931">        int cr = getCodeRange();</span>

<span class="fc" id="L4933">        final StringSupport.TR trSrc = new StringSupport.TR(srcList);</span>
<span class="fc" id="L4934">        boolean cflag = false;</span>
<span class="pc bpc" id="L4935" title="1 of 2 branches missed.">        if (value.getRealSize() &gt; 0) {</span>
<span class="pc bpc" id="L4936" title="1 of 2 branches missed.">            if (enc.isAsciiCompatible()) {</span>
<span class="fc bfc" id="L4937" title="All 6 branches covered.">                if (trSrc.buf.length &gt; 0 &amp;&amp; (trSrc.buf[trSrc.p] &amp; 0xff) == '^' &amp;&amp; trSrc.p + 1 &lt; trSrc.pend) {</span>
<span class="fc" id="L4938">                    cflag = true;</span>
<span class="fc" id="L4939">                    trSrc.p++;</span>
                }
            } else {
<span class="nc" id="L4942">                int cl = StringSupport.preciseLength(enc, trSrc.buf, trSrc.p, trSrc.pend);</span>
<span class="nc bnc" id="L4943" title="All 4 branches missed.">                if (enc.mbcToCode(trSrc.buf, trSrc.p, trSrc.pend) == '^' &amp;&amp; trSrc.p + cl &lt; trSrc.pend) {</span>
<span class="nc" id="L4944">                    cflag = true;</span>
<span class="nc" id="L4945">                    trSrc.p += cl;</span>
                }
            }
        }

<span class="fc" id="L4950">        boolean singlebyte = singleByteOptimizable();</span>

        int c;
<span class="fc" id="L4953">        final int[]trans = new int[StringSupport.TRANS_SIZE];</span>
<span class="fc" id="L4954">        IntHash&lt;Integer&gt; hash = null;</span>
<span class="fc" id="L4955">        final StringSupport.TR trRepl = new StringSupport.TR(replList);</span>

<span class="fc" id="L4957">        int last = 0;</span>
<span class="fc bfc" id="L4958" title="All 2 branches covered.">        if (cflag) {</span>
<span class="fc bfc" id="L4959" title="All 2 branches covered.">            for (int i=0; i&lt; StringSupport.TRANS_SIZE; i++) trans[i] = 1;</span>

<span class="fc bfc" id="L4961" title="All 2 branches covered.">            while ((c = StringSupport.trNext(trSrc, runtime, enc)) &gt;= 0) {</span>
<span class="pc bpc" id="L4962" title="1 of 2 branches missed.">                if (c &lt; StringSupport.TRANS_SIZE) {</span>
<span class="fc" id="L4963">                    trans[c &amp; 0xff] = -1;</span>
                } else {
<span class="nc bnc" id="L4965" title="All 2 branches missed.">                    if (hash == null) hash = new IntHash&lt;Integer&gt;();</span>
<span class="nc" id="L4966">                    hash.put(c, 1); // QTRUE</span>
                }
            }
<span class="fc bfc" id="L4969" title="All 2 branches covered.">            while ((c = StringSupport.trNext(trRepl, runtime, enc)) &gt;= 0) {}  /* retrieve last replacer */</span>
<span class="fc" id="L4970">            last = trRepl.now;</span>
<span class="fc bfc" id="L4971" title="All 2 branches covered.">            for (int i=0; i&lt; StringSupport.TRANS_SIZE; i++) {</span>
<span class="fc bfc" id="L4972" title="All 2 branches covered.">                if (trans[i] &gt;= 0) trans[i] = last;</span>
            }
        } else {
<span class="fc bfc" id="L4975" title="All 2 branches covered.">            for (int i=0; i&lt; StringSupport.TRANS_SIZE; i++) trans[i] = -1;</span>

<span class="fc bfc" id="L4977" title="All 2 branches covered.">            while ((c = StringSupport.trNext(trSrc, runtime, enc)) &gt;= 0) {</span>
<span class="fc" id="L4978">                int r = StringSupport.trNext(trRepl, runtime, enc);</span>
<span class="fc bfc" id="L4979" title="All 2 branches covered.">                if (r == -1) r = trRepl.now;</span>
<span class="pc bpc" id="L4980" title="1 of 2 branches missed.">                if (c &lt; StringSupport.TRANS_SIZE) {</span>
<span class="fc" id="L4981">                    trans[c] = r;</span>
<span class="fc bfc" id="L4982" title="All 2 branches covered.">                    if (codeLength(runtime, enc, r) != 1) singlebyte = false;</span>
                } else {
<span class="nc bnc" id="L4984" title="All 2 branches missed.">                    if (hash == null) hash = new IntHash&lt;Integer&gt;();</span>
<span class="nc" id="L4985">                    hash.put(c, r);</span>
                }
<span class="fc" id="L4987">            }</span>
        }

<span class="pc bpc" id="L4990" title="1 of 2 branches missed.">        if (cr == CR_VALID) cr = CR_7BIT;</span>
<span class="fc" id="L4991">        modifyAndKeepCodeRange();</span>
<span class="fc" id="L4992">        int s = value.getBegin();</span>
<span class="fc" id="L4993">        int send = s + value.getRealSize();</span>
<span class="fc" id="L4994">        byte sbytes[] = value.getUnsafeBytes();</span>
<span class="fc" id="L4995">        int max = value.getRealSize();</span>
<span class="fc" id="L4996">        boolean modify = false;</span>

        int clen, tlen, c0;

<span class="fc bfc" id="L5000" title="All 2 branches covered.">        if (sflag) {</span>
<span class="fc" id="L5001">            int save = -1;</span>
<span class="fc" id="L5002">            byte[]buf = new byte[max];</span>
<span class="fc" id="L5003">            int t = 0;</span>
<span class="fc bfc" id="L5004" title="All 2 branches covered.">            while (s &lt; send) {</span>
<span class="fc" id="L5005">                boolean mayModify = false;</span>
<span class="fc" id="L5006">                c0 = c = codePoint(runtime, e1, sbytes, s, send);</span>
<span class="fc" id="L5007">                clen = codeLength(runtime, e1, c);</span>
<span class="pc bpc" id="L5008" title="1 of 2 branches missed.">                tlen = enc == e1 ? clen : codeLength(runtime, enc, c);</span>
<span class="fc" id="L5009">                s += clen;</span>

<span class="fc" id="L5011">                c = trCode(c, trans, hash, cflag, last, false);</span>
<span class="fc bfc" id="L5012" title="All 2 branches covered.">                if (c != -1) {</span>
<span class="fc bfc" id="L5013" title="All 2 branches covered.">                    if (save == c) {</span>
<span class="pc bpc" id="L5014" title="3 of 4 branches missed.">                        if (cr == CR_7BIT &amp;&amp; !Encoding.isAscii(c)) cr = CR_VALID;</span>
                        continue;
                    }
<span class="fc" id="L5017">                    save = c;</span>
<span class="fc" id="L5018">                    tlen = codeLength(runtime, enc, c);</span>
<span class="fc" id="L5019">                    modify = true;</span>
                } else {
<span class="fc" id="L5021">                    save = -1;</span>
<span class="fc" id="L5022">                    c = c0;</span>
<span class="pc bpc" id="L5023" title="1 of 2 branches missed.">                    if (enc != e1) mayModify = true;</span>
                }

<span class="fc bfc" id="L5026" title="All 2 branches covered.">                while (t + tlen &gt;= max) {</span>
<span class="fc" id="L5027">                    max &lt;&lt;= 1;</span>
<span class="fc" id="L5028">                    byte[]tbuf = new byte[max];</span>
<span class="fc" id="L5029">                    System.arraycopy(buf, 0, tbuf, 0, buf.length);</span>
<span class="fc" id="L5030">                    buf = tbuf;</span>
<span class="fc" id="L5031">                }</span>
<span class="fc" id="L5032">                enc.codeToMbc(c, buf, t);</span>
<span class="pc bpc" id="L5033" title="7 of 8 branches missed.">                if (mayModify &amp;&amp; (tlen == 1 ? sbytes[s] != buf[t] : ByteList.memcmp(sbytes, s, buf, t, tlen) != 0)) modify = true;</span>
<span class="pc bpc" id="L5034" title="1 of 4 branches missed.">                if (cr == CR_7BIT &amp;&amp; !Encoding.isAscii(c)) cr = CR_VALID;</span>
<span class="fc" id="L5035">                t += tlen;</span>
<span class="fc" id="L5036">            }</span>
<span class="fc" id="L5037">            value.setUnsafeBytes(buf);</span>
<span class="fc" id="L5038">            value.setRealSize(t);</span>
<span class="pc bpc" id="L5039" title="2 of 6 branches missed.">        } else if (enc.isSingleByte() || (singlebyte &amp;&amp; hash == null)) {</span>
<span class="fc bfc" id="L5040" title="All 2 branches covered.">            while (s &lt; send) {</span>
<span class="fc" id="L5041">                c = sbytes[s] &amp; 0xff;</span>
<span class="pc bpc" id="L5042" title="1 of 2 branches missed.">                if (trans[c] != -1) {</span>
<span class="nc bnc" id="L5043" title="All 2 branches missed.">                    if (!cflag) {</span>
<span class="nc" id="L5044">                        c = trans[c];</span>
<span class="nc" id="L5045">                        sbytes[s] = (byte)c;</span>
                    } else {
<span class="nc" id="L5047">                        sbytes[s] = (byte)last;</span>
                    }
<span class="nc" id="L5049">                    modify = true;</span>
                }
<span class="pc bpc" id="L5051" title="2 of 4 branches missed.">                if (cr == CR_7BIT &amp;&amp; !Encoding.isAscii(c)) cr = CR_VALID;</span>
<span class="fc" id="L5052">                s++;</span>
            }
        } else {
<span class="fc" id="L5055">            max += max &gt;&gt; 1;</span>
<span class="fc" id="L5056">            byte[]buf = new byte[max];</span>
<span class="fc" id="L5057">            int t = 0;</span>

<span class="fc bfc" id="L5059" title="All 2 branches covered.">            while (s &lt; send) {</span>
<span class="fc" id="L5060">                boolean mayModify = false;</span>
<span class="fc" id="L5061">                c0 = c = codePoint(runtime, e1, sbytes, s, send);</span>
<span class="fc" id="L5062">                clen = codeLength(runtime, e1, c);</span>
<span class="pc bpc" id="L5063" title="1 of 2 branches missed.">                tlen = enc == e1 ? clen : codeLength(runtime, enc, c);</span>

<span class="fc" id="L5065">                c = trCode(c, trans, hash, cflag, last, true);</span>

<span class="fc bfc" id="L5067" title="All 2 branches covered.">                if (c != -1) {</span>
<span class="fc" id="L5068">                    tlen = codeLength(runtime, enc, c);</span>
<span class="fc" id="L5069">                    modify = true;</span>
                } else {
<span class="fc" id="L5071">                    c = c0;</span>
<span class="pc bpc" id="L5072" title="1 of 2 branches missed.">                    if (enc != e1) mayModify = true;</span>
                }
<span class="fc bfc" id="L5074" title="All 2 branches covered.">                while (t + tlen &gt;= max) {</span>
<span class="fc" id="L5075">                    max &lt;&lt;= 1;</span>
<span class="fc" id="L5076">                    byte[]tbuf = new byte[max];</span>
<span class="fc" id="L5077">                    System.arraycopy(buf, 0, tbuf, 0, buf.length);</span>
<span class="fc" id="L5078">                    buf = tbuf;</span>
<span class="fc" id="L5079">                }</span>
<span class="fc" id="L5080">                enc.codeToMbc(c, buf, t);</span>
<span class="pc bpc" id="L5081" title="7 of 8 branches missed.">                if (mayModify &amp;&amp; (tlen == 1 ? sbytes[s] != buf[t] : ByteList.memcmp(sbytes, s, buf, t, tlen) != 0)) modify = true;</span>

<span class="pc bpc" id="L5083" title="3 of 4 branches missed.">                if (cr == CR_7BIT &amp;&amp; !Encoding.isAscii(c)) cr = CR_VALID;</span>
<span class="fc" id="L5084">                s += clen;</span>
<span class="fc" id="L5085">                t += tlen;</span>
<span class="fc" id="L5086">            }</span>
<span class="fc" id="L5087">            value.setUnsafeBytes(buf);</span>
<span class="fc" id="L5088">            value.setRealSize(t);</span>
        }

<span class="fc bfc" id="L5091" title="All 2 branches covered.">        if (modify) {</span>
<span class="pc bpc" id="L5092" title="1 of 2 branches missed.">            if (cr != CR_BROKEN) setCodeRange(cr);</span>
<span class="fc" id="L5093">            associateEncoding(enc);</span>
<span class="fc" id="L5094">            return this;</span>
        }
<span class="fc" id="L5096">        return runtime.getNil();</span>
    }

    private int trCode(int c, int[]trans, IntHash&lt;Integer&gt; hash, boolean cflag, int last, boolean set) {
<span class="fc bfc" id="L5100" title="All 2 branches covered.">        if (c &lt; StringSupport.TRANS_SIZE) {</span>
<span class="fc" id="L5101">            return trans[c];</span>
<span class="pc bpc" id="L5102" title="1 of 2 branches missed.">        } else if (hash != null) {</span>
<span class="nc" id="L5103">            Integer tmp = hash.get(c);</span>
<span class="nc bnc" id="L5104" title="All 2 branches missed.">            if (tmp == null) {</span>
<span class="nc bnc" id="L5105" title="All 2 branches missed.">                return cflag ? last : -1;</span>
            } else {
<span class="nc bnc" id="L5107" title="All 2 branches missed.">                return cflag ? -1 : tmp;</span>
            }
        } else {
<span class="pc bpc" id="L5110" title="3 of 4 branches missed.">            return cflag &amp;&amp; set ? last : -1;</span>
        }
    }

    /** rb_str_tr_s / rb_str_tr_s_bang
     *
     */
    public IRubyObject tr_s(ThreadContext context, IRubyObject src, IRubyObject repl) {
<span class="nc" id="L5118">        return tr_s19(context, src, repl);</span>
    }

    public IRubyObject tr_s_bang(ThreadContext context, IRubyObject src, IRubyObject repl) {
<span class="nc" id="L5122">        return tr_s_bang19(context, src, repl);</span>
    }

    @JRubyMethod(name = &quot;tr_s&quot;)
    public IRubyObject tr_s19(ThreadContext context, IRubyObject src, IRubyObject repl) {
<span class="fc" id="L5127">        RubyString str = strDup(context.runtime);</span>
<span class="fc" id="L5128">        str.trTrans19(context, src, repl, true);</span>
<span class="fc" id="L5129">        return str;</span>
    }

    @JRubyMethod(name = &quot;tr_s!&quot;)
    public IRubyObject tr_s_bang19(ThreadContext context, IRubyObject src, IRubyObject repl) {
<span class="fc" id="L5134">        return trTrans19(context, src, repl, true);</span>
    }

    /** rb_str_each_line
     *
     */
    public IRubyObject each_line(ThreadContext context, Block block) {
<span class="nc" id="L5141">        return each_lineCommon(context, context.runtime.getGlobalVariables().get(&quot;$/&quot;), block);</span>
    }

    public IRubyObject each_line(ThreadContext context, IRubyObject arg, Block block) {
<span class="nc" id="L5145">        return each_lineCommon(context, arg, block);</span>
    }

    public IRubyObject each_lineCommon(ThreadContext context, IRubyObject sep, Block block) {
<span class="nc" id="L5149">        Ruby runtime = context.runtime;</span>
<span class="nc bnc" id="L5150" title="All 2 branches missed.">        if (sep.isNil()) {</span>
<span class="nc" id="L5151">            block.yield(context, this);</span>
<span class="nc" id="L5152">            return this;</span>
        }

<span class="nc" id="L5155">        RubyString sepStr = sep.convertToString();</span>
<span class="nc" id="L5156">        ByteList sepValue = sepStr.value;</span>
<span class="nc" id="L5157">        int rslen = sepValue.getRealSize();</span>

        final byte newline;
<span class="nc bnc" id="L5160" title="All 2 branches missed.">        if (rslen == 0) {</span>
<span class="nc" id="L5161">            newline = '\n';</span>
        } else {
<span class="nc" id="L5163">            newline = sepValue.getUnsafeBytes()[sepValue.getBegin() + rslen - 1];</span>
        }

<span class="nc" id="L5166">        int p = value.getBegin();</span>
<span class="nc" id="L5167">        int end = p + value.getRealSize();</span>
<span class="nc" id="L5168">        int ptr = p, s = p;</span>
<span class="nc" id="L5169">        int len = value.getRealSize();</span>
<span class="nc" id="L5170">        byte[] bytes = value.getUnsafeBytes();</span>

<span class="nc" id="L5172">        p += rslen;</span>

<span class="nc bnc" id="L5174" title="All 2 branches missed.">        for (; p &lt; end; p++) {</span>
<span class="nc bnc" id="L5175" title="All 4 branches missed.">            if (rslen == 0 &amp;&amp; bytes[p] == '\n') {</span>
<span class="nc bnc" id="L5176" title="All 4 branches missed.">                if (++p == end || bytes[p] != '\n') continue;</span>
<span class="nc bnc" id="L5177" title="All 4 branches missed.">                while(p &lt; end &amp;&amp; bytes[p] == '\n') p++;</span>
            }
<span class="nc bnc" id="L5179" title="All 6 branches missed.">            if (ptr &lt; p &amp;&amp; bytes[p - 1] == newline &amp;&amp;</span>
               (rslen &lt;= 1 ||
<span class="nc bnc" id="L5181" title="All 2 branches missed.">                ByteList.memcmp(sepValue.getUnsafeBytes(), sepValue.getBegin(), rslen, bytes, p - rslen, rslen) == 0)) {</span>
<span class="nc" id="L5182">                block.yield(context, makeShared(runtime, s - ptr, p - s).infectBy(this));</span>
<span class="nc" id="L5183">                modifyCheck(bytes, len);</span>
<span class="nc" id="L5184">                s = p;</span>
            }
        }

<span class="nc bnc" id="L5188" title="All 2 branches missed.">        if (s != end) {</span>
<span class="nc bnc" id="L5189" title="All 2 branches missed.">            if (p &gt; end) p = end;</span>
<span class="nc" id="L5190">            block.yield(context, makeShared(runtime, s - ptr, p - s).infectBy(this));</span>
        }

<span class="nc" id="L5193">        return this;</span>
    }

    @JRubyMethod(name = &quot;each_line&quot;)
    public IRubyObject each_line19(ThreadContext context, Block block) {
<span class="fc bfc" id="L5198" title="All 2 branches covered.">        return block.isGiven() ? each_lineCommon19(context, block) :</span>
<span class="fc" id="L5199">            enumeratorize(context.runtime, this, &quot;each_line&quot;);</span>
    }

    @JRubyMethod(name = &quot;each_line&quot;)
    public IRubyObject each_line19(ThreadContext context, IRubyObject arg, Block block) {
<span class="fc bfc" id="L5204" title="All 2 branches covered.">        return block.isGiven() ? each_lineCommon19(context, arg, block) :</span>
<span class="fc" id="L5205">            enumeratorize(context.runtime, this, &quot;each_line&quot;, arg);</span>
    }

    public IRubyObject lines(ThreadContext context, Block block) {
<span class="nc" id="L5209">        return lines20(context, block);</span>
    }

    public IRubyObject lines(ThreadContext context, IRubyObject arg, Block block) {
<span class="nc" id="L5213">        return lines20(context, arg, block);</span>
    }

    @JRubyMethod(name = &quot;lines&quot;)
    public IRubyObject lines20(ThreadContext context, Block block) {
        // FIXME: Inefficient; build array manually rather than via Enumerator
<span class="pc bpc" id="L5219" title="1 of 2 branches missed.">        return block.isGiven() ? each_lineCommon19(context, block) :</span>
<span class="pc" id="L5220">            enumeratorize(context.runtime, this, &quot;lines&quot;).callMethod(context, &quot;to_a&quot;);</span>
    }

    @JRubyMethod(name = &quot;lines&quot;)
    public IRubyObject lines20(ThreadContext context, IRubyObject arg, Block block) {
        // FIXME: Inefficient; build array manually rather than via Enumerator
<span class="fc bfc" id="L5226" title="All 2 branches covered.">        return block.isGiven() ? each_lineCommon19(context, arg, block) :</span>
<span class="fc" id="L5227">            enumeratorize(context.runtime, this, &quot;lines&quot;, arg).callMethod(context, &quot;to_a&quot;);</span>
    }

    private IRubyObject each_lineCommon19(ThreadContext context, Block block) {
<span class="fc" id="L5231">        return each_lineCommon19(context, context.runtime.getGlobalVariables().get(&quot;$/&quot;), block);</span>
    }

    private IRubyObject each_lineCommon19(ThreadContext context, IRubyObject sep, Block block) {
<span class="fc" id="L5235">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L5236" title="All 2 branches covered.">        if (sep.isNil()) {</span>
<span class="fc" id="L5237">            block.yield(context, this);</span>
<span class="fc" id="L5238">            return this;</span>
        }
<span class="fc bfc" id="L5240" title="All 2 branches covered.">        if (! sep.respondsTo(&quot;to_str&quot;)) {</span>
<span class="fc" id="L5241">            throw runtime.newTypeError(&quot;can't convert &quot; + sep.getMetaClass() + &quot; into String&quot;);</span>
        }

<span class="fc" id="L5244">        ByteList val = value.shallowDup();</span>
<span class="fc" id="L5245">        int p = val.getBegin();</span>
<span class="fc" id="L5246">        int s = p;</span>
<span class="fc" id="L5247">        int offset = p;</span>
<span class="fc" id="L5248">        int len = val.getRealSize();</span>
<span class="fc" id="L5249">        int end = p + len;</span>
<span class="fc" id="L5250">        byte[]bytes = val.getUnsafeBytes();</span>

        final Encoding enc;
<span class="fc" id="L5253">        RubyString sepStr = sep.convertToString();</span>
<span class="fc bfc" id="L5254" title="All 2 branches covered.">        if (sepStr == runtime.getGlobalVariables().getDefaultSeparator()) {</span>
<span class="fc" id="L5255">            enc = val.getEncoding();</span>
<span class="fc bfc" id="L5256" title="All 2 branches covered.">            while (p &lt; end) {</span>
<span class="fc bfc" id="L5257" title="All 2 branches covered.">                if (bytes[p] == (byte)'\n') {</span>
<span class="fc" id="L5258">                    int p0 = enc.leftAdjustCharHead(bytes, s, p, end);</span>
<span class="pc bpc" id="L5259" title="1 of 2 branches missed.">                    if (enc.isNewLine(bytes, p0, end)) {</span>
<span class="fc" id="L5260">                        p = p0 + StringSupport.length(enc, bytes, p0, end);</span>
<span class="fc" id="L5261">                        block.yield(context, makeShared19(runtime, val, s - offset, p - s).infectBy(this));</span>
<span class="fc" id="L5262">                        s = p;</span>
<span class="fc" id="L5263">                        continue;</span>
                    }
                }
<span class="fc" id="L5266">                p++;</span>
            }
        } else {
<span class="fc" id="L5269">            enc = checkEncoding(sepStr);</span>
<span class="fc" id="L5270">            ByteList sepValue = sepStr.value;</span>
            final int newLine;
<span class="fc" id="L5272">            int rslen = sepValue.getRealSize();</span>
<span class="fc bfc" id="L5273" title="All 2 branches covered.">            if (rslen == 0) {</span>
<span class="fc" id="L5274">                newLine = '\n';</span>
            } else {
<span class="fc" id="L5276">                newLine = codePoint(runtime, enc, sepValue.getUnsafeBytes(), sepValue.getBegin(), sepValue.getBegin() + sepValue.getRealSize());</span>
            }

<span class="fc bfc" id="L5279" title="All 2 branches covered.">            while (p &lt; end) {</span>
<span class="fc" id="L5280">                int c = codePoint(runtime, enc, bytes, p, end);</span>
                again: do {
<span class="fc" id="L5282">                    int n = codeLength(runtime, enc, c);</span>
<span class="fc bfc" id="L5283" title="All 4 branches covered.">                    if (rslen == 0 &amp;&amp; c == newLine) {</span>
<span class="fc" id="L5284">                        p += n;</span>
<span class="pc bpc" id="L5285" title="1 of 4 branches missed.">                        if (p &lt; end &amp;&amp; (c = codePoint(runtime, enc, bytes, p, end)) != newLine) continue again;</span>
<span class="fc bfc" id="L5286" title="All 4 branches covered.">                        while (p &lt; end &amp;&amp; codePoint(runtime, enc, bytes, p, end) == newLine) p += n;</span>
<span class="fc" id="L5287">                        p -= n;</span>
                    }
<span class="fc bfc" id="L5289" title="All 6 branches covered.">                    if (c == newLine &amp;&amp;</span>
                            rslen &lt;= end - p &amp;&amp;
                            (rslen &lt;= 1 ||
<span class="fc bfc" id="L5292" title="All 2 branches covered.">                            ByteList.memcmp(sepValue.getUnsafeBytes(), sepValue.getBegin(), rslen, bytes, p, rslen) == 0)) {</span>
<span class="fc bfc" id="L5293" title="All 2 branches covered.">                        block.yield(context, makeShared19(runtime, val, s - offset, p - s + (rslen != 0 ? rslen : n)).infectBy(this));</span>
<span class="fc bfc" id="L5294" title="All 2 branches covered.">                        s = p + (rslen != 0 ? rslen : n);</span>
                    }
<span class="fc" id="L5296">                    p += n;</span>
                } while (false);
<span class="fc" id="L5298">            }</span>
        }

<span class="fc bfc" id="L5301" title="All 2 branches covered.">        if (s != end) {</span>
<span class="fc" id="L5302">            block.yield(context, makeShared19(runtime, val, s-offset, end - s).infectBy(this));</span>
        }
<span class="fc" id="L5304">        return this;</span>
    }

    /**
     * rb_str_each_byte
     */
    public RubyString each_byte(ThreadContext context, Block block) {
<span class="nc" id="L5311">        Ruby runtime = context.runtime;</span>
        // Check the length every iteration, since
        // the block can modify this string.
<span class="nc bnc" id="L5314" title="All 2 branches missed.">        for (int i = 0; i &lt; value.length(); i++) {</span>
<span class="nc" id="L5315">            block.yield(context, runtime.newFixnum(value.get(i) &amp; 0xFF));</span>
        }
<span class="nc" id="L5317">        return this;</span>
    }

    @JRubyMethod(name = &quot;each_byte&quot;)
    public IRubyObject each_byte19(ThreadContext context, Block block) {
<span class="fc" id="L5322">        return enumerateBytes(context, &quot;each_byte&quot;, block, false);</span>
    }

    @JRubyMethod
    public IRubyObject bytes(ThreadContext context, Block block) {
<span class="fc" id="L5327">        return enumerateBytes(context, &quot;bytes&quot;, block, true);</span>
    }

    @JRubyMethod(name = &quot;each_char&quot;)
    public IRubyObject each_char19(ThreadContext context, Block block) {
<span class="fc" id="L5332">        return enumerateChars(context, &quot;each_char&quot;, block, false);</span>
    }

    @JRubyMethod(name = &quot;chars&quot;)
    public IRubyObject chars19(ThreadContext context, Block block) {
<span class="fc" id="L5337">        return enumerateChars(context, &quot;chars&quot;, block, true);</span>
    }

    private SizeFn eachCharSizeFn() {
<span class="fc" id="L5341">        final RubyString self = this;</span>
<span class="fc" id="L5342">        return new SizeFn() {</span>
            @Override
            public IRubyObject size(IRubyObject[] args) {
<span class="nc" id="L5345">                return self.length();</span>
            }
        };
    }

    /** rb_str_each_codepoint
     *
     */
    @JRubyMethod
    public IRubyObject each_codepoint(ThreadContext context, Block block) {
<span class="fc" id="L5355">        return enumerateCodepoints(context, &quot;each_codepoint&quot;, block, false);</span>
    }

    @JRubyMethod
    public IRubyObject codepoints(ThreadContext context, Block block) {
<span class="fc" id="L5360">        return enumerateCodepoints(context, &quot;codepoints&quot;, block, true);</span>
    }

    // MRI: rb_str_enumerate_chars
    private IRubyObject enumerateChars(ThreadContext context, String name, Block block, boolean wantarray) {
<span class="fc" id="L5365">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L5366">        RubyString str = this;</span>
<span class="fc" id="L5367">        IRubyObject orig = str;</span>
        IRubyObject substr;
        int i, len, n;
        byte[] ptrBytes;
        int ptr;
        Encoding enc;
<span class="fc" id="L5373">        RubyArray ary = null;</span>

<span class="fc" id="L5375">        str = RubyString.newString(runtime, str.getByteList().dup());</span>
<span class="fc" id="L5376">        ByteList strByteList = str.getByteList();</span>
<span class="fc" id="L5377">        ptrBytes = strByteList.unsafeBytes();</span>
<span class="fc" id="L5378">        ptr = strByteList.begin();</span>
<span class="fc" id="L5379">        len = strByteList.getRealSize();</span>
<span class="fc" id="L5380">        enc = str.getEncoding();</span>

<span class="fc bfc" id="L5382" title="All 2 branches covered.">        if (block.isGiven()) {</span>
<span class="fc bfc" id="L5383" title="All 2 branches covered.">            if (wantarray) {</span>
                // this code should be live in 3.0
                if (false) { // #if STRING_ENUMERATORS_WANTARRAY
                    runtime.getWarnings().warn(&quot;given block not used&quot;);
                    ary = RubyArray.newArray(runtime, str.length().getLongValue());
                } else {
<span class="fc" id="L5389">                    runtime.getWarnings().warning(&quot;passing a block to String#chars is deprecated&quot;);</span>
<span class="fc" id="L5390">                    wantarray = false;</span>
                }
            }
        }
        else {
<span class="fc bfc" id="L5395" title="All 2 branches covered.">            if (wantarray)</span>
<span class="fc" id="L5396">                ary = RubyArray.newArray(runtime, str.length().getLongValue());</span>
            else
<span class="fc" id="L5398">                return enumeratorizeWithSize(context, this, name, eachCharSizeFn());</span>
        }

<span class="fc bfc" id="L5401" title="All 2 branches covered.">        switch (getCodeRange()) {</span>
            case CR_VALID:
            case CR_7BIT:
<span class="fc bfc" id="L5404" title="All 2 branches covered.">                for (i = 0; i &lt; len; i += n) {</span>
<span class="fc" id="L5405">                    n = StringSupport.encFastMBCLen(ptrBytes, ptr + i, ptr + len, enc);</span>
<span class="fc" id="L5406">                    substr = str.substr(runtime, i, n);</span>
<span class="fc bfc" id="L5407" title="All 2 branches covered.">                    if (wantarray)</span>
<span class="fc" id="L5408">                        ary.push(substr);</span>
                    else
<span class="fc" id="L5410">                        block.yield(context, substr);</span>
                }
                break;
            default:
<span class="fc bfc" id="L5414" title="All 2 branches covered.">                for (i = 0; i &lt; len; i += n) {</span>
<span class="fc" id="L5415">                    n = StringSupport.length(enc, ptrBytes, ptr + i, ptr + len);</span>
<span class="fc" id="L5416">                    substr = str.substr(runtime, i, n);</span>
<span class="fc bfc" id="L5417" title="All 2 branches covered.">                    if (wantarray)</span>
<span class="fc" id="L5418">                        ary.push(substr);</span>
                    else
<span class="fc" id="L5420">                        block.yield(context, substr);</span>
                }
        }
<span class="fc bfc" id="L5423" title="All 2 branches covered.">        if (wantarray)</span>
<span class="fc" id="L5424">            return ary;</span>
        else
<span class="fc" id="L5426">            return orig;</span>
    }

    // MRI: rb_str_enumerate_codepoints
    private IRubyObject enumerateCodepoints(ThreadContext context, String name, Block block, boolean wantarray) {
<span class="fc" id="L5431">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L5432">        RubyString str = this;</span>
<span class="fc" id="L5433">        IRubyObject orig = str;</span>
        int n;
        int c;
        byte[] ptrBytes;
        int ptr, end;
        Encoding enc;
<span class="fc" id="L5439">        RubyArray ary = null;</span>

<span class="fc bfc" id="L5441" title="All 2 branches covered.">        if (singleByteOptimizable())</span>
<span class="fc" id="L5442">            return enumerateBytes(context, name, block, wantarray);</span>

<span class="fc" id="L5444">        str = RubyString.newString(runtime, str.getByteList().dup());</span>
<span class="fc" id="L5445">        ByteList strByteList = str.getByteList();</span>
<span class="fc" id="L5446">        ptrBytes = strByteList.unsafeBytes();</span>
<span class="fc" id="L5447">        ptr = strByteList.begin();</span>
<span class="fc" id="L5448">        end = ptr + strByteList.getRealSize();</span>
<span class="fc" id="L5449">        enc = str.getEncoding();</span>

<span class="fc bfc" id="L5451" title="All 2 branches covered.">        if (block.isGiven()) {</span>
<span class="fc bfc" id="L5452" title="All 2 branches covered.">            if (wantarray) {</span>
                // this code should be live in 3.0
                if (false) { // #if STRING_ENUMERATORS_WANTARRAY
                    runtime.getWarnings().warn(&quot;given block not used&quot;);
                    ary = RubyArray.newArray(runtime, str.length().getLongValue());
                } else {
<span class="fc" id="L5458">                    runtime.getWarnings().warning(&quot;passing a block to String#codepoints is deprecated&quot;);</span>
<span class="fc" id="L5459">                    wantarray = false;</span>
                }
            }
        }
        else {
<span class="fc bfc" id="L5464" title="All 2 branches covered.">            if (wantarray)</span>
<span class="fc" id="L5465">                ary = RubyArray.newArray(runtime, str.length().getLongValue());</span>
            else
<span class="fc" id="L5467">                return enumeratorizeWithSize(context, str, name, eachCodepointSizeFn());</span>
        }

<span class="fc bfc" id="L5470" title="All 2 branches covered.">        while (ptr &lt; end) {</span>
<span class="fc" id="L5471">            c = codePoint(runtime, enc, ptrBytes, ptr, end);</span>
<span class="fc" id="L5472">            n = codeLength(runtime, enc, c);</span>
<span class="fc bfc" id="L5473" title="All 2 branches covered.">            if (wantarray)</span>
<span class="fc" id="L5474">                ary.push(RubyFixnum.newFixnum(runtime, c));</span>
            else
<span class="fc" id="L5476">                block.yield(context, RubyFixnum.newFixnum(runtime, c));</span>
<span class="fc" id="L5477">            ptr += n;</span>
        }
<span class="fc bfc" id="L5479" title="All 2 branches covered.">        if (wantarray)</span>
<span class="fc" id="L5480">            return ary;</span>
        else
<span class="fc" id="L5482">            return orig;</span>
    }

    private IRubyObject enumerateBytes(ThreadContext context, String name, Block block, boolean wantarray) {
<span class="fc" id="L5486">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L5487">        RubyString str = this;</span>
        int i;
<span class="fc" id="L5489">        RubyArray ary = null;</span>

<span class="fc bfc" id="L5491" title="All 2 branches covered.">        if (block.isGiven()) {</span>
<span class="fc bfc" id="L5492" title="All 2 branches covered.">            if (wantarray) {</span>
                // this code should be live in 3.0
                if (false) { // #if STRING_ENUMERATORS_WANTARRAY
                    runtime.getWarnings().warn(&quot;given block not used&quot;);
                    ary = RubyArray.newArray(runtime);
                } else {
<span class="fc" id="L5498">                    runtime.getWarnings().warning(&quot;passing a block to String#bytes is deprecated&quot;);</span>
<span class="fc" id="L5499">                    wantarray = false;</span>
                }
            }
        }
        else {
<span class="fc bfc" id="L5504" title="All 2 branches covered.">            if (wantarray)</span>
<span class="fc" id="L5505">                ary = RubyArray.newArray(runtime, str.size());</span>
            else
<span class="fc" id="L5507">                return enumeratorizeWithSize(context, str, name, eachByteSizeFn());</span>
        }

<span class="fc bfc" id="L5510" title="All 2 branches covered.">        for (i=0; i&lt;str.size(); i++) {</span>
<span class="fc" id="L5511">            RubyFixnum bite = RubyFixnum.newFixnum(runtime, str.getByteList().get(i) &amp; 0xff);</span>
<span class="fc bfc" id="L5512" title="All 2 branches covered.">            if (wantarray)</span>
<span class="fc" id="L5513">                ary.push(bite);</span>
            else
<span class="fc" id="L5515">                block.yield(context, bite);</span>
        }
<span class="fc bfc" id="L5517" title="All 2 branches covered.">        if (wantarray)</span>
<span class="fc" id="L5518">            return ary;</span>
        else
<span class="fc" id="L5520">            return str;</span>
    }

    private SizeFn eachCodepointSizeFn() {
<span class="fc" id="L5524">        final RubyString self = this;</span>
<span class="fc" id="L5525">        return new SizeFn() {</span>
            @Override
            public IRubyObject size(IRubyObject[] args) {
<span class="nc" id="L5528">                return self.length();</span>
            }
        };
    }

    /** rb_str_intern
     *
     */
    private RubySymbol to_sym() {
<span class="fc" id="L5537">        RubySymbol specialCaseIntern = checkSpecialCasesIntern(value);</span>
<span class="pc bpc" id="L5538" title="1 of 2 branches missed.">        if (specialCaseIntern != null) return specialCaseIntern;</span>

<span class="fc" id="L5540">        RubySymbol symbol = getRuntime().getSymbolTable().getSymbol(value);</span>
<span class="pc bpc" id="L5541" title="1 of 2 branches missed.">        if (symbol.getBytes() == value) shareLevel = SHARE_LEVEL_BYTELIST;</span>
<span class="fc" id="L5542">        return symbol;</span>
    }

    private RubySymbol checkSpecialCasesIntern(ByteList value) {
<span class="fc" id="L5546">        String[][] opTable = opTable19;</span>

<span class="fc bfc" id="L5548" title="All 2 branches covered.">        for (int i = 0; i &lt; opTable.length; i++) {</span>
<span class="fc" id="L5549">            String op = opTable[i][1];</span>
<span class="pc bpc" id="L5550" title="1 of 2 branches missed.">            if (value.toString().equals(op)) {</span>
<span class="nc" id="L5551">                return getRuntime().getSymbolTable().getSymbol(opTable[i][0]);</span>
            }
        }

<span class="fc" id="L5555">        return null;</span>
    }

    public RubySymbol intern() {
<span class="nc" id="L5559">        return intern19();</span>
    }

    @JRubyMethod(name = {&quot;to_sym&quot;, &quot;intern&quot;})
    public RubySymbol intern19() {
<span class="fc" id="L5564">        return to_sym();</span>
    }

    @JRubyMethod
    public IRubyObject ord(ThreadContext context) {
<span class="fc" id="L5569">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L5570">        return RubyFixnum.newFixnum(runtime, codePoint(runtime, value.getEncoding(), value.getUnsafeBytes(), value.getBegin(),</span>
<span class="fc" id="L5571">                                                                value.getBegin() + value.getRealSize()));</span>
    }

    @JRubyMethod
    public IRubyObject sum(ThreadContext context) {
<span class="fc" id="L5576">        return sumCommon(context, 16);</span>
    }

    @JRubyMethod
    public IRubyObject sum(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L5581">        return sumCommon(context, RubyNumeric.num2long(arg));</span>
    }

    public IRubyObject sumCommon(ThreadContext context, long bits) {
<span class="fc" id="L5585">        Ruby runtime = context.runtime;</span>

<span class="fc" id="L5587">        byte[]bytes = value.getUnsafeBytes();</span>
<span class="fc" id="L5588">        int p = value.getBegin();</span>
<span class="fc" id="L5589">        int len = value.getRealSize();</span>
<span class="fc" id="L5590">        int end = p + len;</span>

<span class="pc bpc" id="L5592" title="1 of 2 branches missed.">        if (bits &gt;= 8 * 8) { // long size * bits in byte</span>
<span class="nc" id="L5593">            IRubyObject one = RubyFixnum.one(runtime);</span>
<span class="nc" id="L5594">            IRubyObject sum = RubyFixnum.zero(runtime);</span>
<span class="nc bnc" id="L5595" title="All 2 branches missed.">            while (p &lt; end) {</span>
<span class="nc" id="L5596">                modifyCheck(bytes, len);</span>
<span class="nc" id="L5597">                sum = sum.callMethod(context, &quot;+&quot;, RubyFixnum.newFixnum(runtime, bytes[p++] &amp; 0xff));</span>
            }
<span class="nc bnc" id="L5599" title="All 2 branches missed.">            if (bits != 0) {</span>
<span class="nc" id="L5600">                IRubyObject mod = one.callMethod(context, &quot;&lt;&lt;&quot;, RubyFixnum.newFixnum(runtime, bits));</span>
<span class="nc" id="L5601">                sum = sum.callMethod(context, &quot;&amp;&quot;, mod.callMethod(context, &quot;-&quot;, one));</span>
            }
<span class="nc" id="L5603">            return sum;</span>
        } else {
<span class="fc" id="L5605">            long sum = 0;</span>
<span class="fc bfc" id="L5606" title="All 2 branches covered.">            while (p &lt; end) {</span>
<span class="fc" id="L5607">                modifyCheck(bytes, len);</span>
<span class="fc" id="L5608">                sum += bytes[p++] &amp; 0xff;</span>
            }
<span class="fc bfc" id="L5610" title="All 2 branches covered.">            return RubyFixnum.newFixnum(runtime, bits == 0 ? sum : sum &amp; (1L &lt;&lt; bits) - 1L);</span>
        }
    }

    /** string_to_c
     *
     */
    @JRubyMethod
    public IRubyObject to_c(ThreadContext context) {
<span class="fc" id="L5619">        Ruby runtime = context.runtime;</span>

<span class="fc" id="L5621">        RubyString underscore = runtime.newString(new ByteList(new byte[]{'_'}));</span>
<span class="fc" id="L5622">        RubyRegexp underscore_pattern = RubyRegexp.newDummyRegexp(runtime, Numeric.ComplexPatterns.underscores_pat);</span>
<span class="fc" id="L5623">        IRubyObject s = this.gsubCommon19(context, null, underscore, null, underscore_pattern, false, 0, false);</span>

<span class="fc" id="L5625">        RubyArray a = RubyComplex.str_to_c_internal(context, s);</span>

<span class="fc bfc" id="L5627" title="All 2 branches covered.">        if (!a.eltInternal(0).isNil()) {</span>
<span class="fc" id="L5628">            return a.eltInternal(0);</span>
        } else {
<span class="fc" id="L5630">            return RubyComplex.newComplexCanonicalize(context, RubyFixnum.zero(runtime));</span>
        }
    }

    /** string_to_r
     *
     */
    @JRubyMethod
    public IRubyObject to_r(ThreadContext context) {
<span class="fc" id="L5639">        Ruby runtime = context.runtime;</span>

<span class="fc" id="L5641">        RubyString underscore = runtime.newString(new ByteList(new byte[]{'_'}));</span>
<span class="fc" id="L5642">        RubyRegexp underscore_pattern = RubyRegexp.newDummyRegexp(runtime, Numeric.ComplexPatterns.underscores_pat);</span>
<span class="fc" id="L5643">        IRubyObject s = this.gsubCommon19(context, null, underscore, null, underscore_pattern, false, 0, false);</span>

<span class="fc" id="L5645">        RubyArray a = RubyRational.str_to_r_internal(context, s);</span>

<span class="fc bfc" id="L5647" title="All 2 branches covered.">        if (!a.eltInternal(0).isNil()) {</span>
<span class="fc" id="L5648">            return a.eltInternal(0);</span>
        } else {
<span class="fc" id="L5650">            return RubyRational.newRationalCanonicalize(context, RubyFixnum.zero(runtime));</span>
        }
    }

    public static RubyString unmarshalFrom(UnmarshalStream input) throws java.io.IOException {
<span class="fc" id="L5655">        RubyString result = newString(input.getRuntime(), input.unmarshalString());</span>
<span class="fc" id="L5656">        input.registerLinkTarget(result);</span>
<span class="fc" id="L5657">        return result;</span>
    }

    /**
     * @see org.jruby.util.Pack#unpack
     */
    @JRubyMethod
    public RubyArray unpack(IRubyObject obj) {
<span class="fc" id="L5665">        return Pack.unpack(getRuntime(), this.value, stringValue(obj).value);</span>
    }

    public void empty() {
<span class="nc" id="L5669">        value = ByteList.EMPTY_BYTELIST;</span>
<span class="nc" id="L5670">        shareLevel = SHARE_LEVEL_BYTELIST;</span>
<span class="nc" id="L5671">    }</span>

    @JRubyMethod
    public IRubyObject encoding(ThreadContext context) {
<span class="fc" id="L5675">        return context.runtime.getEncodingService().getEncoding(value.getEncoding());</span>
    }

    // TODO: re-split this
    public IRubyObject encode_bang(ThreadContext context, IRubyObject arg0) {
<span class="nc" id="L5680">        return encode_bang(context, new IRubyObject[]{arg0});</span>
    }

    public IRubyObject encode_bang(ThreadContext context, IRubyObject arg0, IRubyObject arg1) {
<span class="nc" id="L5684">        return encode_bang(context, new IRubyObject[]{arg0,arg1});</span>
    }

    public IRubyObject encode_bang(ThreadContext context, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {
<span class="nc" id="L5688">        return encode_bang(context, new IRubyObject[]{arg0,arg1,arg2});</span>
    }

    @JRubyMethod(name = &quot;encode!&quot;, optional = 3)
    public IRubyObject encode_bang(ThreadContext context, IRubyObject[] args) {
        IRubyObject[] newstr_p;
        Encoding encindex;

<span class="fc" id="L5696">        modify19();</span>

<span class="fc" id="L5698">        newstr_p = new IRubyObject[]{this};</span>
<span class="fc" id="L5699">        encindex = EncodingUtils.strTranscode(context, args, newstr_p);</span>

<span class="fc bfc" id="L5701" title="All 2 branches covered.">        if (encindex == null) return this;</span>
<span class="fc bfc" id="L5702" title="All 2 branches covered.">        if (newstr_p[0] == this) {</span>
<span class="fc" id="L5703">            this.setEncoding(encindex);</span>
<span class="fc" id="L5704">            return this;</span>
        }
<span class="fc" id="L5706">        replace(newstr_p[0]);</span>
<span class="fc" id="L5707">        this.setEncoding(encindex);</span>
<span class="fc" id="L5708">        return this;</span>
    }

    @JRubyMethod
    public IRubyObject encode(ThreadContext context) {
<span class="fc" id="L5713">        return EncodingUtils.strEncode(context, this);</span>
    }

    @JRubyMethod
    public IRubyObject encode(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L5718">        return EncodingUtils.strEncode(context, this, arg);</span>
    }

    @JRubyMethod
    public IRubyObject encode(ThreadContext context, IRubyObject toEncoding, IRubyObject arg) {
<span class="fc" id="L5723">        return EncodingUtils.strEncode(context, this, toEncoding, arg);</span>
    }

    @JRubyMethod
    public IRubyObject encode(ThreadContext context, IRubyObject toEncoding,
            IRubyObject forcedEncoding, IRubyObject opts) {
<span class="fc" id="L5729">        return EncodingUtils.strEncode(context, this, toEncoding, forcedEncoding, opts);</span>
    }

    @JRubyMethod
    public IRubyObject force_encoding(ThreadContext context, IRubyObject enc) {
<span class="fc" id="L5734">        modify19();</span>
<span class="fc" id="L5735">        Encoding encoding = context.runtime.getEncodingService().getEncodingFromObject(enc);</span>
<span class="fc" id="L5736">        associateEncoding(encoding);</span>
<span class="fc" id="L5737">        clearCodeRange();</span>
<span class="fc" id="L5738">        return this;</span>
    }

    @JRubyMethod(name = &quot;valid_encoding?&quot;)
    public IRubyObject valid_encoding_p(ThreadContext context) {
<span class="fc bfc" id="L5743" title="All 2 branches covered.">        return context.runtime.newBoolean(scanForCodeRange() != CR_BROKEN);</span>
    }

    @JRubyMethod(name = &quot;ascii_only?&quot;)
    public IRubyObject ascii_only_p(ThreadContext context) {
<span class="fc bfc" id="L5748" title="All 2 branches covered.">        return context.runtime.newBoolean(scanForCodeRange() == CR_7BIT);</span>
    }

    @JRubyMethod
    public IRubyObject b(ThreadContext context) {
<span class="fc" id="L5753">        Encoding encoding = ASCIIEncoding.INSTANCE;</span>
<span class="fc" id="L5754">        RubyString dup = (RubyString)dup();</span>
<span class="fc" id="L5755">        dup.associateEncoding(encoding);</span>
<span class="fc" id="L5756">        dup.clearCodeRange();</span>
<span class="fc" id="L5757">        return dup;</span>
    }

    // MRI: str_scrub arity 0
    @JRubyMethod
    public IRubyObject scrub(ThreadContext context, Block block) {
<span class="fc" id="L5763">        return scrub(context, context.nil, block);</span>
    }

    // MRI: str_scrub arity 1
    @JRubyMethod
    public IRubyObject scrub(ThreadContext context, IRubyObject repl, Block block) {
<span class="fc" id="L5769">        IRubyObject newStr = strScrub(context, repl, block);</span>
<span class="fc bfc" id="L5770" title="All 2 branches covered.">        if (newStr.isNil()) return strDup(context.runtime);</span>
<span class="fc" id="L5771">        return newStr;</span>
    }

    /**
     * Mutator for internal string representation.
     *
     * @param value The new java.lang.String this RubyString should encapsulate
     * @deprecated
     */
    public void setValue(CharSequence value) {
<span class="nc" id="L5781">        view(ByteList.plain(value));</span>
<span class="nc" id="L5782">    }</span>

    public void setValue(ByteList value) {
<span class="fc" id="L5785">        view(value);</span>
<span class="fc" id="L5786">    }</span>

    public CharSequence getValue() {
<span class="nc" id="L5789">        return toString();</span>
    }

    public byte[] getBytes() {
<span class="fc" id="L5793">        return value.bytes();</span>
    }

    public ByteList getByteList() {
<span class="fc" id="L5797">        return value;</span>
    }

    /** used by ar-jdbc
     *
     */
    public String getUnicodeValue() {
<span class="fc" id="L5804">        return RubyEncoding.decodeUTF8(value.getUnsafeBytes(), value.getBegin(), value.getRealSize());</span>
    }

    public static ByteList encodeBytelist(CharSequence value, Encoding encoding) {

<span class="fc" id="L5809">        Charset charset = encoding.getCharset();</span>

        // if null charset, fall back on Java default charset
<span class="pc bpc" id="L5812" title="1 of 2 branches missed.">        if (charset == null) charset = Charset.defaultCharset();</span>

        byte[] bytes;
<span class="fc bfc" id="L5815" title="All 2 branches covered.">        if (charset == RubyEncoding.UTF8) {</span>
<span class="fc" id="L5816">            bytes = RubyEncoding.encodeUTF8(value);</span>
<span class="pc bpc" id="L5817" title="1 of 2 branches missed.">        } else if (charset == RubyEncoding.UTF16) {</span>
<span class="nc" id="L5818">            bytes = RubyEncoding.encodeUTF16(value);</span>
        } else {
<span class="fc" id="L5820">            bytes = RubyEncoding.encode(value, charset);</span>
        }

<span class="fc" id="L5823">        return new ByteList(bytes, encoding, false);</span>
    }

    @Override
    public Object toJava(Class target) {
<span class="pc bpc" id="L5828" title="1 of 2 branches missed.">        if (target.isAssignableFrom(String.class)) {</span>
<span class="fc" id="L5829">            return decodeString();</span>
<span class="nc bnc" id="L5830" title="All 2 branches missed.">        } else if (target.isAssignableFrom(ByteList.class)) {</span>
<span class="nc" id="L5831">            return value;</span>
        } else {
<span class="nc" id="L5833">            return super.toJava(target);</span>
        }
    }

    /**
     * Scrub the contents of this string, replacing invalid characters as appropriate.
     *
     * MRI: rb_str_scrub
     */
    public IRubyObject strScrub(ThreadContext context, IRubyObject repl, Block block) {
<span class="fc" id="L5843">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L5844">        int cr = getCodeRange();</span>
        Encoding enc;
        Encoding encidx;

<span class="pc bpc" id="L5848" title="2 of 4 branches missed.">        if (cr == CR_7BIT || cr == CR_VALID)</span>
<span class="nc" id="L5849">            return context.nil;</span>

<span class="fc" id="L5851">        enc = getEncoding();</span>
<span class="fc bfc" id="L5852" title="All 2 branches covered.">        if (!repl.isNil()) {</span>
<span class="fc" id="L5853">            repl = EncodingUtils.strCompatAndValid(context, repl, enc);</span>
        }

<span class="pc bpc" id="L5856" title="1 of 2 branches missed.">        if (enc.isDummy()) {</span>
<span class="nc" id="L5857">            return context.nil;</span>
        }
<span class="fc" id="L5859">        encidx = enc;</span>

<span class="pc bpc" id="L5861" title="1 of 2 branches missed.">        if (enc.isAsciiCompatible()) {</span>
<span class="fc" id="L5862">            byte[] pBytes = value.unsafeBytes();</span>
<span class="fc" id="L5863">            int p = value.begin();</span>
<span class="fc" id="L5864">            int e = p + value.getRealSize();</span>
<span class="fc" id="L5865">            int p1 = p;</span>
            byte[] repBytes;
            int rep;
            int replen;
            boolean rep7bit_p;
<span class="fc" id="L5870">            IRubyObject buf = context.nil;</span>
<span class="fc bfc" id="L5871" title="All 2 branches covered.">            if (block.isGiven()) {</span>
<span class="fc" id="L5872">                repBytes = null;</span>
<span class="fc" id="L5873">                rep = 0;</span>
<span class="fc" id="L5874">                replen = 0;</span>
<span class="fc" id="L5875">                rep7bit_p = false;</span>
            }
<span class="fc bfc" id="L5877" title="All 2 branches covered.">            else if (!repl.isNil()) {</span>
<span class="fc" id="L5878">                repBytes = ((RubyString)repl).value.unsafeBytes();</span>
<span class="fc" id="L5879">                rep = ((RubyString)repl).value.begin();</span>
<span class="fc" id="L5880">                replen = ((RubyString)repl).value.getRealSize();</span>
<span class="pc bpc" id="L5881" title="1 of 2 branches missed.">                rep7bit_p = (((RubyString)repl).getCodeRange() == CR_7BIT);</span>
            }
<span class="pc bpc" id="L5883" title="1 of 2 branches missed.">            else if (encidx == UTF8Encoding.INSTANCE) {</span>
<span class="fc" id="L5884">                repBytes = SCRUB_REPL_UTF8;</span>
<span class="fc" id="L5885">                rep = 0;</span>
<span class="fc" id="L5886">                replen = repBytes.length;</span>
<span class="fc" id="L5887">                rep7bit_p = false;</span>
            }
            else {
<span class="nc" id="L5890">                repBytes = SCRUB_REPL_ASCII;</span>
<span class="nc" id="L5891">                rep = 0;</span>
<span class="nc" id="L5892">                replen = repBytes.length;</span>
<span class="nc" id="L5893">                rep7bit_p = false;</span>
            }
<span class="fc" id="L5895">            cr = CR_7BIT;</span>

<span class="fc" id="L5897">            p = StringSupport.searchNonAscii(pBytes, p, e);</span>
<span class="fc bfc" id="L5898" title="All 2 branches covered.">            if (p == -1) {</span>
<span class="fc" id="L5899">                p = e;</span>
            }
<span class="fc bfc" id="L5901" title="All 2 branches covered.">            while (p &lt; e) {</span>
<span class="fc" id="L5902">                int ret = enc.length(pBytes, p, e);</span>
<span class="pc bpc" id="L5903" title="1 of 2 branches missed.">                if (MBCLEN_NEEDMORE_P(ret)) {</span>
<span class="nc" id="L5904">                    break;</span>
                }
<span class="fc bfc" id="L5906" title="All 2 branches covered.">                else if (MBCLEN_CHARFOUND_P(ret)) {</span>
<span class="fc" id="L5907">                    cr = CR_VALID;</span>
<span class="fc" id="L5908">                    p += MBCLEN_CHARFOUND_LEN(ret);</span>
                }
<span class="pc bpc" id="L5910" title="1 of 2 branches missed.">                else if (MBCLEN_INVALID_P(ret)) {</span>
                    /*
                     * p1~p: valid ascii/multibyte chars
                     * p ~e: invalid bytes + unknown bytes
                     */
<span class="fc" id="L5915">                    int clen = enc.maxLength();</span>
<span class="pc bpc" id="L5916" title="1 of 2 branches missed.">                    if (buf.isNil()) buf = RubyString.newStringLight(runtime, value.getRealSize());</span>
<span class="pc bpc" id="L5917" title="1 of 2 branches missed.">                    if (p &gt; p1) {</span>
<span class="fc" id="L5918">                        ((RubyString)buf).cat(pBytes, p1, p - p1);</span>
                    }

<span class="pc bpc" id="L5921" title="1 of 2 branches missed.">                    if (e - p &lt; clen) clen = e - p;</span>
<span class="pc bpc" id="L5922" title="1 of 2 branches missed.">                    if (clen &lt;= 2) {</span>
<span class="fc" id="L5923">                        clen = 1;</span>
                    }
                    else {
<span class="nc" id="L5926">                        int q = p;</span>
<span class="nc" id="L5927">                        clen--;</span>
<span class="nc bnc" id="L5928" title="All 2 branches missed.">                        for (; clen &gt; 1; clen--) {</span>
<span class="nc" id="L5929">                            ret = enc.length(pBytes, q, q + clen);</span>
<span class="nc bnc" id="L5930" title="All 2 branches missed.">                            if (MBCLEN_NEEDMORE_P(ret)) break;</span>
<span class="nc bnc" id="L5931" title="All 2 branches missed.">                            if (MBCLEN_INVALID_P(ret)) continue;</span>
                        }
                    }
<span class="pc bpc" id="L5934" title="1 of 2 branches missed.">                    if (repBytes != null) {</span>
<span class="fc" id="L5935">                        ((RubyString)buf).cat(repBytes, rep, replen);</span>
<span class="fc bfc" id="L5936" title="All 2 branches covered.">                        if (!rep7bit_p) cr = CR_VALID;</span>
                    }
                    else {
<span class="nc" id="L5939">                        repl = block.yieldSpecific(context, RubyString.newString(runtime, pBytes, p, clen, enc));</span>
<span class="nc" id="L5940">                        repl = EncodingUtils.strCompatAndValid(context, repl, enc);</span>
<span class="nc" id="L5941">                        ((RubyString)buf).cat((RubyString)repl);</span>
<span class="nc bnc" id="L5942" title="All 2 branches missed.">                        if (((RubyString)repl).getCodeRange() == CR_VALID)</span>
<span class="nc" id="L5943">                            cr = CR_VALID;</span>
                    }
<span class="fc" id="L5945">                    p += clen;</span>
<span class="fc" id="L5946">                    p1 = p;</span>
<span class="fc" id="L5947">                    p = StringSupport.searchNonAscii(pBytes, p, e);</span>
<span class="pc bpc" id="L5948" title="1 of 2 branches missed.">                    if (p == -1) {</span>
<span class="fc" id="L5949">                        p = e;</span>
<span class="fc" id="L5950">                        break;</span>
                    }
                }
<span class="fc" id="L5953">            }</span>
<span class="fc bfc" id="L5954" title="All 2 branches covered.">            if (buf.isNil()) {</span>
<span class="pc bpc" id="L5955" title="1 of 2 branches missed.">                if (p == e) {</span>
<span class="fc" id="L5956">                    setCodeRange(cr);</span>
<span class="fc" id="L5957">                    return context.nil;</span>
                }
<span class="nc" id="L5959">                buf = RubyString.newStringLight(runtime, value.getRealSize());</span>
            }
<span class="pc bpc" id="L5961" title="1 of 2 branches missed.">            if (p1 &lt; p) {</span>
<span class="nc" id="L5962">                ((RubyString)buf).cat(pBytes, p1, p - p1);</span>
            }
<span class="pc bpc" id="L5964" title="1 of 2 branches missed.">            if (p &lt; e) {</span>
<span class="nc bnc" id="L5965" title="All 2 branches missed.">                if (repBytes != null) {</span>
<span class="nc" id="L5966">                    ((RubyString)buf).cat(repBytes, rep, replen);</span>
<span class="nc bnc" id="L5967" title="All 2 branches missed.">                    if (!rep7bit_p) cr = CR_VALID;</span>
                }
                else {
<span class="nc" id="L5970">                    repl = block.yieldSpecific(context, RubyString.newString(runtime, pBytes, p, e - p, enc));</span>
<span class="nc" id="L5971">                    repl = EncodingUtils.strCompatAndValid(context, repl, enc);</span>
<span class="nc" id="L5972">                    ((RubyString)buf).cat((RubyString)repl);</span>
<span class="nc bnc" id="L5973" title="All 2 branches missed.">                    if (((RubyString)repl).getCodeRange() == CR_VALID)</span>
<span class="nc" id="L5974">                        cr = CR_VALID;</span>
                }
            }
<span class="fc" id="L5977">            ((RubyString)buf).setEncodingAndCodeRange(enc, cr);</span>
<span class="fc" id="L5978">            return buf;</span>
        }
        else {
	        /* ASCII incompatible */
<span class="nc" id="L5982">            byte[] pBytes = value.unsafeBytes();</span>
<span class="nc" id="L5983">            int p = value.begin();</span>
<span class="nc" id="L5984">            int e = p + value.getRealSize();</span>
<span class="nc" id="L5985">            int p1 = p;</span>
<span class="nc" id="L5986">            IRubyObject buf = context.nil;</span>
            byte[] repBytes;
            int rep;
            int replen;
<span class="nc" id="L5990">            int mbminlen = enc.minLength();</span>
<span class="nc bnc" id="L5991" title="All 2 branches missed.">            if (!repl.isNil()) {</span>
<span class="nc" id="L5992">                repBytes = ((RubyString)repl).value.unsafeBytes();</span>
<span class="nc" id="L5993">                rep = ((RubyString)repl).value.begin();</span>
<span class="nc" id="L5994">                replen = ((RubyString)repl).value.getRealSize();</span>
            }
<span class="nc bnc" id="L5996" title="All 2 branches missed.">            else if (encidx == UTF16BEEncoding.INSTANCE) {</span>
<span class="nc" id="L5997">                repBytes = SCRUB_REPL_UTF16BE;</span>
<span class="nc" id="L5998">                rep = 0;</span>
<span class="nc" id="L5999">                replen = repBytes.length;</span>
            }
<span class="nc bnc" id="L6001" title="All 2 branches missed.">            else if (encidx == UTF16LEEncoding.INSTANCE) {</span>
<span class="nc" id="L6002">                repBytes = SCRUB_REPL_UTF16LE;</span>
<span class="nc" id="L6003">                rep = 0;</span>
<span class="nc" id="L6004">                replen = repBytes.length;</span>
            }
<span class="nc bnc" id="L6006" title="All 2 branches missed.">            else if (encidx == UTF32BEEncoding.INSTANCE) {</span>
<span class="nc" id="L6007">                repBytes = SCRUB_REPL_UTF32BE;</span>
<span class="nc" id="L6008">                rep = 0;</span>
<span class="nc" id="L6009">                replen = repBytes.length;</span>
            }
<span class="nc bnc" id="L6011" title="All 2 branches missed.">            else if (encidx == UTF32LEEncoding.INSTANCE) {</span>
<span class="nc" id="L6012">                repBytes = SCRUB_REPL_UTF32LE;</span>
<span class="nc" id="L6013">                rep = 0;</span>
<span class="nc" id="L6014">                replen = repBytes.length;</span>
            }
            else {
<span class="nc" id="L6017">                repBytes = SCRUB_REPL_ASCII;</span>
<span class="nc" id="L6018">                rep = 0;</span>
<span class="nc" id="L6019">                replen = repBytes.length;</span>
            }

<span class="nc bnc" id="L6022" title="All 2 branches missed.">            while (p &lt; e) {</span>
<span class="nc" id="L6023">                int ret = enc.length(pBytes, p, e);</span>
<span class="nc bnc" id="L6024" title="All 2 branches missed.">                if (MBCLEN_NEEDMORE_P(ret)) {</span>
<span class="nc" id="L6025">                    break;</span>
                }
<span class="nc bnc" id="L6027" title="All 2 branches missed.">                else if (MBCLEN_CHARFOUND_P(ret)) {</span>
<span class="nc" id="L6028">                    p += MBCLEN_CHARFOUND_LEN(ret);</span>
                }
<span class="nc bnc" id="L6030" title="All 2 branches missed.">                else if (MBCLEN_INVALID_P(ret)) {</span>
<span class="nc" id="L6031">                    int q = p;</span>
<span class="nc" id="L6032">                    int clen = enc.maxLength();</span>
<span class="nc bnc" id="L6033" title="All 2 branches missed.">                    if (buf.isNil()) buf = RubyString.newStringLight(runtime, value.getRealSize());</span>
<span class="nc bnc" id="L6034" title="All 2 branches missed.">                    if (p &gt; p1) ((RubyString)buf).cat(pBytes, p1, p - p1);</span>

<span class="nc bnc" id="L6036" title="All 2 branches missed.">                    if (e - p &lt; clen) clen = e - p;</span>
<span class="nc bnc" id="L6037" title="All 2 branches missed.">                    if (clen &lt;= mbminlen * 2) {</span>
<span class="nc" id="L6038">                        clen = mbminlen;</span>
                    }
                    else {
<span class="nc" id="L6041">                        clen -= mbminlen;</span>
<span class="nc bnc" id="L6042" title="All 2 branches missed.">                        for (; clen &gt; mbminlen; clen-=mbminlen) {</span>
<span class="nc" id="L6043">                            ret = enc.length(pBytes, q, q + clen);</span>
<span class="nc bnc" id="L6044" title="All 2 branches missed.">                            if (MBCLEN_NEEDMORE_P(ret)) break;</span>
<span class="nc bnc" id="L6045" title="All 2 branches missed.">                            if (MBCLEN_INVALID_P(ret)) continue;</span>
                        }
                    }
<span class="nc bnc" id="L6048" title="All 2 branches missed.">                    if (repBytes != null) {</span>
<span class="nc" id="L6049">                        ((RubyString)buf).cat(repBytes, rep, replen);</span>
                    }
                    else {
<span class="nc" id="L6052">                        repl = block.yieldSpecific(context, RubyString.newString(runtime, pBytes, p, e-p, enc));</span>
<span class="nc" id="L6053">                        repl = EncodingUtils.strCompatAndValid(context, repl, enc);</span>
<span class="nc" id="L6054">                        ((RubyString)buf).cat((RubyString)repl);</span>
                    }
<span class="nc" id="L6056">                    p += clen;</span>
<span class="nc" id="L6057">                    p1 = p;</span>
                }
<span class="nc" id="L6059">            }</span>
<span class="nc bnc" id="L6060" title="All 2 branches missed.">            if (buf.isNil()) {</span>
<span class="nc bnc" id="L6061" title="All 2 branches missed.">                if (p == e) {</span>
<span class="nc" id="L6062">                    setCodeRange(CR_VALID);</span>
<span class="nc" id="L6063">                    return context.nil;</span>
                }
<span class="nc" id="L6065">                buf = RubyString.newStringLight(runtime, value.getRealSize());</span>
            }
<span class="nc bnc" id="L6067" title="All 2 branches missed.">            if (p1 &lt; p) {</span>
<span class="nc" id="L6068">                ((RubyString)buf).cat(pBytes, p1, p - p1);</span>
            }
<span class="nc bnc" id="L6070" title="All 2 branches missed.">            if (p &lt; e) {</span>
<span class="nc bnc" id="L6071" title="All 2 branches missed.">                if (repBytes != null) {</span>
<span class="nc" id="L6072">                    ((RubyString)buf).cat(repBytes, rep, replen);</span>
                }
                else {
<span class="nc" id="L6075">                    repl = block.yieldSpecific(context, RubyString.newString(runtime, pBytes, p, e - p, enc));</span>
<span class="nc" id="L6076">                    repl = EncodingUtils.strCompatAndValid(context, repl, enc);</span>
<span class="nc" id="L6077">                    ((RubyString)buf).cat((RubyString)repl);</span>
                }
            }
<span class="nc" id="L6080">            ((RubyString)buf).setEncodingAndCodeRange(enc, CR_VALID);</span>
<span class="nc" id="L6081">            return buf;</span>
        }
    }

    @Deprecated
    public final RubyString strDup() {
<span class="nc" id="L6087">        return strDup(getRuntime(), getMetaClass().getRealClass());</span>
    }

    @Deprecated
    final RubyString strDup(RubyClass clazz) {
<span class="nc" id="L6092">        return strDup(getRuntime(), getMetaClass());</span>
    }

    @Deprecated
    public final void modify19(int length) {
<span class="fc" id="L6097">        modifyExpand(length);</span>
<span class="fc" id="L6098">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>