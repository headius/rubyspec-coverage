<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RubyComplex.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby</a> &gt; <span class="el_source">RubyComplex.java</span></div><h1>RubyComplex.java</h1><pre class="source lang-java linenums">/***** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby;

import static org.jruby.util.Numeric.f_abs;
import static org.jruby.util.Numeric.f_abs2;
import static org.jruby.util.Numeric.f_add;
import static org.jruby.util.Numeric.f_arg;
import static org.jruby.util.Numeric.f_conjugate;
import static org.jruby.util.Numeric.f_denominator;
import static org.jruby.util.Numeric.f_div;
import static org.jruby.util.Numeric.f_divmod;
import static org.jruby.util.Numeric.f_equal;
import static org.jruby.util.Numeric.f_exact_p;
import static org.jruby.util.Numeric.f_expt;
import static org.jruby.util.Numeric.f_gt_p;
import static org.jruby.util.Numeric.f_inspect;
import static org.jruby.util.Numeric.f_lcm;
import static org.jruby.util.Numeric.f_mul;
import static org.jruby.util.Numeric.f_negate;
import static org.jruby.util.Numeric.f_negative_p;
import static org.jruby.util.Numeric.f_numerator;
import static org.jruby.util.Numeric.f_one_p;
import static org.jruby.util.Numeric.f_polar;
import static org.jruby.util.Numeric.f_quo;
import static org.jruby.util.Numeric.f_real_p;
import static org.jruby.util.Numeric.f_sub;
import static org.jruby.util.Numeric.f_to_f;
import static org.jruby.util.Numeric.f_to_i;
import static org.jruby.util.Numeric.f_to_r;
import static org.jruby.util.Numeric.f_to_s;
import static org.jruby.util.Numeric.f_xor;
import static org.jruby.util.Numeric.f_zero_p;
import static org.jruby.util.Numeric.k_exact_p;
import static org.jruby.util.Numeric.k_inexact_p;

import org.jcodings.specific.ASCIIEncoding;
import org.jruby.anno.JRubyClass;
import org.jruby.anno.JRubyMethod;
import org.jruby.runtime.Arity;
import org.jruby.runtime.Block;
import org.jruby.runtime.ClassIndex;
import org.jruby.runtime.ObjectAllocator;
import org.jruby.runtime.ThreadContext;
import org.jruby.runtime.Visibility;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.util.ByteList;
import org.jruby.util.Numeric;

import static org.jruby.runtime.Helpers.invokedynamic;
import static org.jruby.runtime.invokedynamic.MethodNames.HASH;

/**
 *  1.9 complex.c as of revision: 20011
 */

<span class="pc bpc" id="L80" title="1 of 2 branches missed.">@JRubyClass(name = &quot;Complex&quot;, parent = &quot;Numeric&quot;)</span>
public class RubyComplex extends RubyNumeric {

    public static RubyClass createComplexClass(Ruby runtime) {
<span class="fc" id="L84">        RubyClass complexc = runtime.defineClass(&quot;Complex&quot;, runtime.getNumeric(), COMPLEX_ALLOCATOR);</span>
<span class="fc" id="L85">        runtime.setComplex(complexc);</span>

<span class="fc" id="L87">        complexc.setClassIndex(ClassIndex.COMPLEX);</span>
<span class="fc" id="L88">        complexc.setReifiedClass(RubyComplex.class);</span>
        
<span class="fc" id="L90">        complexc.kindOf = new RubyModule.JavaClassKindOf(RubyComplex.class);</span>

<span class="fc" id="L92">        complexc.defineAnnotatedMethods(RubyComplex.class);</span>

<span class="fc" id="L94">        complexc.getSingletonClass().undefineMethod(&quot;allocate&quot;);</span>
<span class="fc" id="L95">        complexc.getSingletonClass().undefineMethod(&quot;new&quot;);</span>

<span class="fc" id="L97">        String[]undefined = {&quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;&lt;=&gt;&quot;, &quot;&gt;&quot;, &quot;&gt;=&quot;, &quot;between?&quot;, &quot;divmod&quot;,</span>
                             &quot;floor&quot;, &quot;ceil&quot;, &quot;modulo&quot;, &quot;round&quot;, &quot;step&quot;, &quot;truncate&quot;};

<span class="fc bfc" id="L100" title="All 2 branches covered.">        for (String undef : undefined) {</span>
<span class="fc" id="L101">            complexc.undefineMethod(undef);</span>
        }

<span class="fc" id="L104">        complexc.defineConstant(&quot;I&quot;, RubyComplex.newComplexConvert(runtime.getCurrentContext(), RubyFixnum.zero(runtime), RubyFixnum.one(runtime)));</span>

<span class="fc" id="L106">        return complexc;</span>
    }

<span class="fc" id="L109">    private static ObjectAllocator COMPLEX_ALLOCATOR = new ObjectAllocator() {</span>
        @Override
        public IRubyObject allocate(Ruby runtime, RubyClass klass) {
<span class="fc" id="L112">            RubyFixnum zero = RubyFixnum.zero(runtime);</span>
<span class="fc" id="L113">            return new RubyComplex(runtime, klass, zero, zero);</span>
        }
    };

    /** internal
     * 
     */
    private RubyComplex(Ruby runtime, IRubyObject clazz, IRubyObject real, IRubyObject image) {
<span class="fc" id="L121">        super(runtime, (RubyClass)clazz);</span>
<span class="fc" id="L122">        this.real = real;</span>
<span class="fc" id="L123">        this.image = image;</span>
<span class="fc" id="L124">    }</span>

    /** rb_complex_raw
     * 
     */
    public static RubyComplex newComplexRaw(Ruby runtime, IRubyObject x, IRubyObject y) {
<span class="fc" id="L130">        return new RubyComplex(runtime, runtime.getComplex(), x, y);</span>
    }

    /** rb_complex_raw1
     * 
     */
    public static RubyComplex newComplexRaw(Ruby runtime, IRubyObject x) {
<span class="fc" id="L137">        return new RubyComplex(runtime, runtime.getComplex(), x, RubyFixnum.zero(runtime));</span>
    }

    /** rb_complex_new1
     * 
     */
    public static IRubyObject newComplexCanonicalize(ThreadContext context, IRubyObject x) {
<span class="fc" id="L144">        return newComplexCanonicalize(context, x, RubyFixnum.zero(context.runtime));</span>
    }
    
    /** rb_complex_new
     * 
     */
    public static IRubyObject newComplexCanonicalize(ThreadContext context, IRubyObject x, IRubyObject y) {
<span class="fc" id="L151">        return canonicalizeInternal(context, context.runtime.getComplex(), x, y);</span>
    }

    /** rb_complex_polar
     * 
     */
    static IRubyObject newComplexPolar(ThreadContext context, IRubyObject x, IRubyObject y) {
<span class="nc" id="L158">        return f_complex_polar(context, context.runtime.getComplex(), x, y);</span>
    }

    /** f_complex_new1
     * 
     */
    static IRubyObject newComplex(ThreadContext context, IRubyObject clazz, IRubyObject x) {
<span class="nc" id="L165">        return newComplex(context, clazz, x, RubyFixnum.zero(context.runtime));</span>
    }

    /** f_complex_new2
     * 
     */
    static IRubyObject newComplex(ThreadContext context, IRubyObject clazz, IRubyObject x, IRubyObject y) {
<span class="pc bpc" id="L172" title="3 of 4 branches missed.">        assert !(x instanceof RubyComplex);</span>
<span class="fc" id="L173">        return canonicalizeInternal(context, clazz, x, y);</span>
    }
    
    /** f_complex_new_bang2
     * 
     */
    static RubyComplex newComplexBang(ThreadContext context, IRubyObject clazz, IRubyObject x, IRubyObject y) {
// FIXME: what should these really be? Numeric?       assert x instanceof RubyComplex &amp;&amp; y instanceof RubyComplex;
<span class="fc" id="L181">        return new RubyComplex(context.runtime, clazz, x, y);</span>
    }

    /** f_complex_new_bang1
     * 
     */
    public static RubyComplex newComplexBang(ThreadContext context, IRubyObject clazz, IRubyObject x) {
// FIXME: what should this really be?       assert x instanceof RubyComplex;
<span class="fc" id="L189">        return newComplexBang(context, clazz, x, RubyFixnum.zero(context.runtime));</span>
    }

    private IRubyObject real;
    private IRubyObject image;
    
    IRubyObject getImage() {
<span class="fc" id="L196">        return image;</span>
    }

    IRubyObject getReal() {
<span class="fc" id="L200">        return real;</span>
    }

    /** m_cos
     * 
     */
    private static IRubyObject m_cos(ThreadContext context, IRubyObject x) {
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (f_real_p(context, x).isTrue()) return RubyMath.cos(context, x, x);</span>
<span class="nc" id="L208">        RubyComplex complex = (RubyComplex)x;</span>
<span class="nc" id="L209">        return newComplex(context, context.runtime.getComplex(),</span>
<span class="nc" id="L210">                          f_mul(context, RubyMath.cos(context, x, complex.real), RubyMath.cosh(context, x, complex.image)),</span>
<span class="nc" id="L211">                          f_mul(context, f_negate(context, RubyMath.sin(context, x, complex.real)), RubyMath.sinh(context, x, complex.image)));</span>
    }

    /** m_sin
     * 
     */
    private static IRubyObject m_sin(ThreadContext context, IRubyObject x) {
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">        if (f_real_p(context, x).isTrue()) return RubyMath.sin(context, x, x);</span>
<span class="nc" id="L219">        RubyComplex complex = (RubyComplex)x;</span>
<span class="nc" id="L220">        return newComplex(context, context.runtime.getComplex(),</span>
<span class="nc" id="L221">                          f_mul(context, RubyMath.sin(context, x, complex.real), RubyMath.cosh(context, x, complex.image)),</span>
<span class="nc" id="L222">                          f_mul(context, RubyMath.cos(context, x, complex.real), RubyMath.sinh(context, x, complex.image)));</span>
    }    
    
    /** m_sqrt
     * 
     */
    private static IRubyObject m_sqrt(ThreadContext context, IRubyObject x) {
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (f_real_p(context, x).isTrue()) {</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (!f_negative_p(context, x)) return RubyMath.sqrt(context, x, x);</span>
<span class="nc" id="L231">            return newComplex(context, context.runtime.getComplex(),</span>
<span class="nc" id="L232">                              RubyFixnum.zero(context.runtime),</span>
<span class="nc" id="L233">                              RubyMath.sqrt(context, x, f_negate(context, x)));</span>
        } else {
<span class="nc" id="L235">            RubyComplex complex = (RubyComplex)x;</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">            if (f_negative_p(context, complex.image)) {</span>
<span class="nc" id="L237">                return f_conjugate(context, m_sqrt(context, f_conjugate(context, x)));</span>
            } else {
<span class="nc" id="L239">                IRubyObject a = f_abs(context, x);</span>
<span class="nc" id="L240">                IRubyObject two = RubyFixnum.two(context.runtime);</span>
<span class="nc" id="L241">                return newComplex(context, context.runtime.getComplex(),</span>
<span class="nc" id="L242">                                  RubyMath.sqrt(context, x, f_div(context, f_add(context, a, complex.real), two)),</span>
<span class="nc" id="L243">                                  RubyMath.sqrt(context, x, f_div(context, f_sub(context, a, complex.real), two)));</span>
            }
        }
    }

    /** nucomp_s_new_bang
     *
     */
    @Deprecated
    public static IRubyObject newInstanceBang(ThreadContext context, IRubyObject recv, IRubyObject[]args) {
<span class="nc bnc" id="L253" title="All 3 branches missed.">        switch (args.length) {</span>
<span class="nc" id="L254">        case 1: return newInstanceBang(context, recv, args[0]);</span>
<span class="nc" id="L255">        case 2: return newInstanceBang(context, recv, args[0], args[1]);</span>
        }
<span class="nc" id="L257">        Arity.raiseArgumentError(context.runtime, args.length, 1, 1);</span>
<span class="nc" id="L258">        return null;</span>
    }

    @JRubyMethod(name = &quot;new!&quot;, meta = true, visibility = Visibility.PRIVATE)
    public static IRubyObject newInstanceBang(ThreadContext context, IRubyObject recv, IRubyObject real) {
<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (!(real instanceof RubyNumeric)) real = f_to_i(context, real);</span>
<span class="nc" id="L264">        return new RubyComplex(context.runtime, recv, real, RubyFixnum.zero(context.runtime));</span>
    }

    @JRubyMethod(name = &quot;new!&quot;, meta = true, visibility = Visibility.PRIVATE)
    public static IRubyObject newInstanceBang(ThreadContext context, IRubyObject recv, IRubyObject real, IRubyObject image) {
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (!(real instanceof RubyNumeric)) real = f_to_i(context, real);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (!(image instanceof RubyNumeric)) image = f_to_i(context, image);</span>
<span class="nc" id="L271">        return new RubyComplex(context.runtime, recv, real, image);</span>
    }

    /** nucomp_canonicalization
     * 
     */
<span class="fc" id="L277">    private static boolean canonicalization = false;</span>
    public static void setCanonicalization(boolean canonical) {
<span class="nc" id="L279">        canonicalization = canonical;</span>
<span class="nc" id="L280">    }</span>

    /** nucomp_real_check (might go to bimorphic)
     * 
     */
    private static void realCheck(ThreadContext context, IRubyObject num) {
<span class="pc bfc" id="L286" title="All 2 branches covered.">        switch (num.getMetaClass().getClassIndex()) {</span>
        case FIXNUM:
        case BIGNUM:
        case FLOAT:
        case RATIONAL:
<span class="fc" id="L291">            break;</span>
        default:
<span class="fc bfc" id="L293" title="All 4 branches covered.">             if (!(num instanceof RubyNumeric ) || !f_real_p(context, num).isTrue()) {</span>
<span class="fc" id="L294">                 throw context.runtime.newTypeError(&quot;not a real&quot;);</span>
             }
        }
<span class="fc" id="L297">    }</span>

    /** nucomp_s_canonicalize_internal
     * 
     */
    private static final boolean CL_CANON = Numeric.CANON;
    private static IRubyObject canonicalizeInternal(ThreadContext context, IRubyObject clazz, IRubyObject real, IRubyObject image) {
        if (Numeric.CANON) {
<span class="fc bfc" id="L305" title="All 2 branches covered.">            if (f_zero_p(context, image) &amp;&amp;</span>
<span class="pc bpc" id="L306" title="1 of 4 branches missed.">                    (!CL_CANON || k_exact_p(image)) &amp;&amp;</span>
                    canonicalization)
<span class="nc" id="L308">                    return real;</span>
        }
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        if (f_real_p(context, real).isTrue() &amp;&amp;</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">                   f_real_p(context, image).isTrue()) {</span>
<span class="fc" id="L312">            return new RubyComplex(context.runtime, clazz, real, image);</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">        } else if (f_real_p(context, real).isTrue()) {</span>
<span class="nc" id="L314">            RubyComplex complex = (RubyComplex)image;</span>
<span class="nc" id="L315">            return new RubyComplex(context.runtime, clazz,</span>
<span class="nc" id="L316">                                   f_sub(context, real, complex.image),</span>
<span class="nc" id="L317">                                   f_add(context, RubyFixnum.zero(context.runtime), complex.real));</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">        } else if (f_real_p(context, image).isTrue()) {</span>
<span class="nc" id="L319">            RubyComplex complex = (RubyComplex)real;</span>
<span class="nc" id="L320">            return new RubyComplex(context.runtime, clazz,</span>
                                   complex.real,
<span class="nc" id="L322">                                   f_add(context, complex.image, image));</span>
        } else {
<span class="nc" id="L324">            RubyComplex complex1 = (RubyComplex)real;</span>
<span class="nc" id="L325">            RubyComplex complex2 = (RubyComplex)image;</span>
<span class="nc" id="L326">            return new RubyComplex(context.runtime, clazz,</span>
<span class="nc" id="L327">                                   f_sub(context, complex1.real, complex2.image),</span>
<span class="nc" id="L328">                                   f_add(context, complex1.image, complex2.real));</span>
        }
    }
    
    /** nucomp_s_new
     * 
     */
    @Deprecated
    public static IRubyObject newInstance(ThreadContext context, IRubyObject recv, IRubyObject[]args) {
<span class="nc bnc" id="L337" title="All 3 branches missed.">        switch (args.length) {</span>
<span class="nc" id="L338">        case 1: return newInstance(context, recv, args[0]);</span>
<span class="nc" id="L339">        case 2: return newInstance(context, recv, args[0], args[1]);</span>
        }
<span class="nc" id="L341">        Arity.raiseArgumentError(context.runtime, args.length, 1, 1);</span>
<span class="nc" id="L342">        return null;</span>
    }

    // @JRubyMethod(name = &quot;new&quot;, meta = true, visibility = Visibility.PRIVATE)
    public static IRubyObject newInstanceNew(ThreadContext context, IRubyObject recv, IRubyObject real) {
<span class="nc" id="L347">        return newInstance(context, recv, real);</span>
    }

    @JRubyMethod(name = {&quot;rect&quot;, &quot;rectangular&quot;}, meta = true)
    public static IRubyObject newInstance(ThreadContext context, IRubyObject recv, IRubyObject real) {
<span class="fc" id="L352">        realCheck(context, real);</span>
<span class="fc" id="L353">        return canonicalizeInternal(context, recv, real, RubyFixnum.zero(context.runtime));</span>
    }

    // @JRubyMethod(name = &quot;new&quot;, meta = true, visibility = Visibility.PRIVATE)
    public static IRubyObject newInstanceNew(ThreadContext context, IRubyObject recv, IRubyObject real, IRubyObject image) {
<span class="nc" id="L358">        return newInstance(context, recv, real, image);</span>
    }

    @JRubyMethod(name = {&quot;rect&quot;, &quot;rectangular&quot;}, meta = true)
    public static IRubyObject newInstance(ThreadContext context, IRubyObject recv, IRubyObject real, IRubyObject image) {
<span class="fc" id="L363">        realCheck(context, real);</span>
<span class="fc" id="L364">        realCheck(context, image);</span>
<span class="fc" id="L365">        return canonicalizeInternal(context, recv, real, image);</span>
    }

    /** f_complex_polar
     * 
     */
    private static IRubyObject f_complex_polar(ThreadContext context, IRubyObject clazz, IRubyObject x, IRubyObject y) {
<span class="pc bpc" id="L372" title="5 of 6 branches missed.">        assert !(x instanceof RubyComplex) &amp;&amp; !(y instanceof RubyComplex);</span>
<span class="fc" id="L373">        return canonicalizeInternal(context, clazz,</span>
<span class="fc" id="L374">                                             f_mul(context, x, m_cos(context, y)),</span>
<span class="fc" id="L375">                                             f_mul(context, x, m_sin(context, y)));</span>
    }

    /** nucomp_s_polar
     * 
     */
    public static IRubyObject polar(ThreadContext context, IRubyObject clazz, IRubyObject abs, IRubyObject arg) {
<span class="nc" id="L382">        return polar19(context, clazz, new IRubyObject[]{abs, arg});</span>
    }

    /** nucomp_s_polar
     *
     */
    @JRubyMethod(name = &quot;polar&quot;, meta = true, required = 1, optional = 1)
    public static IRubyObject polar19(ThreadContext context, IRubyObject clazz, IRubyObject[] args) {
<span class="fc" id="L390">        IRubyObject abs = args[0];</span>
        IRubyObject arg;
<span class="fc bfc" id="L392" title="All 2 branches covered.">        if (args.length &lt; 2) {</span>
<span class="fc" id="L393">            arg = RubyFixnum.zero(context.runtime);</span>
        } else {
<span class="fc" id="L395">            arg = args[1];</span>
        }
<span class="fc" id="L397">        realCheck(context, abs);</span>
<span class="fc" id="L398">        realCheck(context, arg);</span>
<span class="fc" id="L399">        return f_complex_polar(context, clazz, abs, arg);</span>
    }

    /** rb_Complex1
     * 
     */
    public static IRubyObject newComplexConvert(ThreadContext context, IRubyObject x) {
<span class="nc" id="L406">        return newComplexConvert(context, x, RubyFixnum.zero(context.runtime));</span>
    }

    /** rb_Complex/rb_Complex2
     * 
     */
    public static IRubyObject newComplexConvert(ThreadContext context, IRubyObject x, IRubyObject y) {
<span class="fc" id="L413">        return convert(context, context.runtime.getComplex(), x, y);</span>
    }

    @Deprecated
    public static IRubyObject convert(ThreadContext context, IRubyObject clazz, IRubyObject[]args) {
<span class="nc bnc" id="L418" title="All 3 branches missed.">        switch (args.length) {</span>
<span class="nc" id="L419">        case 1: return convert(context, clazz, args[0]);        </span>
<span class="nc" id="L420">        case 2: return convert(context, clazz, args[0], args[1]);</span>
        }
<span class="nc" id="L422">        Arity.raiseArgumentError(context.runtime, args.length, 1, 1);</span>
<span class="nc" id="L423">        return null;</span>
    }

    /** nucomp_s_convert
     * 
     */
    @JRubyMethod(name = &quot;convert&quot;, meta = true, visibility = Visibility.PRIVATE)
    public static IRubyObject convert(ThreadContext context, IRubyObject recv, IRubyObject a1) {
<span class="fc" id="L431">        return convertCommon(context, recv, a1, context.runtime.getNil());</span>
    }

    /** nucomp_s_convert
     * 
     */
    @JRubyMethod(name = &quot;convert&quot;, meta = true, visibility = Visibility.PRIVATE)
    public static IRubyObject convert(ThreadContext context, IRubyObject recv, IRubyObject a1, IRubyObject a2) {
<span class="fc" id="L439">        return convertCommon(context, recv, a1, a2);</span>
    }
    
    private static IRubyObject convertCommon(ThreadContext context, IRubyObject recv, IRubyObject a1, IRubyObject a2) {
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">        if (a1 instanceof RubyString) a1 = str_to_c_strict(context, a1);</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">        if (a2 instanceof RubyString) a2 = str_to_c_strict(context, a2);</span>

<span class="fc bfc" id="L446" title="All 2 branches covered.">        if (a1 instanceof RubyComplex) {</span>
<span class="fc" id="L447">            RubyComplex a1Complex = (RubyComplex)a1;</span>
<span class="pc bpc" id="L448" title="2 of 4 branches missed.">            if (k_exact_p(a1Complex.image) &amp;&amp; f_zero_p(context, a1Complex.image)) {</span>
<span class="nc" id="L449">                a1 = a1Complex.real;</span>
            }
        }

<span class="fc bfc" id="L453" title="All 2 branches covered.">        if (a2 instanceof RubyComplex) {</span>
<span class="fc" id="L454">            RubyComplex a2Complex = (RubyComplex)a2;</span>
<span class="pc bpc" id="L455" title="1 of 4 branches missed.">            if (k_exact_p(a2Complex.image) &amp;&amp; f_zero_p(context, a2Complex.image)) {</span>
<span class="nc" id="L456">                a2 = a2Complex.real;</span>
            }
        }

<span class="fc bfc" id="L460" title="All 2 branches covered.">        if (a1 instanceof RubyComplex) {</span>
<span class="pc bpc" id="L461" title="2 of 6 branches missed.">            if (a2.isNil() || (k_exact_p(a2) &amp;&amp; f_zero_p(context, a2))) return a1;</span>
        }

<span class="fc bfc" id="L464" title="All 2 branches covered.">        if (a2.isNil()) {</span>
<span class="pc bpc" id="L465" title="1 of 4 branches missed.">            if (a1 instanceof RubyNumeric &amp;&amp; !f_real_p(context, a1).isTrue()) return a1;</span>
<span class="fc" id="L466">            return newInstance(context, recv, a1);</span>
        } else {
<span class="fc bfc" id="L468" title="All 4 branches covered.">            if (a1 instanceof RubyNumeric &amp;&amp; a2 instanceof RubyNumeric &amp;&amp;</span>
<span class="fc bfc" id="L469" title="All 4 branches covered.">                (!f_real_p(context, a1).isTrue() || !f_real_p(context, a2).isTrue())) {</span>
<span class="fc" id="L470">                Ruby runtime = context.runtime;</span>
<span class="fc" id="L471">                return f_add(context, a1,</span>
<span class="fc" id="L472">                             f_mul(context, a2, newComplexBang(context, runtime.getComplex(),</span>
<span class="fc" id="L473">                                     RubyFixnum.zero(runtime), RubyFixnum.one(runtime))));</span>
            }
<span class="fc" id="L475">            return newInstance(context, recv, a1, a2);</span>
        }
    }

    /** nucomp_real
     * 
     */
    @JRubyMethod(name = &quot;real&quot;)
    public IRubyObject real() {
<span class="fc" id="L484">        return real;</span>
    }
    
    /** nucomp_image
     * 
     */
    @JRubyMethod(name = {&quot;imaginary&quot;, &quot;imag&quot;})
    public IRubyObject image() {
<span class="fc" id="L492">        return image;</span>
    }

    /** nucomp_negate
     * 
     */
    @JRubyMethod(name = &quot;-@&quot;)
    public IRubyObject negate(ThreadContext context) {
<span class="fc" id="L500">        return newComplex(context, getMetaClass(), f_negate(context, real), f_negate(context, image));</span>
    }

    /** nucomp_add
     * 
     */
    @JRubyMethod(name = &quot;+&quot;)
    public IRubyObject op_add(ThreadContext context, IRubyObject other) {
<span class="fc bfc" id="L508" title="All 2 branches covered.">        if (other instanceof RubyComplex) {</span>
<span class="fc" id="L509">            RubyComplex otherComplex = (RubyComplex)other;</span>
<span class="fc" id="L510">            return newComplex(context, getMetaClass(), </span>
<span class="fc" id="L511">                              f_add(context, real, otherComplex.real),</span>
<span class="fc" id="L512">                              f_add(context, image, otherComplex.image));</span>
<span class="fc bfc" id="L513" title="All 4 branches covered.">        } else if (other instanceof RubyNumeric &amp;&amp; f_real_p(context, other).isTrue()) {</span>
<span class="fc" id="L514">            return newComplex(context, getMetaClass(), f_add(context, real, other), image);</span>
        }
<span class="fc" id="L516">        return coerceBin(context, &quot;+&quot;, other);</span>
    }

    /** nucomp_sub
     * 
     */
    @JRubyMethod(name = &quot;-&quot;)
    public IRubyObject op_sub(ThreadContext context, IRubyObject other) {
<span class="fc bfc" id="L524" title="All 2 branches covered.">        if (other instanceof RubyComplex) {</span>
<span class="fc" id="L525">            RubyComplex otherComplex = (RubyComplex)other;</span>
<span class="fc" id="L526">            return newComplex(context, getMetaClass(), </span>
<span class="fc" id="L527">                              f_sub(context, real, otherComplex.real),</span>
<span class="fc" id="L528">                              f_sub(context, image, otherComplex.image));</span>
<span class="fc bfc" id="L529" title="All 4 branches covered.">        } else if (other instanceof RubyNumeric &amp;&amp; f_real_p(context, other).isTrue()) {</span>
<span class="fc" id="L530">            return newComplex(context, getMetaClass(), f_sub(context, real, other), image);</span>
        }
<span class="fc" id="L532">        return coerceBin(context, &quot;-&quot;, other);</span>
    }

    /** nucomp_mul
     * 
     */
    @JRubyMethod(name = &quot;*&quot;)
    public IRubyObject op_mul(ThreadContext context, IRubyObject other) {
<span class="fc bfc" id="L540" title="All 2 branches covered.">        if (other instanceof RubyComplex) {</span>
<span class="fc" id="L541">            RubyComplex otherComplex = (RubyComplex)other;</span>
<span class="fc" id="L542">            IRubyObject realp = f_sub(context, </span>
<span class="fc" id="L543">                                f_mul(context, real, otherComplex.real),</span>
<span class="fc" id="L544">                                f_mul(context, image, otherComplex.image));</span>
<span class="fc" id="L545">            IRubyObject imagep = f_add(context,</span>
<span class="fc" id="L546">                                f_mul(context, real, otherComplex.image),</span>
<span class="fc" id="L547">                                f_mul(context, image, otherComplex.real));</span>
            
<span class="fc" id="L549">            return newComplex(context, getMetaClass(), realp, imagep); </span>
<span class="fc bfc" id="L550" title="All 4 branches covered.">        } else if (other instanceof RubyNumeric &amp;&amp; f_real_p(context, other).isTrue()) {</span>
<span class="fc" id="L551">            return newComplex(context, getMetaClass(),</span>
<span class="fc" id="L552">                    f_mul(context, real, other),</span>
<span class="fc" id="L553">                    f_mul(context, image, other));</span>
        }
<span class="fc" id="L555">        return coerceBin(context, &quot;*&quot;, other);</span>
    }
    
    /** nucomp_div / nucomp_quo
     * 
     */
    @JRubyMethod(name = {&quot;/&quot;, &quot;quo&quot;})
    public IRubyObject op_div(ThreadContext context, IRubyObject other) {
<span class="fc bfc" id="L563" title="All 2 branches covered.">        if (other instanceof RubyComplex) {</span>
<span class="fc" id="L564">            RubyComplex otherComplex = (RubyComplex)other;</span>
<span class="pc bpc" id="L565" title="3 of 8 branches missed.">            if (real instanceof RubyFloat || image instanceof RubyFloat ||</span>
                otherComplex.real instanceof RubyFloat || otherComplex.image instanceof RubyFloat) {
<span class="fc" id="L567">                IRubyObject magn = RubyMath.hypot(context, this, otherComplex.real, otherComplex.image);</span>
<span class="fc" id="L568">                IRubyObject tmp = newComplexBang(context, getMetaClass(),</span>
<span class="fc" id="L569">                                                 f_quo(context, otherComplex.real, magn),</span>
<span class="fc" id="L570">                                                 f_quo(context, otherComplex.image, magn));</span>
<span class="fc" id="L571">                return f_quo(context, f_mul(context, this, f_conjugate(context, tmp)), magn);</span>
            }
<span class="fc" id="L573">            return f_quo(context, f_mul(context, this, f_conjugate(context, other)), f_abs2(context, other));</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">        } else if (other instanceof RubyNumeric) {</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">            if (f_real_p(context, other).isTrue()) {</span>
<span class="fc" id="L576">                return newComplex(context, getMetaClass(),</span>
<span class="fc" id="L577">                        f_quo(context, real, other),</span>
<span class="fc" id="L578">                        f_quo(context, image, other));</span>
            } else {
<span class="fc" id="L580">                RubyArray coercedOther = doCoerce(context, other, true);</span>
<span class="fc" id="L581">                return RubyRational.newInstance(context, context.runtime.getRational(), coercedOther.first(), coercedOther.last());</span>
            }
        }
<span class="fc" id="L584">        return coerceBin(context, &quot;/&quot;, other);</span>
    }

    /** nucomp_fdiv
     *
     */
    @JRubyMethod(name = &quot;fdiv&quot;)
    @Override
    public IRubyObject fdiv(ThreadContext context, IRubyObject other) {
<span class="fc" id="L593">        IRubyObject complex = newComplex(context, getMetaClass(),</span>
<span class="fc" id="L594">                                         f_to_f(context, real),   </span>
<span class="fc" id="L595">                                         f_to_f(context, image));</span>

<span class="fc" id="L597">        return f_div(context, complex, other);</span>
    }

    /** nucomp_expt
     * 
     */
    @JRubyMethod(name = &quot;**&quot;)
    public IRubyObject op_expt(ThreadContext context, IRubyObject other) {
<span class="fc bfc" id="L605" title="All 4 branches covered.">        if (k_exact_p(other) &amp;&amp; f_zero_p(context, other)) {</span>
<span class="fc" id="L606">            return newComplexBang(context, getMetaClass(), RubyFixnum.one(context.runtime));</span>
<span class="pc bpc" id="L607" title="1 of 4 branches missed.">        } else if (other instanceof RubyRational &amp;&amp; f_one_p(context, f_denominator(context, other))) {</span>
<span class="nc" id="L608">            other = f_numerator(context, other); </span>
        } 

<span class="fc bfc" id="L611" title="All 2 branches covered.">        if (other instanceof RubyComplex) {</span>
<span class="fc" id="L612">            RubyArray a = f_polar(context, this).convertToArray();</span>
<span class="fc" id="L613">            IRubyObject r = a.eltInternal(0);</span>
<span class="fc" id="L614">            IRubyObject theta = a.eltInternal(1);</span>
<span class="fc" id="L615">            RubyComplex otherComplex = (RubyComplex)other;</span>
<span class="fc" id="L616">            IRubyObject nr = RubyMath.exp(context, this, f_sub(context, </span>
<span class="fc" id="L617">                    f_mul(context, otherComplex.real, RubyMath.log_19(context, this, new IRubyObject[] {r})),</span>
<span class="fc" id="L618">                    f_mul(context, otherComplex.image, theta)));</span>
<span class="fc" id="L619">            IRubyObject ntheta = f_add(context,</span>
<span class="fc" id="L620">                    f_mul(context, theta, otherComplex.real),</span>
<span class="fc" id="L621">                    f_mul(context, otherComplex.image, RubyMath.log_19(context, this, new IRubyObject[] {r})));</span>
<span class="fc" id="L622">            return f_complex_polar(context, getMetaClass(), nr, ntheta);</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">        } else if (other instanceof RubyInteger) {</span>
<span class="fc" id="L624">            IRubyObject one = RubyFixnum.one(context.runtime);</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">            if (f_gt_p(context, other, RubyFixnum.zero(context.runtime)).isTrue()) {</span>
<span class="fc" id="L626">                IRubyObject x = this;</span>
<span class="fc" id="L627">                IRubyObject z = x;</span>
<span class="fc" id="L628">                IRubyObject n = f_sub(context, other, one);</span>

<span class="fc" id="L630">                IRubyObject two = RubyFixnum.two(context.runtime);</span>
                
<span class="fc bfc" id="L632" title="All 2 branches covered.">                while (!f_zero_p(context, n)) {</span>
                    
<span class="fc" id="L634">                    RubyArray a = f_divmod(context, n, two).convertToArray();</span>

<span class="pc bpc" id="L636" title="1 of 2 branches missed.">                    while (f_zero_p(context, a.eltInternal(1))) {</span>
<span class="nc" id="L637">                        RubyComplex xComplex = (RubyComplex)x;</span>
<span class="nc" id="L638">                        x = newComplex(context, getMetaClass(),</span>
<span class="nc" id="L639">                                       f_sub(context, f_mul(context, xComplex.real, xComplex.real),</span>
<span class="nc" id="L640">                                                      f_mul(context, xComplex.image, xComplex.image)),</span>
<span class="nc" id="L641">                                       f_mul(context, f_mul(context, two, xComplex.real), xComplex.image));</span>
                        
<span class="nc" id="L643">                        n = a.eltInternal(0);</span>
<span class="nc" id="L644">                        a = f_divmod(context, n, two).convertToArray();</span>
<span class="nc" id="L645">                    }</span>
<span class="fc" id="L646">                    z = f_mul(context, z, x);</span>
<span class="fc" id="L647">                    n = f_sub(context, n, one);</span>
<span class="fc" id="L648">                }</span>
<span class="fc" id="L649">                return z;</span>
            }
<span class="fc" id="L651">            return f_expt(context, f_div(context, f_to_r(context, one), this), f_negate(context, other));</span>
<span class="pc bpc" id="L652" title="1 of 4 branches missed.">        } else if (other instanceof RubyNumeric &amp;&amp; f_real_p(context, other).isTrue()) {</span>
<span class="fc" id="L653">            RubyArray a = f_polar(context, this).convertToArray();</span>
<span class="fc" id="L654">            IRubyObject r = a.eltInternal(0);</span>
<span class="fc" id="L655">            IRubyObject theta = a.eltInternal(1);</span>
<span class="fc" id="L656">            return f_complex_polar(context, getMetaClass(), f_expt(context, r, other), f_mul(context, theta, other));</span>
        }
<span class="fc" id="L658">        return coerceBin(context, &quot;**&quot;, other);</span>
    }

    /** nucomp_equal_p
     * 
     */
    @JRubyMethod(name = &quot;==&quot;)
    @Override
    public IRubyObject op_equal(ThreadContext context, IRubyObject other) {
<span class="fc bfc" id="L667" title="All 2 branches covered.">        if (other instanceof RubyComplex) {</span>
<span class="fc" id="L668">            RubyComplex otherComplex = (RubyComplex) other;</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">            boolean test = f_equal(context, real, otherComplex.real).isTrue() &amp;&amp;</span>
<span class="pc bpc" id="L670" title="1 of 2 branches missed.">                    f_equal(context, image, otherComplex.image).isTrue();</span>

<span class="fc" id="L672">            return context.runtime.newBoolean(test);</span>
        }

<span class="fc bfc" id="L675" title="All 4 branches covered.">        if (other instanceof RubyNumeric &amp;&amp; f_real_p(context, other).isTrue()) {</span>
<span class="pc bpc" id="L676" title="1 of 4 branches missed.">            boolean test = f_equal(context, real, other).isTrue() &amp;&amp; f_zero_p(context, image);</span>

<span class="fc" id="L678">            return context.runtime.newBoolean(test);</span>
        }
        
<span class="fc" id="L681">        return f_equal(context, other, this);</span>
    }

    /** nucomp_coerce 
     * 
     */
    @JRubyMethod(name = &quot;coerce&quot;)
    public IRubyObject coerce(ThreadContext context, IRubyObject other) {
<span class="fc bfc" id="L689" title="All 4 branches covered.">        if (other instanceof RubyNumeric &amp;&amp; f_real_p(context, other).isTrue()) {</span>
<span class="fc" id="L690">            return context.runtime.newArray(newComplexBang(context, getMetaClass(), other), this);</span>
        }
<span class="fc bfc" id="L692" title="All 2 branches covered.">        if (other instanceof RubyComplex) {</span>
<span class="fc" id="L693">            return context.runtime.newArray(other, this);</span>
        }
<span class="fc" id="L695">        throw context.runtime.newTypeError(other.getMetaClass().getName() + &quot; can't be coerced into &quot; + getMetaClass().getName());</span>
    }

    /** nucomp_abs 
     * 
     */
    @JRubyMethod(name = {&quot;abs&quot;, &quot;magnitude&quot;})
    @Override
    public IRubyObject abs(ThreadContext context) {
<span class="fc" id="L704">        return RubyMath.hypot(context, this, real, image);</span>
    }

    /** nucomp_abs2 
     * 
     */
    @JRubyMethod(name = &quot;abs2&quot;)
    @Override
    public IRubyObject abs2(ThreadContext context) {
<span class="fc" id="L713">        return f_add(context,</span>
<span class="fc" id="L714">                     f_mul(context, real, real),</span>
<span class="fc" id="L715">                     f_mul(context, image, image));</span>
    }

    /** nucomp_arg 
     * 
     */
    @JRubyMethod(name = {&quot;arg&quot;, &quot;angle&quot;, &quot;phase&quot;})
    @Override
    public IRubyObject arg(ThreadContext context) {
<span class="fc" id="L724">        return RubyMath.atan2(context, this, image, real);</span>
    }

    /** nucomp_rect
     * 
     */
    @JRubyMethod(name = {&quot;rectangular&quot;, &quot;rect&quot;})
    @Override
    public IRubyObject rect(ThreadContext context) {
<span class="fc" id="L733">        return context.runtime.newArray(real, image);</span>
    }

    /** nucomp_polar 
     * 
     */
    @JRubyMethod(name = &quot;polar&quot;)
    @Override
    public IRubyObject polar(ThreadContext context) {
<span class="fc" id="L742">        return context.runtime.newArray(f_abs(context, this), f_arg(context, this));</span>
    }

    /** nucomp_conjugate
     * 
     */
    @JRubyMethod(name = {&quot;conjugate&quot;, &quot;conj&quot;, &quot;~&quot;})
    @Override
    public IRubyObject conjugate(ThreadContext context) {
<span class="fc" id="L751">        return newComplex(context, getMetaClass(), real, f_negate(context, image));</span>
    }

    /** nucomp_real_p
     * 
     */
    @JRubyMethod(name = &quot;real?&quot;)
    public IRubyObject real_p(ThreadContext context) {
<span class="fc" id="L759">        return context.runtime.getFalse();</span>
    }

    /** nucomp_complex_p
     * 
     */
    // @JRubyMethod(name = &quot;complex?&quot;)
    public IRubyObject complex_p(ThreadContext context) {
<span class="nc" id="L767">        return context.runtime.getTrue();</span>
    }

    /** nucomp_exact_p
     * 
     */
    // @JRubyMethod(name = &quot;exact?&quot;)
    public IRubyObject exact_p(ThreadContext context) {
<span class="nc bnc" id="L775" title="All 4 branches missed.">        return (f_exact_p(context, real).isTrue() &amp;&amp; f_exact_p(context, image).isTrue()) ? context.runtime.getTrue() : context.runtime.getFalse();</span>
    }

    /** nucomp_exact_p
     * 
     */
    // @JRubyMethod(name = &quot;inexact?&quot;)
    public IRubyObject inexact_p(ThreadContext context) {
<span class="nc bnc" id="L783" title="All 2 branches missed.">        return exact_p(context).isTrue() ? context.runtime.getFalse() : context.runtime.getTrue();</span>
    }

    /** nucomp_denominator
     * 
     */
    @JRubyMethod(name = &quot;denominator&quot;)
    public IRubyObject demoninator(ThreadContext context) {
<span class="fc" id="L791">        return f_lcm(context, f_denominator(context, real), f_denominator(context, image));</span>
    }

    /** nucomp_numerator
     * 
     */
    @JRubyMethod(name = &quot;numerator&quot;)
    @Override
    public IRubyObject numerator(ThreadContext context) {
<span class="fc" id="L800">        IRubyObject cd = callMethod(context, &quot;denominator&quot;);</span>
<span class="fc" id="L801">        return newComplex(context, getMetaClass(),</span>
<span class="fc" id="L802">                          f_mul(context, </span>
<span class="fc" id="L803">                                f_numerator(context, real),</span>
<span class="fc" id="L804">                                f_div(context, cd, f_denominator(context, real))),</span>
<span class="fc" id="L805">                          f_mul(context,</span>
<span class="fc" id="L806">                                f_numerator(context, image),</span>
<span class="fc" id="L807">                                f_div(context, cd, f_denominator(context, image))));</span>
    }

    /** nucomp_hash
     * 
     */
    @JRubyMethod(name = &quot;hash&quot;)
    public IRubyObject hash(ThreadContext context) {
<span class="fc" id="L815">        return f_xor(context, invokedynamic(context, real, HASH), invokedynamic(context, image, HASH));</span>
    }

    /** nucomp_eql_p
     * 
     */
    @JRubyMethod(name = &quot;eql?&quot;)
    @Override
    public IRubyObject eql_p(ThreadContext context, IRubyObject other) {
<span class="fc bfc" id="L824" title="All 2 branches covered.">        if (other instanceof RubyComplex) {</span>
<span class="fc" id="L825">            RubyComplex otherComplex = (RubyComplex)other;</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">            if (real.getMetaClass() == otherComplex.real.getMetaClass() &amp;&amp;</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">                image.getMetaClass() == otherComplex.image.getMetaClass() &amp;&amp;</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">                f_equal(context, this, otherComplex).isTrue()) {</span>
<span class="fc" id="L829">                return context.runtime.getTrue();</span>
            }
        }
<span class="fc" id="L832">        return context.runtime.getFalse();</span>
    }

    /** f_signbit
     * 
     */
    private static boolean signbit(ThreadContext context, IRubyObject x) {
<span class="fc bfc" id="L839" title="All 2 branches covered.">        if (x instanceof RubyFloat) {</span>
<span class="fc" id="L840">            double value = ((RubyFloat)x).getDoubleValue();</span>
<span class="fc bfc" id="L841" title="All 4 branches covered.">            return !Double.isNaN(value) &amp;&amp; Double.doubleToLongBits(value) &lt; 0;</span>
        }
<span class="fc" id="L843">        return f_negative_p(context, x);</span>
    }

    /** f_tpositive_p
     * 
     */
    private static boolean tpositive_p(ThreadContext context, IRubyObject x) {
<span class="fc bfc" id="L850" title="All 2 branches covered.">        return !signbit(context, x);</span>
    }

    /** nucomp_to_s
     * 
     */
    @JRubyMethod(name = &quot;to_s&quot;)
    public IRubyObject to_s(ThreadContext context) {
<span class="fc" id="L858">        boolean impos = tpositive_p(context, image);</span>

<span class="fc" id="L860">        RubyString str = f_to_s(context, real).convertToString();</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">        str.cat(impos ? (byte)'+' : (byte)'-');</span>
<span class="fc" id="L862">        str.cat(f_to_s(context, f_abs(context, image)).convertToString().getByteList());</span>
<span class="fc bfc" id="L863" title="All 2 branches covered.">        if (!lastCharDigit(str)) str.cat((byte)'*');</span>
<span class="fc" id="L864">        str.cat((byte)'i');</span>
<span class="fc" id="L865">        return str;</span>
    }

    /** nucomp_inspect
     * 
     */
    @JRubyMethod(name = &quot;inspect&quot;)
    public IRubyObject inspect(ThreadContext context) {
<span class="fc" id="L873">        boolean impos = tpositive_p(context, image);</span>
<span class="fc" id="L874">        RubyString str = context.runtime.newString();</span>
<span class="fc" id="L875">        str.cat((byte)'(');</span>
<span class="fc" id="L876">        str.cat(f_inspect(context, real).convertToString().getByteList());</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">        str.cat(impos ? (byte)'+' : (byte)'-');</span>
<span class="fc" id="L878">        str.cat(f_inspect(context, f_abs(context, image)).convertToString().getByteList());</span>
<span class="pc bpc" id="L879" title="1 of 2 branches missed.">        if (!lastCharDigit(str)) str.cat((byte)'*');</span>
<span class="fc" id="L880">        str.cat((byte)'i');</span>
<span class="fc" id="L881">        str.cat((byte)')');</span>
<span class="fc" id="L882">        return str;</span>
    }

    private static boolean lastCharDigit(RubyString str) {
<span class="fc" id="L886">        ByteList bytes = str.getByteList();</span>
<span class="fc" id="L887">        return ASCIIEncoding.INSTANCE.isDigit(bytes.getUnsafeBytes()[bytes.getBegin() + bytes.getRealSize() - 1]);</span>
    }

    /** nucomp_marshal_dump
     * 
     */
    @JRubyMethod(name = &quot;marshal_dump&quot;)
    public IRubyObject marshal_dump(ThreadContext context) {
<span class="fc" id="L895">        RubyArray dump = context.runtime.newArray(real, image);</span>
<span class="pc bpc" id="L896" title="1 of 2 branches missed.">        if (hasVariables()) dump.syncVariables(this);</span>
<span class="fc" id="L897">        return dump;</span>
    }

    /** nucomp_marshal_load
     * 
     */
    @JRubyMethod(name = &quot;marshal_load&quot;)
    public IRubyObject marshal_load(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L905">        RubyArray load = arg.convertToArray();</span>
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">        real = load.size() &gt; 0 ? load.eltInternal(0) : context.runtime.getNil();</span>
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">        image = load.size() &gt; 1 ? load.eltInternal(1) : context.runtime.getNil();</span>

<span class="pc bpc" id="L909" title="1 of 2 branches missed.">        if (load.hasVariables()) syncVariables((IRubyObject)load);</span>
<span class="fc" id="L910">        return this;</span>
    }

    /** nucomp_to_c
     *
     */
    @JRubyMethod(name = &quot;to_c&quot;)
    public IRubyObject to_c(ThreadContext context) {
<span class="nc" id="L918">        return this;</span>
    }

    /** nucomp_to_i
     * 
     */
    @JRubyMethod(name = &quot;to_i&quot;)
    public IRubyObject to_i(ThreadContext context) {
<span class="fc bfc" id="L926" title="All 4 branches covered.">        if (k_inexact_p(image) || !f_zero_p(context, image)) {</span>
<span class="fc" id="L927">            throw context.runtime.newRangeError(&quot;can't convert &quot; + f_to_s(context, this).convertToString() + &quot; into Integer&quot;);</span>
        }
<span class="fc" id="L929">        return f_to_i(context, real);</span>
    }

    /** nucomp_to_f
     * 
     */
    @JRubyMethod(name = &quot;to_f&quot;)
    public IRubyObject to_f(ThreadContext context) {
<span class="fc bfc" id="L937" title="All 4 branches covered.">        if (k_inexact_p(image) || !f_zero_p(context, image)) {</span>
<span class="fc" id="L938">            throw context.runtime.newRangeError(&quot;can't convert &quot; + f_to_s(context, this).convertToString() + &quot; into Float&quot;);</span>
        }
<span class="fc" id="L940">        return f_to_f(context, real);</span>
    }

    /** nucomp_to_r
     * 
     */
    @JRubyMethod(name = &quot;to_r&quot;)
    public IRubyObject to_r(ThreadContext context) {
<span class="fc bfc" id="L948" title="All 4 branches covered.">        if (k_inexact_p(image) || !f_zero_p(context, image)) {</span>
<span class="fc" id="L949">            throw context.runtime.newRangeError(&quot;can't convert &quot; + f_to_s(context, this).convertToString() + &quot; into Rational&quot;);</span>
        }
<span class="fc" id="L951">        return f_to_r(context, real);</span>
    }

    /** nucomp_rationalize
     *
     */
    @JRubyMethod(name = &quot;rationalize&quot;, optional = 1)
    public IRubyObject rationalize(ThreadContext context, IRubyObject[] args) {
<span class="fc bfc" id="L959" title="All 4 branches covered.">        if (k_inexact_p(image) || !f_zero_p(context, image)) {</span>
<span class="fc" id="L960">            throw context.runtime.newRangeError(&quot;can't convert &quot; + f_to_s(context, this).convertToString() + &quot; into Rational&quot;);</span>
        }
<span class="fc" id="L962">        return real.callMethod(context, &quot;rationalize&quot;, args);</span>
    }
    
    static RubyArray str_to_c_internal(ThreadContext context, IRubyObject recv) {
<span class="fc" id="L966">        RubyString s = recv.convertToString();</span>
<span class="fc" id="L967">        ByteList bytes = s.getByteList();</span>

<span class="fc" id="L969">        Ruby runtime = context.runtime;</span>
<span class="pc bpc" id="L970" title="1 of 2 branches missed.">        if (bytes.getRealSize() == 0) return runtime.newArray(runtime.getNil(), recv);</span>

        IRubyObject sr, si, re;
<span class="fc" id="L973">        sr = si = re = runtime.getNil();</span>
<span class="fc" id="L974">        boolean po = false;</span>
<span class="fc" id="L975">        IRubyObject m = RubyRegexp.newDummyRegexp(runtime, Numeric.ComplexPatterns.comp_pat0).match_m19(context, s, false, Block.NULL_BLOCK);</span>

<span class="pc bpc" id="L977" title="1 of 2 branches missed.">        if (!m.isNil()) {</span>
<span class="nc" id="L978">            RubyMatchData match = (RubyMatchData)m;</span>
<span class="nc" id="L979">            sr = match.op_aref19(RubyFixnum.one(runtime));</span>
<span class="nc" id="L980">            si = match.op_aref19(RubyFixnum.two(runtime));</span>
<span class="nc" id="L981">            re = match.post_match(context);</span>
<span class="nc" id="L982">            po = true;</span>
        }

<span class="pc bpc" id="L985" title="1 of 2 branches missed.">        if (m.isNil()) {</span>
<span class="fc" id="L986">            m = RubyRegexp.newDummyRegexp(runtime, Numeric.ComplexPatterns.comp_pat1).match_m19(context, s, false, Block.NULL_BLOCK);</span>

<span class="fc bfc" id="L988" title="All 2 branches covered.">            if (!m.isNil()) {</span>
<span class="fc" id="L989">                RubyMatchData match = (RubyMatchData)m;</span>
<span class="fc" id="L990">                sr = runtime.getNil();</span>
<span class="fc" id="L991">                si = match.op_aref19(RubyFixnum.one(runtime));</span>
<span class="fc bfc" id="L992" title="All 2 branches covered.">                if (si.isNil()) si = runtime.newString();</span>
<span class="fc" id="L993">                IRubyObject t = match.op_aref19(RubyFixnum.two(runtime));</span>
<span class="fc bfc" id="L994" title="All 2 branches covered.">                if (t.isNil()) t = runtime.newString(new ByteList(new byte[]{'1'}));</span>
<span class="fc" id="L995">                si.convertToString().cat(t.convertToString().getByteList());</span>
<span class="fc" id="L996">                re = match.post_match(context);</span>
<span class="fc" id="L997">                po = false;</span>
            }
        }

<span class="fc bfc" id="L1001" title="All 2 branches covered.">        if (m.isNil()) {</span>
<span class="fc" id="L1002">            m = RubyRegexp.newDummyRegexp(runtime, Numeric.ComplexPatterns.comp_pat2).match_m19(context, s, false, Block.NULL_BLOCK);</span>
<span class="fc bfc" id="L1003" title="All 2 branches covered.">            if (m.isNil()) return runtime.newArray(runtime.getNil(), recv);</span>
<span class="fc" id="L1004">            RubyMatchData match = (RubyMatchData)m;</span>
<span class="fc" id="L1005">            sr = match.op_aref19(RubyFixnum.one(runtime));</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">            if (match.op_aref19(RubyFixnum.two(runtime)).isNil()) {</span>
<span class="fc" id="L1007">                si = runtime.getNil();</span>
            } else {
<span class="fc" id="L1009">                si = match.op_aref19(RubyFixnum.three(runtime));</span>
<span class="fc" id="L1010">                IRubyObject t = match.op_aref19(RubyFixnum.four(runtime));</span>
<span class="pc bpc" id="L1011" title="1 of 2 branches missed.">                if (t.isNil()) t = runtime.newString(RubyFixnum.SINGLE_CHAR_BYTELISTS19['1']);</span>
<span class="fc" id="L1012">                si.convertToString().cat(t.convertToString().getByteList());</span>
            }
<span class="fc" id="L1014">            re = match.post_match(context);</span>
<span class="fc" id="L1015">            po = false;</span>
        }

<span class="fc" id="L1018">        IRubyObject r = RubyFixnum.zero(runtime);</span>
<span class="fc" id="L1019">        IRubyObject i = r;</span>

<span class="fc bfc" id="L1021" title="All 2 branches covered.">        if (!sr.isNil()) {</span>
<span class="fc bfc" id="L1022" title="All 2 branches covered.">            if (sr.callMethod(context, &quot;include?&quot;, runtime.newString(new ByteList(new byte[]{'/'}))).isTrue()) {</span>
<span class="fc" id="L1023">                r = f_to_r(context, sr);</span>
<span class="fc bfc" id="L1024" title="All 2 branches covered.">            } else if (f_gt_p(context, sr.callMethod(context, &quot;count&quot;, runtime.newString(&quot;.eE&quot;)), RubyFixnum.zero(runtime)).isTrue()) {</span>
<span class="fc" id="L1025">                r = f_to_f(context, sr); </span>
            } else {
<span class="fc" id="L1027">                r = f_to_i(context, sr);</span>
            }
        }

<span class="fc bfc" id="L1031" title="All 2 branches covered.">        if (!si.isNil()) {</span>
<span class="fc bfc" id="L1032" title="All 2 branches covered.">            if (si.callMethod(context, &quot;include?&quot;, runtime.newString(new ByteList(new byte[]{'/'}))).isTrue()) {</span>
<span class="fc" id="L1033">                i = f_to_r(context, si);</span>
<span class="fc bfc" id="L1034" title="All 2 branches covered.">            } else if (f_gt_p(context, si.callMethod(context, &quot;count&quot;, runtime.newString(&quot;.eE&quot;)), RubyFixnum.zero(runtime)).isTrue()) {</span>
<span class="fc" id="L1035">                i = f_to_f(context, si);</span>
            } else {
<span class="fc" id="L1037">                i = f_to_i(context, si);</span>
            }
        }
<span class="pc bpc" id="L1040" title="1 of 2 branches missed.">        return runtime.newArray(po ? newComplexPolar(context, r, i) : newComplexCanonicalize(context, r, i), re);</span>
    }
    
    private static IRubyObject str_to_c_strict(ThreadContext context, IRubyObject recv) {
<span class="nc" id="L1044">        RubyArray a = str_to_c_internal(context, recv);</span>
<span class="nc bnc" id="L1045" title="All 4 branches missed.">        if (a.eltInternal(0).isNil() || a.eltInternal(1).convertToString().getByteList().length() &gt; 0) {</span>
<span class="nc" id="L1046">            IRubyObject s = recv.callMethod(context, &quot;inspect&quot;);</span>
<span class="nc" id="L1047">            throw context.runtime.newArgumentError(&quot;invalid value for convert(): &quot; + s.convertToString());</span>
        }
<span class="nc" id="L1049">        return a.eltInternal(0);</span>
    }    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>