<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RubyModule.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby</a> &gt; <span class="el_source">RubyModule.java</span></div><h1>RubyModule.java</h1><pre class="source lang-java linenums">/*
 **** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2001 Chad Fowler &lt;chadfowler@chadfowler.com&gt;
 * Copyright (C) 2001 Alan Moore &lt;alan_moore@gmx.net&gt;
 * Copyright (C) 2001-2002 Benoit Cerrina &lt;b.cerrina@wanadoo.fr&gt;
 * Copyright (C) 2001-2004 Jan Arne Petersen &lt;jpetersen@uni-bonn.de&gt;
 * Copyright (C) 2002-2004 Anders Bengtsson &lt;ndrsbngtssn@yahoo.se&gt;
 * Copyright (C) 2004 Thomas E Enebo &lt;enebo@acm.org&gt;
 * Copyright (C) 2004-2005 Charles O Nutter &lt;headius@headius.com&gt;
 * Copyright (C) 2004 Stefan Matthias Aust &lt;sma@3plus4.de&gt;
 * Copyright (C) 2006-2007 Miguel Covarrubias &lt;mlcovarrubias@gmail.com&gt;
 * Copyright (C) 2007 William N Dortch &lt;bill.dortch@gmail.com&gt;
 * 
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby;

import org.jcodings.Encoding;
import org.jruby.anno.AnnotationBinder;
import org.jruby.anno.AnnotationHelper;
import org.jruby.anno.JRubyClass;
import org.jruby.anno.JRubyConstant;
import org.jruby.anno.JRubyMethod;
import org.jruby.anno.JavaMethodDescriptor;
import org.jruby.anno.TypePopulator;
import org.jruby.common.IRubyWarnings.ID;
import org.jruby.common.RubyWarnings;
import org.jruby.embed.Extension;
import org.jruby.exceptions.RaiseException;
import org.jruby.internal.runtime.methods.AliasMethod;
import org.jruby.internal.runtime.methods.AttrReaderMethod;
import org.jruby.internal.runtime.methods.AttrWriterMethod;
import org.jruby.internal.runtime.methods.CacheableMethod;
import org.jruby.internal.runtime.methods.CallConfiguration;
import org.jruby.internal.runtime.methods.DynamicMethod;
import org.jruby.internal.runtime.methods.Framing;
import org.jruby.internal.runtime.methods.JavaMethod;
import org.jruby.internal.runtime.methods.ProcMethod;
import org.jruby.internal.runtime.methods.Scoping;
import org.jruby.internal.runtime.methods.SynchronizedDynamicMethod;
import org.jruby.internal.runtime.methods.UndefinedMethod;
import org.jruby.internal.runtime.methods.WrapperMethod;
import org.jruby.parser.StaticScope;
import org.jruby.runtime.Arity;
import org.jruby.runtime.Block;
import org.jruby.runtime.CallSite;
import org.jruby.runtime.ClassIndex;
import org.jruby.runtime.Helpers;
import org.jruby.runtime.MethodFactory;
import org.jruby.runtime.MethodIndex;
import org.jruby.runtime.ObjectAllocator;
import org.jruby.runtime.ThreadContext;
import org.jruby.runtime.Visibility;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.runtime.builtin.Variable;
import org.jruby.runtime.callsite.CacheEntry;
import org.jruby.runtime.callsite.FunctionalCachingCallSite;
import org.jruby.runtime.ivars.MethodData;
import org.jruby.runtime.load.IAutoloadMethod;
import org.jruby.runtime.marshal.MarshalStream;
import org.jruby.runtime.marshal.UnmarshalStream;
import org.jruby.runtime.opto.Invalidator;
import org.jruby.runtime.opto.OptoFactory;
import org.jruby.runtime.profile.MethodEnhancer;
import org.jruby.util.ClassProvider;
import org.jruby.util.IdUtil;
import org.jruby.util.TypeConverter;
import org.jruby.util.cli.Options;
import org.jruby.util.collections.WeakHashSet;
import org.jruby.util.log.Logger;
import org.jruby.util.log.LoggerFactory;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

import static org.jruby.anno.FrameField.*;
import static org.jruby.runtime.Visibility.*;


/**
 *
 * @author  jpetersen
 */
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">@JRubyClass(name=&quot;Module&quot;)</span>
public class RubyModule extends RubyObject {

<span class="fc" id="L122">    private static final Logger LOG = LoggerFactory.getLogger(&quot;RubyModule&quot;);</span>

    private static final boolean DEBUG = false;
    protected static final String ERR_INSECURE_SET_CONSTANT  = &quot;Insecure: can't modify constant&quot;;
    protected static final String ERR_FROZEN_CONST_TYPE = &quot;class/module &quot;;

<span class="fc" id="L128">    public static final ObjectAllocator MODULE_ALLOCATOR = new ObjectAllocator() {</span>
        @Override
        public IRubyObject allocate(Ruby runtime, RubyClass klass) {
<span class="fc" id="L131">            return new RubyModule(runtime, klass);</span>
        }
    };
    
    public static RubyClass createModuleClass(Ruby runtime, RubyClass moduleClass) {
<span class="fc" id="L136">        moduleClass.setClassIndex(ClassIndex.MODULE);</span>
<span class="fc" id="L137">        moduleClass.setReifiedClass(RubyModule.class);</span>
<span class="fc" id="L138">        moduleClass.kindOf = new RubyModule.JavaClassKindOf(RubyModule.class);</span>
        
<span class="fc" id="L140">        moduleClass.defineAnnotatedMethods(RubyModule.class);</span>
<span class="fc" id="L141">        moduleClass.defineAnnotatedMethods(ModuleKernelMethods.class);</span>

<span class="fc" id="L143">        return moduleClass;</span>
    }

    public void checkValidBindTargetFrom(ThreadContext context, RubyModule originModule) throws RaiseException {
<span class="fc bfc" id="L147" title="All 2 branches covered.">        if (!this.hasModuleInHierarchy(originModule)) {</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">            if (originModule instanceof MetaClass) {</span>
<span class="fc" id="L149">                throw context.runtime.newTypeError(&quot;can't bind singleton method to a different class&quot;);</span>
            } else {
<span class="fc" id="L151">                throw context.runtime.newTypeError(&quot;bind argument must be an instance of &quot; + originModule.getName());</span>
            }
        }
<span class="fc" id="L154">    }</span>
    
    /**
     * Get the ClassIndex for this class. Will be NO_CLASS for non-core types.
     */
    public ClassIndex getClassIndex() {
<span class="fc" id="L160">        return classIndex;</span>
    }

    /**
     * Set the ClassIndex for this core class. Only used at boot time for core
     * types.
     * 
     * @param classIndex the ClassIndex for this type
     */
    @SuppressWarnings(&quot;deprecated&quot;)
    void setClassIndex(ClassIndex classIndex) {
<span class="fc" id="L171">        this.classIndex = classIndex;</span>
<span class="fc" id="L172">        this.index = classIndex.ordinal();</span>
<span class="fc" id="L173">    }</span>
    
<span class="nc" id="L175">    public static class ModuleKernelMethods {</span>
        @JRubyMethod
        public static IRubyObject autoload(IRubyObject recv, IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L178">            return RubyKernel.autoload(recv, arg0, arg1);</span>
        }
        
        @JRubyMethod(name = &quot;autoload?&quot;)
        public static IRubyObject autoload_p(ThreadContext context, IRubyObject recv, IRubyObject arg0) {
<span class="fc" id="L183">            return RubyKernel.autoload_p(context, recv, arg0);</span>
        }
    }
    
    @Override
    public ClassIndex getNativeClassIndex() {
<span class="fc" id="L189">        return ClassIndex.MODULE;</span>
    }

    @Override
    public boolean isModule() {
<span class="fc" id="L194">        return true;</span>
    }

    @Override
    public boolean isClass() {
<span class="fc" id="L199">        return false;</span>
    }

    public boolean isSingleton() {
<span class="fc" id="L203">        return false;</span>
    }

<span class="fc" id="L206">    public static class KindOf {</span>
<span class="fc" id="L207">        public static final KindOf DEFAULT_KIND_OF = new KindOf();</span>
        public boolean isKindOf(IRubyObject obj, RubyModule type) {
<span class="fc" id="L209">            return obj.getMetaClass().hasModuleInHierarchy(type);</span>
        }
    }

    public static final class JavaClassKindOf extends RubyModule.KindOf {
        private final Class klass;

<span class="fc" id="L216">        public JavaClassKindOf(Class klass) {</span>
<span class="fc" id="L217">            this.klass = klass;</span>
<span class="fc" id="L218">        }</span>

        @Override
        public boolean isKindOf(IRubyObject obj, RubyModule type) {
<span class="fc" id="L222">            return klass.isInstance(obj);</span>
        }
    }

    public boolean isInstance(IRubyObject object) {
<span class="fc" id="L227">        return kindOf.isKindOf(object, this);</span>
    }

    public Map&lt;String, ConstantEntry&gt; getConstantMap() {
<span class="fc" id="L231">        return constants;</span>
    }

    public synchronized Map&lt;String, ConstantEntry&gt; getConstantMapForWrite() {
<span class="fc bfc" id="L235" title="All 2 branches covered.">        return constants == Collections.EMPTY_MAP ? constants = new ConcurrentHashMap&lt;String, ConstantEntry&gt;(4, 0.9f, 1) : constants;</span>
    }
    
    /**
     * AutoloadMap must be accessed after checking ConstantMap. Checking UNDEF value in constantMap works as a guard.
     * For looking up constant, check constantMap first then try to get an Autoload object from autoloadMap.
     * For setting constant, update constantMap first and remove an Autoload object from autoloadMap.
     */
    private Map&lt;String, Autoload&gt; getAutoloadMap() {
<span class="fc" id="L244">        return autoloads;</span>
    }
    
    private synchronized Map&lt;String, Autoload&gt; getAutoloadMapForWrite() {
<span class="fc bfc" id="L248" title="All 2 branches covered.">        return autoloads == Collections.EMPTY_MAP ? autoloads = new ConcurrentHashMap&lt;String, Autoload&gt;(4, 0.9f, 1) : autoloads;</span>
    }
    
    public void addIncludingHierarchy(IncludedModule hierarchy) {
<span class="fc" id="L252">        synchronized (getRuntime().getHierarchyLock()) {</span>
<span class="fc" id="L253">            Set&lt;RubyClass&gt; oldIncludingHierarchies = includingHierarchies;</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">            if (oldIncludingHierarchies == Collections.EMPTY_SET) includingHierarchies = oldIncludingHierarchies = new WeakHashSet(4);</span>
<span class="fc" id="L255">            oldIncludingHierarchies.add(hierarchy);</span>
<span class="pc" id="L256">        }</span>
<span class="fc" id="L257">    }</span>

    /** separate path for MetaClass construction
     * 
     */
    protected RubyModule(Ruby runtime, RubyClass metaClass, boolean objectSpace) {
<span class="fc" id="L263">        super(runtime, metaClass, objectSpace);</span>
<span class="fc" id="L264">        id = runtime.allocModuleId();</span>
<span class="fc" id="L265">        runtime.addModule(this);</span>
        // if (parent == null) parent = runtime.getObject();
<span class="fc bfc" id="L267" title="All 2 branches covered.">        setFlag(USER7_F, !isClass());</span>
<span class="fc" id="L268">        generationObject = generation = runtime.getNextModuleGeneration();</span>

<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        if (runtime.getInstanceConfig().isProfiling()) {</span>
<span class="nc" id="L271">            cacheEntryFactory = new ProfilingCacheEntryFactory(runtime, NormalCacheEntryFactory);</span>
        } else {
<span class="fc" id="L273">            cacheEntryFactory = NormalCacheEntryFactory;</span>
        }
        
        // set up an invalidator for use in new optimization strategies
<span class="fc" id="L277">        methodInvalidator = OptoFactory.newMethodInvalidator(this);</span>
<span class="fc" id="L278">    }</span>
    
    /** used by MODULE_ALLOCATOR and RubyClass constructors
     * 
     */
    protected RubyModule(Ruby runtime, RubyClass metaClass) {
<span class="fc" id="L284">        this(runtime, metaClass, runtime.isObjectSpaceEnabled());</span>
<span class="fc" id="L285">    }</span>
    
    /** standard path for Module construction
     * 
     */
    protected RubyModule(Ruby runtime) {
<span class="fc" id="L291">        this(runtime, runtime.getModule());</span>
<span class="fc" id="L292">    }</span>

    public boolean needsImplementer() {
<span class="fc" id="L295">        return getFlag(USER7_F);</span>
    }
    
    /** rb_module_new
     * 
     */
    public static RubyModule newModule(Ruby runtime) {
<span class="fc" id="L302">        return new RubyModule(runtime);</span>
    }
    
    /** rb_module_new/rb_define_module_id/rb_name_class/rb_set_class_path
     * 
     */
    public static RubyModule newModule(Ruby runtime, String name, RubyModule parent, boolean setParent) {
<span class="fc" id="L309">        RubyModule module = newModule(runtime);</span>
<span class="fc" id="L310">        module.setBaseName(name);</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">        if (setParent) module.setParent(parent);</span>
<span class="fc" id="L312">        parent.setConstant(name, module);</span>
<span class="fc" id="L313">        return module;</span>
    }
    
    // synchronized method per JRUBY-1173 (unsafe Double-Checked Locking)
    // FIXME: synchronization is still wrong in CP code
    public synchronized void addClassProvider(ClassProvider provider) {
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">        if (!classProviders.contains(provider)) {</span>
<span class="fc" id="L320">            Set&lt;ClassProvider&gt; cp = new HashSet&lt;ClassProvider&gt;(classProviders);</span>
<span class="fc" id="L321">            cp.add(provider);</span>
<span class="fc" id="L322">            classProviders = cp;</span>
        }
<span class="fc" id="L324">    }</span>

    public synchronized void removeClassProvider(ClassProvider provider) {
<span class="nc" id="L327">        Set&lt;ClassProvider&gt; cp = new HashSet&lt;ClassProvider&gt;(classProviders);</span>
<span class="nc" id="L328">        cp.remove(provider);</span>
<span class="nc" id="L329">        classProviders = cp;</span>
<span class="nc" id="L330">    }</span>

    private void checkForCyclicInclude(RubyModule m) throws RaiseException {
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (getNonIncludedClass() == m.getNonIncludedClass()) {</span>
<span class="fc" id="L334">            throw getRuntime().newArgumentError(&quot;cyclic include detected&quot;);</span>
        }
<span class="fc" id="L336">    }</span>

    protected void checkForCyclicPrepend(RubyModule m) throws RaiseException {
<span class="nc bnc" id="L339" title="All 2 branches missed.">        if (getNonIncludedClass() == m.getNonIncludedClass()) {</span>
<span class="nc" id="L340">            throw getRuntime().newArgumentError(getName() + &quot; cyclic prepend detected &quot; + m.getName());</span>
        }
<span class="nc" id="L342">    }</span>

    private RubyClass searchProvidersForClass(String name, RubyClass superClazz) {
        RubyClass clazz;
<span class="fc bfc" id="L346" title="All 2 branches covered.">        for (ClassProvider classProvider: classProviders) {</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">            if ((clazz = classProvider.defineClassUnder(this, name, superClazz)) != null) {</span>
<span class="fc" id="L348">                return clazz;</span>
            }
<span class="nc" id="L350">        }</span>
<span class="fc" id="L351">        return null;</span>
    }

    private RubyModule searchProvidersForModule(String name) {
        RubyModule module;
<span class="fc bfc" id="L356" title="All 2 branches covered.">        for (ClassProvider classProvider: classProviders) {</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">            if ((module = classProvider.defineModuleUnder(this, name)) != null) {</span>
<span class="fc" id="L358">                return module;</span>
            }
<span class="nc" id="L360">        }</span>
<span class="fc" id="L361">        return null;</span>
    }

    /** Getter for property superClass.
     * @return Value of property superClass.
     */
    public RubyClass getSuperClass() {
<span class="fc" id="L368">        return superClass;</span>
    }

    public void setSuperClass(RubyClass superClass) {
        // update superclass reference
<span class="fc" id="L373">        this.superClass = superClass;</span>
<span class="pc bpc" id="L374" title="1 of 4 branches missed.">        if (superClass != null &amp;&amp; superClass.isSynchronized()) becomeSynchronized();</span>
<span class="fc" id="L375">    }</span>

    public RubyModule getParent() {
<span class="fc" id="L378">        return parent;</span>
    }

    public void setParent(RubyModule parent) {
<span class="fc" id="L382">        this.parent = parent;</span>
<span class="fc" id="L383">    }</span>

    public RubyModule getMethodLocation() {
<span class="fc" id="L386">        return methodLocation;</span>
    }

    public void setMethodLocation(RubyModule module){
<span class="nc" id="L390">        methodLocation = module;</span>
<span class="nc" id="L391">    }</span>

    public Map&lt;String, DynamicMethod&gt; getMethods() {
<span class="fc" id="L394">        return this.methods;</span>
    }

    public synchronized Map&lt;String, DynamicMethod&gt; getMethodsForWrite() {
<span class="fc" id="L398">        Map&lt;String, DynamicMethod&gt; myMethods = this.methods;</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">        return myMethods == Collections.EMPTY_MAP ?</span>
            this.methods = new ConcurrentHashMap&lt;String, DynamicMethod&gt;(0, 0.9f, 1) :
            myMethods;
    }
    
    // note that addMethod now does its own put, so any change made to
    // functionality here should be made there as well 
    private void putMethod(String name, DynamicMethod method) {
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">        if (hasPrepends()) method = new WrapperMethod(methodLocation, method, method.getVisibility());</span>
<span class="fc" id="L408">        methodLocation.getMethodsForWrite().put(name, method);</span>

<span class="fc" id="L410">        getRuntime().addProfiledMethod(name, method);</span>
<span class="fc" id="L411">    }</span>

    /**
     * Is this module one that in an included one (e.g. an IncludedModuleWrapper).
     */
    public boolean isIncluded() {
<span class="fc" id="L417">        return false;</span>
    }

    public boolean isPrepended() {
<span class="fc" id="L421">        return false;</span>
    }

    public RubyModule getNonIncludedClass() {
<span class="fc" id="L425">        return this;</span>
    }

    public RubyModule getDelegate() {
<span class="fc" id="L429">        return this;</span>
    }

    public RubyModule getNonPrependedClass() {
<span class="nc" id="L433">        return this;</span>
    }

    /**
     * Get the base name of this class, or null if it is an anonymous class.
     * 
     * @return base name of the class
     */
    public String getBaseName() {
<span class="fc" id="L442">        return baseName;</span>
    }

    /**
     * Set the base name of the class. If null, the class effectively becomes
     * anonymous (though constants elsewhere may reference it).
     * @param name the new base name of the class
     */
    public void setBaseName(String name) {
<span class="fc" id="L451">        baseName = name;</span>
<span class="fc" id="L452">    }</span>

    /**
     * Generate a fully-qualified class name or a #-style name for anonymous and singleton classes.
     * 
     * Ruby C equivalent = &quot;classname&quot;
     * 
     * @return The generated class name
     */
    public String getName() {
<span class="fc bfc" id="L462" title="All 2 branches covered.">        if (cachedName != null) return cachedName;</span>
<span class="fc" id="L463">        return calculateName();</span>
    }
    
    /**
     * Get the &quot;simple&quot; name for the class, which is either the &quot;base&quot; name or
     * the &quot;anonymous&quot; class name.
     * 
     * @return the &quot;simple&quot; name of the class
     */
    public String getSimpleName() {
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">        if (baseName != null) return baseName;</span>
<span class="fc" id="L474">        return calculateAnonymousName();</span>
    }

    /**
     * Recalculate the fully-qualified name of this class/module.
     */
    private String calculateName() {
<span class="fc" id="L481">        boolean cache = true;</span>

<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (getBaseName() == null) {</span>
            // we are anonymous, use anonymous name
<span class="fc" id="L485">            return calculateAnonymousName();</span>
        }
        
<span class="fc" id="L488">        Ruby runtime = getRuntime();</span>
        
<span class="fc" id="L490">        String name = getBaseName();</span>
<span class="fc" id="L491">        RubyClass objectClass = runtime.getObject();</span>
        
        // First, we count the parents
<span class="fc" id="L494">        int parentCount = 0;</span>
<span class="fc bfc" id="L495" title="All 4 branches covered.">        for (RubyModule p = getParent() ; p != null &amp;&amp; p != objectClass ; p = p.getParent()) {</span>
<span class="fc" id="L496">            parentCount++;</span>
        }
        
        // Allocate a String array for all of their names and populate it
<span class="fc" id="L500">        String[] parentNames = new String[parentCount];</span>
<span class="fc" id="L501">        int i = parentCount - 1;</span>
<span class="fc" id="L502">        int totalLength = name.length() + parentCount * 2; // name length + enough :: for all parents</span>
<span class="fc bfc" id="L503" title="All 4 branches covered.">        for (RubyModule p = getParent() ; p != null &amp;&amp; p != objectClass ; p = p.getParent(), i--) {</span>
<span class="fc" id="L504">            String pName = p.getBaseName();</span>
            
            // This is needed when the enclosing class or module is a singleton.
            // In that case, we generated a name such as null::Foo, which broke 
            // Marshalling, among others. The correct thing to do in this situation 
            // is to insert the generate the name of form #&lt;Class:01xasdfasd&gt; if 
            // it's a singleton module/class, which this code accomplishes.
<span class="fc bfc" id="L511" title="All 2 branches covered.">            if(pName == null) {</span>
<span class="fc" id="L512">                cache = false;</span>
<span class="fc" id="L513">                pName = p.getName();</span>
             }
            
<span class="fc" id="L516">            parentNames[i] = pName;</span>
<span class="fc" id="L517">            totalLength += pName.length();</span>
        }
        
        // Then build from the front using a StringBuilder
<span class="fc" id="L521">        StringBuilder builder = new StringBuilder(totalLength);</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">        for (String parentName : parentNames) {</span>
<span class="fc" id="L523">            builder.append(parentName).append(&quot;::&quot;);</span>
        }
<span class="fc" id="L525">        builder.append(name);</span>
        
<span class="fc" id="L527">        String fullName = builder.toString();</span>

<span class="fc bfc" id="L529" title="All 2 branches covered.">        if (cache) cachedName = fullName;</span>

<span class="fc" id="L531">        return fullName;</span>
    }

    private String calculateAnonymousName() {
<span class="fc bfc" id="L535" title="All 2 branches covered.">        if (anonymousName == null) {</span>
            // anonymous classes get the #&lt;Class:0xdeadbeef&gt; format
<span class="fc" id="L537">            StringBuilder anonBase = new StringBuilder(&quot;#&lt;&quot; + metaClass.getRealClass().getName() + &quot;:0x&quot;);</span>
<span class="fc" id="L538">            anonBase.append(Integer.toHexString(System.identityHashCode(this))).append('&gt;');</span>
<span class="fc" id="L539">            anonymousName = anonBase.toString();</span>
        }
<span class="fc" id="L541">        return anonymousName;</span>
    }

    /**
     * Create a wrapper to use for including the specified module into this one.
     * 
     * Ruby C equivalent = &quot;include_class_new&quot;
     * 
     * @return The module wrapper
     */
    @Deprecated
    public IncludedModuleWrapper newIncludeClass(RubyClass superClazz) {
<span class="nc" id="L553">        IncludedModuleWrapper includedModule = new IncludedModuleWrapper(getRuntime(), superClazz, this);</span>

        // include its parent (and in turn that module's parents)
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (getSuperClass() != null) {</span>
<span class="nc" id="L557">            includedModule.includeModule(getSuperClass());</span>
        }

<span class="nc" id="L560">        return includedModule;</span>
    }
    /**
     * Finds a class that is within the current module (or class).
     * 
     * @param name to be found in this module (or class)
     * @return the class or null if no such class
     */
    public RubyClass getClass(String name) {
        IRubyObject module;
<span class="fc bfc" id="L570" title="All 2 branches covered.">        if ((module = getConstantAt(name)) instanceof RubyClass) {</span>
<span class="fc" id="L571">            return (RubyClass)module;</span>
        }
<span class="fc" id="L573">        return null;</span>
    }

    @Deprecated
    public RubyClass fastGetClass(String internedName) {
<span class="nc" id="L578">        return getClass(internedName);</span>
    }

    /**
     * Prepend a new module to this module or class.
     *
     * @param arg The module to include
     */
    public synchronized void prependModule(IRubyObject arg) {
<span class="pc bpc" id="L587" title="3 of 4 branches missed.">        assert arg != null;</span>

<span class="fc" id="L589">        testFrozen(&quot;module&quot;);</span>

<span class="pc bpc" id="L591" title="1 of 2 branches missed.">        if (!(arg instanceof RubyModule)) {</span>
<span class="nc" id="L592">            throw getRuntime().newTypeError(&quot;Wrong argument type &quot; + arg.getMetaClass().getName() +</span>
                    &quot; (expected Module).&quot;);
        }

<span class="fc" id="L596">        RubyModule module = (RubyModule) arg;</span>

        // Make sure the module we include does not already exist
<span class="fc" id="L599">        checkForCyclicInclude(module);</span>

<span class="pc bpc" id="L601" title="1 of 2 branches missed.">        if (hasModuleInHierarchy((RubyModule)arg)) {</span>
<span class="nc" id="L602">            invalidateCacheDescendants();</span>
<span class="nc" id="L603">            return;</span>
        }

<span class="fc" id="L606">        infectBy(module);</span>

<span class="fc" id="L608">        doPrependModule(module);</span>

<span class="fc" id="L610">        invalidateCoreClasses();</span>
<span class="fc" id="L611">        invalidateCacheDescendants();</span>
<span class="fc" id="L612">        invalidateConstantCacheForModuleInclusion(module);</span>
<span class="fc" id="L613">    }</span>

    /**
     * Include a new module in this module or class.
     * 
     * @param arg The module to include
     */
    public synchronized void includeModule(IRubyObject arg) {
<span class="pc bpc" id="L621" title="3 of 4 branches missed.">        assert arg != null;</span>

<span class="fc" id="L623">        testFrozen(&quot;module&quot;);</span>

<span class="pc bpc" id="L625" title="1 of 2 branches missed.">        if (!(arg instanceof RubyModule)) {</span>
<span class="nc" id="L626">            throw getRuntime().newTypeError(&quot;Wrong argument type &quot; + arg.getMetaClass().getName() +</span>
                    &quot; (expected Module).&quot;);
        }

<span class="fc" id="L630">        RubyModule module = (RubyModule) arg;</span>

        // Make sure the module we include does not already exist
<span class="fc" id="L633">        checkForCyclicInclude(module);</span>

<span class="pc bpc" id="L635" title="1 of 2 branches missed.">        if (hasModuleInPrepends(((RubyModule)arg).getNonIncludedClass())) {</span>
<span class="nc" id="L636">            invalidateCacheDescendants();</span>
<span class="nc" id="L637">            return;</span>
        }

<span class="fc" id="L640">        infectBy(module);</span>

<span class="fc" id="L642">        doIncludeModule(module);</span>
<span class="fc" id="L643">        invalidateCoreClasses();</span>
<span class="fc" id="L644">        invalidateCacheDescendants();</span>
<span class="fc" id="L645">        invalidateConstantCacheForModuleInclusion(module);</span>
<span class="fc" id="L646">    }</span>
    
    public void defineAnnotatedMethod(Class clazz, String name) {
        // FIXME: This is probably not very efficient, since it loads all methods for each call
<span class="nc" id="L650">        boolean foundMethod = false;</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">        for (Method method : clazz.getDeclaredMethods()) {</span>
<span class="nc bnc" id="L652" title="All 4 branches missed.">            if (method.getName().equals(name) &amp;&amp; defineAnnotatedMethod(method, MethodFactory.createFactory(getRuntime().getJRubyClassLoader()))) {</span>
<span class="nc" id="L653">                foundMethod = true;</span>
            }
        }

<span class="nc bnc" id="L657" title="All 2 branches missed.">        if (!foundMethod) {</span>
<span class="nc" id="L658">            throw new RuntimeException(&quot;No JRubyMethod present for method &quot; + name + &quot;on class &quot; + clazz.getName());</span>
        }
<span class="nc" id="L660">    }</span>
    
    public void defineAnnotatedConstants(Class clazz) {
<span class="fc" id="L663">        Field[] declaredFields = clazz.getDeclaredFields();</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">        for (Field field : declaredFields) {</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">            if (Modifier.isStatic(field.getModifiers())) {</span>
<span class="fc" id="L666">                defineAnnotatedConstant(field);</span>
            }
        }
<span class="fc" id="L669">    }</span>

    public boolean defineAnnotatedConstant(Field field) {
<span class="fc" id="L672">        JRubyConstant jrubyConstant = field.getAnnotation(JRubyConstant.class);</span>

<span class="fc bfc" id="L674" title="All 2 branches covered.">        if (jrubyConstant == null) return false;</span>

<span class="fc" id="L676">        String[] names = jrubyConstant.value();</span>
<span class="pc bpc" id="L677" title="1 of 2 branches missed.">        if(names.length == 0) {</span>
<span class="fc" id="L678">            names = new String[]{field.getName()};</span>
        }

<span class="fc" id="L681">        Class tp = field.getType();</span>
        IRubyObject realVal;

        try {
<span class="pc bpc" id="L685" title="10 of 12 branches missed.">            if(tp == Integer.class || tp == Integer.TYPE || tp == Short.class || tp == Short.TYPE || tp == Byte.class || tp == Byte.TYPE) {</span>
<span class="fc" id="L686">                realVal = RubyNumeric.int2fix(getRuntime(), field.getInt(null));</span>
<span class="nc bnc" id="L687" title="All 4 branches missed.">            } else if(tp == Boolean.class || tp == Boolean.TYPE) {</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">                realVal = field.getBoolean(null) ? getRuntime().getTrue() : getRuntime().getFalse();</span>
            } else {
<span class="nc" id="L690">                realVal = getRuntime().getNil();</span>
            }
<span class="nc" id="L692">        } catch(Exception e) {</span>
<span class="nc" id="L693">            realVal = getRuntime().getNil();</span>
<span class="fc" id="L694">        }</span>

        
<span class="fc bfc" id="L697" title="All 2 branches covered.">        for(String name : names) {</span>
<span class="fc" id="L698">            this.setConstant(name, realVal);</span>
        }

<span class="fc" id="L701">        return true;</span>
    }

    @Extension
    public void defineAnnotatedMethods(Class clazz) {
<span class="fc" id="L706">        defineAnnotatedMethodsIndividually(clazz);</span>
<span class="fc" id="L707">    }</span>
    
<span class="fc" id="L709">    public static class MethodClumper {</span>
<span class="fc" id="L710">        Map&lt;String, List&lt;JavaMethodDescriptor&gt;&gt; annotatedMethods = new HashMap&lt;String, List&lt;JavaMethodDescriptor&gt;&gt;();</span>
<span class="fc" id="L711">        Map&lt;String, List&lt;JavaMethodDescriptor&gt;&gt; staticAnnotatedMethods = new HashMap&lt;String, List&lt;JavaMethodDescriptor&gt;&gt;();</span>
<span class="fc" id="L712">        Map&lt;String, List&lt;JavaMethodDescriptor&gt;&gt; allAnnotatedMethods = new HashMap&lt;String, List&lt;JavaMethodDescriptor&gt;&gt;();</span>
        
        public void clump(Class cls) {
<span class="fc" id="L715">            Method[] declaredMethods = cls.getDeclaredMethods();</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">            for (Method method: declaredMethods) {</span>
<span class="fc" id="L717">                JRubyMethod anno = method.getAnnotation(JRubyMethod.class);</span>

<span class="fc bfc" id="L719" title="All 2 branches covered.">                if (anno == null) continue;</span>

                // skip bridge methods, as generated by JDK8 javac for e.g. return-value overloaded methods
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">                if (method.isBridge()) continue;</span>
                
<span class="fc" id="L724">                JavaMethodDescriptor desc = new JavaMethodDescriptor(method);</span>
                
<span class="fc bfc" id="L726" title="All 2 branches covered.">                String name = anno.name().length == 0 ? method.getName() : anno.name()[0];</span>
                
                List&lt;JavaMethodDescriptor&gt; methodDescs;
                Map&lt;String, List&lt;JavaMethodDescriptor&gt;&gt; methodsHash;
<span class="fc bfc" id="L730" title="All 2 branches covered.">                if (desc.isStatic) {</span>
<span class="fc" id="L731">                    methodsHash = staticAnnotatedMethods;</span>
                } else {
<span class="fc" id="L733">                    methodsHash = annotatedMethods;</span>
                }

                // add to specific
<span class="fc" id="L737">                methodDescs = methodsHash.get(name);</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">                if (methodDescs == null) {</span>
<span class="fc" id="L739">                    methodDescs = new ArrayList&lt;JavaMethodDescriptor&gt;();</span>
<span class="fc" id="L740">                    methodsHash.put(name, methodDescs);</span>
                } else {
<span class="fc" id="L742">                    CompatVersion oldCompat = methodDescs.get(0).anno.compat();</span>
<span class="fc" id="L743">                    CompatVersion newCompat = desc.anno.compat();</span>

<span class="fc" id="L745">                    int comparison = newCompat.compareTo(oldCompat);</span>
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">                    if (comparison == 1) {</span>
                        // new method's compat is higher than old method's, so we throw old one away
<span class="nc" id="L748">                        methodDescs = new ArrayList&lt;JavaMethodDescriptor&gt;();</span>
<span class="nc" id="L749">                        methodsHash.put(name, methodDescs);</span>
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">                    } else if (comparison == 0) {</span>
                        // same compat version, proceed to adding additional method
                    } else {
                        // lower compat, skip this method
                        continue;
                    }
                }
                
<span class="fc" id="L758">                methodDescs.add(desc);</span>

                // add to general
<span class="fc" id="L761">                methodDescs = allAnnotatedMethods.get(name);</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">                if (methodDescs == null) {</span>
<span class="fc" id="L763">                    methodDescs = new ArrayList&lt;JavaMethodDescriptor&gt;();</span>
<span class="fc" id="L764">                    allAnnotatedMethods.put(name, methodDescs);</span>
                }

<span class="fc" id="L767">                methodDescs.add(desc);</span>
            }
<span class="fc" id="L769">        }</span>

        public Map&lt;String, List&lt;JavaMethodDescriptor&gt;&gt; getAllAnnotatedMethods() {
<span class="fc" id="L772">            return allAnnotatedMethods;</span>
        }

        public Map&lt;String, List&lt;JavaMethodDescriptor&gt;&gt; getAnnotatedMethods() {
<span class="fc" id="L776">            return annotatedMethods;</span>
        }

        public Map&lt;String, List&lt;JavaMethodDescriptor&gt;&gt; getStaticAnnotatedMethods() {
<span class="fc" id="L780">            return staticAnnotatedMethods;</span>
        }
    }
    
    public void defineAnnotatedMethodsIndividually(Class clazz) {
        TypePopulator populator;
        
<span class="pc bpc" id="L787" title="2 of 4 branches missed.">        if (RubyInstanceConfig.FULL_TRACE_ENABLED || RubyInstanceConfig.REFLECTED_HANDLES) {</span>
            // we want reflected invokers or need full traces, use default (slow) populator
            if (DEBUG) LOG.info(&quot;trace mode, using default populator&quot;);
<span class="nc" id="L790">            populator = TypePopulator.DEFAULT;</span>
        } else {
            try {
<span class="fc" id="L793">                String qualifiedName = &quot;org.jruby.gen.&quot; + clazz.getCanonicalName().replace('.', '$');</span>

                if (DEBUG) LOG.info(&quot;looking for &quot; + qualifiedName + AnnotationBinder.POPULATOR_SUFFIX);

<span class="fc" id="L797">                Class populatorClass = Class.forName(qualifiedName + AnnotationBinder.POPULATOR_SUFFIX);</span>
<span class="fc" id="L798">                populator = (TypePopulator)populatorClass.newInstance();</span>
<span class="fc" id="L799">            } catch (Throwable t) {</span>
                if (DEBUG) LOG.info(&quot;Could not find it, using default populator&quot;);
<span class="fc" id="L801">                populator = TypePopulator.DEFAULT;</span>
<span class="fc" id="L802">            }</span>
        }
        
<span class="fc" id="L805">        populator.populate(this, clazz);</span>
<span class="fc" id="L806">    }</span>
    
    public boolean defineAnnotatedMethod(String name, List&lt;JavaMethodDescriptor&gt; methods, MethodFactory methodFactory) {
<span class="fc" id="L809">        JavaMethodDescriptor desc = methods.get(0);</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">        if (methods.size() == 1) {</span>
<span class="fc" id="L811">            return defineAnnotatedMethod(name, desc, methodFactory);</span>
        } else {
<span class="fc" id="L813">            DynamicMethod dynamicMethod = methodFactory.getAnnotatedMethod(this, methods);</span>
<span class="fc" id="L814">            define(this, desc, name, dynamicMethod);</span>

<span class="fc" id="L816">            return true;</span>
        }
    }
    
    public boolean defineAnnotatedMethod(Method method, MethodFactory methodFactory) { 
<span class="nc" id="L821">        JRubyMethod jrubyMethod = method.getAnnotation(JRubyMethod.class);</span>

<span class="nc bnc" id="L823" title="All 2 branches missed.">        if (jrubyMethod == null) return false;</span>

<span class="nc" id="L825">        JavaMethodDescriptor desc = new JavaMethodDescriptor(method);</span>
<span class="nc" id="L826">        DynamicMethod dynamicMethod = methodFactory.getAnnotatedMethod(this, desc);</span>
<span class="nc" id="L827">        define(this, desc, method.getName(), dynamicMethod);</span>

<span class="nc" id="L829">        return true;</span>
    }
    
    public boolean defineAnnotatedMethod(String name, JavaMethodDescriptor desc, MethodFactory methodFactory) { 
<span class="fc" id="L833">        JRubyMethod jrubyMethod = desc.anno;</span>

<span class="pc bpc" id="L835" title="1 of 2 branches missed.">        if (jrubyMethod == null) return false;</span>

<span class="fc" id="L837">        DynamicMethod dynamicMethod = methodFactory.getAnnotatedMethod(this, desc);</span>
<span class="fc" id="L838">        define(this, desc, name, dynamicMethod);</span>

<span class="fc" id="L840">        return true;</span>
    }

    public void undefineMethod(String name) {
<span class="fc" id="L844">        methodLocation.addMethod(name, UndefinedMethod.getInstance());</span>
<span class="fc" id="L845">    }</span>

    /** rb_undef
     *
     */
    public void undef(ThreadContext context, String name) {
<span class="fc" id="L851">        Ruby runtime = context.runtime;</span>

<span class="fc" id="L853">        testFrozen(&quot;module&quot;);</span>
<span class="pc bpc" id="L854" title="3 of 6 branches missed.">        if (name.equals(&quot;__id__&quot;) || name.equals(&quot;__send__&quot;) || name.equals(&quot;object_id&quot;)) {</span>
<span class="nc" id="L855">            runtime.getWarnings().warn(ID.UNDEFINING_BAD, &quot;undefining `&quot;+ name +&quot;' may cause serious problem&quot;);</span>
        }

<span class="pc bpc" id="L858" title="1 of 2 branches missed.">        if (name.equals(&quot;method_missing&quot;)) {</span>

            try {
<span class="nc" id="L861">                removeMethod(context, name);</span>
<span class="nc" id="L862">            } catch (RaiseException t) {</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">                if(!(t.getException() instanceof RubyNameError)) {</span>
<span class="nc" id="L864">                    throw t;</span>
                }
<span class="nc" id="L866">            }</span>
<span class="nc" id="L867">            return;</span>
        }

<span class="fc" id="L870">        DynamicMethod method = searchMethod(name);</span>
<span class="fc bfc" id="L871" title="All 2 branches covered.">        if (method.isUndefined()) {</span>
<span class="fc" id="L872">            String s0 = &quot; class&quot;;</span>
<span class="fc" id="L873">            RubyModule c = this;</span>

<span class="pc bpc" id="L875" title="1 of 2 branches missed.">            if (c.isSingleton()) {</span>
<span class="nc" id="L876">                IRubyObject obj = ((MetaClass)c).getAttached();</span>

<span class="nc bnc" id="L878" title="All 4 branches missed.">                if (obj != null &amp;&amp; obj instanceof RubyModule) {</span>
<span class="nc" id="L879">                    c = (RubyModule) obj;</span>
<span class="nc" id="L880">                    s0 = &quot;&quot;;</span>
                }
<span class="pc bpc" id="L882" title="1 of 2 branches missed.">            } else if (c.isModule()) {</span>
<span class="fc" id="L883">                s0 = &quot; module&quot;;</span>
            }

<span class="fc" id="L886">            throw runtime.newNameError(&quot;Undefined method &quot; + name + &quot; for&quot; + s0 + &quot; '&quot; + c.getName() + &quot;'&quot;, name);</span>
        }
<span class="fc" id="L888">        methodLocation.addMethod(name, UndefinedMethod.getInstance());</span>
        
<span class="fc bfc" id="L890" title="All 2 branches covered.">        if (isSingleton()) {</span>
<span class="fc" id="L891">            IRubyObject singleton = ((MetaClass)this).getAttached(); </span>
<span class="fc" id="L892">            singleton.callMethod(context, &quot;singleton_method_undefined&quot;, runtime.newSymbol(name));</span>
<span class="fc" id="L893">        } else {</span>
<span class="fc" id="L894">            callMethod(context, &quot;method_undefined&quot;, runtime.newSymbol(name));</span>
        }
<span class="fc" id="L896">    }</span>

    @JRubyMethod(name = &quot;include?&quot;, required = 1)
    public IRubyObject include_p(ThreadContext context, IRubyObject arg) {
<span class="fc bfc" id="L900" title="All 2 branches covered.">        if (!arg.isModule()) {</span>
<span class="fc" id="L901">            throw context.runtime.newTypeError(arg, context.runtime.getModule());</span>
        }
<span class="fc" id="L903">        RubyModule moduleToCompare = (RubyModule) arg;</span>

        // See if module is in chain...Cannot match against itself so start at superClass.
<span class="fc bfc" id="L906" title="All 2 branches covered.">        for (RubyModule p = getSuperClass(); p != null; p = p.getSuperClass()) {</span>
<span class="fc bfc" id="L907" title="All 2 branches covered.">            if (p.isSame(moduleToCompare)) {</span>
<span class="fc" id="L908">                return context.runtime.getTrue();</span>
            }
        }

<span class="fc" id="L912">        return context.runtime.getFalse();</span>
    }

    @JRubyMethod(name = &quot;singleton_class?&quot;)
    public IRubyObject singleton_class_p(ThreadContext context) {
<span class="fc" id="L917">        return context.runtime.newBoolean(isSingleton());</span>
    }

    // TODO: Consider a better way of synchronizing 
    public void addMethod(String name, DynamicMethod method) {
<span class="fc" id="L922">        testFrozen(&quot;class/module&quot;);</span>

<span class="fc bfc" id="L924" title="All 2 branches covered.">        if (this instanceof MetaClass) {</span>
            // FIXME: Gross and not quite right. See MRI's rb_frozen_class_p logic
<span class="fc" id="L926">            RubyBasicObject attached = (RubyBasicObject)((MetaClass)this).getAttached();</span>
<span class="fc" id="L927">            attached.testFrozen();</span>
        }

<span class="fc" id="L930">        addMethodInternal(name, method);</span>
<span class="fc" id="L931">    }</span>

    public void addMethodInternal(String name, DynamicMethod method) {
<span class="fc" id="L934">        synchronized(methodLocation.getMethodsForWrite()) {</span>
<span class="fc" id="L935">            addMethodAtBootTimeOnly(name, method);</span>
<span class="fc" id="L936">            invalidateCoreClasses();</span>
<span class="fc" id="L937">            invalidateCacheDescendants();</span>
<span class="pc" id="L938">        }</span>
<span class="fc" id="L939">    }</span>

    /**
     * This method is not intended for use by normal users; it is a fast-path
     * method that skips synchronization and hierarchy invalidation to speed
     * boot-time method definition.
     *
     * @param name The name to which to bind the method
     * @param method The method to bind
     */
    public void addMethodAtBootTimeOnly(String name, DynamicMethod method) {
<span class="fc bfc" id="L950" title="All 2 branches covered.">        if (hasPrepends()) method = new WrapperMethod(methodLocation, method, method.getVisibility());</span>

<span class="fc" id="L952">        methodLocation.getMethodsForWrite().put(name, method);</span>

<span class="fc" id="L954">        getRuntime().addProfiledMethod(name, method);</span>
<span class="fc" id="L955">    }</span>

    public void removeMethod(ThreadContext context, String name) {
<span class="fc" id="L958">        Ruby runtime = context.runtime;</span>

<span class="fc" id="L960">        testFrozen(&quot;class/module&quot;);</span>

<span class="pc bpc" id="L962" title="3 of 6 branches missed.">        if(name.equals(&quot;object_id&quot;) || name.equals(&quot;__send__&quot;) || name.equals(&quot;initialize&quot;)) {</span>
<span class="nc" id="L963">            runtime.getWarnings().warn(ID.UNDEFINING_BAD, &quot;removing `&quot; + name + &quot;' may cause serious problems&quot;);</span>
        }

        // We can safely reference methods here instead of doing getMethods() since if we
        // are adding we are not using a IncludedModule.
<span class="fc" id="L968">        synchronized(methodLocation.getMethodsForWrite()) {</span>
<span class="fc" id="L969">            DynamicMethod method = (DynamicMethod) methodLocation.getMethodsForWrite().remove(name);</span>
<span class="fc bfc" id="L970" title="All 2 branches covered.">            if (method == null) {</span>
<span class="fc" id="L971">                throw runtime.newNameError(&quot;method '&quot; + name + &quot;' not defined in &quot; + getName(), name);</span>
            }

<span class="fc" id="L974">            invalidateCoreClasses();</span>
<span class="fc" id="L975">            invalidateCacheDescendants();</span>
<span class="fc" id="L976">        }</span>
        
<span class="fc bfc" id="L978" title="All 2 branches covered.">        if (isSingleton()) {</span>
<span class="fc" id="L979">            IRubyObject singleton = ((MetaClass)this).getAttached(); </span>
<span class="fc" id="L980">            singleton.callMethod(context, &quot;singleton_method_removed&quot;, runtime.newSymbol(name));</span>
<span class="fc" id="L981">        } else {</span>
<span class="fc" id="L982">            callMethod(context, &quot;method_removed&quot;, runtime.newSymbol(name));</span>
        }
<span class="fc" id="L984">    }</span>

    /**
     * Search through this module and supermodules for method definitions. Cache superclass definitions in this class.
     * 
     * @param name The name of the method to search for
     * @return The method, or UndefinedMethod if not found
     */    
    public DynamicMethod searchMethod(String name) {
<span class="fc" id="L993">        return searchWithCache(name).method;</span>
    }

    public CacheEntry searchWithCache(String name) {
<span class="fc" id="L997">        return searchWithCache(name, true);</span>
    }
        
    /**
     * Search through this module and supermodules for method definitions. Cache superclass definitions in this class.
     * 
     * @param name The name of the method to search for
     * @param cacheUndef Flag for caching UndefinedMethod. This should normally be true.
     * @return The method, or UndefinedMethod if not found
     */    
    public CacheEntry searchWithCache(String name, boolean cacheUndef) {
<span class="fc" id="L1008">        CacheEntry entry = cacheHit(name);</span>

<span class="fc bfc" id="L1010" title="All 2 branches covered.">        if (entry != null) return entry;</span>

        // we grab serial number first; the worst that will happen is we cache a later
        // update with an earlier serial number, which would just flush anyway
<span class="fc" id="L1014">        int token = getGeneration();</span>
<span class="fc" id="L1015">        DynamicMethod method = searchMethodInner(name);</span>

<span class="pc bpc" id="L1017" title="1 of 2 branches missed.">        if (method instanceof CacheableMethod) {</span>
<span class="nc" id="L1018">            method = ((CacheableMethod) method).getMethodForCaching();</span>
        }

<span class="pc bpc" id="L1021" title="1 of 4 branches missed.">        return method != null ? addToCache(name, method, token) : cacheUndef ? addToCache(name, UndefinedMethod.getInstance(), token) : cacheEntryFactory.newCacheEntry(name, method, token);</span>
    }

    @Deprecated
    public final int getCacheToken() {
<span class="nc" id="L1026">        return generation;</span>
    }
    
    public final int getGeneration() {
<span class="fc" id="L1030">        return generation;</span>
    }

    public final Integer getGenerationObject() {
<span class="nc" id="L1034">        return generationObject;</span>
    }

    private final Map&lt;String, CacheEntry&gt; getCachedMethods() {
<span class="fc" id="L1038">        return this.cachedMethods;</span>
    }

    private final Map&lt;String, CacheEntry&gt; getCachedMethodsForWrite() {
<span class="fc" id="L1042">        Map&lt;String, CacheEntry&gt; myCachedMethods = this.cachedMethods;</span>
<span class="fc bfc" id="L1043" title="All 2 branches covered.">        return myCachedMethods == Collections.EMPTY_MAP ?</span>
            this.cachedMethods = new ConcurrentHashMap&lt;String, CacheEntry&gt;(0, 0.75f, 1) :
            myCachedMethods;
    }
    
    private CacheEntry cacheHit(String name) {
<span class="fc" id="L1049">        CacheEntry cacheEntry = getCachedMethods().get(name);</span>

<span class="fc bfc" id="L1051" title="All 2 branches covered.">        if (cacheEntry != null) {</span>
<span class="fc bfc" id="L1052" title="All 2 branches covered.">            if (cacheEntry.token == getGeneration()) {</span>
<span class="fc" id="L1053">                return cacheEntry;</span>
            }
        }
        
<span class="fc" id="L1057">        return null;</span>
    }

    private void invalidateConstantCacheForModuleInclusion(RubyModule module)
    {
<span class="fc bfc" id="L1062" title="All 2 branches covered.">        for (RubyModule mod : gatherModules(module)) {</span>
<span class="fc bfc" id="L1063" title="All 2 branches covered.">            for (String key : mod.getConstantMap().keySet()) {</span>
<span class="fc" id="L1064">                invalidateConstantCache(key);</span>
<span class="fc" id="L1065">            }</span>
<span class="fc" id="L1066">        }</span>
<span class="fc" id="L1067">    }</span>
    
<span class="fc" id="L1069">    protected static abstract class CacheEntryFactory {</span>
        public abstract CacheEntry newCacheEntry(String name,DynamicMethod method, int token);

        /**
         * Test all WrapperCacheEntryFactory instances in the chain for assignability
         * from the given class.
         *
         * @param cacheEntryFactoryClass the class from which to test assignability
         * @return whether the given class is assignable from any factory in the chain
         */
        public boolean hasCacheEntryFactory(Class cacheEntryFactoryClass) {
<span class="fc" id="L1080">            CacheEntryFactory current = this;</span>
<span class="pc bpc" id="L1081" title="1 of 2 branches missed.">            while (current instanceof WrapperCacheEntryFactory) {</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">                if (cacheEntryFactoryClass.isAssignableFrom(current.getClass())) {</span>
<span class="nc" id="L1083">                    return true;</span>
                }
<span class="nc" id="L1085">                current = ((WrapperCacheEntryFactory)current).getPrevious();</span>
            }

<span class="fc" id="L1088">            return cacheEntryFactoryClass.isAssignableFrom(current.getClass());</span>
        }
    }

    /**
     * A wrapper CacheEntryFactory, for delegating cache entry creation along a chain.
     */
    protected static abstract class WrapperCacheEntryFactory extends CacheEntryFactory {
        /** The CacheEntryFactory being wrapped. */
        protected final CacheEntryFactory previous;

        /**
         * Construct a new WrapperCacheEntryFactory using the given CacheEntryFactory as
         * the &quot;previous&quot; wrapped factory.
         *
         * @param previous the wrapped factory
         */
<span class="nc" id="L1105">        public WrapperCacheEntryFactory(CacheEntryFactory previous) {</span>
<span class="nc" id="L1106">            this.previous = previous;</span>
<span class="nc" id="L1107">        }</span>

        public CacheEntryFactory getPrevious() {
<span class="nc" id="L1110">            return previous;</span>
        }
    }

<span class="fc" id="L1114">    protected static final CacheEntryFactory NormalCacheEntryFactory = new CacheEntryFactory() {</span>
        @Override
        public CacheEntry newCacheEntry(String name, DynamicMethod method, int token) {
<span class="fc" id="L1117">            return new CacheEntry(method, token);</span>
        }
    };

    protected static class SynchronizedCacheEntryFactory extends WrapperCacheEntryFactory {
        public SynchronizedCacheEntryFactory(CacheEntryFactory previous) {
<span class="nc" id="L1123">            super(previous);</span>
<span class="nc" id="L1124">        }</span>
        @Override
        public CacheEntry newCacheEntry(String name,DynamicMethod method, int token) {
<span class="nc bnc" id="L1127" title="All 2 branches missed.">            if (method.isUndefined()) {</span>
<span class="nc" id="L1128">                return new CacheEntry(method, token);</span>
            }
            // delegate up the chain
<span class="nc" id="L1131">            CacheEntry delegated = previous.newCacheEntry(name,method, token);</span>
<span class="nc" id="L1132">            return new CacheEntry(new SynchronizedDynamicMethod(delegated.method), delegated.token);</span>
        }
    }

    protected static class ProfilingCacheEntryFactory extends WrapperCacheEntryFactory {

        private final MethodEnhancer enhancer;

        public ProfilingCacheEntryFactory( Ruby runtime, CacheEntryFactory previous) {
<span class="nc" id="L1141">            super(previous);</span>
<span class="nc" id="L1142">            this.enhancer = runtime.getProfilingService().newMethodEnhancer( runtime );</span>
<span class="nc" id="L1143">        }</span>

        private MethodEnhancer getMethodEnhancer() {
<span class="nc" id="L1146">            return enhancer;</span>
        }

        @Override
        public CacheEntry newCacheEntry(String name, DynamicMethod method, int token) {
<span class="nc bnc" id="L1151" title="All 2 branches missed.">            if (method.isUndefined()) {</span>
<span class="nc" id="L1152">                return new CacheEntry(method, token);</span>
            }
<span class="nc" id="L1154">            CacheEntry delegated = previous.newCacheEntry(name, method, token);</span>
<span class="nc" id="L1155">            DynamicMethod enhancedMethod = getMethodEnhancer().enhance( name, delegated.method );</span>
<span class="nc" id="L1156">            return new CacheEntry( enhancedMethod, delegated.token );</span>
        }
    }

    private volatile CacheEntryFactory cacheEntryFactory;

    // modifies this class only; used to make the Synchronized module synchronized
    public void becomeSynchronized() {
<span class="nc" id="L1164">        cacheEntryFactory = new SynchronizedCacheEntryFactory(cacheEntryFactory);</span>
<span class="nc" id="L1165">    }</span>

    public boolean isSynchronized() {
<span class="fc" id="L1168">        return cacheEntryFactory.hasCacheEntryFactory(SynchronizedCacheEntryFactory.class);</span>
    }

    private CacheEntry addToCache(String name, DynamicMethod method, int token) {
<span class="fc" id="L1172">        CacheEntry entry = cacheEntryFactory.newCacheEntry(name, method, token);</span>
<span class="fc" id="L1173">        methodLocation.getCachedMethodsForWrite().put(name, entry);</span>

<span class="fc" id="L1175">        return entry;</span>
    }
    
    public DynamicMethod searchMethodInner(String name) {
        // This flattens some of the recursion that would be otherwise be necessary.
        // Used to recurse up the class hierarchy which got messy with prepend.
<span class="fc bfc" id="L1181" title="All 2 branches covered.">        for (RubyModule module = this; module != null; module = module.getSuperClass()) {</span>
            // Only recurs if module is an IncludedModuleWrapper.
            // This way only the recursion needs to be handled differently on
            // IncludedModuleWrapper.
<span class="fc" id="L1185">            DynamicMethod method = module.searchMethodCommon(name);</span>
<span class="fc bfc" id="L1186" title="All 4 branches covered.">            if (method != null) return method.isNull() ? null : method;</span>
        }
<span class="fc" id="L1188">        return null;</span>
    }

    // The local method resolution logic. Overridden in IncludedModuleWrapper for recursion.
    protected DynamicMethod searchMethodCommon(String name) {
<span class="fc" id="L1193">        return getMethods().get(name);</span>
    }

    public void invalidateCacheDescendants() {
        if (DEBUG) LOG.debug(&quot;invalidating descendants: {}&quot;, baseName);

<span class="fc bfc" id="L1199" title="All 2 branches covered.">        if (includingHierarchies.isEmpty()) {</span>
            // it's only us; just invalidate directly
<span class="fc" id="L1201">            methodInvalidator.invalidate();</span>
<span class="fc" id="L1202">            return;</span>
        }

<span class="fc" id="L1205">        List&lt;Invalidator&gt; invalidators = new ArrayList&lt;Invalidator&gt;();</span>
<span class="fc" id="L1206">        invalidators.add(methodInvalidator);</span>
        
<span class="fc" id="L1208">        synchronized (getRuntime().getHierarchyLock()) {</span>
<span class="fc bfc" id="L1209" title="All 2 branches covered.">            for (RubyClass includingHierarchy : includingHierarchies) {</span>
<span class="fc" id="L1210">                includingHierarchy.addInvalidatorsAndFlush(invalidators);</span>
<span class="fc" id="L1211">            }</span>
<span class="pc" id="L1212">        }</span>
        
<span class="fc" id="L1214">        methodInvalidator.invalidateAll(invalidators);</span>
<span class="fc" id="L1215">    }</span>
    
    protected void invalidateCoreClasses() {
<span class="fc bfc" id="L1218" title="All 2 branches covered.">        if (!getRuntime().isBootingCore()) {</span>
<span class="fc bfc" id="L1219" title="All 2 branches covered.">            if (this == getRuntime().getFixnum()) {</span>
<span class="fc" id="L1220">                getRuntime().reopenFixnum();</span>
<span class="pc bpc" id="L1221" title="1 of 2 branches missed.">            } else if (this == getRuntime().getFloat()) {</span>
<span class="nc" id="L1222">                getRuntime().reopenFloat();</span>
            }
        }
<span class="fc" id="L1225">    }</span>
    
    public Invalidator getInvalidator() {
<span class="nc" id="L1228">        return methodInvalidator;</span>
    }
    
    public void updateGeneration() {
<span class="fc" id="L1232">        generationObject = generation = getRuntime().getNextModuleGeneration();</span>
<span class="fc" id="L1233">    }</span>

    @Deprecated
    protected void invalidateCacheDescendantsInner() {
<span class="nc" id="L1237">        methodInvalidator.invalidate();</span>
<span class="nc" id="L1238">    }</span>
    
    protected void invalidateConstantCache(String constantName) {
<span class="fc" id="L1241">        getRuntime().getConstantInvalidator(constantName).invalidate();</span>
<span class="fc" id="L1242">    }    </span>

    /**
     * Search through this module and supermodules for method definitions. Cache superclass definitions in this class.
     * 
     * @param name The name of the method to search for
     * @return The method, or UndefinedMethod if not found
     */
    public DynamicMethod retrieveMethod(String name) {
<span class="nc" id="L1251">        return getMethods().get(name);</span>
    }

    /**
     * Find the given class in this hierarchy, considering modules along the way.
     * 
     * @param clazz the class to find
     * @return The method, or UndefinedMethod if not found
     */
    public RubyModule findImplementer(RubyModule clazz) {
<span class="pc bpc" id="L1261" title="1 of 2 branches missed.">        for (RubyModule module = this; module != null; module = module.getSuperClass()) {</span>
<span class="fc bfc" id="L1262" title="All 2 branches covered.">            if (module.isSame(clazz)) return module;</span>
        }

<span class="nc" id="L1265">        return null;</span>
    }

    public void addModuleFunction(String name, DynamicMethod method) {
<span class="nc" id="L1269">        addMethod(name, method);</span>
<span class="nc" id="L1270">        getSingletonClass().addMethod(name, method);</span>
<span class="nc" id="L1271">    }</span>

    /** rb_alias
     *
     */
    public synchronized void defineAlias(String name, String oldName) {
<span class="fc" id="L1277">        testFrozen(&quot;module&quot;);</span>
<span class="fc bfc" id="L1278" title="All 2 branches covered.">        if (oldName.equals(name)) return;</span>

<span class="fc" id="L1280">        DynamicMethod method = searchForAliasMethod(getRuntime(), oldName);</span>

<span class="fc" id="L1282">        putMethod(name, new AliasMethod(this, method, oldName));</span>

<span class="fc" id="L1284">        methodLocation.invalidateCoreClasses();</span>
<span class="fc" id="L1285">        methodLocation.invalidateCacheDescendants();</span>
<span class="fc" id="L1286">    }</span>

    public synchronized void defineAliases(List&lt;String&gt; aliases, String oldName) {
<span class="fc" id="L1289">        testFrozen(&quot;module&quot;);</span>
<span class="fc" id="L1290">        DynamicMethod method = searchForAliasMethod(getRuntime(), oldName);</span>

<span class="fc bfc" id="L1292" title="All 2 branches covered.">        for (String name: aliases) {</span>
<span class="pc bpc" id="L1293" title="1 of 2 branches missed.">            if (oldName.equals(name)) continue;</span>

<span class="fc" id="L1295">            putMethod(name, new AliasMethod(this, method, oldName));</span>
<span class="fc" id="L1296">        }</span>
        
<span class="fc" id="L1298">        methodLocation.invalidateCoreClasses();</span>
<span class="fc" id="L1299">        methodLocation.invalidateCacheDescendants();</span>
<span class="fc" id="L1300">    }</span>
    
    private DynamicMethod searchForAliasMethod(Ruby runtime, String name) {
<span class="fc" id="L1303">        DynamicMethod method = deepMethodSearch(name, runtime);</span>

<span class="fc bfc" id="L1305" title="All 2 branches covered.">        if (method instanceof JavaMethod) {</span>
            // JRUBY-2435: Aliasing eval and other &quot;special&quot; methods should display a warning
            // We warn because we treat certain method names as &quot;special&quot; for purposes of
            // optimization. Hopefully this will be enough to convince people not to alias
            // them.
<span class="fc" id="L1310">            CallConfiguration callerReq = ((JavaMethod)method).getCallerRequirement();</span>

<span class="fc bfc" id="L1312" title="All 2 branches covered.">            if (callerReq.framing() != Framing.None ||</span>
<span class="pc bpc" id="L1313" title="1 of 2 branches missed.">                    callerReq.scoping() != Scoping.None) {String baseName = getBaseName();</span>
<span class="fc" id="L1314">                char refChar = '#';</span>
<span class="fc" id="L1315">                String simpleName = getSimpleName();</span>

<span class="pc bpc" id="L1317" title="2 of 4 branches missed.">                if (baseName == null &amp;&amp; this instanceof MetaClass) {</span>
<span class="fc" id="L1318">                    IRubyObject attached = ((MetaClass)this).getAttached();</span>
<span class="pc bpc" id="L1319" title="1 of 2 branches missed.">                    if (attached instanceof RubyModule) {</span>
<span class="nc" id="L1320">                        simpleName = ((RubyModule)attached).getSimpleName();</span>
<span class="nc" id="L1321">                        refChar = '.';</span>
                    }
                }

<span class="fc" id="L1325">                runtime.getWarnings().warn(simpleName + refChar + name + &quot; accesses caller's state and should not be aliased&quot;);</span>
            }
        }

<span class="fc" id="L1329">        return method;</span>
    }

    /** this method should be used only by interpreter or compiler 
     * 
     */
    public RubyClass defineOrGetClassUnder(String name, RubyClass superClazz) {
        // This method is intended only for defining new classes in Ruby code,
        // so it uses the allocator of the specified superclass or default to
        // the Object allocator. It should NOT be used to define classes that require a native allocator.

<span class="fc" id="L1340">        Ruby runtime = getRuntime();</span>
<span class="fc" id="L1341">        IRubyObject classObj = getConstantAtSpecial(name);</span>
        RubyClass clazz;

<span class="fc bfc" id="L1344" title="All 2 branches covered.">        if (classObj != null) {</span>
<span class="fc bfc" id="L1345" title="All 2 branches covered.">            if (!(classObj instanceof RubyClass)) throw runtime.newTypeError(name + &quot; is not a class&quot;);</span>
<span class="fc" id="L1346">            clazz = (RubyClass)classObj;</span>

<span class="fc bfc" id="L1348" title="All 2 branches covered.">            if (superClazz != null) {</span>
<span class="fc" id="L1349">                RubyClass tmp = clazz.getSuperClass();</span>
<span class="pc bpc" id="L1350" title="1 of 4 branches missed.">                while (tmp != null &amp;&amp; tmp.isIncluded()) tmp = tmp.getSuperClass(); // need to skip IncludedModuleWrappers</span>
<span class="pc bpc" id="L1351" title="1 of 2 branches missed.">                if (tmp != null) tmp = tmp.getRealClass();</span>
<span class="fc bfc" id="L1352" title="All 2 branches covered.">                if (tmp != superClazz) throw runtime.newTypeError(&quot;superclass mismatch for class &quot; + name);</span>
                // superClazz = null;
<span class="fc" id="L1354">            }</span>
<span class="pc bpc" id="L1355" title="1 of 4 branches missed.">        } else if (classProviders != null &amp;&amp; (clazz = searchProvidersForClass(name, superClazz)) != null) {</span>
            // reopen a java class
        } else {
<span class="fc bfc" id="L1358" title="All 2 branches covered.">            if (superClazz == null) superClazz = runtime.getObject();</span>
            
            ObjectAllocator allocator;
<span class="fc bfc" id="L1361" title="All 2 branches covered.">            if (superClazz == runtime.getObject()) {</span>
<span class="pc bpc" id="L1362" title="1 of 2 branches missed.">                if (RubyInstanceConfig.REIFY_RUBY_CLASSES) {</span>
<span class="nc" id="L1363">                    allocator = REIFYING_OBJECT_ALLOCATOR;</span>
<span class="pc bpc" id="L1364" title="1 of 2 branches missed.">                } else if (Options.REIFY_VARIABLES.load()) {</span>
<span class="nc" id="L1365">                    allocator = IVAR_INSPECTING_OBJECT_ALLOCATOR;</span>
                } else {
<span class="fc" id="L1367">                    allocator = OBJECT_ALLOCATOR;</span>
                }
            } else {
<span class="fc" id="L1370">                allocator = superClazz.getAllocator();</span>
            }
            
<span class="fc" id="L1373">            clazz = RubyClass.newClass(runtime, superClazz, name, allocator, this, true);</span>
        }

<span class="fc" id="L1376">        return clazz;</span>
    }

    /** this method should be used only by interpreter or compiler 
     * 
     */
    public RubyModule defineOrGetModuleUnder(String name) {
        // This method is intended only for defining new modules in Ruby code
<span class="fc" id="L1384">        Ruby runtime = getRuntime();</span>
<span class="fc" id="L1385">        IRubyObject moduleObj = getConstantAtSpecial(name);</span>
        RubyModule module;
<span class="fc bfc" id="L1387" title="All 2 branches covered.">        if (moduleObj != null) {</span>
<span class="fc bfc" id="L1388" title="All 2 branches covered.">            if (!moduleObj.isModule()) throw runtime.newTypeError(name + &quot; is not a module&quot;);</span>
<span class="fc" id="L1389">            module = (RubyModule)moduleObj;</span>
<span class="pc bpc" id="L1390" title="1 of 4 branches missed.">        } else if (classProviders != null &amp;&amp; (module = searchProvidersForModule(name)) != null) {</span>
            // reopen a java module
        } else {
<span class="fc" id="L1393">            module = RubyModule.newModule(runtime, name, this, true); </span>
        }
<span class="fc" id="L1395">        return module;</span>
    }

    /** rb_define_class_under
     *  this method should be used only as an API to define/open nested classes 
     */
    public RubyClass defineClassUnder(String name, RubyClass superClass, ObjectAllocator allocator) {
<span class="fc" id="L1402">        return getRuntime().defineClassUnder(name, superClass, allocator, this);</span>
    }

    /** rb_define_module_under
     *  this method should be used only as an API to define/open nested module
     */
    public RubyModule defineModuleUnder(String name) {
<span class="fc" id="L1409">        return getRuntime().defineModuleUnder(name, this);</span>
    }

    private void addAccessor(ThreadContext context, String internedName, Visibility visibility, boolean readable, boolean writeable) {
<span class="pc bpc" id="L1413" title="3 of 4 branches missed.">        assert internedName == internedName.intern() : internedName + &quot; is not interned&quot;;</span>

<span class="fc" id="L1415">        final Ruby runtime = context.runtime;</span>

<span class="pc bpc" id="L1417" title="1 of 2 branches missed.">        if (visibility == PRIVATE) {</span>
            //FIXME warning
<span class="pc bpc" id="L1419" title="1 of 2 branches missed.">        } else if (visibility == MODULE_FUNCTION) {</span>
<span class="nc" id="L1420">            visibility = PRIVATE;</span>
            // FIXME warning
        }

<span class="pc bpc" id="L1424" title="3 of 4 branches missed.">        if (!(IdUtil.isLocal(internedName) || IdUtil.isConstant(internedName))) {</span>
<span class="nc" id="L1425">            throw runtime.newNameError(&quot;invalid attribute name&quot;, internedName);</span>
        }

<span class="fc" id="L1428">        final String variableName = (&quot;@&quot; + internedName).intern();</span>
<span class="fc bfc" id="L1429" title="All 2 branches covered.">        if (readable) {</span>
<span class="fc" id="L1430">            addMethod(internedName, new AttrReaderMethod(methodLocation, visibility, CallConfiguration.FrameNoneScopeNone, variableName));</span>
<span class="fc" id="L1431">            callMethod(context, &quot;method_added&quot;, runtime.fastNewSymbol(internedName));</span>
        }
<span class="fc bfc" id="L1433" title="All 2 branches covered.">        if (writeable) {</span>
<span class="fc" id="L1434">            internedName = (internedName + &quot;=&quot;).intern();</span>
<span class="fc" id="L1435">            addMethod(internedName, new AttrWriterMethod(methodLocation, visibility, CallConfiguration.FrameNoneScopeNone, variableName));</span>
<span class="fc" id="L1436">            callMethod(context, &quot;method_added&quot;, runtime.fastNewSymbol(internedName));</span>
        }
<span class="fc" id="L1438">    }</span>

    /** set_method_visibility
     *
     */
    public void setMethodVisibility(IRubyObject[] methods, Visibility visibility) {
<span class="fc bfc" id="L1444" title="All 2 branches covered.">        for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="fc" id="L1445">            exportMethod(methods[i].asJavaString(), visibility);</span>
        }
<span class="fc" id="L1447">    }</span>

    /** rb_export_method
     *
     */
    public void exportMethod(String name, Visibility visibility) {
<span class="fc" id="L1453">        Ruby runtime = getRuntime();</span>

<span class="fc" id="L1455">        DynamicMethod method = deepMethodSearch(name, runtime);</span>

<span class="fc bfc" id="L1457" title="All 2 branches covered.">        if (method.getVisibility() != visibility) {</span>
<span class="fc bfc" id="L1458" title="All 2 branches covered.">            if (this == method.getImplementationClass()) {</span>
<span class="fc" id="L1459">                method.setVisibility(visibility);</span>
            } else {
                // FIXME: Why was this using a FullFunctionCallbackMethod before that did callSuper?
<span class="fc" id="L1462">                methodLocation.addMethod(name, new WrapperMethod(this, method, visibility));</span>
            }

<span class="fc" id="L1465">            invalidateCoreClasses();</span>
<span class="fc" id="L1466">            invalidateCacheDescendants();</span>
        }
<span class="fc" id="L1468">    }</span>

    private DynamicMethod deepMethodSearch(String name, Ruby runtime) {
<span class="fc" id="L1471">        DynamicMethod method = searchMethod(name);</span>

<span class="fc bfc" id="L1473" title="All 4 branches covered.">        if (method.isUndefined() &amp;&amp; isModule()) {</span>
<span class="fc" id="L1474">            method = runtime.getObject().searchMethod(name);</span>
        }

<span class="fc bfc" id="L1477" title="All 2 branches covered.">        if (method.isUndefined()) {</span>
<span class="fc" id="L1478">            throw runtime.newNameError(&quot;undefined method '&quot; + name + &quot;' for &quot; +</span>
<span class="pc bpc" id="L1479" title="1 of 2 branches missed.">                                (isModule() ? &quot;module&quot; : &quot;class&quot;) + &quot; '&quot; + getName() + &quot;'&quot;, name);</span>
        }
<span class="fc" id="L1481">        return method;</span>
    }

    /**
     * MRI: rb_method_boundp
     *
     */
    public boolean isMethodBound(String name, boolean checkVisibility) {
<span class="fc" id="L1489">        DynamicMethod method = searchMethod(name);</span>
<span class="fc bfc" id="L1490" title="All 2 branches covered.">        if (!method.isUndefined()) {</span>
<span class="fc bfc" id="L1491" title="All 4 branches covered.">            return !(checkVisibility &amp;&amp; method.getVisibility() == PRIVATE);</span>
        }
<span class="fc" id="L1493">        return false;</span>
    }
    
    public boolean isMethodBound(String name, boolean checkVisibility, boolean checkRespondTo) {
<span class="pc bpc" id="L1497" title="1 of 2 branches missed.">        if (!checkRespondTo) return isMethodBound(name, checkVisibility);</span>
<span class="fc" id="L1498">        DynamicMethod method = searchMethod(name);</span>
<span class="pc bpc" id="L1499" title="1 of 4 branches missed.">        if (!method.isUndefined() &amp;&amp; !method.isNotImplemented()) {</span>
<span class="pc bpc" id="L1500" title="1 of 4 branches missed.">            return !(checkVisibility &amp;&amp; method.getVisibility() == PRIVATE);</span>
        }
<span class="fc" id="L1502">        return false;</span>
    }

    public IRubyObject newMethod(IRubyObject receiver, String methodName, boolean bound, Visibility visibility) {
<span class="fc" id="L1506">        return newMethod(receiver, methodName, bound, visibility, false, true);</span>
    }

    public IRubyObject newMethod(IRubyObject receiver, final String methodName, boolean bound, Visibility visibility, boolean respondToMissing) {
<span class="fc" id="L1510">        return newMethod(receiver, methodName, bound, visibility, respondToMissing, true);</span>
    }

    public static class RespondToMissingMethod extends JavaMethod.JavaMethodNBlock {
        final CallSite site;
        public RespondToMissingMethod(RubyModule implClass, Visibility vis, String methodName) {
<span class="fc" id="L1516">            super(implClass, vis);</span>

<span class="fc" id="L1518">            site = new FunctionalCachingCallSite(methodName);</span>
<span class="fc" id="L1519">        }</span>
        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="fc" id="L1522">            return site.call(context, self, self, args, block);</span>
        }

        public boolean equals(Object other) {
<span class="nc bnc" id="L1526" title="All 2 branches missed.">            if (!(other instanceof RespondToMissingMethod)) return false;</span>

<span class="nc" id="L1528">            RespondToMissingMethod rtmm = (RespondToMissingMethod)other;</span>

<span class="nc bnc" id="L1530" title="All 2 branches missed.">            return this.site.methodName.equals(rtmm.site.methodName) &amp;&amp;</span>
<span class="nc bnc" id="L1531" title="All 2 branches missed.">                    isImplementedBy(rtmm.getImplementationClass());</span>
        }
    }

    public IRubyObject newMethod(IRubyObject receiver, final String methodName, boolean bound, Visibility visibility, boolean respondToMissing, boolean priv) {
<span class="fc" id="L1536">        DynamicMethod method = searchMethod(methodName);</span>

<span class="fc bfc" id="L1538" title="All 4 branches covered.">        if (method.isUndefined() ||</span>
<span class="fc bfc" id="L1539" title="All 2 branches covered.">            (visibility != null &amp;&amp; method.getVisibility() != visibility)) {</span>
<span class="pc bpc" id="L1540" title="1 of 2 branches missed.">            if (respondToMissing) { // 1.9 behavior</span>
<span class="fc bfc" id="L1541" title="All 2 branches covered.">                if (receiver.respondsToMissing(methodName, priv)) {</span>
<span class="fc" id="L1542">                    method = new RespondToMissingMethod(this, PUBLIC, methodName);</span>
                } else {
<span class="fc" id="L1544">                    throw getRuntime().newNameError(&quot;undefined method `&quot; + methodName +</span>
<span class="fc" id="L1545">                        &quot;' for class `&quot; + this.getName() + &quot;'&quot;, methodName);</span>
                }
            } else {
<span class="nc" id="L1548">                throw getRuntime().newNameError(&quot;undefined method `&quot; + methodName +</span>
<span class="nc" id="L1549">                    &quot;' for class `&quot; + this.getName() + &quot;'&quot;, methodName);</span>
            }
        }

<span class="fc" id="L1553">        RubyModule implementationModule = method.getImplementationClass();</span>
<span class="fc" id="L1554">        RubyModule originModule = this;</span>
<span class="fc bfc" id="L1555" title="All 4 branches covered.">        while (originModule != implementationModule &amp;&amp; originModule.isSingleton()) {</span>
<span class="fc" id="L1556">            originModule = ((MetaClass)originModule).getRealClass();</span>
        }

        RubyMethod newMethod;
<span class="fc bfc" id="L1560" title="All 2 branches covered.">        if (bound) {</span>
<span class="fc" id="L1561">            newMethod = RubyMethod.newMethod(implementationModule, methodName, originModule, methodName, method, receiver);</span>
        } else {
<span class="fc" id="L1563">            newMethod = RubyUnboundMethod.newUnboundMethod(implementationModule, methodName, originModule, methodName, method);</span>
        }
<span class="fc" id="L1565">        newMethod.infectBy(this);</span>

<span class="fc" id="L1567">        return newMethod;</span>
    }

    @JRubyMethod(name = &quot;define_method&quot;, visibility = PRIVATE, reads = VISIBILITY)
    public IRubyObject define_method(ThreadContext context, IRubyObject arg0, Block block) {
<span class="fc" id="L1572">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L1573">        String name = TypeConverter.convertToIdentifier(arg0);</span>
<span class="fc" id="L1574">        DynamicMethod newMethod = null;</span>
<span class="fc" id="L1575">        Visibility visibility = PUBLIC;</span>

        // We need our identifier to be retrievable and creatable as a symbol.  This side-effect
        // populates this name into our symbol table so it will exist later if needed.  The
        // reason for this hack/side-effect is that symbols store their values as raw bytes.  We lose encoding
        // info so we need to make an entry so any accesses with raw bytes later gets proper symbol.
<span class="fc" id="L1581">        RubySymbol nameSym = RubySymbol.newSymbol(runtime, arg0);</span>
        
<span class="fc bfc" id="L1583" title="All 2 branches covered.">        if (!block.isGiven()) {</span>
<span class="fc" id="L1584">            throw getRuntime().newArgumentError(&quot;tried to create Proc object without a block&quot;);</span>
        }

<span class="fc" id="L1587">        block = block.cloneBlockAndFrame();</span>
<span class="fc" id="L1588">        RubyProc proc = runtime.newProc(Block.Type.LAMBDA, block);</span>

        // a normal block passed to define_method changes to do arity checking; make it a lambda
<span class="fc" id="L1591">        proc.getBlock().type = Block.Type.LAMBDA;</span>
        
<span class="fc" id="L1593">        newMethod = createProcMethod(name, visibility, proc);</span>
        
<span class="fc" id="L1595">        Helpers.addInstanceMethod(this, name, newMethod, visibility, context, runtime);</span>

<span class="fc" id="L1597">        return nameSym;</span>
    }
    
    @JRubyMethod(name = &quot;define_method&quot;, visibility = PRIVATE, reads = VISIBILITY)
    public IRubyObject define_method(ThreadContext context, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="fc" id="L1602">        Ruby runtime = context.runtime;</span>
        IRubyObject body;
<span class="fc" id="L1604">        String name = TypeConverter.convertToIdentifier(arg0);</span>
<span class="fc" id="L1605">        DynamicMethod newMethod = null;</span>
<span class="fc" id="L1606">        Visibility visibility = PUBLIC;</span>
        
        // We need our identifier to be retrievable and creatable as a symbol.  This side-effect
        // populates this name into our symbol table so it will exist later if needed.  The
        // reason for this hack/side-effect is that symbols store their values as raw bytes.  We lose encoding
        // info so we need to make an entry so any accesses with raw bytes later gets proper symbol.
<span class="fc" id="L1612">        RubySymbol nameSym = RubySymbol.newSymbol(runtime, arg0);</span>

<span class="fc bfc" id="L1614" title="All 2 branches covered.">        if (runtime.getProc().isInstance(arg1)) {</span>
            // double-testing args.length here, but it avoids duplicating the proc-setup code in two places
<span class="fc" id="L1616">            RubyProc proc = (RubyProc)arg1;</span>
<span class="fc" id="L1617">            body = proc;</span>

<span class="fc" id="L1619">            newMethod = createProcMethod(name, visibility, proc);</span>
<span class="fc bfc" id="L1620" title="All 2 branches covered.">        } else if (runtime.getMethod().isInstance(arg1)) {</span>
<span class="fc" id="L1621">            RubyMethod method = (RubyMethod)arg1;</span>
<span class="fc" id="L1622">            body = method;</span>
            
<span class="fc" id="L1624">            checkValidBindTargetFrom(context, (RubyModule)method.owner(context));</span>
            
<span class="fc" id="L1626">            newMethod = method.unbind().getMethod().dup();</span>
<span class="fc" id="L1627">            newMethod.setImplementationClass(this);</span>
<span class="fc" id="L1628">        } else {</span>
<span class="fc" id="L1629">            throw runtime.newTypeError(&quot;wrong argument type &quot; + arg1.getType().getName() + &quot; (expected Proc/Method)&quot;);</span>
        }
        
<span class="fc" id="L1632">        Helpers.addInstanceMethod(this, name, newMethod, visibility, context, runtime);</span>

<span class="fc" id="L1634">        return nameSym;</span>
    }
    @Deprecated
    public IRubyObject define_method(ThreadContext context, IRubyObject[] args, Block block) {
<span class="nc bnc" id="L1638" title="All 3 branches missed.">        switch (args.length) {</span>
        case 1:
<span class="nc" id="L1640">            return define_method(context, args[0], block);</span>
        case 2:
<span class="nc" id="L1642">            return define_method(context, args[0], args[1], block);</span>
        default:
<span class="nc" id="L1644">            throw context.runtime.newArgumentError(&quot;wrong number of arguments (&quot; + args.length + &quot; for 2)&quot;);</span>
        }
    }
    
    private DynamicMethod createProcMethod(String name, Visibility visibility, RubyProc proc) {
<span class="fc" id="L1649">        Block block = proc.getBlock();</span>
<span class="fc" id="L1650">        block.getBinding().getFrame().setKlazz(this);</span>
<span class="fc" id="L1651">        block.getBinding().getFrame().setName(name);</span>
<span class="fc" id="L1652">        block.getBinding().setMethod(name);</span>
        
<span class="fc" id="L1654">        StaticScope scope = block.getBody().getStaticScope();</span>

        // for zsupers in define_method (blech!) we tell the proc scope to act as the &quot;argument&quot; scope
<span class="fc" id="L1657">        scope.makeArgumentScope();</span>

<span class="fc" id="L1659">        Arity arity = block.arity();</span>
        // just using required is broken...but no more broken than before zsuper refactoring
<span class="fc" id="L1661">        scope.setRequiredArgs(arity.required());</span>

<span class="fc bfc" id="L1663" title="All 2 branches covered.">        if(!arity.isFixed()) {</span>
<span class="fc" id="L1664">            scope.setRestArg(arity.required());</span>
        }

<span class="fc" id="L1667">        return new ProcMethod(this, proc, visibility);</span>
    }

    public IRubyObject name() {
<span class="nc" id="L1671">        return name19();</span>
    }

    @JRubyMethod(name = &quot;name&quot;)
    public IRubyObject name19() {
<span class="fc" id="L1676">        Ruby runtime = getRuntime();</span>
<span class="fc bfc" id="L1677" title="All 2 branches covered.">        if (getBaseName() == null) {</span>
<span class="fc" id="L1678">            return runtime.getNil();</span>
        } else {
<span class="fc" id="L1680">            return runtime.newString(getName());</span>
        }
    }

    protected IRubyObject cloneMethods(RubyModule clone) {
<span class="fc" id="L1685">        RubyModule realType = this.getNonIncludedClass();</span>
<span class="fc bfc" id="L1686" title="All 2 branches covered.">        for (Map.Entry&lt;String, DynamicMethod&gt; entry : getMethods().entrySet()) {</span>
<span class="fc" id="L1687">            DynamicMethod method = entry.getValue();</span>
            // Do not clone cached methods
            // FIXME: MRI copies all methods here
<span class="pc bpc" id="L1690" title="3 of 4 branches missed.">            if (method.isImplementedBy(realType) || method.isUndefined()) {</span>
                
                // A cloned method now belongs to a new class.  Set it.
                // TODO: Make DynamicMethod immutable
<span class="fc" id="L1694">                DynamicMethod clonedMethod = method.dup();</span>
<span class="fc" id="L1695">                clonedMethod.setImplementationClass(clone);</span>
<span class="fc" id="L1696">                clone.putMethod(entry.getKey(), clonedMethod);</span>
            }
<span class="fc" id="L1698">        }</span>

<span class="fc" id="L1700">        return clone;</span>
    }

    /** mri: rb_mod_init_copy
     * 
     */
    @JRubyMethod(name = &quot;initialize_copy&quot;, required = 1, visibility = Visibility.PRIVATE)
    @Override
    public IRubyObject initialize_copy(IRubyObject original) {
<span class="fc bfc" id="L1709" title="All 2 branches covered.">        if (this instanceof RubyClass) {</span>
<span class="fc" id="L1710">            checkSafeTypeToCopy((RubyClass) original);</span>
        }
<span class="fc" id="L1712">        super.initialize_copy(original);</span>

<span class="fc" id="L1714">        RubyModule originalModule = (RubyModule)original;</span>

<span class="pc bpc" id="L1716" title="1 of 2 branches missed.">        if (!getMetaClass().isSingleton()) setMetaClass(originalModule.getSingletonClassClone());</span>
<span class="fc" id="L1717">        setSuperClass(originalModule.getSuperClass());</span>
<span class="fc bfc" id="L1718" title="All 2 branches covered.">        if (originalModule.hasVariables()) syncVariables(originalModule);</span>
<span class="fc" id="L1719">        syncConstants(originalModule);</span>

<span class="fc" id="L1721">        originalModule.cloneMethods(this);</span>

<span class="fc" id="L1723">        return this;</span>
    }

    // mri: class_init_copy_check
    private void checkSafeTypeToCopy(RubyClass original) {
<span class="fc" id="L1728">        Ruby runtime = getRuntime();</span>

<span class="pc bpc" id="L1730" title="1 of 2 branches missed.">        if (original == runtime.getBasicObject()) throw runtime.newTypeError(&quot;can't copy the root class&quot;);</span>
<span class="pc bpc" id="L1731" title="1 of 2 branches missed.">        if (getSuperClass() == runtime.getBasicObject()) throw runtime.newTypeError(&quot;already initialized class&quot;);</span>
<span class="pc bpc" id="L1732" title="1 of 2 branches missed.">        if (original.isSingleton()) throw runtime.newTypeError(&quot;can't copy singleton class&quot;);</span>
<span class="fc" id="L1733">    }</span>

    public void syncConstants(RubyModule other) {
<span class="fc bfc" id="L1736" title="All 2 branches covered.">        if (other.getConstantMap() != Collections.EMPTY_MAP) {</span>
<span class="fc" id="L1737">            getConstantMapForWrite().putAll(other.getConstantMap());</span>
        }
<span class="fc" id="L1739">    }</span>

    public void syncClassVariables(RubyModule other) {
<span class="fc bfc" id="L1742" title="All 2 branches covered.">        if (other.getClassVariablesForRead() != Collections.EMPTY_MAP) {</span>
<span class="fc" id="L1743">            getClassVariables().putAll(other.getClassVariablesForRead());</span>
        }
<span class="fc" id="L1745">    }</span>

    /** rb_mod_included_modules
     *
     */
    @JRubyMethod(name = &quot;included_modules&quot;)
    public RubyArray included_modules(ThreadContext context) {
<span class="fc" id="L1752">        RubyArray ary = context.runtime.newArray();</span>

<span class="fc bfc" id="L1754" title="All 2 branches covered.">        for (RubyModule p = getSuperClass(); p != null; p = p.getSuperClass()) {</span>
<span class="fc bfc" id="L1755" title="All 2 branches covered.">            if (p.isIncluded()) {</span>
<span class="fc" id="L1756">                ary.append(p.getNonIncludedClass());</span>
            }
        }

<span class="fc" id="L1760">        return ary;</span>
    }

    public boolean hasPrepends() {
<span class="fc bfc" id="L1764" title="All 2 branches covered.">        return methodLocation != this;</span>
    }

    /** rb_mod_ancestors
     *
     */
    @JRubyMethod(name = &quot;ancestors&quot;)
    public RubyArray ancestors(ThreadContext context) {
<span class="fc" id="L1772">        return context.runtime.newArray(getAncestorList());</span>
    }
    
    @Deprecated
    public RubyArray ancestors() {
<span class="nc" id="L1777">        return getRuntime().newArray(getAncestorList());</span>
    }

    public List&lt;IRubyObject&gt; getAncestorList() {
<span class="fc" id="L1781">        ArrayList&lt;IRubyObject&gt; list = new ArrayList&lt;IRubyObject&gt;();</span>

<span class="fc bfc" id="L1783" title="All 2 branches covered.">        for (RubyModule module = this; module != null; module = module.getSuperClass()) {</span>
            // FIXME this is silly. figure out how to delegate the getNonIncludedClass()
            // call to drop the getDelegate().
<span class="fc bfc" id="L1786" title="All 2 branches covered.">            if (module.methodLocation == module) list.add(module.getDelegate().getNonIncludedClass());</span>
        }

<span class="fc" id="L1789">        return list;</span>
    }

    public boolean hasModuleInPrepends(RubyModule type) {
<span class="pc bpc" id="L1793" title="1 of 2 branches missed.">        for (RubyModule module = this; module != methodLocation; module = module.getSuperClass()) {</span>
<span class="nc bnc" id="L1794" title="All 2 branches missed.">            if (type == module.getNonIncludedClass()) return true;</span>
        }
<span class="fc" id="L1796">        return false;</span>
    }

    public boolean hasModuleInHierarchy(RubyModule type) {
        // XXX: This check previously used callMethod(&quot;==&quot;) to check for equality between classes
        // when scanning the hierarchy. However the == check may be safe; we should only ever have
        // one instance bound to a given type/constant. If it's found to be unsafe, examine ways
        // to avoid the == call.
<span class="fc bfc" id="L1804" title="All 2 branches covered.">        for (RubyModule module = this; module != null; module = module.getSuperClass()) {</span>
<span class="fc bfc" id="L1805" title="All 2 branches covered.">            if (module.getNonIncludedClass() == type) return true;</span>
        }

<span class="fc" id="L1808">        return false;</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L1813">        return id;</span>
    }

    @JRubyMethod(name = &quot;hash&quot;)
    @Override
    public RubyFixnum hash() {
<span class="fc" id="L1819">        return getRuntime().newFixnum(id);</span>
    }

    /** rb_mod_to_s
     *
     */
    @JRubyMethod(name = &quot;to_s&quot;, alias = &quot;inspect&quot;)
    @Override
    public IRubyObject to_s() {
<span class="fc bfc" id="L1828" title="All 2 branches covered.">        if(isSingleton()){            </span>
<span class="fc" id="L1829">            IRubyObject attached = ((MetaClass)this).getAttached();</span>
<span class="fc" id="L1830">            StringBuilder buffer = new StringBuilder(&quot;#&lt;Class:&quot;);</span>
<span class="pc bpc" id="L1831" title="1 of 2 branches missed.">            if (attached != null) { // FIXME: figure out why we getService null sometimes</span>
<span class="pc bpc" id="L1832" title="2 of 4 branches missed.">                if(attached instanceof RubyClass || attached instanceof RubyModule){</span>
<span class="nc" id="L1833">                    buffer.append(attached.inspect());</span>
                }else{
<span class="fc" id="L1835">                    buffer.append(attached.anyToString());</span>
                }
            }
<span class="fc" id="L1838">            buffer.append(&quot;&gt;&quot;);</span>
<span class="fc" id="L1839">            return getRuntime().newString(buffer.toString());</span>
        }
<span class="fc" id="L1841">        return getRuntime().newString(getName());</span>
    }

    /** rb_mod_eqq
     *
     */
    @JRubyMethod(name = &quot;===&quot;, required = 1)
    @Override
    public RubyBoolean op_eqq(ThreadContext context, IRubyObject obj) {
<span class="fc" id="L1850">        return context.runtime.newBoolean(isInstance(obj));</span>
    }

    /**
     * We override equals here to provide a faster path, since equality for modules
     * is pretty cut and dried.
     * @param other The object to check for equality
     * @return true if reference equality, false otherwise
     */
    @Override
    public boolean equals(Object other) {
<span class="fc bfc" id="L1861" title="All 2 branches covered.">        return this == other;</span>
    }

    @JRubyMethod(name = &quot;==&quot;, required = 1)
    @Override
    public IRubyObject op_equal(ThreadContext context, IRubyObject other) {
<span class="fc bfc" id="L1867" title="All 2 branches covered.">        if(!(other instanceof RubyModule)) return context.runtime.getFalse();</span>

<span class="fc" id="L1869">        RubyModule otherModule = (RubyModule) other;</span>
<span class="pc bpc" id="L1870" title="1 of 2 branches missed.">        if(otherModule.isIncluded()) {</span>
<span class="nc" id="L1871">            return context.runtime.newBoolean(otherModule.isSame(this));</span>
        } else {
<span class="fc" id="L1873">            return context.runtime.newBoolean(isSame(otherModule));</span>
        }
    }

    /** rb_mod_freeze
     *
     */
    @JRubyMethod(name = &quot;freeze&quot;)
    @Override
    public final IRubyObject freeze(ThreadContext context) {
<span class="fc" id="L1883">        to_s();</span>
<span class="fc" id="L1884">        return super.freeze(context);</span>
    }

    /** rb_mod_le
    *
    */
    @JRubyMethod(name = &quot;&lt;=&quot;, required = 1)
   public IRubyObject op_le(IRubyObject obj) {
<span class="fc bfc" id="L1892" title="All 2 branches covered.">        if (!(obj instanceof RubyModule)) {</span>
<span class="fc" id="L1893">            throw getRuntime().newTypeError(&quot;compared with non class/module&quot;);</span>
        }

<span class="fc bfc" id="L1896" title="All 2 branches covered.">        if (isKindOfModule((RubyModule) obj)) return getRuntime().getTrue();</span>
<span class="fc bfc" id="L1897" title="All 2 branches covered.">        if (((RubyModule) obj).isKindOfModule(this)) return getRuntime().getFalse();</span>

<span class="fc" id="L1899">        return getRuntime().getNil();</span>
    }

    /** rb_mod_lt
    *
    */
    @JRubyMethod(name = &quot;&lt;&quot;, required = 1)
   public IRubyObject op_lt(IRubyObject obj) {
<span class="fc bfc" id="L1907" title="All 2 branches covered.">        return obj == this ? getRuntime().getFalse() : op_le(obj);</span>
    }

    /** rb_mod_ge
    *
    */
    @JRubyMethod(name = &quot;&gt;=&quot;, required = 1)
   public IRubyObject op_ge(IRubyObject obj) {
<span class="fc bfc" id="L1915" title="All 2 branches covered.">        if (!(obj instanceof RubyModule)) {</span>
<span class="fc" id="L1916">            throw getRuntime().newTypeError(&quot;compared with non class/module&quot;);</span>
        }

<span class="fc" id="L1919">        return ((RubyModule) obj).op_le(this);</span>
    }

    /** rb_mod_gt
    *
    */
    @JRubyMethod(name = &quot;&gt;&quot;, required = 1)
   public IRubyObject op_gt(IRubyObject obj) {
<span class="fc bfc" id="L1927" title="All 2 branches covered.">        return this == obj ? getRuntime().getFalse() : op_ge(obj);</span>
    }

    /** rb_mod_cmp
    *
    */
    @JRubyMethod(name = &quot;&lt;=&gt;&quot;, required = 1)
    public IRubyObject op_cmp(IRubyObject obj) {
<span class="fc bfc" id="L1935" title="All 2 branches covered.">        if (this == obj) return getRuntime().newFixnum(0);</span>
<span class="fc bfc" id="L1936" title="All 2 branches covered.">        if (!(obj instanceof RubyModule)) return getRuntime().getNil();</span>

<span class="fc" id="L1938">        RubyModule module = (RubyModule) obj;</span>

<span class="fc bfc" id="L1940" title="All 2 branches covered.">        if (module.isKindOfModule(this)) return getRuntime().newFixnum(1);</span>
<span class="fc bfc" id="L1941" title="All 2 branches covered.">        if (this.isKindOfModule(module)) return getRuntime().newFixnum(-1);</span>

<span class="fc" id="L1943">        return getRuntime().getNil();</span>
    }

    public boolean isKindOfModule(RubyModule type) {
<span class="fc bfc" id="L1947" title="All 2 branches covered.">        for (RubyModule module = this; module != null; module = module.getSuperClass()) {</span>
<span class="fc bfc" id="L1948" title="All 2 branches covered.">            if (module.isSame(type)) return true;</span>
        }

<span class="fc" id="L1951">        return false;</span>
    }

    protected boolean isSame(RubyModule module) {
<span class="fc bfc" id="L1955" title="All 2 branches covered.">        return this == module;</span>
    }

    /** rb_mod_initialize
     *
     */
    @JRubyMethod(name = &quot;initialize&quot;, visibility = PRIVATE)
    public IRubyObject initialize(ThreadContext context, Block block) {
<span class="fc bfc" id="L1963" title="All 2 branches covered.">        if (block.isGiven()) {</span>
<span class="fc" id="L1964">            module_exec(context, new IRubyObject[] {this}, block);</span>
        }

<span class="fc" id="L1967">        return getRuntime().getNil();</span>
    }
    
    public void addReadWriteAttribute(ThreadContext context, String name) {
<span class="fc" id="L1971">        addAccessor(context, name.intern(), PUBLIC, true, true);</span>
<span class="fc" id="L1972">    }</span>
    
    public void addReadAttribute(ThreadContext context, String name) {
<span class="fc" id="L1975">        addAccessor(context, name.intern(), PUBLIC, true, false);</span>
<span class="fc" id="L1976">    }</span>
    
    public void addWriteAttribute(ThreadContext context, String name) {
<span class="nc" id="L1979">        addAccessor(context, name.intern(), PUBLIC, false, true);</span>
<span class="nc" id="L1980">    }</span>

    /** rb_mod_attr
     *
     */
    public IRubyObject attr(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L1986">        return attr19(context, args);</span>
    }
    
    @JRubyMethod(name = &quot;attr&quot;, rest = true, visibility = PRIVATE, reads = VISIBILITY)
    public IRubyObject attr19(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L1991">        Ruby runtime = context.runtime;</span>

<span class="pc bpc" id="L1993" title="1 of 6 branches missed.">        if (args.length == 2 &amp;&amp; (args[1] == runtime.getTrue() || args[1] == runtime.getFalse())) {</span>
<span class="fc" id="L1994">            runtime.getWarnings().warn(ID.OBSOLETE_ARGUMENT, &quot;optional boolean argument is obsoleted&quot;);</span>
<span class="fc" id="L1995">            addAccessor(context, args[0].asJavaString().intern(), context.getCurrentVisibility(), args[0].isTrue(), args[1].isTrue());</span>
<span class="fc" id="L1996">            return runtime.getNil();</span>
        }

<span class="fc" id="L1999">        return attr_reader(context, args);</span>
    }

    @Deprecated
    public IRubyObject attr_reader(IRubyObject[] args) {
<span class="nc" id="L2004">        return attr_reader(getRuntime().getCurrentContext(), args);</span>
    }
    
    /** rb_mod_attr_reader
     *
     */
    @JRubyMethod(name = &quot;attr_reader&quot;, rest = true, visibility = PRIVATE, reads = VISIBILITY)
    public IRubyObject attr_reader(ThreadContext context, IRubyObject[] args) {
        // Check the visibility of the previous frame, which will be the frame in which the class is being eval'ed
<span class="fc" id="L2013">        Visibility visibility = context.getCurrentVisibility();</span>

<span class="fc bfc" id="L2015" title="All 2 branches covered.">        for (int i = 0; i &lt; args.length; i++) {</span>
<span class="fc" id="L2016">            addAccessor(context, args[i].asJavaString().intern(), visibility, true, false);</span>
        }

<span class="fc" id="L2019">        return context.runtime.getNil();</span>
    }

    /** rb_mod_attr_writer
     *
     */
    @JRubyMethod(name = &quot;attr_writer&quot;, rest = true, visibility = PRIVATE, reads = VISIBILITY)
    public IRubyObject attr_writer(ThreadContext context, IRubyObject[] args) {
        // Check the visibility of the previous frame, which will be the frame in which the class is being eval'ed
<span class="fc" id="L2028">        Visibility visibility = context.getCurrentVisibility();</span>

<span class="fc bfc" id="L2030" title="All 2 branches covered.">        for (int i = 0; i &lt; args.length; i++) {</span>
<span class="fc" id="L2031">            addAccessor(context, args[i].asJavaString().intern(), visibility, false, true);</span>
        }

<span class="fc" id="L2034">        return context.runtime.getNil();</span>
    }


    @Deprecated
    public IRubyObject attr_accessor(IRubyObject[] args) {
<span class="nc" id="L2040">        return attr_accessor(getRuntime().getCurrentContext(), args);</span>
    }

    /** rb_mod_attr_accessor
     *  Note: this method should not be called from Java in most cases, since
     *  it depends on Ruby frame state for visibility. Use add[Read/Write]Attribute instead.
     */
    @JRubyMethod(name = &quot;attr_accessor&quot;, rest = true, visibility = PRIVATE, reads = VISIBILITY)
    public IRubyObject attr_accessor(ThreadContext context, IRubyObject[] args) {
        // Check the visibility of the previous frame, which will be the frame in which the class is being eval'ed
<span class="fc" id="L2050">        Visibility visibility = context.getCurrentVisibility();</span>

<span class="fc bfc" id="L2052" title="All 2 branches covered.">        for (int i = 0; i &lt; args.length; i++) {</span>
            // This is almost always already interned, since it will be called with a symbol in most cases
            // but when created from Java code, we might getService an argument that needs to be interned.
            // addAccessor has as a precondition that the string MUST be interned
<span class="fc" id="L2056">            addAccessor(context, args[i].asJavaString().intern(), visibility, true, true);</span>
        }

<span class="fc" id="L2059">        return context.runtime.getNil();</span>
    }

    /**
     * Get a list of all instance methods names of the provided visibility unless not is true, then 
     * getService all methods which are not the provided
     * 
     * @param args passed into one of the Ruby instance_method methods
     * @param visibility to find matching instance methods against
     * @param not if true only find methods not matching supplied visibility
     * @return a RubyArray of instance method names
     */
    private RubyArray instance_methods(IRubyObject[] args, final Visibility visibility, boolean not, boolean useSymbols) {
<span class="fc bfc" id="L2072" title="All 2 branches covered.">        boolean includeSuper = args.length &gt; 0 ? args[0].isTrue() : true;</span>
<span class="fc" id="L2073">        Ruby runtime = getRuntime();</span>
<span class="fc" id="L2074">        RubyArray ary = runtime.newArray();</span>
<span class="fc" id="L2075">        Set&lt;String&gt; seen = new HashSet&lt;String&gt;();</span>

<span class="fc" id="L2077">        populateInstanceMethodNames(seen, ary, visibility, not, useSymbols, includeSuper);</span>

<span class="fc" id="L2079">        return ary;</span>
    }

    public void populateInstanceMethodNames(Set&lt;String&gt; seen, RubyArray ary, final Visibility visibility, boolean not, boolean useSymbols, boolean includeSuper) {
<span class="fc" id="L2083">        Ruby runtime = getRuntime();</span>

<span class="fc bfc" id="L2085" title="All 2 branches covered.">        for (RubyModule type = this; type != null; type = type.getSuperClass()) {</span>
<span class="fc" id="L2086">            RubyModule realType = type.getNonIncludedClass();</span>
<span class="fc bfc" id="L2087" title="All 2 branches covered.">            for (Map.Entry entry : type.getMethods().entrySet()) {</span>
<span class="fc" id="L2088">                String methodName = (String) entry.getKey();</span>

<span class="fc bfc" id="L2090" title="All 2 branches covered.">                if (! seen.contains(methodName)) {</span>
<span class="fc" id="L2091">                    seen.add(methodName);</span>

<span class="fc" id="L2093">                    DynamicMethod method = (DynamicMethod) entry.getValue();</span>
<span class="pc bpc" id="L2094" title="1 of 6 branches missed.">                    if ((method.isImplementedBy(realType) || method.isImplementedBy(type)) &amp;&amp;</span>
<span class="fc bfc" id="L2095" title="All 6 branches covered.">                        (!not &amp;&amp; method.getVisibility() == visibility || (not &amp;&amp; method.getVisibility() != visibility)) &amp;&amp;</span>
<span class="pc bpc" id="L2096" title="1 of 2 branches missed.">                        ! method.isUndefined()) {</span>

<span class="pc bpc" id="L2098" title="1 of 2 branches missed.">                        ary.append(useSymbols ? runtime.newSymbol(methodName) : runtime.newString(methodName));</span>
                    }
                }
<span class="fc" id="L2101">            }</span>

<span class="pc bpc" id="L2103" title="1 of 4 branches missed.">            if (!includeSuper &amp;&amp; type == methodLocation) {</span>
<span class="fc" id="L2104">                break;</span>
            }
        }
<span class="fc" id="L2107">    }</span>

    public RubyArray instance_methods(IRubyObject[] args) {
<span class="nc" id="L2110">        return instance_methods19(args);</span>
    }

    @JRubyMethod(name = &quot;instance_methods&quot;, optional = 1)
    public RubyArray instance_methods19(IRubyObject[] args) {
<span class="fc" id="L2115">        return instance_methods(args, PRIVATE, true, true);</span>
    }

    public RubyArray public_instance_methods(IRubyObject[] args) {
<span class="nc" id="L2119">        return public_instance_methods19(args);</span>
    }

    @JRubyMethod(name = &quot;public_instance_methods&quot;, optional = 1)
    public RubyArray public_instance_methods19(IRubyObject[] args) {
<span class="fc" id="L2124">        return instance_methods(args, PUBLIC, false, true);</span>
    }

    @JRubyMethod(name = &quot;instance_method&quot;, required = 1)
    public IRubyObject instance_method(IRubyObject symbol) {
<span class="fc" id="L2129">        return newMethod(null, symbol.asJavaString(), false, null);</span>
    }

    /** rb_class_protected_instance_methods
     *
     */
    public RubyArray protected_instance_methods(IRubyObject[] args) {
<span class="nc" id="L2136">        return protected_instance_methods19(args);</span>
    }

    @JRubyMethod(name = &quot;protected_instance_methods&quot;, optional = 1)
    public RubyArray protected_instance_methods19(IRubyObject[] args) {
<span class="fc" id="L2141">        return instance_methods(args, PROTECTED, false, true);</span>
    }

    /** rb_class_private_instance_methods
     *
     */
    public RubyArray private_instance_methods(IRubyObject[] args) {
<span class="nc" id="L2148">        return private_instance_methods19(args);</span>
    }

    @JRubyMethod(name = &quot;private_instance_methods&quot;, optional = 1)
    public RubyArray private_instance_methods19(IRubyObject[] args) {
<span class="fc" id="L2153">        return instance_methods(args, PRIVATE, false, true);</span>
    }

    /** rb_mod_prepend_features
     *
     */
    @JRubyMethod(name = &quot;prepend_features&quot;, required = 1, visibility = PRIVATE)
    public RubyModule prepend_features(IRubyObject include) {
<span class="fc bfc" id="L2161" title="All 2 branches covered.">        if (!isModule()) {</span>
<span class="fc" id="L2162">            throw getRuntime().newTypeError(this, getRuntime().getModule());</span>
        }
<span class="pc bpc" id="L2164" title="1 of 2 branches missed.">        if (!(include instanceof RubyModule)) {</span>
<span class="nc" id="L2165">            throw getRuntime().newTypeError(include, getRuntime().getModule());</span>
        }

<span class="pc bpc" id="L2168" title="1 of 4 branches missed.">        if (!(include.isModule() || include.isClass())) {</span>
<span class="nc" id="L2169">            throw getRuntime().newTypeError(include, getRuntime().getModule());</span>
        }

<span class="fc" id="L2172">        ((RubyModule) include).prependModule(this);</span>
<span class="fc" id="L2173">        return this;</span>
    }

    /** rb_mod_append_features
     *
     */
    @JRubyMethod(name = &quot;append_features&quot;, required = 1, visibility = PRIVATE)
    public RubyModule append_features(IRubyObject include) {
<span class="pc bpc" id="L2181" title="1 of 2 branches missed.">        if (!isModule()) {</span>
<span class="nc" id="L2182">            throw getRuntime().newTypeError(this, getRuntime().getModule());</span>
        }
<span class="pc bpc" id="L2184" title="1 of 2 branches missed.">        if (!(include instanceof RubyModule)) {</span>
<span class="nc" id="L2185">            throw getRuntime().newTypeError(include, getRuntime().getModule());</span>
        }

<span class="pc bpc" id="L2188" title="1 of 4 branches missed.">        if (!(include.isModule() || include.isClass())) {</span>
<span class="nc" id="L2189">            throw getRuntime().newTypeError(include, getRuntime().getModule());</span>
        }

<span class="fc" id="L2192">        ((RubyModule) include).includeModule(this);</span>
<span class="fc" id="L2193">        return this;</span>
    }

    /** rb_mod_extend_object
     *
     */
    @JRubyMethod(name = &quot;extend_object&quot;, required = 1, visibility = PRIVATE)
    public IRubyObject extend_object(IRubyObject obj) {
<span class="fc" id="L2201">        obj.getSingletonClass().includeModule(this);</span>
<span class="fc" id="L2202">        return obj;</span>
    }

    /** rb_mod_include
     *
     */
    @JRubyMethod(name = &quot;include&quot;, rest = true, visibility = PRIVATE)
    public RubyModule include(IRubyObject[] modules) {
<span class="fc" id="L2210">        ThreadContext context = getRuntime().getCurrentContext();</span>
        // MRI checks all types first:
<span class="fc bfc" id="L2212" title="All 2 branches covered.">        for (int i = modules.length; --i &gt;= 0; ) {</span>
<span class="fc" id="L2213">            IRubyObject obj = modules[i];</span>
<span class="fc bfc" id="L2214" title="All 2 branches covered.">            if (!obj.isModule()) {</span>
<span class="fc" id="L2215">                throw context.runtime.newTypeError(obj, context.runtime.getModule());</span>
            }
<span class="fc" id="L2217">        }</span>
<span class="fc bfc" id="L2218" title="All 2 branches covered.">        for (int i = modules.length - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L2219">            modules[i].callMethod(context, &quot;append_features&quot;, this);</span>
<span class="fc" id="L2220">            modules[i].callMethod(context, &quot;included&quot;, this);</span>
        }

<span class="fc" id="L2223">        return this;</span>
    }

    @JRubyMethod(name = &quot;included&quot;, required = 1, visibility = PRIVATE)
    public IRubyObject included(ThreadContext context, IRubyObject other) {
<span class="fc" id="L2228">        return context.runtime.getNil();</span>
    }

    @JRubyMethod(name = &quot;extended&quot;, required = 1, visibility = PRIVATE)
    public IRubyObject extended(ThreadContext context, IRubyObject other, Block block) {
<span class="fc" id="L2233">        return context.runtime.getNil();</span>
    }

    @JRubyMethod(name = &quot;mix&quot;, visibility = PRIVATE)
    public IRubyObject mix(ThreadContext context, IRubyObject mod) {
<span class="nc" id="L2238">        Ruby runtime = context.runtime;</span>

<span class="nc bnc" id="L2240" title="All 2 branches missed.">        if (!mod.isModule()) {</span>
<span class="nc" id="L2241">            throw runtime.newTypeError(mod, runtime.getModule());</span>
        }

<span class="nc bnc" id="L2244" title="All 2 branches missed.">        for (Map.Entry&lt;String, DynamicMethod&gt; entry : ((RubyModule)mod).methods.entrySet()) {</span>
<span class="nc bnc" id="L2245" title="All 2 branches missed.">            if (methodLocation.getMethods().containsKey(entry.getKey())) {</span>
<span class="nc" id="L2246">                throw runtime.newArgumentError(&quot;method would conflict - &quot; + entry.getKey());</span>
            }
<span class="nc" id="L2248">        }</span>

<span class="nc bnc" id="L2250" title="All 2 branches missed.">        for (Map.Entry&lt;String, DynamicMethod&gt; entry : ((RubyModule)mod).methods.entrySet()) {</span>
<span class="nc" id="L2251">            methodLocation.getMethodsForWrite().put(entry.getKey(), entry.getValue().dup());</span>
<span class="nc" id="L2252">        }</span>

<span class="nc" id="L2254">        return mod;</span>
    }

    @JRubyMethod(name = &quot;mix&quot;, visibility = PRIVATE)
    public IRubyObject mix(ThreadContext context, IRubyObject mod, IRubyObject hash0) {
<span class="nc" id="L2259">        Ruby runtime = context.runtime;</span>
<span class="nc" id="L2260">        RubyHash methodNames = null;</span>

<span class="nc bnc" id="L2262" title="All 2 branches missed.">        if (!mod.isModule()) {</span>
<span class="nc" id="L2263">            throw runtime.newTypeError(mod, runtime.getModule());</span>
        }

<span class="nc bnc" id="L2266" title="All 2 branches missed.">        if (hash0 instanceof RubyHash) {</span>
<span class="nc" id="L2267">            methodNames = (RubyHash)hash0;</span>
        } else {
<span class="nc" id="L2269">            throw runtime.newTypeError(hash0, runtime.getHash());</span>
        }
        
<span class="nc bnc" id="L2272" title="All 2 branches missed.">        for (Map.Entry&lt;IRubyObject, IRubyObject&gt; entry : (Set&lt;Map.Entry&lt;IRubyObject, IRubyObject&gt;&gt;)methodNames.directEntrySet()) {</span>
<span class="nc" id="L2273">            String name = entry.getValue().toString();</span>
<span class="nc bnc" id="L2274" title="All 2 branches missed.">            if (methods.containsKey(entry.getValue().toString())) {</span>
<span class="nc" id="L2275">                throw runtime.newArgumentError(&quot;constant would conflict - &quot; + name);</span>
            }
<span class="nc" id="L2277">        }</span>

<span class="nc bnc" id="L2279" title="All 2 branches missed.">        for (Map.Entry&lt;String, DynamicMethod&gt; entry : ((RubyModule)mod).methods.entrySet()) {</span>
<span class="nc bnc" id="L2280" title="All 2 branches missed.">            if (methods.containsKey(entry.getKey())) {</span>
<span class="nc" id="L2281">                throw runtime.newArgumentError(&quot;method would conflict - &quot; + entry.getKey());</span>
            }
<span class="nc" id="L2283">        }</span>

<span class="nc bnc" id="L2285" title="All 2 branches missed.">        for (Map.Entry&lt;String, DynamicMethod&gt; entry : ((RubyModule)mod).methods.entrySet()) {</span>
<span class="nc" id="L2286">            String name = entry.getKey();</span>
<span class="nc" id="L2287">            IRubyObject mapped = methodNames.fastARef(runtime.newSymbol(name));</span>
<span class="nc bnc" id="L2288" title="All 2 branches missed.">            if (mapped == NEVER) {</span>
                // unmapped
<span class="nc bnc" id="L2290" title="All 2 branches missed.">            } else if (mapped == context.nil) {</span>
                // do not mix
<span class="nc" id="L2292">                continue;</span>
            } else {
<span class="nc" id="L2294">                name = mapped.toString();</span>
            }
<span class="nc" id="L2296">            methodLocation.getMethodsForWrite().put(name, entry.getValue().dup());</span>
<span class="nc" id="L2297">        }</span>

<span class="nc" id="L2299">        return mod;</span>
    }

    private void setVisibility(ThreadContext context, IRubyObject[] args, Visibility visibility) {
<span class="fc bfc" id="L2303" title="All 2 branches covered.">        if (args.length == 0) {</span>
            // Note: we change current frames visibility here because the methods which call
            // this method are all &quot;fast&quot; (e.g. they do not created their own frame).
<span class="fc" id="L2306">            context.setCurrentVisibility(visibility);</span>
        } else {
<span class="fc" id="L2308">            setMethodVisibility(args, visibility);</span>
        }
<span class="fc" id="L2310">    }</span>

    /** rb_mod_public
     *
     */
    @JRubyMethod(name = &quot;public&quot;, rest = true, visibility = PRIVATE, writes = VISIBILITY)
    public RubyModule rbPublic(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L2317">        setVisibility(context, args, PUBLIC);</span>
<span class="fc" id="L2318">        return this;</span>
    }

    /** rb_mod_protected
     *
     */
    @JRubyMethod(name = &quot;protected&quot;, rest = true, visibility = PRIVATE, writes = VISIBILITY)
    public RubyModule rbProtected(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L2326">        setVisibility(context, args, PROTECTED);</span>
<span class="fc" id="L2327">        return this;</span>
    }

    /** rb_mod_private
     *
     */
    @JRubyMethod(name = &quot;private&quot;, rest = true, visibility = PRIVATE, writes = VISIBILITY)
    public RubyModule rbPrivate(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L2335">        setVisibility(context, args, PRIVATE);</span>
<span class="fc" id="L2336">        return this;</span>
    }

    /** rb_mod_modfunc
     *
     */
    @JRubyMethod(name = &quot;module_function&quot;, rest = true, visibility = PRIVATE, writes = VISIBILITY)
    public RubyModule module_function(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L2344">        Ruby runtime = context.runtime;</span>

<span class="fc bfc" id="L2346" title="All 2 branches covered.">        if (args.length == 0) {</span>
<span class="fc" id="L2347">            context.setCurrentVisibility(MODULE_FUNCTION);</span>
        } else {
<span class="fc" id="L2349">            setMethodVisibility(args, PRIVATE);</span>

<span class="fc bfc" id="L2351" title="All 2 branches covered.">            for (int i = 0; i &lt; args.length; i++) {</span>
<span class="fc" id="L2352">                String name = args[i].asJavaString().intern();</span>
<span class="fc" id="L2353">                DynamicMethod method = deepMethodSearch(name, runtime);</span>
<span class="fc" id="L2354">                getSingletonClass().addMethod(name, new WrapperMethod(getSingletonClass(), method, PUBLIC));</span>
<span class="fc" id="L2355">                callMethod(context, &quot;singleton_method_added&quot;, context.runtime.fastNewSymbol(name));</span>
            }
        }
<span class="fc" id="L2358">        return this;</span>
    }

    @JRubyMethod(name = &quot;method_added&quot;, required = 1, visibility = PRIVATE)
    public IRubyObject method_added(ThreadContext context, IRubyObject nothing) {
<span class="fc" id="L2363">        return context.runtime.getNil();</span>
    }

    @JRubyMethod(name = &quot;method_removed&quot;, required = 1, visibility = PRIVATE)
    public IRubyObject method_removed(ThreadContext context, IRubyObject nothing) {
<span class="fc" id="L2368">        return context.runtime.getNil();</span>
    }

    @JRubyMethod(name = &quot;method_undefined&quot;, required = 1, visibility = PRIVATE)
    public IRubyObject method_undefined(ThreadContext context, IRubyObject nothing) {
<span class="fc" id="L2373">        return context.runtime.getNil();</span>
    }
    
    @JRubyMethod(name = &quot;method_defined?&quot;, required = 1)
    public RubyBoolean method_defined_p(ThreadContext context, IRubyObject symbol) {
<span class="fc bfc" id="L2378" title="All 2 branches covered.">        return isMethodBound(symbol.asJavaString(), true) ? context.runtime.getTrue() : context.runtime.getFalse();</span>
    }

    @JRubyMethod(name = &quot;public_method_defined?&quot;, required = 1)
    public IRubyObject public_method_defined(ThreadContext context, IRubyObject symbol) {
<span class="fc" id="L2383">        DynamicMethod method = searchMethod(symbol.asJavaString());</span>

<span class="fc bfc" id="L2385" title="All 4 branches covered.">        return context.runtime.newBoolean(!method.isUndefined() &amp;&amp; method.getVisibility() == PUBLIC);</span>
    }

    @JRubyMethod(name = &quot;protected_method_defined?&quot;, required = 1)
    public IRubyObject protected_method_defined(ThreadContext context, IRubyObject symbol) {
<span class="fc" id="L2390">        DynamicMethod method = searchMethod(symbol.asJavaString());</span>

<span class="fc bfc" id="L2392" title="All 4 branches covered.">        return context.runtime.newBoolean(!method.isUndefined() &amp;&amp; method.getVisibility() == PROTECTED);</span>
    }
	
    @JRubyMethod(name = &quot;private_method_defined?&quot;, required = 1)
    public IRubyObject private_method_defined(ThreadContext context, IRubyObject symbol) {
<span class="fc" id="L2397">        DynamicMethod method = searchMethod(symbol.asJavaString());</span>

<span class="fc bfc" id="L2399" title="All 4 branches covered.">        return context.runtime.newBoolean(!method.isUndefined() &amp;&amp; method.getVisibility() == PRIVATE);</span>
    }

    @JRubyMethod(name = &quot;public_class_method&quot;, rest = true)
    public RubyModule public_class_method(IRubyObject[] args) {
<span class="fc" id="L2404">        getSingletonClass().setMethodVisibility(args, PUBLIC);</span>
<span class="fc" id="L2405">        return this;</span>
    }

    @JRubyMethod(name = &quot;private_class_method&quot;, rest = true)
    public RubyModule private_class_method(IRubyObject[] args) {
<span class="fc" id="L2410">        getSingletonClass().setMethodVisibility(args, PRIVATE);</span>
<span class="fc" id="L2411">        return this;</span>
    }

    @JRubyMethod(name = &quot;alias_method&quot;, required = 2, visibility = PRIVATE)
    public RubyModule alias_method(ThreadContext context, IRubyObject newId, IRubyObject oldId) {
<span class="fc" id="L2416">        String newName = newId.asJavaString();</span>
<span class="fc" id="L2417">        defineAlias(newName, oldId.asJavaString());</span>
<span class="fc bfc" id="L2418" title="All 2 branches covered.">        RubySymbol newSym = newId instanceof RubySymbol ? (RubySymbol)newId :</span>
<span class="fc" id="L2419">            context.runtime.newSymbol(newName);</span>
<span class="fc bfc" id="L2420" title="All 2 branches covered.">        if (isSingleton()) {</span>
<span class="fc" id="L2421">            ((MetaClass)this).getAttached().callMethod(context, &quot;singleton_method_added&quot;, newSym);</span>
        } else {
<span class="fc" id="L2423">            callMethod(context, &quot;method_added&quot;, newSym);</span>
        }
<span class="fc" id="L2425">        return this;</span>
    }

    @JRubyMethod(name = &quot;undef_method&quot;, rest = true, visibility = PRIVATE)
    public RubyModule undef_method(ThreadContext context, IRubyObject[] args) {
<span class="fc bfc" id="L2430" title="All 2 branches covered.">        for (int i=0; i&lt;args.length; i++) {</span>
<span class="fc" id="L2431">            undef(context, args[i].asJavaString());</span>
        }
<span class="fc" id="L2433">        return this;</span>
    }

    @JRubyMethod(name = {&quot;module_eval&quot;, &quot;class_eval&quot;},
            reads = {LASTLINE, BACKREF, VISIBILITY, BLOCK, SELF, METHODNAME, LINE, JUMPTARGET, CLASS, FILENAME, SCOPE},
            writes = {LASTLINE, BACKREF, VISIBILITY, BLOCK, SELF, METHODNAME, LINE, JUMPTARGET, CLASS, FILENAME, SCOPE})
    public IRubyObject module_eval(ThreadContext context, Block block) {
<span class="fc" id="L2440">        return specificEval(context, this, block, EvalType.MODULE_EVAL);</span>
    }
    @JRubyMethod(name = {&quot;module_eval&quot;, &quot;class_eval&quot;},
            reads = {LASTLINE, BACKREF, VISIBILITY, BLOCK, SELF, METHODNAME, LINE, JUMPTARGET, CLASS, FILENAME, SCOPE},
            writes = {LASTLINE, BACKREF, VISIBILITY, BLOCK, SELF, METHODNAME, LINE, JUMPTARGET, CLASS, FILENAME, SCOPE})
    public IRubyObject module_eval(ThreadContext context, IRubyObject arg0, Block block) {
<span class="fc" id="L2446">        return specificEval(context, this, arg0, block, EvalType.MODULE_EVAL);</span>
    }
    @JRubyMethod(name = {&quot;module_eval&quot;, &quot;class_eval&quot;},
            reads = {LASTLINE, BACKREF, VISIBILITY, BLOCK, SELF, METHODNAME, LINE, JUMPTARGET, CLASS, FILENAME, SCOPE},
            writes = {LASTLINE, BACKREF, VISIBILITY, BLOCK, SELF, METHODNAME, LINE, JUMPTARGET, CLASS, FILENAME, SCOPE})
    public IRubyObject module_eval(ThreadContext context, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="fc" id="L2452">        return specificEval(context, this, arg0, arg1, block, EvalType.MODULE_EVAL);</span>
    }
    @JRubyMethod(name = {&quot;module_eval&quot;, &quot;class_eval&quot;},
            reads = {LASTLINE, BACKREF, VISIBILITY, BLOCK, SELF, METHODNAME, LINE, JUMPTARGET, CLASS, FILENAME, SCOPE},
            writes = {LASTLINE, BACKREF, VISIBILITY, BLOCK, SELF, METHODNAME, LINE, JUMPTARGET, CLASS, FILENAME, SCOPE})
    public IRubyObject module_eval(ThreadContext context, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2, Block block) {
<span class="fc" id="L2458">        return specificEval(context, this, arg0, arg1, arg2, block, EvalType.MODULE_EVAL);</span>
    }
    @Deprecated
    public IRubyObject module_eval(ThreadContext context, IRubyObject[] args, Block block) {
<span class="nc" id="L2462">        return specificEval(context, this, args, block, EvalType.MODULE_EVAL);</span>
    }

    @JRubyMethod(name = {&quot;module_exec&quot;, &quot;class_exec&quot;},
            reads = {LASTLINE, BACKREF, VISIBILITY, BLOCK, SELF, METHODNAME, LINE, JUMPTARGET, CLASS, FILENAME, SCOPE},
            writes = {LASTLINE, BACKREF, VISIBILITY, BLOCK, SELF, METHODNAME, LINE, JUMPTARGET, CLASS, FILENAME, SCOPE})
    public IRubyObject module_exec(ThreadContext context, Block block) {
<span class="fc bfc" id="L2469" title="All 2 branches covered.">        if (block.isGiven()) {</span>
<span class="fc" id="L2470">            return yieldUnder(context, this, IRubyObject.NULL_ARRAY, block, EvalType.MODULE_EVAL);</span>
        } else {
<span class="fc" id="L2472">            throw context.runtime.newLocalJumpErrorNoBlock();</span>
        }
    }

    @JRubyMethod(name = {&quot;module_exec&quot;, &quot;class_exec&quot;}, rest = true,
            reads = {LASTLINE, BACKREF, VISIBILITY, BLOCK, SELF, METHODNAME, LINE, JUMPTARGET, CLASS, FILENAME, SCOPE},
            writes = {LASTLINE, BACKREF, VISIBILITY, BLOCK, SELF, METHODNAME, LINE, JUMPTARGET, CLASS, FILENAME, SCOPE})
    public IRubyObject module_exec(ThreadContext context, IRubyObject[] args, Block block) {
<span class="pc bpc" id="L2480" title="1 of 2 branches missed.">        if (block.isGiven()) {</span>
<span class="fc" id="L2481">            return yieldUnder(context, this, args, block, EvalType.MODULE_EVAL);</span>
        } else {
<span class="nc" id="L2483">            throw context.runtime.newLocalJumpErrorNoBlock();</span>
        }
    }

    @JRubyMethod(name = &quot;remove_method&quot;, rest = true, visibility = PRIVATE)
    public RubyModule remove_method(ThreadContext context, IRubyObject[] args) {
<span class="fc bfc" id="L2489" title="All 2 branches covered.">        for(int i=0;i&lt;args.length;i++) {</span>
<span class="fc" id="L2490">            removeMethod(context, args[i].asJavaString());</span>
        }
<span class="fc" id="L2492">        return this;</span>
    }

    public static void marshalTo(RubyModule module, MarshalStream output) throws java.io.IOException {
<span class="fc" id="L2496">        output.registerLinkTarget(module);</span>
<span class="fc" id="L2497">        output.writeString(MarshalStream.getPathFromClass(module));</span>
<span class="fc" id="L2498">    }</span>

    public static RubyModule unmarshalFrom(UnmarshalStream input) throws java.io.IOException {
<span class="fc" id="L2501">        String name = RubyString.byteListToString(input.unmarshalString());</span>
<span class="fc" id="L2502">        RubyModule result = UnmarshalStream.getModuleFromPath(input.getRuntime(), name);</span>
<span class="fc" id="L2503">        input.registerLinkTarget(result);</span>
<span class="fc" id="L2504">        return result;</span>
    }

    /* Module class methods */
    
    /** 
     * Return an array of nested modules or classes.
     */
    @JRubyMethod(name = &quot;nesting&quot;, reads = SCOPE, meta = true)
    public static RubyArray nesting(ThreadContext context, IRubyObject recv, Block block) {
<span class="fc" id="L2514">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L2515">        RubyModule object = runtime.getObject();</span>
<span class="fc" id="L2516">        StaticScope scope = context.getCurrentScope().getStaticScope();</span>
<span class="fc" id="L2517">        RubyArray result = runtime.newArray();</span>
        
<span class="fc bfc" id="L2519" title="All 2 branches covered.">        for (StaticScope current = scope; current.getModule() != object; current = current.getPreviousCRefScope()) {</span>
<span class="fc" id="L2520">            result.append(current.getModule());</span>
        }
        
<span class="fc" id="L2523">        return result;</span>
    }

    /**
     * Include the given module and all related modules into the hierarchy above
     * this module/class. Inspects the hierarchy to ensure the same module isn't
     * included twice, and selects an appropriate insertion point for each incoming
     * module.
     * 
     * @param baseModule The module to include, along with any modules it itself includes
     */
    private void doIncludeModule(RubyModule baseModule) {
<span class="fc" id="L2535">        List&lt;RubyModule&gt; modulesToInclude = gatherModules(baseModule);</span>
        
<span class="fc" id="L2537">        RubyModule currentInclusionPoint = methodLocation;</span>
<span class="fc bfc" id="L2538" title="All 2 branches covered.">        ModuleLoop: for (RubyModule nextModule : modulesToInclude) {</span>
<span class="fc" id="L2539">            checkForCyclicInclude(nextModule);</span>

<span class="fc" id="L2541">            boolean superclassSeen = false;</span>

            // nextClass.isIncluded() &amp;&amp; nextClass.getNonIncludedClass() == nextModule.getNonIncludedClass();
            // scan class hierarchy for module
<span class="fc bfc" id="L2545" title="All 2 branches covered.">            for (RubyClass nextClass = methodLocation.getSuperClass(); nextClass != null; nextClass = nextClass.getSuperClass()) {</span>
<span class="fc bfc" id="L2546" title="All 2 branches covered.">                if (doesTheClassWrapTheModule(nextClass, nextModule)) {</span>
                    // next in hierarchy is an included version of the module we're attempting,
                    // so we skip including it

                    // if we haven't encountered a real superclass, use the found module as the new inclusion point
<span class="fc bfc" id="L2551" title="All 2 branches covered.">                    if (!superclassSeen) currentInclusionPoint = nextClass;</span>

                    continue ModuleLoop;
                } else {
<span class="fc" id="L2555">                    superclassSeen = true;</span>
                }
            }

<span class="fc" id="L2559">            currentInclusionPoint = proceedWithInclude(currentInclusionPoint, nextModule.getDelegate());</span>
<span class="fc" id="L2560">        }</span>
<span class="fc" id="L2561">    }</span>

    /**
     * Prepend the given module and all related modules into the hierarchy above
     * this module/class. Inspects the hierarchy to ensure the same module isn't
     * included twice, and selects an appropriate insertion point for each incoming
     * module.
     *
     * @param baseModule The module to prepend, along with any modules it itself includes
     */
    private void doPrependModule(RubyModule baseModule) {
<span class="fc" id="L2572">        List&lt;RubyModule&gt; modulesToInclude = gatherModules(baseModule);</span>

<span class="fc" id="L2574">        RubyClass insertBelowSuperClass = null;</span>
<span class="fc bfc" id="L2575" title="All 2 branches covered.">        if (methodLocation == this) {</span>
            // In the current logic, if we getService here we know that module is not an
            // IncludedModule, so there's no need to fish out the delegate. But just
            // in case the logic should change later, let's do it anyway
<span class="fc" id="L2579">            RubyClass prep = new PrependedModule(getRuntime(), getSuperClass(), this);</span>

            // if the insertion point is a class, update subclass lists
<span class="fc bfc" id="L2582" title="All 2 branches covered.">            if (this instanceof RubyClass) {</span>
<span class="fc" id="L2583">                RubyClass insertBelowClass = (RubyClass)this;</span>

                // if there's a non-null superclass, we're including into a normal class hierarchy;
                // update subclass relationships to avoid stale parent/child relationships
<span class="pc bpc" id="L2587" title="1 of 2 branches missed.">                if (insertBelowClass.getSuperClass() != null) {</span>
<span class="fc" id="L2588">                    insertBelowClass.getSuperClass().replaceSubclass(insertBelowClass, prep);</span>
                }

<span class="fc" id="L2591">                prep.addSubclass(insertBelowClass);</span>
            }
<span class="fc" id="L2593">            setSuperClass(prep);</span>
        }

<span class="fc" id="L2596">        RubyModule currentInclusionPoint = this;</span>
<span class="fc bfc" id="L2597" title="All 2 branches covered.">        ModuleLoop: for (RubyModule nextModule : modulesToInclude) {</span>
<span class="fc" id="L2598">            checkForCyclicInclude(nextModule);</span>

<span class="fc" id="L2600">            boolean superclassSeen = false;</span>

            // scan class hierarchy for module
<span class="fc bfc" id="L2603" title="All 2 branches covered.">            for (RubyClass nextClass = this.getSuperClass(); nextClass != null; nextClass = nextClass.getSuperClass()) {</span>
<span class="pc bpc" id="L2604" title="1 of 2 branches missed.">                if (doesTheClassWrapTheModule(nextClass, nextModule)) {</span>
                    // next in hierarchy is an included version of the module we're attempting,
                    // so we skip including it

                    // if we haven't encountered a real superclass, use the found module as the new inclusion point
<span class="nc bnc" id="L2609" title="All 2 branches missed.">                    if (!superclassSeen) currentInclusionPoint = nextClass;</span>

                    continue ModuleLoop;
                } else {
<span class="fc" id="L2613">                    superclassSeen = true;</span>
                }
            }

<span class="fc" id="L2617">            currentInclusionPoint = proceedWithPrepend(currentInclusionPoint, nextModule);</span>
<span class="fc" id="L2618">        }</span>
<span class="fc" id="L2619">    }</span>

    /**
     * Is the given class a wrapper for the specified module?
     * 
     * @param theClass The class to inspect
     * @param theModule The module we're looking for
     * @return true if the class is a wrapper for the module, false otherwise
     */
    private boolean doesTheClassWrapTheModule(RubyClass theClass, RubyModule theModule) {
<span class="fc bfc" id="L2629" title="All 2 branches covered.">        return theClass.isIncluded() &amp;&amp;</span>
<span class="fc bfc" id="L2630" title="All 2 branches covered.">                theClass.getDelegate() == theModule.getDelegate();</span>
    }

    /**
     * Gather all modules that would be included by including the given module.
     * The resulting list contains the given module and its (zero or more)
     * module-wrapping superclasses.
     * 
     * @param baseModule The base module from which to aggregate modules
     * @return A list of all modules that would be included by including the given module
     */
    private List&lt;RubyModule&gt; gatherModules(RubyModule baseModule) {
        // build a list of all modules to consider for inclusion
<span class="fc" id="L2643">        List&lt;RubyModule&gt; modulesToInclude = new ArrayList&lt;RubyModule&gt;();</span>
<span class="fc bfc" id="L2644" title="All 2 branches covered.">        while (baseModule != null) {</span>
<span class="fc" id="L2645">            modulesToInclude.add(baseModule.getDelegate());</span>
<span class="fc" id="L2646">            baseModule = baseModule.getSuperClass();</span>
        }

<span class="fc" id="L2649">        return modulesToInclude;</span>
    }

    /**
     * Actually proceed with including the specified module above the given target
     * in a hierarchy. Return the new module wrapper.
     * 
     * @param insertAbove The hierarchy target above which to include the wrapped module
     * @param moduleToInclude The module to wrap and include
     * @return The new module wrapper resulting from this include
     */
    private RubyModule proceedWithInclude(RubyModule insertAbove, RubyModule moduleToInclude) {
        // In the current logic, if we getService here we know that module is not an
        // IncludedModuleWrapper, so there's no need to fish out the delegate. But just
        // in case the logic should change later, let's do it anyway
<span class="fc" id="L2664">        RubyClass wrapper = new IncludedModuleWrapper(getRuntime(), insertAbove.getSuperClass(), moduleToInclude);</span>

        // if the insertion point is a class, update subclass lists
<span class="fc bfc" id="L2667" title="All 2 branches covered.">        if (insertAbove instanceof RubyClass) {</span>
<span class="fc" id="L2668">            RubyClass insertAboveClass = (RubyClass)insertAbove;</span>

            // if there's a non-null superclass, we're including into a normal class hierarchy;
            // update subclass relationships to avoid stale parent/child relationships
<span class="fc bfc" id="L2672" title="All 2 branches covered.">            if (insertAboveClass.getSuperClass() != null) {</span>
<span class="fc" id="L2673">                insertAboveClass.getSuperClass().replaceSubclass(insertAboveClass, wrapper);</span>
            }

<span class="fc" id="L2676">            wrapper.addSubclass(insertAboveClass);</span>
        }

<span class="fc" id="L2679">        insertAbove.setSuperClass(wrapper);</span>
<span class="fc" id="L2680">        insertAbove = insertAbove.getSuperClass();</span>
<span class="fc" id="L2681">        return insertAbove;</span>
    }

    /**
     * Actually proceed with prepending the specified module below the given target
     * in a hierarchy. Return the new module wrapper.
     *
     * @param insertBelow The hierarchy target below which to include the wrapped module
     * @param moduleToPrepend The module to wrap and prepend
     * @return The new module wrapper resulting from this prepend
     */
    private RubyModule proceedWithPrepend(RubyModule insertBelow, RubyModule moduleToPrepend) {
<span class="fc bfc" id="L2693" title="All 2 branches covered.">        if (!moduleToPrepend.isPrepended()) moduleToPrepend = moduleToPrepend.getNonIncludedClass();</span>

<span class="fc" id="L2695">        RubyModule newInclusionPoint = proceedWithInclude(insertBelow, moduleToPrepend);</span>

<span class="fc" id="L2697">        return newInclusionPoint;</span>
    }


    //
    ////////////////// CLASS VARIABLE RUBY METHODS ////////////////
    //

    @JRubyMethod(name = &quot;class_variable_defined?&quot;, required = 1)
    public IRubyObject class_variable_defined_p(ThreadContext context, IRubyObject var) {
<span class="fc" id="L2707">        String internedName = validateClassVariable(var.asJavaString().intern());</span>
<span class="fc" id="L2708">        RubyModule module = this;</span>
        do {
<span class="fc bfc" id="L2710" title="All 2 branches covered.">            if (module.hasClassVariable(internedName)) {</span>
<span class="fc" id="L2711">                return context.runtime.getTrue();</span>
            }
<span class="fc bfc" id="L2713" title="All 2 branches covered.">        } while ((module = module.getSuperClass()) != null);</span>

<span class="fc" id="L2715">        return context.runtime.getFalse();</span>
    }

    /** rb_mod_cvar_get
     *
     */
    public IRubyObject class_variable_get(IRubyObject var) {
<span class="fc" id="L2722">        return getClassVar(validateClassVariable(var.asJavaString()).intern());</span>
    }

    @JRubyMethod(name = &quot;class_variable_get&quot;)
    public IRubyObject class_variable_get19(IRubyObject var) {
<span class="fc" id="L2727">        return class_variable_get(var);</span>
    }

    /** rb_mod_cvar_set
     *
     */
    public IRubyObject class_variable_set(IRubyObject var, IRubyObject value) {
<span class="fc" id="L2734">        return setClassVar(validateClassVariable(var.asJavaString()).intern(), value);</span>
    }

    @JRubyMethod(name = &quot;class_variable_set&quot;)
    public IRubyObject class_variable_set19(IRubyObject var, IRubyObject value) {
<span class="fc" id="L2739">        return class_variable_set(var, value);</span>
    }

    /** rb_mod_remove_cvar
     *
     */
    public IRubyObject remove_class_variable(ThreadContext context, IRubyObject name) {
<span class="fc" id="L2746">        return removeClassVariable(name.asJavaString());</span>
    }

    @JRubyMethod(name = &quot;remove_class_variable&quot;)
    public IRubyObject remove_class_variable19(ThreadContext context, IRubyObject name) {
<span class="fc" id="L2751">        return remove_class_variable(context, name);</span>
    }

    /** rb_mod_class_variables
     *
     */
    public RubyArray class_variables(ThreadContext context) {
<span class="nc" id="L2758">        return class_variables19(context);</span>
    }

    @JRubyMethod(name = &quot;class_variables&quot;)
    public RubyArray class_variables19(ThreadContext context) {
<span class="fc" id="L2763">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L2764">        RubyArray ary = runtime.newArray();</span>
        
<span class="fc" id="L2766">        Collection&lt;String&gt; names = classVariablesCommon();</span>
<span class="fc bfc" id="L2767" title="All 2 branches covered.">        for (String name : names) {</span>
<span class="fc" id="L2768">            ary.add(runtime.newSymbol(name));</span>
<span class="fc" id="L2769">        }</span>
<span class="fc" id="L2770">        return ary;</span>
    }

    private Collection&lt;String&gt; classVariablesCommon() {
<span class="fc" id="L2774">        Set&lt;String&gt; names = new HashSet&lt;String&gt;();</span>
<span class="fc bfc" id="L2775" title="All 2 branches covered.">        for (RubyModule p = this; p != null; p = p.getSuperClass()) {</span>
<span class="fc" id="L2776">            names.addAll(p.getClassVariableNameList());</span>
        }
<span class="fc" id="L2778">        return names;</span>
    }


    //
    ////////////////// CONSTANT RUBY METHODS ////////////////
    //

    /** rb_mod_const_defined
     *
     */
    public RubyBoolean const_defined_p(ThreadContext context, IRubyObject symbol) {
<span class="nc" id="L2790">        return const_defined_p19(context, new IRubyObject[]{symbol});</span>
    }

    @JRubyMethod(name = &quot;const_defined?&quot;, required = 1, optional = 1)
    public RubyBoolean const_defined_p19(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L2795">        IRubyObject symbol = args[0];</span>
<span class="pc bpc" id="L2796" title="1 of 6 branches missed.">        boolean inherit = args.length == 1 || (!args[1].isNil() &amp;&amp; args[1].isTrue());</span>

        // Note: includes part of fix for JRUBY-1339
<span class="fc" id="L2799">        return context.runtime.newBoolean(fastIsConstantDefined19(validateConstant(symbol).intern(), inherit));</span>
    }

    /** rb_mod_const_get
     *
     */
    public IRubyObject const_get(IRubyObject symbol) {
<span class="nc" id="L2806">        return const_get_2_0(getRuntime().getCurrentContext(), new IRubyObject[]{symbol});</span>
    }

    public IRubyObject const_get_1_9(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L2810">        return const_get_2_0(context, args);</span>
    }

    @JRubyMethod(name = &quot;const_get&quot;, required = 1, optional = 1)
    public IRubyObject const_get_2_0(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L2815">        String fullName = args[0].asJavaString();</span>
<span class="fc" id="L2816">        String symbol = fullName;</span>
<span class="pc bpc" id="L2817" title="1 of 6 branches missed.">        boolean inherit = args.length == 1 || (!args[1].isNil() &amp;&amp; args[1].isTrue());</span>

<span class="fc" id="L2819">        RubyModule mod = this;</span>
        int sep;
<span class="fc bfc" id="L2821" title="All 2 branches covered.">        while((sep = symbol.indexOf(&quot;::&quot;)) != -1) {</span>
<span class="fc" id="L2822">            String segment = symbol.substring(0, sep);</span>
<span class="fc" id="L2823">            symbol = symbol.substring(sep + 2);</span>
<span class="fc" id="L2824">            IRubyObject obj = mod.getConstant(validateConstant(segment, args[0]), inherit, inherit);</span>
<span class="pc bpc" id="L2825" title="1 of 2 branches missed.">            if(obj instanceof RubyModule) {</span>
<span class="fc" id="L2826">                mod = (RubyModule)obj;</span>
            } else {
<span class="nc" id="L2828">                throw context.runtime.newTypeError(segment + &quot; does not refer to class/module&quot;);</span>
            }
<span class="fc" id="L2830">        }</span>

<span class="fc" id="L2832">        return mod.getConstant(validateConstant(symbol, args[0]), inherit, inherit);</span>
    }

    /** rb_mod_const_set
     *
     */
    @JRubyMethod(name = &quot;const_set&quot;, required = 2)
    public IRubyObject const_set(IRubyObject symbol, IRubyObject value) {
<span class="fc" id="L2840">        IRubyObject constant = setConstant(validateConstant(symbol).intern(), value);</span>

<span class="fc bfc" id="L2842" title="All 2 branches covered.">        if (constant instanceof RubyModule) {</span>
<span class="fc" id="L2843">            ((RubyModule)constant).calculateName();</span>
        }
<span class="fc" id="L2845">        return constant;</span>
    }

    @JRubyMethod(name = &quot;remove_const&quot;, required = 1, visibility = PRIVATE)
    public IRubyObject remove_const(ThreadContext context, IRubyObject rubyName) {
<span class="fc" id="L2850">        String name = validateConstant(rubyName);</span>
        IRubyObject value;
<span class="fc bfc" id="L2852" title="All 2 branches covered.">        if ((value = deleteConstant(name)) != null) {</span>
<span class="fc" id="L2853">            invalidateConstantCache(name);</span>
<span class="fc bfc" id="L2854" title="All 2 branches covered.">            if (value != UNDEF) {</span>
<span class="fc" id="L2855">                return value;</span>
            }
<span class="fc" id="L2857">            removeAutoload(name);</span>
            // FIXME: I'm not sure this is right, but the old code returned
            // the undef, which definitely isn't right...
<span class="fc" id="L2860">            return context.runtime.getNil();</span>
        }

<span class="fc bfc" id="L2863" title="All 2 branches covered.">        if (hasConstantInHierarchy(name)) {</span>
<span class="fc" id="L2864">            throw cannotRemoveError(name);</span>
        }

<span class="fc" id="L2867">        throw context.runtime.newNameError(&quot;constant &quot; + name + &quot; not defined for &quot; + getName(), name);</span>
    }

    private boolean hasConstantInHierarchy(final String name) {
<span class="fc bfc" id="L2871" title="All 2 branches covered.">        for (RubyModule p = this; p != null; p = p.getSuperClass()) {</span>
<span class="fc bfc" id="L2872" title="All 2 branches covered.">            if (p.hasConstant(name)) {</span>
<span class="fc" id="L2873">                return true;</span>
            }
        }
<span class="fc" id="L2876">        return false;</span>
    }
    
    /**
     * Base implementation of Module#const_missing, throws NameError for specific missing constant.
     * 
     * @param rubyName The constant name which was found to be missing
     * @return Nothing! Absolutely nothing! (though subclasses might choose to return something)
     */
    @JRubyMethod(name = &quot;const_missing&quot;, required = 1)
    public IRubyObject const_missing(ThreadContext context, IRubyObject rubyName, Block block) {
<span class="fc" id="L2887">        Ruby runtime = context.runtime;</span>
        String name;
        
<span class="fc bfc" id="L2890" title="All 2 branches covered.">        if (this != runtime.getObject()) {</span>
<span class="fc" id="L2891">            name = getName() + &quot;::&quot; + rubyName.asJavaString();</span>
        } else {
<span class="fc" id="L2893">            name = rubyName.asJavaString();</span>
        }

<span class="fc" id="L2896">        throw runtime.newNameErrorObject(&quot;uninitialized constant &quot; + name, runtime.newSymbol(name));</span>
    }

    public RubyArray constants(ThreadContext context) {
<span class="nc" id="L2900">        return constants19(context);</span>
    }

    @JRubyMethod(name = &quot;constants&quot;)
    public RubyArray constants19(ThreadContext context) {
<span class="fc" id="L2905">        return constantsCommon19(context, true, true);</span>
    }

    @JRubyMethod(name = &quot;constants&quot;)
    public RubyArray constants19(ThreadContext context, IRubyObject allConstants) {
<span class="fc" id="L2910">        return constantsCommon19(context, false, allConstants.isTrue());</span>
    }
    
    public RubyArray constantsCommon19(ThreadContext context, boolean replaceModule, boolean allConstants) {
<span class="fc" id="L2914">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L2915">        RubyArray array = runtime.newArray();</span>
        
<span class="fc" id="L2917">        Collection&lt;String&gt; constantNames = constantsCommon(runtime, replaceModule, allConstants, false);</span>
        
<span class="fc bfc" id="L2919" title="All 2 branches covered.">        for (String name : constantNames) {</span>
<span class="fc" id="L2920">            array.add(runtime.newSymbol(name));</span>
<span class="fc" id="L2921">        }</span>
<span class="fc" id="L2922">        return array;</span>
    }

    /** rb_mod_constants
     *
     */
    public Collection&lt;String&gt; constantsCommon(Ruby runtime, boolean replaceModule, boolean allConstants) {
<span class="nc" id="L2929">        return constantsCommon(runtime, replaceModule, allConstants, true);</span>
    }


    public Collection&lt;String&gt; constantsCommon(Ruby runtime, boolean replaceModule, boolean allConstants, boolean includePrivate) {
<span class="fc" id="L2934">        RubyModule objectClass = runtime.getObject();</span>

<span class="fc" id="L2936">        Collection&lt;String&gt; constantNames = new HashSet&lt;String&gt;();</span>
<span class="fc bfc" id="L2937" title="All 2 branches covered.">        if (allConstants) {</span>
<span class="fc bfc" id="L2938" title="All 6 branches covered.">            if ((replaceModule &amp;&amp; runtime.getModule() == this) || objectClass == this) {</span>
<span class="fc" id="L2939">                constantNames = objectClass.getConstantNames(includePrivate);</span>
            } else {
<span class="fc" id="L2941">                Set&lt;String&gt; names = new HashSet&lt;String&gt;();</span>
<span class="fc bfc" id="L2942" title="All 4 branches covered.">                for (RubyModule module = this; module != null &amp;&amp; module != objectClass; module = module.getSuperClass()) {</span>
<span class="fc" id="L2943">                    names.addAll(module.getConstantNames(includePrivate));</span>
                }
<span class="fc" id="L2945">                constantNames = names;</span>
<span class="fc" id="L2946">            }</span>
        } else {
<span class="pc bpc" id="L2948" title="4 of 6 branches missed.">            if ((replaceModule &amp;&amp; runtime.getModule() == this) || objectClass == this) {</span>
<span class="nc" id="L2949">                constantNames = objectClass.getConstantNames(includePrivate);</span>
            } else {
<span class="fc" id="L2951">                constantNames = getConstantNames(includePrivate);</span>
            }
        }

<span class="fc" id="L2955">        return constantNames;</span>
    }

    @JRubyMethod
    public IRubyObject private_constant(ThreadContext context, IRubyObject rubyName) {
<span class="fc" id="L2960">        String name = validateConstant(rubyName);</span>

<span class="fc" id="L2962">        setConstantVisibility(context, name, true);</span>
<span class="fc" id="L2963">        invalidateConstantCache(name);</span>

<span class="fc" id="L2965">        return this;</span>
    }

    @JRubyMethod(required = 1, rest = true)
    public IRubyObject private_constant(ThreadContext context, IRubyObject[] rubyNames) {
<span class="fc bfc" id="L2970" title="All 2 branches covered.">        for (IRubyObject rubyName : rubyNames) {</span>
<span class="fc" id="L2971">            String name = validateConstant(rubyName);</span>

<span class="fc" id="L2973">            setConstantVisibility(context, name, true);</span>
<span class="fc" id="L2974">            invalidateConstantCache(name);</span>
        }
<span class="fc" id="L2976">        return this;</span>
    }

    @JRubyMethod
    public IRubyObject public_constant(ThreadContext context, IRubyObject rubyName) {
<span class="nc" id="L2981">        String name = validateConstant(rubyName);</span>

<span class="nc" id="L2983">        setConstantVisibility(context, name, false);</span>
<span class="nc" id="L2984">        invalidateConstantCache(name);</span>
<span class="nc" id="L2985">        return this;</span>
    }

    @JRubyMethod(required = 1, rest = true)
    public IRubyObject public_constant(ThreadContext context, IRubyObject[] rubyNames) {
<span class="fc bfc" id="L2990" title="All 2 branches covered.">        for (IRubyObject rubyName : rubyNames) {</span>
<span class="fc" id="L2991">            String name = validateConstant(rubyName);</span>
<span class="fc" id="L2992">            setConstantVisibility(context, name, false);</span>
<span class="fc" id="L2993">            invalidateConstantCache(name);</span>
        }
<span class="fc" id="L2995">        return this;</span>
    }

    @JRubyMethod(name = &quot;prepend&quot;, rest = true, visibility = PUBLIC)
    public IRubyObject prepend(ThreadContext context, IRubyObject[] modules) {
        // MRI checks all types first:
<span class="fc bfc" id="L3001" title="All 2 branches covered.">        for (int i = modules.length; --i &gt;= 0; ) {</span>
<span class="fc" id="L3002">            IRubyObject obj = modules[i];</span>
<span class="fc bfc" id="L3003" title="All 2 branches covered.">            if (!obj.isModule()) {</span>
<span class="fc" id="L3004">                throw context.runtime.newTypeError(obj, context.runtime.getModule());</span>
            }
<span class="fc" id="L3006">        }</span>
<span class="fc bfc" id="L3007" title="All 2 branches covered.">        for (int i = modules.length - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L3008">            modules[i].callMethod(context, &quot;prepend_features&quot;, this);</span>
<span class="fc" id="L3009">            modules[i].callMethod(context, &quot;prepended&quot;, this);</span>
        }

<span class="fc" id="L3012">        return this;</span>
    }

    @JRubyMethod(name = &quot;prepended&quot;, required = 1, visibility = PRIVATE)
    public IRubyObject prepended(ThreadContext context, IRubyObject other) {
<span class="fc" id="L3017">        return context.runtime.getNil();</span>
    }

    private void setConstantVisibility(ThreadContext context, String name, boolean hidden) {
<span class="fc" id="L3021">        ConstantEntry entry = getConstantMap().get(name);</span>

<span class="fc bfc" id="L3023" title="All 2 branches covered.">        if (entry == null) {</span>
<span class="fc" id="L3024">            throw context.runtime.newNameError(&quot;constant &quot; + getName() + &quot;::&quot; + name + &quot; not defined&quot;, name);</span>
        }

<span class="fc" id="L3027">        getConstantMapForWrite().put(name, new ConstantEntry(entry.value, hidden));</span>
<span class="fc" id="L3028">    }</span>

    //
    ////////////////// CLASS VARIABLE API METHODS ////////////////
    //

    /**
     * Set the named class variable to the given value, provided taint and freeze allow setting it.
     * 
     * Ruby C equivalent = &quot;rb_cvar_set&quot;
     * 
     * @param name The variable name to set
     * @param value The value to set it to
     */
    public IRubyObject setClassVar(String name, IRubyObject value) {
<span class="fc" id="L3043">        RubyModule module = this;</span>
        do {
<span class="fc bfc" id="L3045" title="All 2 branches covered.">            if (module.hasClassVariable(name)) {</span>
<span class="fc" id="L3046">                return module.storeClassVariable(name, value);</span>
            }
<span class="fc bfc" id="L3048" title="All 2 branches covered.">        } while ((module = module.getSuperClass()) != null);</span>
        
<span class="fc" id="L3050">        return storeClassVariable(name, value);</span>
    }

    @Deprecated
    public IRubyObject fastSetClassVar(final String internedName, final IRubyObject value) {
<span class="nc" id="L3055">        return setClassVar(internedName, value);</span>
    }

    /**
     * Retrieve the specified class variable, searching through this module, included modules, and supermodules.
     * 
     * Ruby C equivalent = &quot;rb_cvar_get&quot;
     * 
     * @param name The name of the variable to retrieve
     * @return The variable's value, or throws NameError if not found
     */
    public IRubyObject getClassVar(String name) {
<span class="pc bpc" id="L3067" title="3 of 4 branches missed.">        assert IdUtil.isClassVariable(name);</span>
        Object value;
<span class="fc" id="L3069">        RubyModule module = this;</span>

        do {
<span class="fc bfc" id="L3072" title="All 2 branches covered.">            if ((value = module.fetchClassVariable(name)) != null) return (IRubyObject)value;</span>
<span class="fc bfc" id="L3073" title="All 2 branches covered.">        } while ((module = module.getSuperClass()) != null);</span>

<span class="fc" id="L3075">        throw getRuntime().newNameError(&quot;uninitialized class variable &quot; + name + &quot; in &quot; + getName(), name);</span>
    }

    @Deprecated
    public IRubyObject fastGetClassVar(String internedName) {
<span class="nc" id="L3080">        return getClassVar(internedName);</span>
    }

    /**
     * Is class var defined?
     * 
     * Ruby C equivalent = &quot;rb_cvar_defined&quot;
     * 
     * @param name The class var to determine &quot;is defined?&quot;
     * @return true if true, false if false
     */
    public boolean isClassVarDefined(String name) {
<span class="fc" id="L3092">        RubyModule module = this;</span>
        do {
<span class="fc bfc" id="L3094" title="All 2 branches covered.">            if (module.hasClassVariable(name)) return true;</span>
<span class="fc bfc" id="L3095" title="All 2 branches covered.">        } while ((module = module.getSuperClass()) != null);</span>

<span class="fc" id="L3097">        return false;</span>
    }

    @Deprecated
    public boolean fastIsClassVarDefined(String internedName) {
<span class="nc" id="L3102">        return isClassVarDefined(internedName);</span>
    }
    
    /** rb_mod_remove_cvar
     *
     * @deprecated - use {@link #removeClassVariable(String)}
     */
    @Deprecated
    public IRubyObject removeCvar(IRubyObject name) {
<span class="nc" id="L3111">        return removeClassVariable(name.asJavaString());</span>
    }

    public IRubyObject removeClassVariable(String name) {
<span class="fc" id="L3115">        String javaName = validateClassVariable(name);</span>
        IRubyObject value;

<span class="fc bfc" id="L3118" title="All 2 branches covered.">        if ((value = deleteClassVariable(javaName)) != null) {</span>
<span class="fc" id="L3119">            return value;</span>
        }

<span class="pc bpc" id="L3122" title="1 of 2 branches missed.">        if (isClassVarDefined(javaName)) {</span>
<span class="nc" id="L3123">            throw cannotRemoveError(javaName);</span>
        }

<span class="fc" id="L3126">        throw getRuntime().newNameError(&quot;class variable &quot; + javaName + &quot; not defined for &quot; + getName(), javaName);</span>
    }


    //
    ////////////////// CONSTANT API METHODS ////////////////
    //

    /**
     * This version searches superclasses if we're starting with Object. This
     * corresponds to logic in rb_const_defined_0 that recurses for Object only.
     *
     * @param name the constant name to find
     * @return the constant, or null if it was not found
     */
    public IRubyObject getConstantAtSpecial(String name) {
        IRubyObject value;
<span class="fc bfc" id="L3143" title="All 2 branches covered.">        if (this == getRuntime().getObject()) {</span>
<span class="fc" id="L3144">            value = getConstantNoConstMissing(name);</span>
        } else {
<span class="fc" id="L3146">            value = fetchConstant(name);</span>
        }
        
<span class="fc bfc" id="L3149" title="All 2 branches covered.">        return value == UNDEF ? resolveUndefConstant(name) : value;</span>
    }

    public IRubyObject getConstantAt(String name) {
<span class="fc" id="L3153">        return getConstantAt(name, true);</span>
    }
    
    public IRubyObject getConstantAt(String name, boolean includePrivate) {
<span class="fc" id="L3157">        IRubyObject value = fetchConstant(name, includePrivate);</span>

<span class="fc bfc" id="L3159" title="All 2 branches covered.">        return value == UNDEF ? resolveUndefConstant(name) : value;</span>
    }

    @Deprecated
    public IRubyObject fastGetConstantAt(String internedName) {
<span class="nc" id="L3164">        return getConstantAt(internedName);</span>
    }

    /**
     * Retrieve the named constant, invoking 'const_missing' should that be appropriate.
     * 
     * @param name The constant to retrieve
     * @return The value for the constant, or null if not found
     */
    public IRubyObject getConstant(String name) {
<span class="fc" id="L3174">        return getConstant(name, true);</span>
    }

    public IRubyObject getConstant(String name, boolean inherit) {
<span class="fc" id="L3178">        return getConstant(name, inherit, true);</span>
    }

    public IRubyObject getConstant(String name, boolean inherit, boolean includeObject) {
<span class="fc" id="L3182">        IRubyObject value = getConstantNoConstMissing(name, inherit, includeObject);</span>
<span class="fc" id="L3183">        Ruby runtime = getRuntime();</span>

<span class="fc bfc" id="L3185" title="All 2 branches covered.">        return value == null ? callMethod(runtime.getCurrentContext(), &quot;const_missing&quot;,</span>
<span class="fc" id="L3186">                runtime.newSymbol(name)) : value;</span>
    }

    @Deprecated
    public IRubyObject fastGetConstant(String internedName) {
<span class="nc" id="L3191">        return getConstant(internedName);</span>
    }

    @Deprecated
    public IRubyObject fastGetConstant(String internedName, boolean inherit) {
<span class="nc" id="L3196">        return getConstant(internedName, inherit);</span>
    }

    public IRubyObject getConstantNoConstMissing(String name) {
<span class="fc" id="L3200">        return getConstantNoConstMissing(name, true);</span>
    }

    public IRubyObject getConstantNoConstMissing(String name, boolean inherit) {
<span class="fc" id="L3204">        return getConstantNoConstMissing(name, inherit, true);</span>
    }

    public IRubyObject getConstantNoConstMissing(String name, boolean inherit, boolean includeObject) {
<span class="pc bpc" id="L3208" title="3 of 4 branches missed.">        assert IdUtil.isConstant(name);</span>

<span class="fc" id="L3210">        IRubyObject constant = iterateConstantNoConstMissing(name, this, inherit);</span>

<span class="fc bfc" id="L3212" title="All 6 branches covered.">        if (constant == null &amp;&amp; !isClass() &amp;&amp; includeObject) {</span>
<span class="fc" id="L3213">            constant = iterateConstantNoConstMissing(name, getRuntime().getObject(), inherit);</span>
        }

<span class="fc" id="L3216">        return constant;</span>
    }

    private IRubyObject iterateConstantNoConstMissing(String name, RubyModule init, boolean inherit) {
<span class="fc bfc" id="L3220" title="All 2 branches covered.">        for (RubyModule p = init; p != null; p = p.getSuperClass()) {</span>
<span class="fc" id="L3221">            IRubyObject value = p.getConstantAt(name);</span>

<span class="pc bpc" id="L3223" title="1 of 4 branches missed.">            if (value != null) return value == UNDEF ? null : value;</span>
<span class="fc bfc" id="L3224" title="All 2 branches covered.">            if (!inherit) break;</span>
        }
<span class="fc" id="L3226">        return null;</span>
    }

    // not actually called anywhere (all known uses call the fast version)
    public IRubyObject getConstantFrom(String name) {
<span class="nc" id="L3231">        IRubyObject value = getConstantFromNoConstMissing(name);</span>

<span class="nc bnc" id="L3233" title="All 2 branches missed.">        return value != null ? value : getConstantFromConstMissing(name);</span>
    }
    
    @Deprecated
    public IRubyObject fastGetConstantFrom(String internedName) {
<span class="nc" id="L3238">        return getConstantFrom(internedName);</span>
    }

    public IRubyObject getConstantFromNoConstMissing(String name) {
<span class="nc" id="L3242">        return getConstantFromNoConstMissing(name, true);</span>
    }

    public IRubyObject getConstantFromNoConstMissing(String name, boolean includePrivate) {
<span class="pc bpc" id="L3246" title="3 of 4 branches missed.">        assert name == name.intern() : name + &quot; is not interned&quot;;</span>
<span class="pc bpc" id="L3247" title="3 of 4 branches missed.">        assert IdUtil.isConstant(name);</span>
<span class="fc" id="L3248">        Ruby runtime = getRuntime();</span>
<span class="fc" id="L3249">        RubyClass objectClass = runtime.getObject();</span>
        IRubyObject value;

<span class="fc" id="L3252">        RubyModule p = this;</span>

<span class="fc bfc" id="L3254" title="All 2 branches covered.">        while (p != null) {</span>
<span class="fc bfc" id="L3255" title="All 2 branches covered.">            if ((value = p.fetchConstant(name, false)) != null) {</span>
<span class="fc bfc" id="L3256" title="All 2 branches covered.">                if (value == UNDEF) {</span>
<span class="fc" id="L3257">                    return p.resolveUndefConstant(name);</span>
                }

<span class="pc bpc" id="L3260" title="1 of 4 branches missed.">                if (p == objectClass &amp;&amp; this != objectClass) {</span>
<span class="nc" id="L3261">                    String badCName = getName() + &quot;::&quot; + name;</span>
<span class="nc" id="L3262">                    runtime.getWarnings().warn(ID.CONSTANT_BAD_REFERENCE, &quot;toplevel constant &quot; +</span>
                            name + &quot; referenced by &quot; + badCName);
                }

<span class="fc" id="L3266">                return value;</span>
            }
<span class="fc" id="L3268">            p = p.getSuperClass();</span>
        }
<span class="fc" id="L3270">        return null;</span>
    }
    
    @Deprecated
    public IRubyObject fastGetConstantFromNoConstMissing(String internedName) {
<span class="nc" id="L3275">        return getConstantFromNoConstMissing(internedName);</span>
    }

    public IRubyObject getConstantFromConstMissing(String name) {
<span class="nc" id="L3279">        return callMethod(getRuntime().getCurrentContext(),</span>
<span class="nc" id="L3280">                &quot;const_missing&quot;, getRuntime().fastNewSymbol(name));</span>
    }

    @Deprecated
    public IRubyObject fastGetConstantFromConstMissing(String internedName) {
<span class="nc" id="L3285">        return getConstantFromConstMissing(internedName);</span>
    }

    public IRubyObject resolveUndefConstant(String name) {
<span class="fc" id="L3289">        return getAutoloadConstant(name);</span>
    }

    /**
     * Set the named constant on this module. Also, if the value provided is another Module and
     * that module has not yet been named, assign it the specified name. This version does not
     * warn if the constant has already been set.
     *
     * @param name The name to assign
     * @param value The value to assign to it; if an unnamed Module, also set its basename to name
     * @return The result of setting the variable.
     */
    public IRubyObject setConstantQuiet(String name, IRubyObject value) {
<span class="fc" id="L3302">        return setConstantCommon(name, value, false);</span>
    }

    /**
     * Set the named constant on this module. Also, if the value provided is another Module and
     * that module has not yet been named, assign it the specified name.
     *
     * @param name The name to assign
     * @param value The value to assign to it; if an unnamed Module, also set its basename to name
     * @return The result of setting the variable.
     */
    public IRubyObject setConstant(String name, IRubyObject value) {
<span class="fc" id="L3314">        return setConstantCommon(name, value, true);</span>
    }

    /**
     * Set the named constant on this module. Also, if the value provided is another Module and
     * that module has not yet been named, assign it the specified name.
     *
     * @param name The name to assign
     * @param value The value to assign to it; if an unnamed Module, also set its basename to name
     * @return The result of setting the variable.
     */
    private IRubyObject setConstantCommon(String name, IRubyObject value, boolean warn) {
<span class="fc" id="L3326">        IRubyObject oldValue = fetchConstant(name);</span>
<span class="fc bfc" id="L3327" title="All 2 branches covered.">        if (oldValue != null) {</span>
<span class="fc bfc" id="L3328" title="All 2 branches covered.">            if (oldValue == UNDEF) {</span>
<span class="fc" id="L3329">                setAutoloadConstant(name, value);</span>
            } else {
<span class="fc bfc" id="L3331" title="All 2 branches covered.">                if (warn) {</span>
<span class="fc" id="L3332">                    getRuntime().getWarnings().warn(ID.CONSTANT_ALREADY_INITIALIZED, &quot;already initialized constant &quot; + name);</span>
                }
<span class="fc" id="L3334">                storeConstant(name, value);</span>
            }
        } else {
<span class="fc" id="L3337">            storeConstant(name, value);</span>
        }

<span class="fc" id="L3340">        invalidateConstantCache(name);</span>
        
        // if adding a module under a constant name, set that module's basename to the constant name
<span class="fc bfc" id="L3343" title="All 2 branches covered.">        if (value instanceof RubyModule) {</span>
<span class="fc" id="L3344">            RubyModule module = (RubyModule)value;</span>
<span class="fc bfc" id="L3345" title="All 4 branches covered.">            if (module != this &amp;&amp; module.getBaseName() == null) {</span>
<span class="fc" id="L3346">                module.setBaseName(name);</span>
<span class="fc" id="L3347">                module.setParent(this);</span>
            }
        }
<span class="fc" id="L3350">        return value;</span>
    }

    @Deprecated
    public IRubyObject fastSetConstant(String internedName, IRubyObject value) {
<span class="nc" id="L3355">        return setConstant(internedName, value);</span>
    }
    
    /** rb_define_const
     *
     */
    @Extension
    public void defineConstant(String name, IRubyObject value) {
<span class="pc bpc" id="L3363" title="3 of 4 branches missed.">        assert value != null;</span>

<span class="pc bpc" id="L3365" title="1 of 2 branches missed.">        if (!IdUtil.isValidConstantName(name)) {</span>
<span class="nc" id="L3366">            throw getRuntime().newNameError(&quot;bad constant name &quot; + name, name);</span>
        }

<span class="fc" id="L3369">        setConstant(name, value);</span>
<span class="fc" id="L3370">    }</span>

    // Fix for JRUBY-1339 - search hierarchy for constant
    /** rb_const_defined_at
     * 
     */
    public boolean isConstantDefined(String name) {
<span class="pc bpc" id="L3377" title="3 of 4 branches missed.">        assert IdUtil.isConstant(name);</span>
<span class="pc bpc" id="L3378" title="1 of 2 branches missed.">        boolean isObject = this == getRuntime().getObject();</span>

<span class="fc" id="L3380">        RubyModule module = this;</span>

        do {
            Object value;
<span class="fc bfc" id="L3384" title="All 2 branches covered.">            if ((value = module.constantTableFetch(name)) != null) {</span>
<span class="pc bpc" id="L3385" title="1 of 2 branches missed.">                if (value != UNDEF) return true;</span>
<span class="nc bnc" id="L3386" title="All 2 branches missed.">                return getAutoloadMap().get(name) != null;</span>
            }

<span class="pc bpc" id="L3389" title="1 of 4 branches missed.">        } while (isObject &amp;&amp; (module = module.getSuperClass()) != null );</span>

<span class="fc" id="L3391">        return false;</span>
    }

    public boolean fastIsConstantDefined(String internedName) {
<span class="nc bnc" id="L3395" title="All 4 branches missed.">        assert internedName.equals(internedName.intern()) : internedName + &quot; is not interned&quot;;</span>
<span class="nc bnc" id="L3396" title="All 4 branches missed.">        assert IdUtil.isConstant(internedName);</span>
<span class="nc bnc" id="L3397" title="All 2 branches missed.">        boolean isObject = this == getRuntime().getObject();</span>

<span class="nc" id="L3399">        RubyModule module = this;</span>

        do {
            Object value;
<span class="nc bnc" id="L3403" title="All 2 branches missed.">            if ((value = module.constantTableFetch(internedName)) != null) {</span>
<span class="nc bnc" id="L3404" title="All 2 branches missed.">                if (value != UNDEF) return true;</span>
<span class="nc bnc" id="L3405" title="All 2 branches missed.">                return getAutoloadMap().get(internedName) != null;</span>
            }

<span class="nc bnc" id="L3408" title="All 4 branches missed.">        } while (isObject &amp;&amp; (module = module.getSuperClass()) != null );</span>

<span class="nc" id="L3410">        return false;</span>
    }

    public boolean fastIsConstantDefined19(String internedName) {
<span class="nc" id="L3414">        return fastIsConstantDefined19(internedName, true);</span>
    }

    public boolean fastIsConstantDefined19(String internedName, boolean inherit) {
<span class="pc bpc" id="L3418" title="3 of 4 branches missed.">        assert internedName.equals(internedName.intern()) : internedName + &quot; is not interned&quot;;</span>
<span class="pc bpc" id="L3419" title="3 of 4 branches missed.">        assert IdUtil.isConstant(internedName);</span>

<span class="fc bfc" id="L3421" title="All 2 branches covered.">        for (RubyModule module = this; module != null; module = module.getSuperClass()) {</span>
            Object value;
<span class="fc bfc" id="L3423" title="All 2 branches covered.">            if ((value = module.constantTableFetch(internedName)) != null) {</span>
<span class="fc bfc" id="L3424" title="All 2 branches covered.">                if (value != UNDEF) return true;</span>
<span class="pc bpc" id="L3425" title="1 of 2 branches missed.">                return getAutoloadMap().get(internedName) != null;</span>
            }
<span class="fc bfc" id="L3427" title="All 2 branches covered.">            if (!inherit) {</span>
<span class="fc" id="L3428">                break;</span>
            }
        }

<span class="fc" id="L3432">        return false;</span>
    }

    //
    ////////////////// COMMON CONSTANT / CVAR METHODS ////////////////
    //

    private RaiseException cannotRemoveError(String id) {
<span class="fc" id="L3440">        return getRuntime().newNameError(&quot;cannot remove &quot; + id + &quot; for &quot; + getName(), id);</span>
    }


    //
    ////////////////// INTERNAL MODULE VARIABLE API METHODS ////////////////
    //
    
    /**
     * Behaves similarly to {@link #getClassVar(String)}. Searches this
     * class/module &lt;em&gt;and its ancestors&lt;/em&gt; for the specified internal
     * variable.
     * 
     * @param name the internal variable name
     * @return the value of the specified internal variable if found, else null
     * @see #setInternalModuleVariable(String, IRubyObject)
     */
    public boolean hasInternalModuleVariable(final String name) {
<span class="nc bnc" id="L3458" title="All 2 branches missed.">        for (RubyModule module = this; module != null; module = module.getSuperClass()) {</span>
<span class="nc bnc" id="L3459" title="All 2 branches missed.">            if (module.hasInternalVariable(name)) return true;</span>
        }

<span class="nc" id="L3462">        return false;</span>
    }
    /**
     * Behaves similarly to {@link #getClassVar(String)}. Searches this
     * class/module &lt;em&gt;and its ancestors&lt;/em&gt; for the specified internal
     * variable.
     * 
     * @param name the internal variable name
     * @return the value of the specified internal variable if found, else null
     * @see #setInternalModuleVariable(String, IRubyObject)
     */
    public IRubyObject searchInternalModuleVariable(final String name) {
<span class="nc bnc" id="L3474" title="All 2 branches missed.">        for (RubyModule module = this; module != null; module = module.getSuperClass()) {</span>
<span class="nc" id="L3475">            IRubyObject value = (IRubyObject)module.getInternalVariable(name);</span>
<span class="nc bnc" id="L3476" title="All 2 branches missed.">            if (value != null) return value;</span>
        }

<span class="nc" id="L3479">        return null;</span>
    }

    /**
     * Behaves similarly to {@link #setClassVar(String, IRubyObject)}. If the
     * specified internal variable is found in this class/module &lt;em&gt;or an ancestor&lt;/em&gt;,
     * it is set where found.  Otherwise it is set in this module. 
     * 
     * @param name the internal variable name
     * @param value the internal variable value
     * @see #searchInternalModuleVariable(String)
     */
    public void setInternalModuleVariable(final String name, final IRubyObject value) {
<span class="nc bnc" id="L3492" title="All 2 branches missed.">        for (RubyModule module = this; module != null; module = module.getSuperClass()) {</span>
<span class="nc bnc" id="L3493" title="All 2 branches missed.">            if (module.hasInternalVariable(name)) {</span>
<span class="nc" id="L3494">                module.setInternalVariable(name, value);</span>
<span class="nc" id="L3495">                return;</span>
            }
        }

<span class="nc" id="L3499">        setInternalVariable(name, value);</span>
<span class="nc" id="L3500">    }</span>

    //
    ////////////////// LOW-LEVEL CLASS VARIABLE INTERFACE ////////////////
    //
    // fetch/store/list class variables for this module
    //

    protected Map&lt;String, IRubyObject&gt; getClassVariables() {
<span class="pc bpc" id="L3509" title="1 of 2 branches missed.">        if (CLASSVARS_UPDATER == null) {</span>
<span class="nc" id="L3510">            return getClassVariablesForWriteSynchronized();</span>
        } else {
<span class="fc" id="L3512">            return getClassVariablesForWriteAtomic();</span>
        }
    }

    /**
     * Get the class variables for write. If it is not set or not of the right size,
     * synchronize against the object and prepare it accordingly.
     *
     * @return the class vars map, ready for assignment
     */
    private Map&lt;String,IRubyObject&gt; getClassVariablesForWriteSynchronized() {
<span class="nc" id="L3523">        Map myClassVars = classVariables;</span>
<span class="nc bnc" id="L3524" title="All 2 branches missed.">        if (myClassVars == Collections.EMPTY_MAP) {</span>
<span class="nc" id="L3525">            synchronized (this) {</span>
<span class="nc" id="L3526">                myClassVars = classVariables;</span>

<span class="nc bnc" id="L3528" title="All 2 branches missed.">                if (myClassVars == Collections.EMPTY_MAP) {</span>
<span class="nc" id="L3529">                    return classVariables = new ConcurrentHashMap&lt;String, IRubyObject&gt;(4, 0.75f, 2);</span>
                } else {
<span class="nc" id="L3531">                    return myClassVars;</span>
                }
<span class="nc" id="L3533">            }</span>
        }

<span class="nc" id="L3536">        return myClassVars;</span>
    }


    /**
     * Get the class variables for write. If it is not set or not of the right size,
     * atomically update it with an appropriate value.
     *
     * @return the class vars map, ready for assignment
     */
    private Map&lt;String,IRubyObject&gt; getClassVariablesForWriteAtomic() {
        while (true) {
<span class="fc" id="L3548">            Map myClassVars = classVariables;</span>
            Map newClassVars;

<span class="fc bfc" id="L3551" title="All 2 branches covered.">            if (myClassVars == Collections.EMPTY_MAP) {</span>
<span class="fc" id="L3552">                newClassVars = new ConcurrentHashMap&lt;String, IRubyObject&gt;(4, 0.75f, 2);</span>
            } else {
<span class="fc" id="L3554">                return myClassVars;</span>
            }

            // proceed with atomic update of table, or retry
<span class="pc bpc" id="L3558" title="1 of 2 branches missed.">            if (CLASSVARS_UPDATER.compareAndSet(this, myClassVars, newClassVars)) {</span>
<span class="fc" id="L3559">                return newClassVars;</span>
            }
<span class="nc" id="L3561">        }</span>
    }

    protected Map&lt;String, IRubyObject&gt; getClassVariablesForRead() {
<span class="fc" id="L3565">        return classVariables;</span>
    }
    
    public boolean hasClassVariable(String name) {
<span class="pc bpc" id="L3569" title="3 of 4 branches missed.">        assert IdUtil.isClassVariable(name);</span>
<span class="fc" id="L3570">        return getClassVariablesForRead().containsKey(name);</span>
    }

    @Deprecated
    public boolean fastHasClassVariable(String internedName) {
<span class="nc" id="L3575">        return hasClassVariable(internedName);</span>
    }

    public IRubyObject fetchClassVariable(String name) {
<span class="pc bpc" id="L3579" title="3 of 4 branches missed.">        assert IdUtil.isClassVariable(name);</span>
<span class="fc" id="L3580">        return getClassVariablesForRead().get(name);</span>
    }

    @Deprecated
    public IRubyObject fastFetchClassVariable(String internedName) {
<span class="nc" id="L3585">        return fetchClassVariable(internedName);</span>
    }

    public IRubyObject storeClassVariable(String name, IRubyObject value) {
<span class="pc bpc" id="L3589" title="5 of 6 branches missed.">        assert IdUtil.isClassVariable(name) &amp;&amp; value != null;</span>
<span class="fc" id="L3590">        ensureClassVariablesSettable();</span>
<span class="fc" id="L3591">        getClassVariables().put(name, value);</span>
<span class="fc" id="L3592">        return value;</span>
    }

    @Deprecated
    public IRubyObject fastStoreClassVariable(String internedName, IRubyObject value) {
<span class="nc" id="L3597">        return storeClassVariable(internedName, value);</span>
    }

    public IRubyObject deleteClassVariable(String name) {
<span class="pc bpc" id="L3601" title="3 of 4 branches missed.">        assert IdUtil.isClassVariable(name);</span>
<span class="fc" id="L3602">        ensureClassVariablesSettable();</span>
<span class="fc" id="L3603">        return getClassVariablesForRead().remove(name);</span>
    }

    public List&lt;String&gt; getClassVariableNameList() {
<span class="fc" id="L3607">        return new ArrayList&lt;String&gt;(getClassVariablesForRead().keySet());</span>
    }

    protected static final String ERR_INSECURE_SET_CLASS_VAR = &quot;Insecure: can't modify class variable&quot;;
    protected static final String ERR_FROZEN_CVAR_TYPE = &quot;class/module &quot;;
   
    protected final String validateClassVariable(String name) {
<span class="fc bfc" id="L3614" title="All 2 branches covered.">        if (IdUtil.isValidClassVariableName(name)) {</span>
<span class="fc" id="L3615">            return name;</span>
        }
<span class="fc" id="L3617">        throw getRuntime().newNameError(&quot;`&quot; + name + &quot;' is not allowed as a class variable name&quot;, name);</span>
    }

    protected final void ensureClassVariablesSettable() {
<span class="fc" id="L3621">        Ruby runtime = getRuntime();</span>
        
<span class="fc bfc" id="L3623" title="All 2 branches covered.">        if (!isFrozen()) {</span>
<span class="fc" id="L3624">            return;</span>
        }

<span class="pc bpc" id="L3627" title="1 of 2 branches missed.">        if (this instanceof RubyModule) {</span>
<span class="fc" id="L3628">            throw runtime.newFrozenError(ERR_FROZEN_CONST_TYPE);</span>
        } else {
<span class="nc" id="L3630">            throw runtime.newFrozenError(&quot;&quot;);</span>
        }
    }

    //
    ////////////////// LOW-LEVEL CONSTANT INTERFACE ////////////////
    //
    // fetch/store/list constants for this module
    //

    public boolean hasConstant(String name) {
<span class="pc bpc" id="L3641" title="3 of 4 branches missed.">        assert IdUtil.isConstant(name);</span>
<span class="fc" id="L3642">        return constantTableContains(name);</span>
    }

    @Deprecated
    public boolean fastHasConstant(String internedName) {
<span class="nc" id="L3647">        return hasConstant(internedName);</span>
    }

    // returns the stored value without processing undefs (autoloads)
    public IRubyObject fetchConstant(String name) {
<span class="fc" id="L3652">        return fetchConstant(name, true);</span>
    }

    public IRubyObject fetchConstant(String name, boolean includePrivate) {
<span class="pc bpc" id="L3656" title="3 of 4 branches missed.">        assert IdUtil.isConstant(name);</span>
<span class="fc" id="L3657">        ConstantEntry entry = constantEntryFetch(name);</span>

<span class="fc bfc" id="L3659" title="All 2 branches covered.">        if (entry == null) return null;</span>

<span class="fc bfc" id="L3661" title="All 4 branches covered.">        if (entry.hidden &amp;&amp; !includePrivate) {</span>
<span class="fc" id="L3662">            throw getRuntime().newNameError(&quot;private constant &quot; + getName() + &quot;::&quot; + name + &quot; referenced&quot;, name);</span>
        }

<span class="fc" id="L3665">        return entry.value;</span>
    }

    @Deprecated
    public IRubyObject fastFetchConstant(String internedName) {
<span class="nc" id="L3670">        return fetchConstant(internedName);</span>
    }

    public IRubyObject storeConstant(String name, IRubyObject value) {
<span class="pc bpc" id="L3674" title="3 of 4 branches missed.">        assert IdUtil.isConstant(name) : name + &quot; is not a valid constant name&quot;;</span>
<span class="pc bpc" id="L3675" title="3 of 4 branches missed.">        assert value != null : &quot;value is null&quot;;</span>
        
<span class="fc" id="L3677">        ensureConstantsSettable();</span>
<span class="fc" id="L3678">        return constantTableStore(name, value);</span>
    }

    @Deprecated
    public IRubyObject fastStoreConstant(String internedName, IRubyObject value) {
<span class="nc" id="L3683">        return storeConstant(internedName, value);</span>
    }

    // removes and returns the stored value without processing undefs (autoloads)
    public IRubyObject deleteConstant(String name) {
<span class="pc bpc" id="L3688" title="3 of 4 branches missed.">        assert IdUtil.isConstant(name);</span>
<span class="fc" id="L3689">        ensureConstantsSettable();</span>
<span class="fc" id="L3690">        return constantTableRemove(name);</span>
    }
    
    @Deprecated
    public List&lt;Variable&lt;IRubyObject&gt;&gt; getStoredConstantList() {
<span class="nc" id="L3695">        return null;</span>
    }

    @Deprecated
    public List&lt;String&gt; getStoredConstantNameList() {
<span class="nc" id="L3700">        return new ArrayList&lt;String&gt;(getConstantMap().keySet());</span>
    }

    /**
     * @return a list of constant names that exists at time this was called
     */
    public Collection&lt;String&gt; getConstantNames() {
<span class="nc" id="L3707">        return getConstantMap().keySet();</span>
    }

    public Collection&lt;String&gt; getConstantNames(boolean includePrivate) {
<span class="pc bpc" id="L3711" title="1 of 2 branches missed.">        if (includePrivate) return getConstantNames();</span>

<span class="fc bfc" id="L3713" title="All 2 branches covered.">        if (getConstantMap().size() == 0) {</span>
<span class="fc" id="L3714">            return Collections.EMPTY_SET;</span>
        }

<span class="fc" id="L3717">        HashSet&lt;String&gt; publicNames = new HashSet&lt;String&gt;(getConstantMap().size());</span>
        
<span class="fc bfc" id="L3719" title="All 2 branches covered.">        for (Map.Entry&lt;String, ConstantEntry&gt; entry : getConstantMap().entrySet()) {</span>
<span class="fc bfc" id="L3720" title="All 2 branches covered.">            if (entry.getValue().hidden) continue;</span>
<span class="fc" id="L3721">            publicNames.add(entry.getKey());</span>
<span class="fc" id="L3722">        }</span>
<span class="fc" id="L3723">        return publicNames;</span>
    }
   
    protected final String validateConstant(IRubyObject name) {
<span class="fc" id="L3727">        return validateConstant(name.asJavaString(), name);</span>
    }

    protected final String validateConstant(String name, IRubyObject errorName) {
<span class="fc bfc" id="L3731" title="All 2 branches covered.">        if (IdUtil.isValidConstantName19(name)) return name;</span>

<span class="fc" id="L3733">        Ruby runtime = getRuntime();</span>

<span class="fc" id="L3735">        Encoding resultEncoding = runtime.getDefaultInternalEncoding();</span>
<span class="pc bpc" id="L3736" title="1 of 2 branches missed.">        if (resultEncoding == null) resultEncoding = runtime.getDefaultExternalEncoding();</span>

        // MRI is more complicated than this and distinguishes between ID and non-ID.
<span class="fc" id="L3739">        RubyString nameString = errorName.asString();</span>

        // MRI does strlen to check for \0 vs Ruby string length.
<span class="pc bpc" id="L3742" title="1 of 4 branches missed.">        if ((nameString.getEncoding() != resultEncoding &amp;&amp; !nameString.isAsciiOnly()) ||</span>
<span class="pc bpc" id="L3743" title="1 of 2 branches missed.">                nameString.toString().contains(&quot;\0&quot;)) {</span>
<span class="nc" id="L3744">            nameString = (RubyString) nameString.inspect();</span>
        }

<span class="fc" id="L3747">        throw getRuntime().newNameError(&quot;wrong constant name &quot; + nameString, name);</span>
    }

    protected final void ensureConstantsSettable() {
<span class="fc bfc" id="L3751" title="All 2 branches covered.">        if (isFrozen()) throw getRuntime().newFrozenError(ERR_FROZEN_CONST_TYPE);</span>
<span class="fc" id="L3752">    }</span>

    protected boolean constantTableContains(String name) {
<span class="fc" id="L3755">        return getConstantMap().containsKey(name);</span>
    }
    
    protected IRubyObject constantTableFetch(String name) {
<span class="fc" id="L3759">        ConstantEntry entry = getConstantMap().get(name);</span>
<span class="fc bfc" id="L3760" title="All 2 branches covered.">        if (entry == null) return null;</span>
<span class="fc" id="L3761">        return entry.value;</span>
    }

    protected ConstantEntry constantEntryFetch(String name) {
<span class="fc" id="L3765">        return getConstantMap().get(name);</span>
    }
    
    protected IRubyObject constantTableStore(String name, IRubyObject value) {
<span class="fc" id="L3769">        Map&lt;String, ConstantEntry&gt; constMap = getConstantMapForWrite();</span>
<span class="fc" id="L3770">        boolean hidden = false;</span>

<span class="fc" id="L3772">        ConstantEntry entry = constMap.get(name);</span>
<span class="fc bfc" id="L3773" title="All 2 branches covered.">        if (entry != null) hidden = entry.hidden;</span>

<span class="fc" id="L3775">        constMap.put(name, new ConstantEntry(value, hidden));</span>
<span class="fc" id="L3776">        return value;</span>
    }
    
    protected IRubyObject constantTableRemove(String name) {
<span class="fc" id="L3780">        ConstantEntry entry = getConstantMapForWrite().remove(name);</span>
<span class="fc bfc" id="L3781" title="All 2 branches covered.">        if (entry == null) return null;</span>
<span class="fc" id="L3782">        return entry.value;</span>
    }
    
    /**
     * Define an autoload. ConstantMap holds UNDEF for the name as an autoload marker.
     */
    protected void defineAutoload(String name, IAutoloadMethod loadMethod) {
<span class="fc" id="L3789">        Autoload existingAutoload = getAutoloadMap().get(name);</span>
<span class="pc bpc" id="L3790" title="1 of 4 branches missed.">        if (existingAutoload == null || existingAutoload.getValue() == null) {</span>
<span class="fc" id="L3791">            storeConstant(name, RubyObject.UNDEF);</span>
<span class="fc" id="L3792">            getAutoloadMapForWrite().put(name, new Autoload(loadMethod));</span>
        }
<span class="fc" id="L3794">    }</span>
    
    /**
     * Extract an Object which is defined by autoload thread from autoloadMap and define it as a constant.
     */
    protected IRubyObject finishAutoload(String name) {
<span class="fc" id="L3800">        Autoload autoload = getAutoloadMap().get(name);</span>
<span class="fc bfc" id="L3801" title="All 2 branches covered.">        if (autoload != null) {</span>
<span class="fc" id="L3802">            IRubyObject value = autoload.getValue();</span>
<span class="fc bfc" id="L3803" title="All 2 branches covered.">            if (value != null) {</span>
<span class="fc" id="L3804">                storeConstant(name, value);</span>
            }
<span class="fc" id="L3806">            removeAutoload(name);</span>
<span class="fc" id="L3807">            return value;</span>
        }
<span class="fc" id="L3809">        return null;</span>
    }

    /**
     * Get autoload constant.
     * If it's first resolution for the constant, it tries to require the defined feature and returns the defined value.
     * Multi-threaded accesses are blocked and processed sequentially except if the caller is the autoloading thread.
     */
    public IRubyObject getAutoloadConstant(String name) {
<span class="fc" id="L3818">        Autoload autoload = getAutoloadMap().get(name);</span>
<span class="pc bpc" id="L3819" title="1 of 2 branches missed.">        if (autoload == null) {</span>
<span class="nc" id="L3820">            return null;</span>
        }
<span class="fc" id="L3822">        return autoload.getConstant(getRuntime().getCurrentContext());</span>
    }
    
    /**
     * Set an Object as a defined constant in autoloading.
     */
    private void setAutoloadConstant(String name, IRubyObject value) {
<span class="fc" id="L3829">        Autoload autoload = getAutoloadMap().get(name);</span>
<span class="fc bfc" id="L3830" title="All 2 branches covered.">        if (autoload != null) {</span>
<span class="fc bfc" id="L3831" title="All 2 branches covered.">            if (!autoload.setConstant(getRuntime().getCurrentContext(), value)) {</span>
<span class="fc" id="L3832">                storeConstant(name, value);</span>
<span class="fc" id="L3833">                removeAutoload(name);</span>
            }
        } else {
<span class="fc" id="L3836">            storeConstant(name, value);</span>
        }
<span class="fc" id="L3838">    }</span>
    
    /**
     * Removes an Autoload object from autoloadMap. ConstantMap must be updated before calling this.
     */
    private void removeAutoload(String name) {
<span class="fc" id="L3844">        getAutoloadMapForWrite().remove(name);</span>
<span class="fc" id="L3845">    }</span>
    
    protected String getAutoloadFile(String name) {
<span class="fc" id="L3848">        Autoload autoload = getAutoloadMap().get(name);</span>
<span class="fc bfc" id="L3849" title="All 2 branches covered.">        if (autoload != null) {</span>
<span class="fc" id="L3850">            return autoload.getFile();</span>
        }
<span class="fc" id="L3852">        return null;</span>
    }

    private static void define(RubyModule module, JavaMethodDescriptor desc, String simpleName, DynamicMethod dynamicMethod) {
<span class="fc" id="L3856">        JRubyMethod jrubyMethod = desc.anno;</span>
        // check for frame field reads or writes
<span class="fc" id="L3858">        CallConfiguration needs = CallConfiguration.valueOf(AnnotationHelper.getCallerCallConfigNameByAnno(jrubyMethod));</span>

<span class="pc bpc" id="L3860" title="1 of 2 branches missed.">        if (needs.framing() == Framing.Full) {</span>
<span class="nc" id="L3861">            Set&lt;String&gt; frameAwareMethods = new HashSet&lt;String&gt;();</span>
<span class="nc" id="L3862">            AnnotationHelper.addMethodNamesToSet(frameAwareMethods, jrubyMethod, simpleName);</span>
<span class="nc" id="L3863">            MethodIndex.FRAME_AWARE_METHODS.addAll(frameAwareMethods);</span>
        }
<span class="pc bpc" id="L3865" title="1 of 2 branches missed.">        if (needs.scoping() == Scoping.Full) {</span>
<span class="nc" id="L3866">            Set&lt;String&gt; scopeAwareMethods = new HashSet&lt;String&gt;();</span>
<span class="nc" id="L3867">            AnnotationHelper.addMethodNamesToSet(scopeAwareMethods, jrubyMethod, simpleName);</span>
<span class="nc" id="L3868">            MethodIndex.SCOPE_AWARE_METHODS.addAll(scopeAwareMethods);</span>
        }
        
        RubyModule singletonClass;

<span class="fc bfc" id="L3873" title="All 2 branches covered.">        if (jrubyMethod.meta()) {</span>
<span class="fc" id="L3874">            singletonClass = module.getSingletonClass();</span>
<span class="fc" id="L3875">            dynamicMethod.setImplementationClass(singletonClass);</span>

            String baseName;
<span class="fc bfc" id="L3878" title="All 2 branches covered.">            if (jrubyMethod.name().length == 0) {</span>
<span class="fc" id="L3879">                baseName = desc.name;</span>
<span class="fc" id="L3880">                singletonClass.addMethod(baseName, dynamicMethod);</span>
            } else {
<span class="fc" id="L3882">                baseName = jrubyMethod.name()[0];</span>
<span class="fc bfc" id="L3883" title="All 2 branches covered.">                for (String name : jrubyMethod.name()) {</span>
<span class="fc" id="L3884">                    singletonClass.addMethod(name, dynamicMethod);</span>
                }
            }

<span class="pc bpc" id="L3888" title="1 of 2 branches missed.">            if (jrubyMethod.alias().length &gt; 0) {</span>
<span class="nc bnc" id="L3889" title="All 2 branches missed.">                for (String alias : jrubyMethod.alias()) {</span>
<span class="nc" id="L3890">                    singletonClass.defineAlias(alias, baseName);</span>
                }
            }
<span class="fc" id="L3893">        } else {</span>
            String baseName;
<span class="fc bfc" id="L3895" title="All 2 branches covered.">            if (jrubyMethod.name().length == 0) {</span>
<span class="fc" id="L3896">                baseName = desc.name;</span>
<span class="fc" id="L3897">                module.getMethodLocation().addMethod(baseName, dynamicMethod);</span>
            } else {
<span class="fc" id="L3899">                baseName = jrubyMethod.name()[0];</span>
<span class="fc bfc" id="L3900" title="All 2 branches covered.">                for (String name : jrubyMethod.name()) {</span>
<span class="fc" id="L3901">                    module.getMethodLocation().addMethod(name, dynamicMethod);</span>
                }
            }

<span class="fc bfc" id="L3905" title="All 2 branches covered.">            if (jrubyMethod.alias().length &gt; 0) {</span>
<span class="fc bfc" id="L3906" title="All 2 branches covered.">                for (String alias : jrubyMethod.alias()) {</span>
<span class="fc" id="L3907">                    module.defineAlias(alias, baseName);</span>
                }
            }

<span class="fc bfc" id="L3911" title="All 2 branches covered.">            if (jrubyMethod.module()) {</span>
<span class="fc" id="L3912">                singletonClass = module.getSingletonClass();</span>
                // module/singleton methods are all defined public
<span class="fc" id="L3914">                DynamicMethod moduleMethod = dynamicMethod.dup();</span>
<span class="fc" id="L3915">                moduleMethod.setVisibility(PUBLIC);</span>

<span class="pc bpc" id="L3917" title="1 of 2 branches missed.">                if (jrubyMethod.name().length == 0) {</span>
<span class="nc" id="L3918">                    baseName = desc.name;</span>
<span class="nc" id="L3919">                    singletonClass.addMethod(desc.name, moduleMethod);</span>
                } else {
<span class="fc" id="L3921">                    baseName = jrubyMethod.name()[0];</span>
<span class="fc bfc" id="L3922" title="All 2 branches covered.">                    for (String name : jrubyMethod.name()) {</span>
<span class="fc" id="L3923">                        singletonClass.addMethod(name, moduleMethod);</span>
                    }
                }

<span class="pc bpc" id="L3927" title="1 of 2 branches missed.">                if (jrubyMethod.alias().length &gt; 0) {</span>
<span class="nc bnc" id="L3928" title="All 2 branches missed.">                    for (String alias : jrubyMethod.alias()) {</span>
<span class="nc" id="L3929">                        singletonClass.defineAlias(alias, baseName);</span>
                    }
                }
            }
        }
<span class="fc" id="L3934">    }</span>
    
    @Deprecated
    public IRubyObject initialize(Block block) {
<span class="nc" id="L3938">        return initialize(getRuntime().getCurrentContext());</span>
    }

<span class="fc" id="L3941">    public KindOf kindOf = KindOf.DEFAULT_KIND_OF;</span>

    public final int id;

    /**
     * The class/module within whose namespace this class/module resides.
     */
    public RubyModule parent;

    /**
     * The base name of this class/module, excluding nesting. If null, this is
     * an anonymous class.
     */
    protected String baseName;
    
    /**
     * The cached anonymous class name, since it never changes and has a nonzero
     * cost to calculate.
     */
    private String anonymousName;

    /**
     * The cached name, only cached once this class and all containing classes are non-anonymous
     */
    private String cachedName;

<span class="fc" id="L3967">    private volatile Map&lt;String, ConstantEntry&gt; constants = Collections.EMPTY_MAP;</span>

    /**
     * Represents a constant value, possibly hidden (private).
     */
    public static class ConstantEntry {
        public final IRubyObject value;
        public final boolean hidden;

<span class="fc" id="L3976">        public ConstantEntry(IRubyObject value, boolean hidden) {</span>
<span class="fc" id="L3977">            this.value = value;</span>
<span class="fc" id="L3978">            this.hidden = hidden;</span>
<span class="fc" id="L3979">        }</span>
        
        public ConstantEntry dup() {
<span class="nc" id="L3982">            return new ConstantEntry(value, hidden);</span>
        }
    }
    
    /**
     * Objects for holding autoload state for the defined constant.
     * 
     * 'Module#autoload' creates this object and stores it in autoloadMap.
     * This object can be shared with multiple threads so take care to change volatile and synchronized definitions.
     */
    private class Autoload {
        // A ThreadContext which is executing autoload.
        private volatile ThreadContext ctx;
        // The lock for test-and-set the ctx.
<span class="fc" id="L3996">        private final Object ctxLock = new Object();</span>
        // An object defined for the constant while autoloading.
        private volatile IRubyObject value;
        // A method which actually requires a defined feature.
        private final IAutoloadMethod loadMethod;

<span class="fc" id="L4002">        Autoload(IAutoloadMethod loadMethod) {</span>
<span class="fc" id="L4003">            this.ctx = null;</span>
<span class="fc" id="L4004">            this.value = null;</span>
<span class="fc" id="L4005">            this.loadMethod = loadMethod;</span>
<span class="fc" id="L4006">        }</span>

        // Returns an object for the constant if the caller is the autoloading thread.
        // Otherwise, try to start autoloading and returns the defined object by autoload.
        IRubyObject getConstant(ThreadContext ctx) {
<span class="fc" id="L4011">            synchronized (ctxLock) {</span>
<span class="fc bfc" id="L4012" title="All 2 branches covered.">                if (this.ctx == null) {</span>
<span class="fc" id="L4013">                    this.ctx = ctx;</span>
<span class="fc bfc" id="L4014" title="All 2 branches covered.">                } else if (isSelf(ctx)) {</span>
<span class="fc" id="L4015">                    return getValue();</span>
                }
                // This method needs to be synchronized for removing Autoload
                // from autoloadMap when it's loaded. 
<span class="fc" id="L4019">                getLoadMethod().load(ctx.runtime);</span>
<span class="fc" id="L4020">            }</span>
<span class="fc" id="L4021">            return getValue();</span>
        }
        
        // Update an object for the constant if the caller is the autoloading thread.
        boolean setConstant(ThreadContext ctx, IRubyObject newValue) {
<span class="fc" id="L4026">            synchronized(ctxLock) {</span>
<span class="fc" id="L4027">                boolean isSelf = isSelf(ctx);</span>
                
<span class="fc bfc" id="L4029" title="All 2 branches covered.">                if (isSelf) value = newValue;</span>
                
<span class="fc" id="L4031">                return isSelf;</span>
<span class="nc" id="L4032">            }</span>
        }
        
        // Returns an object for the constant defined by autoload.
        IRubyObject getValue() {
<span class="fc" id="L4037">            return value;</span>
        }
        
        // Returns the assigned feature.
        String getFile() {
<span class="fc" id="L4042">            return getLoadMethod().file();</span>
        }

        private IAutoloadMethod getLoadMethod() {
<span class="fc" id="L4046">            return loadMethod;</span>
        }

        private boolean isSelf(ThreadContext rhs) {
<span class="fc bfc" id="L4050" title="All 4 branches covered.">            return ctx != null &amp;&amp; ctx.getThread() == rhs.getThread();</span>
        }
    }
    
    /**
     * Set whether this class is associated with (i.e. a proxy for) a normal
     * Java class or interface.
     */
    public void setJavaProxy(boolean javaProxy) {
<span class="fc" id="L4059">        this.javaProxy = javaProxy;</span>
<span class="fc" id="L4060">    }</span>
    
    /**
     * Get whether this class is associated with (i.e. a proxy for) a normal
     * Java class or interface.
     */
    public boolean getJavaProxy() {
<span class="nc" id="L4067">        return javaProxy;</span>
    }

    /**
     * Get whether this Java proxy class should try to keep its instances idempotent
     * and alive using the ObjectProxyCache.
     */
    public boolean getCacheProxy() {
<span class="fc" id="L4075">        return getFlag(USER0_F);</span>
    }

    /**
     * Set whether this Java proxy class should try to keep its instances idempotent
     * and alive using the ObjectProxyCache.
     */
    public void setCacheProxy(boolean cacheProxy) {
<span class="nc" id="L4083">        setFlag(USER0_F, cacheProxy);</span>
<span class="nc" id="L4084">    }</span>
    
    public Set&lt;String&gt; discoverInstanceVariables() {
<span class="nc" id="L4087">        HashSet&lt;String&gt; set = new HashSet();</span>
<span class="nc" id="L4088">        RubyModule cls = this;</span>
<span class="nc bnc" id="L4089" title="All 2 branches missed.">        while (cls != null) {</span>
<span class="nc bnc" id="L4090" title="All 2 branches missed.">            for (DynamicMethod method : cls.getNonIncludedClass().getMethodLocation().getMethods().values()) {</span>
<span class="nc" id="L4091">                MethodData methodData = method.getMethodData();</span>
<span class="nc" id="L4092">                set.addAll(methodData.getIvarNames());</span>
<span class="nc" id="L4093">            }</span>
            
<span class="nc bnc" id="L4095" title="All 2 branches missed.">            if (cls instanceof RubyClass) {</span>
<span class="nc" id="L4096">                cls = ((RubyClass)cls).getSuperClass();</span>
            } else {
                break;
            }
        }
<span class="nc" id="L4101">        return set;</span>
    }

    /**
     * Return true if the given method is defined on this class and is a builtin
     * (defined in Java at boot).
     *
     * @param methodName
     * @return
     */
    public boolean isMethodBuiltin(String methodName) {
<span class="fc" id="L4112">        DynamicMethod method = searchMethodInner(methodName);</span>

<span class="pc bpc" id="L4114" title="1 of 4 branches missed.">        return method != null &amp;&amp; method.isBuiltin();</span>
    }
    
<span class="fc" id="L4117">    private volatile Map&lt;String, Autoload&gt; autoloads = Collections.EMPTY_MAP;</span>
<span class="fc" id="L4118">    protected volatile Map&lt;String, DynamicMethod&gt; methods = Collections.EMPTY_MAP;</span>
<span class="fc" id="L4119">    protected Map&lt;String, CacheEntry&gt; cachedMethods = Collections.EMPTY_MAP;</span>
    protected int generation;
    protected Integer generationObject;

<span class="fc" id="L4123">    protected volatile Set&lt;RubyClass&gt; includingHierarchies = Collections.EMPTY_SET;</span>
<span class="fc" id="L4124">    protected volatile RubyModule methodLocation = this;</span>

    // ClassProviders return Java class/module (in #defineOrGetClassUnder and
    // #defineOrGetModuleUnder) when class/module is opened using colon syntax.
<span class="fc" id="L4128">    private transient volatile Set&lt;ClassProvider&gt; classProviders = Collections.EMPTY_SET;</span>

    // superClass may be null.
    protected RubyClass superClass;

    /**
     * The index of this class in the ClassIndex. Only non-zero for native JRuby
     * classes that have a corresponding entry in ClassIndex.
     * 
     * @see ClassIndex
     * @deprecated use RubyModule#getClassIndex()
     */
    @Deprecated
    public int index;

    @Deprecated
<span class="fc" id="L4144">    public static final Set&lt;String&gt; SCOPE_CAPTURING_METHODS = new HashSet&lt;String&gt;(Arrays.asList(</span>
            &quot;eval&quot;,
            &quot;module_eval&quot;,
            &quot;class_eval&quot;,
            &quot;instance_eval&quot;,
            &quot;module_exec&quot;,
            &quot;class_exec&quot;,
            &quot;instance_exec&quot;,
            &quot;binding&quot;,
            &quot;local_variables&quot;
    ));
    
<span class="fc" id="L4156">    protected ClassIndex classIndex = ClassIndex.NO_INDEX;</span>

<span class="fc" id="L4158">    private volatile Map&lt;String, IRubyObject&gt; classVariables = Collections.EMPTY_MAP;</span>

    private static final AtomicReferenceFieldUpdater CLASSVARS_UPDATER;

    static {
<span class="fc" id="L4163">        AtomicReferenceFieldUpdater updater = null;</span>
        try {
<span class="fc" id="L4165">            updater = AtomicReferenceFieldUpdater.newUpdater(RubyModule.class, Map.class, &quot;classVariables&quot;);</span>
<span class="nc" id="L4166">        } catch (RuntimeException re) {</span>
<span class="nc bnc" id="L4167" title="All 2 branches missed.">            if (re.getCause() instanceof AccessControlException) {</span>
                // security prevented creation; fall back on synchronized assignment
            } else {
<span class="nc" id="L4170">                throw re;</span>
            }
<span class="fc" id="L4172">        }</span>
<span class="fc" id="L4173">        CLASSVARS_UPDATER = updater;</span>
<span class="fc" id="L4174">    }</span>
    
    // Invalidator used for method caches
    protected final Invalidator methodInvalidator;

    /** Whether this class proxies a normal Java class */
<span class="fc" id="L4180">    private boolean javaProxy = false;</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>