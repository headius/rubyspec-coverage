<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Ruby.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby</a> &gt; <span class="el_source">Ruby.java</span></div><h1>Ruby.java</h1><pre class="source lang-java linenums">/*
 **** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2001 Chad Fowler &lt;chadfowler@chadfowler.com&gt;
 * Copyright (C) 2001 Alan Moore &lt;alan_moore@gmx.net&gt;
 * Copyright (C) 2001-2002 Benoit Cerrina &lt;b.cerrina@wanadoo.fr&gt;
 * Copyright (C) 2001-2004 Jan Arne Petersen &lt;jpetersen@uni-bonn.de&gt;
 * Copyright (C) 2002-2004 Anders Bengtsson &lt;ndrsbngtssn@yahoo.se&gt;
 * Copyright (C) 2004 Thomas E Enebo &lt;enebo@acm.org&gt;
 * Copyright (C) 2004-2005 Charles O Nutter &lt;headius@headius.com&gt;
 * Copyright (C) 2004 Stefan Matthias Aust &lt;sma@3plus4.de&gt;
 * Copyright (C) 2006 Miguel Covarrubias &lt;mlcovarrubias@gmail.com&gt;
 * Copyright (C) 2006 Michael Studman &lt;codehaus@michaelstudman.com&gt;
 * Copyright (C) 2006 Ola Bini &lt;ola@ologix.com&gt;
 * Copyright (C) 2007 Nick Sieger &lt;nicksieger@gmail.com&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby;

import org.jruby.compiler.Constantizable;
import org.jruby.compiler.NotCompilableException;
import org.jruby.ext.jruby.JRubyLibrary;
import org.jruby.ext.thread.ThreadLibrary;
import org.jruby.ir.IRScriptBody;
import org.jruby.parser.StaticScope;
import org.objectweb.asm.util.TraceClassVisitor;

import jnr.constants.Constant;
import jnr.constants.ConstantSet;
import jnr.constants.platform.Errno;
import jnr.posix.POSIX;
import jnr.posix.POSIXFactory;

import org.jcodings.Encoding;
import org.joda.time.DateTimeZone;
import org.jruby.RubyInstanceConfig.CompileMode;
import org.jruby.ast.Node;
import org.jruby.ast.RootNode;
import org.jruby.ast.executable.RuntimeCache;
import org.jruby.ast.executable.Script;
import org.jruby.ast.executable.ScriptAndCode;
import org.jruby.common.IRubyWarnings.ID;
import org.jruby.common.RubyWarnings;
import org.jruby.compiler.JITCompiler;
import org.jruby.embed.Extension;
import org.jruby.exceptions.JumpException;
import org.jruby.exceptions.MainExitException;
import org.jruby.exceptions.RaiseException;
import org.jruby.exceptions.Unrescuable;
import org.jruby.ext.JRubyPOSIXHandler;
import org.jruby.ext.LateLoadingLibrary;
import org.jruby.ext.coverage.CoverageData;
import org.jruby.ext.ffi.FFI;
import org.jruby.ext.fiber.ThreadFiber;
import org.jruby.ext.fiber.ThreadFiberLibrary;
import org.jruby.ext.tracepoint.TracePoint;
import org.jruby.internal.runtime.GlobalVariables;
import org.jruby.internal.runtime.ThreadService;
import org.jruby.internal.runtime.ValueAccessor;
import org.jruby.internal.runtime.methods.CallConfiguration;
import org.jruby.internal.runtime.methods.DynamicMethod;
import org.jruby.internal.runtime.methods.JavaMethod;
import org.jruby.ir.Compiler;
import org.jruby.ir.IRManager;
import org.jruby.ir.interpreter.Interpreter;
import org.jruby.ir.persistence.IRReader;
import org.jruby.ir.persistence.IRReaderFile;
import org.jruby.ir.persistence.util.IRFileExpert;
import org.jruby.javasupport.JavaSupport;
import org.jruby.javasupport.proxy.JavaProxyClassFactory;
import org.jruby.management.BeanManager;
import org.jruby.management.BeanManagerFactory;
import org.jruby.management.Config;
import org.jruby.management.ParserStats;
import org.jruby.parser.Parser;
import org.jruby.parser.ParserConfiguration;
import org.jruby.parser.StaticScopeFactory;
import org.jruby.platform.Platform;
import org.jruby.runtime.Binding;
import org.jruby.runtime.Block;
import org.jruby.runtime.CallSite;
import org.jruby.runtime.CallbackFactory;
import org.jruby.runtime.ClassIndex;
import org.jruby.runtime.DynamicScope;
import org.jruby.runtime.EventHook;
import org.jruby.runtime.GlobalVariable;
import org.jruby.runtime.Helpers;
import org.jruby.runtime.IAccessor;
import org.jruby.runtime.ObjectAllocator;
import org.jruby.runtime.ObjectSpace;
import org.jruby.runtime.RubyEvent;
import org.jruby.runtime.ThreadContext;
import org.jruby.runtime.Visibility;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.runtime.encoding.EncodingService;
import org.jruby.runtime.invokedynamic.MethodNames;
import org.jruby.runtime.load.BasicLibraryService;
import org.jruby.runtime.load.CompiledScriptLoader;
import org.jruby.runtime.load.Library;
import org.jruby.runtime.load.LoadService;
import org.jruby.runtime.opto.Invalidator;
import org.jruby.runtime.opto.OptoFactory;
import org.jruby.runtime.profile.ProfileCollection;
import org.jruby.runtime.profile.ProfilingService;
import org.jruby.runtime.profile.ProfilingServiceLookup;
import org.jruby.runtime.profile.builtin.ProfiledMethods;
import org.jruby.runtime.scope.ManyVarsDynamicScope;
import org.jruby.threading.DaemonThreadFactory;
import org.jruby.truffle.TruffleBridgeImpl;
import org.jruby.truffle.translator.TranslatorDriver;
import org.jruby.util.ByteList;
import org.jruby.util.DefinedMessage;
import org.jruby.util.JRubyClassLoader;
import org.jruby.util.IOInputStream;
import org.jruby.util.IOOutputStream;
import org.jruby.util.ClassDefininngJRubyClassLoader;
import org.jruby.util.KCode;
import org.jruby.util.SafePropertyAccessor;
import org.jruby.util.cli.Options;
import org.jruby.util.collections.WeakHashSet;
import org.jruby.util.func.Function1;
import org.jruby.util.io.FilenoUtil;
import org.jruby.util.io.SelectorPool;
import org.jruby.util.log.Logger;
import org.jruby.util.log.LoggerFactory;
import org.objectweb.asm.ClassReader;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileDescriptor;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.lang.ref.WeakReference;
import java.net.BindException;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.channels.ClosedChannelException;
import java.security.AccessControlException;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.Stack;
import java.util.WeakHashMap;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.regex.Pattern;

import static org.jruby.internal.runtime.GlobalVariable.Scope.GLOBAL;

/**
 * The Ruby object represents the top-level of a JRuby &quot;instance&quot; in a given VM.
 * JRuby supports spawning multiple instances in the same JVM. Generally, objects
 * created under these instances are tied to a given runtime, for such details
 * as identity and type, because multiple Ruby instances means there are
 * multiple instances of each class. This means that in multi-runtime mode
 * (or really, multi-VM mode, where each JRuby instance is a ruby &quot;VM&quot;), objects
 * generally can't be transported across runtimes without marshaling.
 *
 * This class roots everything that makes the JRuby runtime function, and
 * provides a number of utility methods for constructing global types and
 * accessing global runtime structures.
 */
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">public final class Ruby implements Constantizable {</span>

    /**
     * The logger used to log relevant bits.
     */
<span class="fc" id="L208">    private static final Logger LOG = LoggerFactory.getLogger(&quot;Ruby&quot;);</span>

    /**
     * Create and initialize a new JRuby runtime. The properties of the
     * specified RubyInstanceConfig will be used to determine various JRuby
     * runtime characteristics.
     *
     * @param config The configuration to use for the new instance
     * @see org.jruby.RubyInstanceConfig
     */
<span class="fc" id="L218">    private Ruby(RubyInstanceConfig config) {</span>
<span class="fc" id="L219">        this.config             = config;</span>
<span class="fc" id="L220">        this.threadService      = new ThreadService(this);</span>

<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        if( config.isProfiling() ) {</span>
<span class="nc" id="L223">            this.profiledMethods        = new ProfiledMethods(this);</span>
<span class="nc" id="L224">            this.profilingServiceLookup = new ProfilingServiceLookup(this);</span>
        } else {
<span class="fc" id="L226">            this.profiledMethods        = null;</span>
<span class="fc" id="L227">            this.profilingServiceLookup = null;</span>
        }

<span class="fc" id="L230">        constant = OptoFactory.newConstantWrapper(Ruby.class, this);</span>

<span class="fc" id="L232">        getJRubyClassLoader(); // force JRubyClassLoader to init if possible</span>

<span class="fc" id="L234">        this.staticScopeFactory = new StaticScopeFactory(this);</span>
<span class="fc" id="L235">        this.beanManager        = BeanManagerFactory.create(this, config.isManagementEnabled());</span>
<span class="fc" id="L236">        this.jitCompiler        = new JITCompiler(this);</span>
<span class="fc" id="L237">        this.parserStats        = new ParserStats(this);</span>

        Random myRandom;
        try {
<span class="fc" id="L241">            myRandom = new SecureRandom();</span>
<span class="nc" id="L242">        } catch (Throwable t) {</span>
<span class="nc" id="L243">            LOG.debug(&quot;unable to instantiate SecureRandom, falling back on Random&quot;, t);</span>
<span class="nc" id="L244">            myRandom = new Random();</span>
<span class="fc" id="L245">        }</span>
<span class="fc" id="L246">        this.random = myRandom;</span>

<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        if (RubyInstanceConfig.CONSISTENT_HASHING_ENABLED) {</span>
<span class="nc" id="L249">            this.hashSeedK0 = -561135208506705104l;</span>
<span class="nc" id="L250">            this.hashSeedK1 = 7114160726623585955l;</span>
        } else {
<span class="fc" id="L252">            this.hashSeedK0 = this.random.nextLong();</span>
<span class="fc" id="L253">            this.hashSeedK1 = this.random.nextLong();</span>
        }

<span class="fc" id="L256">        this.configBean = new Config(this);</span>
<span class="fc" id="L257">        this.runtimeBean = new org.jruby.management.Runtime(this);</span>

<span class="fc" id="L259">        registerMBeans();</span>

<span class="fc" id="L261">        this.runtimeCache = new RuntimeCache();</span>
<span class="fc" id="L262">        runtimeCache.initMethodCache(ClassIndex.MAX_CLASSES.ordinal() * MethodNames.values().length - 1);</span>

<span class="fc" id="L264">        checkpointInvalidator = OptoFactory.newConstantInvalidator();</span>

<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        if (config.isObjectSpaceEnabled()) {</span>
<span class="nc" id="L267">            objectSpacer = ENABLED_OBJECTSPACE;</span>
        } else {
<span class="fc" id="L269">            objectSpacer = DISABLED_OBJECTSPACE;</span>
        }

<span class="fc" id="L272">        reinitialize(false);</span>
<span class="fc" id="L273">    }</span>

    public void registerMBeans() {
<span class="fc" id="L276">        this.beanManager.register(jitCompiler);</span>
<span class="fc" id="L277">        this.beanManager.register(configBean);</span>
<span class="fc" id="L278">        this.beanManager.register(parserStats);</span>
<span class="fc" id="L279">        this.beanManager.register(runtimeBean);</span>
<span class="fc" id="L280">    }</span>

    void reinitialize(boolean reinitCore) {
<span class="fc" id="L283">        this.doNotReverseLookupEnabled = true;</span>
<span class="fc" id="L284">        this.staticScopeFactory = new StaticScopeFactory(this);</span>
<span class="fc" id="L285">        this.in                 = config.getInput();</span>
<span class="fc" id="L286">        this.out                = config.getOutput();</span>
<span class="fc" id="L287">        this.err                = config.getError();</span>
<span class="fc" id="L288">        this.objectSpaceEnabled = config.isObjectSpaceEnabled();</span>
<span class="fc" id="L289">        this.siphashEnabled     = config.isSiphashEnabled();</span>
<span class="fc" id="L290">        this.profile            = config.getProfile();</span>
<span class="fc" id="L291">        this.currentDirectory   = config.getCurrentDirectory();</span>
<span class="fc" id="L292">        this.kcode              = config.getKCode();</span>

<span class="pc bpc" id="L294" title="1 of 2 branches missed.">        if (reinitCore) {</span>
<span class="nc" id="L295">            RubyGlobal.initARGV(this);</span>
        }
<span class="fc" id="L297">    }</span>

    /**
     * Returns a new instance of the JRuby runtime configured with defaults.
     *
     * @return the JRuby runtime
     * @see org.jruby.RubyInstanceConfig
     */
    public static Ruby newInstance() {
<span class="nc" id="L306">        return newInstance(new RubyInstanceConfig());</span>
    }

    /**
     * Returns a new instance of the JRuby runtime configured as specified.
     *
     * @param config The instance configuration
     * @return The JRuby runtime
     * @see org.jruby.RubyInstanceConfig
     */
    public static Ruby newInstance(RubyInstanceConfig config) {
<span class="fc" id="L317">        Ruby ruby = new Ruby(config);</span>
<span class="fc" id="L318">        ruby.init();</span>
<span class="fc" id="L319">        setGlobalRuntimeFirstTimeOnly(ruby);</span>
<span class="fc" id="L320">        return ruby;</span>
    }

    /**
     * Returns a new instance of the JRuby runtime configured with the given
     * input, output and error streams and otherwise default configuration
     * (except where specified system properties alter defaults).
     *
     * @param in the custom input stream
     * @param out the custom output stream
     * @param err the custom error stream
     * @return the JRuby runtime
     * @see org.jruby.RubyInstanceConfig
     */
    public static Ruby newInstance(InputStream in, PrintStream out, PrintStream err) {
<span class="nc" id="L335">        RubyInstanceConfig config = new RubyInstanceConfig();</span>
<span class="nc" id="L336">        config.setInput(in);</span>
<span class="nc" id="L337">        config.setOutput(out);</span>
<span class="nc" id="L338">        config.setError(err);</span>
<span class="nc" id="L339">        return newInstance(config);</span>
    }

    /**
     * Tests whether globalRuntime has been instantiated or not.
     *
     * This method is used by singleton model of org.jruby.embed.ScriptingContainer
     * to decide what RubyInstanceConfig should be used. When a global runtime is
     * not there, RubyInstanceConfig of AbstractContextProvider will be used to enact
     * configurations set by a user. When a global runtime is already instantiated,
     * RubyInstanceConfig of the global runtime should be used in ScriptingContaiener.
     *
     * @return true if a global runtime is instantiated, false for other.
     *
     */
    public static boolean isGlobalRuntimeReady() {
<span class="nc bnc" id="L355" title="All 2 branches missed.">        return globalRuntime != null;</span>
    }

    /**
     * Set the global runtime to the given runtime only if it has no been set.
     *
     * @param runtime the runtime to use for global runtime
     */
    private static synchronized void setGlobalRuntimeFirstTimeOnly(Ruby runtime) {
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">        if (globalRuntime == null) {</span>
<span class="fc" id="L365">            globalRuntime = runtime;</span>
        }
<span class="fc" id="L367">    }</span>

    /**
     * Get the global runtime.
     *
     * @return the global runtime
     */
    public static synchronized Ruby getGlobalRuntime() {
<span class="nc bnc" id="L375" title="All 2 branches missed.">        if (globalRuntime == null) {</span>
<span class="nc" id="L376">            newInstance();</span>
        }
<span class="nc" id="L378">        return globalRuntime;</span>
    }

    /**
     * Convenience method for java integrators who may need to switch the notion
     * of &quot;global&quot; runtime. Use &lt;tt&gt;JRuby.runtime.use_as_global_runtime&lt;/tt&gt;
     * from Ruby code to activate the current runtime as the global one.
     */
    public void useAsGlobalRuntime() {
<span class="nc" id="L387">        synchronized(Ruby.class) {</span>
<span class="nc" id="L388">            globalRuntime = this;</span>
<span class="nc" id="L389">        }</span>
<span class="nc" id="L390">    }</span>

    /**
     * Clear the global runtime.
     */
    public static void clearGlobalRuntime() {
<span class="nc" id="L396">        globalRuntime = null;</span>
<span class="nc" id="L397">    }</span>

    /**
     * Get the thread-local runtime for the current thread, or null if unset.
     *
     * @return the thread-local runtime, or null if unset
     */
    public static Ruby getThreadLocalRuntime() {
<span class="nc" id="L405">        return threadLocalRuntime.get();</span>
    }

    /**
     * Set the thread-local runtime to the given runtime.
     *
     * Note that static threadlocals like this one can leak resources across
     * (for example) application redeploys. If you use this, it is your
     * responsibility to clean it up appropriately.
     *
     * @param ruby the new runtime for thread-local
     */
    public static void setThreadLocalRuntime(Ruby ruby) {
<span class="nc" id="L418">        threadLocalRuntime.set(ruby);</span>
<span class="nc" id="L419">    }</span>

    /**
     * Evaluates a script under the current scope (perhaps the top-level
     * scope) and returns the result (generally the last value calculated).
     * This version goes straight into the interpreter, bypassing compilation
     * and runtime preparation typical to normal script runs.
     *
     * @param script The scriptlet to run
     * @returns The result of the eval
     */
    public IRubyObject evalScriptlet(String script) {
<span class="nc" id="L431">        ThreadContext context = getCurrentContext();</span>
<span class="nc" id="L432">        DynamicScope currentScope = context.getCurrentScope();</span>
<span class="nc" id="L433">        ManyVarsDynamicScope newScope = new ManyVarsDynamicScope(getStaticScopeFactory().newEvalScope(currentScope.getStaticScope()), currentScope);</span>

<span class="nc" id="L435">        return evalScriptlet(script, newScope);</span>
    }

    /**
     * Evaluates a script under the current scope (perhaps the top-level
     * scope) and returns the result (generally the last value calculated).
     * This version goes straight into the interpreter, bypassing compilation
     * and runtime preparation typical to normal script runs.
     *
     * This version accepts a scope to use, so you can eval many times against
     * the same scope.
     *
     * @param script The scriptlet to run
     * @param scope The scope to execute against (ManyVarsDynamicScope is
     * recommended, so it can grow as needed)
     * @returns The result of the eval
     */
    public IRubyObject evalScriptlet(String script, DynamicScope scope) {
<span class="nc" id="L453">        ThreadContext context = getCurrentContext();</span>
<span class="nc" id="L454">        Node rootNode = parseEval(script, &quot;&lt;script&gt;&quot;, scope, 0);</span>

<span class="nc" id="L456">        context.preEvalScriptlet(scope);</span>

        try {
<span class="nc" id="L459">            return Interpreter.getInstance().execute(this, rootNode, context.getFrameSelf());</span>
<span class="nc" id="L460">        } catch (JumpException.ReturnJump rj) {</span>
<span class="nc" id="L461">            throw newLocalJumpError(RubyLocalJumpError.Reason.RETURN, (IRubyObject)rj.getValue(), &quot;unexpected return&quot;);</span>
<span class="nc" id="L462">        } catch (JumpException.BreakJump bj) {</span>
<span class="nc" id="L463">            throw newLocalJumpError(RubyLocalJumpError.Reason.BREAK, (IRubyObject)bj.getValue(), &quot;unexpected break&quot;);</span>
<span class="nc" id="L464">        } catch (JumpException.RedoJump rj) {</span>
<span class="nc" id="L465">            throw newLocalJumpError(RubyLocalJumpError.Reason.REDO, (IRubyObject)rj.getValue(), &quot;unexpected redo&quot;);</span>
        } finally {
<span class="nc" id="L467">            context.postEvalScriptlet();</span>
        }
    }

    /**
     * Parse and execute the specified script
     * This differs from the other methods in that it accepts a string-based script and
     * parses and runs it as though it were loaded at a command-line. This is the preferred
     * way to start up a new script when calling directly into the Ruby object (which is
     * generally *dis*couraged.
     *
     * @param script The contents of the script to run as a normal, root script
     * @return The last value of the script
     */
    public IRubyObject executeScript(String script, String filename) {
<span class="nc" id="L482">        byte[] bytes = script.getBytes();</span>

<span class="nc" id="L484">        Node node = parseInline(new ByteArrayInputStream(bytes), filename, null);</span>
<span class="nc" id="L485">        ThreadContext context = getCurrentContext();</span>

<span class="nc" id="L487">        String oldFile = context.getFile();</span>
<span class="nc" id="L488">        int oldLine = context.getLine();</span>
        try {
<span class="nc" id="L490">            context.setFileAndLine(node.getPosition());</span>
<span class="nc" id="L491">            return runInterpreter(node);</span>
        } finally {
<span class="nc" id="L493">            context.setFileAndLine(oldFile, oldLine);</span>
        }
    }

    /**
     * Run the script contained in the specified input stream, using the
     * specified filename as the name of the script being executed. The stream
     * will be read fully before being parsed and executed. The given filename
     * will be used for the ruby $PROGRAM_NAME and $0 global variables in this
     * runtime.
     *
     * This method is intended to be called once per runtime, generally from
     * Main or from main-like top-level entry points.
     *
     * As part of executing the script loaded from the input stream, various
     * RubyInstanceConfig properties will be used to determine whether to
     * compile the script before execution or run with various wrappers (for
     * looping, printing, and so on, see jruby -help).
     *
     * @param inputStream The InputStream from which to read the script contents
     * @param filename The filename to use when parsing, and for $PROGRAM_NAME
     * and $0 ruby global variables.
     */
    public void runFromMain(InputStream inputStream, String filename) {
<span class="fc" id="L517">        IAccessor d = new ValueAccessor(newString(filename));</span>
<span class="fc" id="L518">        getGlobalVariables().define(&quot;$PROGRAM_NAME&quot;, d, GLOBAL);</span>
<span class="fc" id="L519">        getGlobalVariables().define(&quot;$0&quot;, d, GLOBAL);</span>

<span class="fc bfc" id="L521" title="All 2 branches covered.">        for (Iterator i = config.getOptionGlobals().entrySet().iterator(); i.hasNext();) {</span>
<span class="fc" id="L522">            Map.Entry entry = (Map.Entry) i.next();</span>
<span class="fc" id="L523">            Object value = entry.getValue();</span>
            IRubyObject varvalue;
<span class="fc bfc" id="L525" title="All 2 branches covered.">            if (value != null) {</span>
<span class="fc" id="L526">                varvalue = newString(value.toString());</span>
            } else {
<span class="fc" id="L528">                varvalue = getTrue();</span>
            }
<span class="fc" id="L530">            getGlobalVariables().set(&quot;$&quot; + entry.getKey().toString(), varvalue);</span>
<span class="fc" id="L531">        }</span>

<span class="pc bpc" id="L533" title="1 of 2 branches missed.">        if (filename.endsWith(&quot;.class&quot;)) {</span>
            // we are presumably running a precompiled class; load directly
<span class="nc" id="L535">            Script script = CompiledScriptLoader.loadScriptFromFile(this, inputStream, filename);</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">            if (script == null) {</span>
<span class="nc" id="L537">                throw new MainExitException(1, &quot;error: .class file specified is not a compiled JRuby script&quot;);</span>
            }
<span class="nc" id="L539">            script.setFilename(filename);</span>
<span class="nc" id="L540">            runScript(script);</span>
<span class="nc" id="L541">            return;</span>
        }

<span class="fc" id="L544">        ParseResult parseResult = parseFromMain(filename, inputStream);</span>

        // if no DATA, we're done with the stream, shut it down
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">        if (fetchGlobalConstant(&quot;DATA&quot;) == null) {</span>
<span class="pc" id="L548">            try {inputStream.close();} catch (IOException ioe) {}</span>
        }

<span class="pc bpc" id="L551" title="1 of 2 branches missed.">        if (parseResult instanceof RootNode) {</span>
<span class="fc" id="L552">            RootNode scriptNode = (RootNode) parseResult;</span>

<span class="fc" id="L554">            ThreadContext context = getCurrentContext();</span>

<span class="fc" id="L556">            String oldFile = context.getFile();</span>
<span class="fc" id="L557">            int oldLine = context.getLine();</span>
            try {
<span class="fc" id="L559">                context.setFileAndLine(scriptNode.getPosition());</span>

<span class="fc bfc" id="L561" title="All 4 branches covered.">                if (config.isAssumePrinting() || config.isAssumeLoop()) {</span>
<span class="fc" id="L562">                    runWithGetsLoop(scriptNode, config.isAssumePrinting(), config.isProcessLineEnds(),</span>
<span class="fc" id="L563">                            config.isSplit());</span>
                } else {
<span class="fc" id="L565">                    runNormally(scriptNode);</span>
                }
            } finally {
<span class="fc" id="L568">                context.setFileAndLine(oldFile, oldLine);</span>
<span class="fc" id="L569">            }</span>
<span class="fc" id="L570">        } else {</span>
            // TODO: Only interpreter supported so far
<span class="nc" id="L572">            runInterpreter(parseResult);</span>
        }
<span class="fc" id="L574">    }</span>

    /**
     * Parse the script contained in the given input stream, using the given
     * filename as the name of the script, and return the root Node. This
     * is used to verify that the script syntax is valid, for jruby -c. The
     * current scope (generally the top-level scope) is used as the parent
     * scope for parsing.
     *
     * @param inputStream The input stream from which to read the script
     * @param filename The filename to use for parsing
     * @returns The root node of the parsed script
     */
    public Node parseFromMain(InputStream inputStream, String filename) {
<span class="fc bfc" id="L588" title="All 2 branches covered.">        if (config.isInlineScript()) {</span>
<span class="fc" id="L589">            return parseInline(inputStream, filename, getCurrentContext().getCurrentScope());</span>
        } else {
<span class="fc" id="L591">            return parseFileFromMain(inputStream, filename, getCurrentContext().getCurrentScope());</span>
        }
    }

    public ParseResult parseFromMain(String fileName, InputStream in) {
<span class="fc bfc" id="L596" title="All 2 branches covered.">        if (config.isInlineScript()) return parseInline(in, fileName, getCurrentContext().getCurrentScope());</span>

<span class="fc" id="L598">        return parseFileFromMain(fileName, in, getCurrentContext().getCurrentScope());</span>
    }

    /**
     * Run the given script with a &quot;while gets; end&quot; loop wrapped around it.
     * This is primarily used for the -n command-line flag, to allow writing
     * a short script that processes input lines using the specified code.
     *
     * @param scriptNode The root node of the script to execute
     * @param printing Whether $_ should be printed after each loop (as in the
     * -p command-line flag)
     * @param processLineEnds Whether line endings should be processed by
     * setting $\ to $/ and &lt;code&gt;chop!&lt;/code&gt;ing every line read
     * @param split Whether to split each line read using &lt;code&gt;String#split&lt;/code&gt;
     * bytecode before executing.
     * @return The result of executing the specified script
     */
    @Deprecated
    public IRubyObject runWithGetsLoop(Node scriptNode, boolean printing, boolean processLineEnds, boolean split, boolean unused) {
<span class="nc" id="L617">        return runWithGetsLoop(scriptNode, printing, processLineEnds, split);</span>
    }

    /**
     * Run the given script with a &quot;while gets; end&quot; loop wrapped around it.
     * This is primarily used for the -n command-line flag, to allow writing
     * a short script that processes input lines using the specified code.
     *
     * @param scriptNode The root node of the script to execute
     * @param printing Whether $_ should be printed after each loop (as in the
     * -p command-line flag)
     * @param processLineEnds Whether line endings should be processed by
     * setting $\ to $/ and &lt;code&gt;chop!&lt;/code&gt;ing every line read
     * @param split Whether to split each line read using &lt;code&gt;String#split&lt;/code&gt;
     * bytecode before executing.
     * @return The result of executing the specified script
     */
    public IRubyObject runWithGetsLoop(Node scriptNode, boolean printing, boolean processLineEnds, boolean split) {
<span class="fc" id="L635">        ThreadContext context = getCurrentContext();</span>

<span class="fc" id="L637">        Script script = null;</span>
<span class="fc" id="L638">        boolean compile = getInstanceConfig().getCompileMode().shouldPrecompileCLI();</span>
<span class="pc bpc" id="L639" title="1 of 2 branches missed.">        if (compile) {</span>
            try {
<span class="fc" id="L641">                script = tryCompile(scriptNode);</span>
<span class="pc bpc" id="L642" title="1 of 2 branches missed.">                if (Options.JIT_LOGGING.load()) {</span>
<span class="nc" id="L643">                    LOG.info(&quot;Successfully compiled: &quot; + scriptNode.getPosition().getFile());</span>
                }
<span class="nc" id="L645">            } catch (Throwable e) {</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">                if (Options.JIT_LOGGING.load()) {</span>
<span class="nc" id="L647">                    LOG.error(&quot;Failed to compile: &quot; + scriptNode.getPosition().getFile());</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">                    if (Options.JIT_LOGGING_VERBOSE.load()) {</span>
<span class="nc" id="L649">                        LOG.error(e);</span>
                    }
                }
<span class="fc" id="L652">            }</span>
<span class="pc bpc" id="L653" title="2 of 4 branches missed.">            if (compile &amp;&amp; script == null) {</span>
                // IR JIT does not handle all scripts yet, so let those that fail run in interpreter instead
                // FIXME: restore error once JIT should handle everything
            }
        }

<span class="pc bpc" id="L659" title="1 of 2 branches missed.">        if (processLineEnds) {</span>
<span class="nc" id="L660">            getGlobalVariables().set(&quot;$\\&quot;, getGlobalVariables().get(&quot;$/&quot;));</span>
        }

        // we do pre and post load outside the &quot;body&quot; versions to pre-prepare
        // and pre-push the dynamic scope we need for lastline
<span class="fc" id="L665">        Helpers.preLoad(context, ((RootNode) scriptNode).getStaticScope().getVariables());</span>

        try {
<span class="fc bfc" id="L668" title="All 2 branches covered.">            while (RubyKernel.gets(context, getTopSelf(), IRubyObject.NULL_ARRAY).isTrue()) {</span>
                loop: while (true) { // Used for the 'redo' command
                    try {
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">                        if (processLineEnds) {</span>
<span class="nc" id="L672">                            getGlobalVariables().get(&quot;$_&quot;).callMethod(context, &quot;chop!&quot;);</span>
                        }

<span class="fc bfc" id="L675" title="All 2 branches covered.">                        if (split) {</span>
<span class="fc" id="L676">                            getGlobalVariables().set(&quot;$F&quot;, getGlobalVariables().get(&quot;$_&quot;).callMethod(context, &quot;split&quot;));</span>
                        }

<span class="pc bpc" id="L679" title="1 of 2 branches missed.">                        if (script != null) {</span>
<span class="fc" id="L680">                            runScriptBody(script);</span>
                        } else {
<span class="nc" id="L682">                            runInterpreterBody(scriptNode);</span>
                        }

<span class="fc bfc" id="L685" title="All 2 branches covered.">                        if (printing) RubyKernel.print(context, getKernel(), new IRubyObject[] {getGlobalVariables().get(&quot;$_&quot;)});</span>
<span class="fc" id="L686">                        break loop;</span>
<span class="nc" id="L687">                    } catch (JumpException.RedoJump rj) {</span>
                        // do nothing, this iteration restarts
<span class="nc" id="L689">                    } catch (JumpException.NextJump nj) {</span>
                        // recheck condition
<span class="nc" id="L691">                        break loop;</span>
<span class="nc" id="L692">                    } catch (JumpException.BreakJump bj) {</span>
                        // end loop
<span class="nc" id="L694">                        return (IRubyObject) bj.getValue();</span>
<span class="nc" id="L695">                    }</span>
                }
            }
        } finally {
<span class="pc" id="L699">            Helpers.postLoad(context);</span>
<span class="fc" id="L700">        }</span>

<span class="fc" id="L702">        return getNil();</span>
    }

    /**
     * Run the specified script without any of the loop-processing wrapper
     * code.
     *
     * @param scriptNode The root node of the script to be executed
     * bytecode before execution
     * @return The result of executing the script
     */
    @Deprecated
    public IRubyObject runNormally(Node scriptNode, boolean unused) {
<span class="nc" id="L715">        return runNormally(scriptNode);</span>
    }

    /**
     * Run the specified script without any of the loop-processing wrapper
     * code.
     *
     * @param scriptNode The root node of the script to be executed
     * bytecode before execution
     * @return The result of executing the script
     */
    public IRubyObject runNormally(Node scriptNode) {
<span class="fc" id="L727">        ScriptAndCode scriptAndCode = null;</span>
<span class="fc" id="L728">        boolean compile = getInstanceConfig().getCompileMode().shouldPrecompileCLI();</span>
<span class="pc bpc" id="L729" title="3 of 4 branches missed.">        if (compile || config.isShowBytecode()) {</span>
            // IR JIT does not handle all scripts yet, so let those that fail run in interpreter instead
            // FIXME: restore error once JIT should handle everything
            try {
<span class="fc" id="L733">                scriptAndCode = tryCompile(scriptNode, new ClassDefininngJRubyClassLoader(getJRubyClassLoader()));</span>
<span class="pc bpc" id="L734" title="2 of 4 branches missed.">                if (scriptAndCode != null &amp;&amp; Options.JIT_LOGGING.load()) {</span>
<span class="nc" id="L735">                    LOG.info(&quot;done compiling target script: &quot; + scriptNode.getPosition().getFile());</span>
                }
<span class="nc" id="L737">            } catch (Exception e) {</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">                if (Options.JIT_LOGGING.load()) {</span>
<span class="nc" id="L739">                    LOG.error(&quot;failed to compile target script '&quot; + scriptNode.getPosition().getFile() + &quot;'&quot;);</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">                    if (Options.JIT_LOGGING_VERBOSE.load()) {</span>
<span class="nc" id="L741">                        e.printStackTrace();</span>
                    }
                }
<span class="fc" id="L744">            }</span>
        }

<span class="pc bpc" id="L747" title="1 of 2 branches missed.">        if (scriptAndCode != null) {</span>
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">            if (config.isShowBytecode()) {</span>
<span class="nc" id="L749">                TraceClassVisitor tracer = new TraceClassVisitor(new PrintWriter(System.err));</span>
<span class="nc" id="L750">                ClassReader reader = new ClassReader(scriptAndCode.bytecode());</span>
<span class="nc" id="L751">                reader.accept(tracer, 0);</span>
<span class="nc" id="L752">                return getNil();</span>
            }

<span class="fc" id="L755">            return runScript(scriptAndCode.script());</span>
        } else {
            // FIXME: temporarily allowing JIT to fail for $0 and fall back on interpreter
//            failForcedCompile(scriptNode);

<span class="nc" id="L760">            return runInterpreter(scriptNode);</span>
        }
    }

    /**
     * Try to compile the code associated with the given Node, returning an
     * instance of the successfully-compiled Script or null if the script could
     * not be compiled.
     *
     * @param node The node to attempt to compiled
     * @return an instance of the successfully-compiled Script, or null.
     */
    public Script tryCompile(Node node) {
<span class="fc" id="L773">        return tryCompile(node, new ClassDefininngJRubyClassLoader(getJRubyClassLoader())).script();</span>
    }

    private void failForcedCompile(Node scriptNode) throws RaiseException {
<span class="nc bnc" id="L777" title="All 2 branches missed.">        if (config.getCompileMode().shouldPrecompileAll()) {</span>
<span class="nc" id="L778">            throw newRuntimeError(&quot;could not compile and compile mode is 'force': &quot; + scriptNode.getPosition().getFile());</span>
        }
<span class="nc" id="L780">    }</span>

    private void handeCompileError(Node node, Throwable t) {
<span class="nc bnc" id="L783" title="All 4 branches missed.">        if (config.isJitLoggingVerbose() || config.isDebug()) {</span>
<span class="nc" id="L784">            LOG.error(&quot;warning: could not compile: {}; full trace follows&quot;, node.getPosition().getFile());</span>
<span class="nc" id="L785">            LOG.error(t.getMessage(), t);</span>
        }
<span class="nc" id="L787">    }</span>

    private ScriptAndCode tryCompile(Node node, ClassDefininngJRubyClassLoader classLoader) {
        try {
<span class="fc" id="L791">            return Compiler.getInstance().execute(this, node, classLoader);</span>
<span class="nc" id="L792">        } catch (NotCompilableException e) {</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">            if (Options.JIT_LOGGING.load()) {</span>
<span class="nc" id="L794">                LOG.error(&quot;failed to compile target script &quot; + node.getPosition().getFile() + &quot;: &quot; + e.getLocalizedMessage());</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">                if (Options.JIT_LOGGING_VERBOSE.load()) {</span>
<span class="nc" id="L796">                    LOG.error(e);</span>
                }
            }
<span class="nc" id="L799">            return null;</span>
        }
    }

    public IRubyObject runScript(Script script) {
<span class="fc" id="L804">        return runScript(script, false);</span>
    }

    public IRubyObject runScript(Script script, boolean wrap) {
<span class="fc" id="L808">        ThreadContext context = getCurrentContext();</span>

        try {
<span class="fc" id="L811">            return script.load(context, getTopSelf(), wrap);</span>
<span class="nc" id="L812">        } catch (JumpException.ReturnJump rj) {</span>
<span class="nc" id="L813">            return (IRubyObject) rj.getValue();</span>
        }
    }

    /**
     * This is used for the &quot;gets&quot; loop, and we bypass 'load' to use an
     * already-prepared, already-pushed scope for the script body.
     */
    public IRubyObject runScriptBody(Script script) {
<span class="fc" id="L822">        ThreadContext context = getCurrentContext();</span>

        try {
<span class="fc" id="L825">            return script.__file__(context, getTopSelf(), Block.NULL_BLOCK);</span>
<span class="nc" id="L826">        } catch (JumpException.ReturnJump rj) {</span>
<span class="nc" id="L827">            return (IRubyObject) rj.getValue();</span>
        }
    }

    public IRubyObject runInterpreter(ThreadContext context, ParseResult parseResult, IRubyObject self) {
<span class="pc bpc" id="L832" title="1 of 2 branches missed.">       if (getInstanceConfig().getCompileMode() == CompileMode.TRUFFLE) {</span>
<span class="nc bnc" id="L833" title="All 4 branches missed.">           assert parseResult instanceof RootNode;</span>
<span class="nc" id="L834">           getTruffleBridge().execute(TranslatorDriver.ParserContext.TOP_LEVEL, getTruffleBridge().toTruffle(self), null, (RootNode) parseResult);</span>
<span class="nc" id="L835">           return getNil();</span>
       } else {
           try {
<span class="fc" id="L838">               return Interpreter.getInstance().execute(this, parseResult, self);</span>
<span class="nc" id="L839">           } catch (JumpException.ReturnJump rj) {</span>
<span class="nc" id="L840">               return (IRubyObject) rj.getValue();</span>
           }
       }
   }

    public IRubyObject runInterpreter(ThreadContext context, Node rootNode, IRubyObject self) {
<span class="nc bnc" id="L846" title="All 4 branches missed.">        assert rootNode != null : &quot;scriptNode is not null&quot;;</span>

<span class="nc bnc" id="L848" title="All 2 branches missed.">        if (getInstanceConfig().getCompileMode() == CompileMode.TRUFFLE) {</span>
<span class="nc bnc" id="L849" title="All 4 branches missed.">            assert rootNode instanceof RootNode;</span>
<span class="nc" id="L850">            getTruffleBridge().execute(TranslatorDriver.ParserContext.TOP_LEVEL, getTruffleBridge().toTruffle(self), null, (RootNode) rootNode);</span>
<span class="nc" id="L851">            return getNil();</span>
        } else {
            try {

                // FIXME: retrieve from IRManager unless lifus does it later
<span class="nc" id="L856">                return Interpreter.getInstance().execute(this, rootNode, self);</span>
<span class="nc" id="L857">            } catch (JumpException.ReturnJump rj) {</span>
<span class="nc" id="L858">                return (IRubyObject) rj.getValue();</span>
            }
        }
    }

    public IRubyObject runInterpreter(Node scriptNode) {
<span class="nc" id="L864">        return runInterpreter(getCurrentContext(), scriptNode, getTopSelf());</span>
    }

    public IRubyObject runInterpreter(ParseResult parseResult) {
<span class="nc" id="L868">        return runInterpreter(getCurrentContext(), parseResult, getTopSelf());</span>
    }

    /**
     * This is used for the &quot;gets&quot; loop, and we bypass 'load' to use an
     * already-prepared, already-pushed scope for the script body.
     */
    public IRubyObject runInterpreterBody(Node scriptNode) {
<span class="nc bnc" id="L876" title="All 4 branches missed.">        assert scriptNode != null : &quot;scriptNode is not null&quot;;</span>
<span class="nc bnc" id="L877" title="All 4 branches missed.">        assert scriptNode instanceof RootNode : &quot;scriptNode is not a RootNode&quot;;</span>

<span class="nc" id="L879">        return runInterpreter(scriptNode);</span>
    }

    public Parser getParser() {
<span class="nc" id="L883">        return parser;</span>
    }

    public BeanManager getBeanManager() {
<span class="fc" id="L887">        return beanManager;</span>
    }

    public JITCompiler getJITCompiler() {
<span class="fc" id="L891">        return jitCompiler;</span>
    }

    public synchronized TruffleBridge getTruffleBridge() {
<span class="nc bnc" id="L895" title="All 2 branches missed.">        if (truffleBridge == null) {</span>
            /*
             * It's possible to remove Truffle classes from the JRuby distribution, so we provide a sensible
             * explanation when the classes are not found.
             */

            try {
<span class="nc" id="L902">                truffleBridge = new TruffleBridgeImpl(this);</span>
<span class="nc" id="L903">                truffleBridge.init();</span>
<span class="nc" id="L904">            } catch (NoClassDefFoundError e) {</span>
<span class="nc" id="L905">                throw new UnsupportedOperationException(&quot;Support for Truffle has been removed from this distribution&quot;, e);</span>
<span class="nc" id="L906">            }</span>
        }

<span class="nc" id="L909">        return truffleBridge;</span>
    }

    public synchronized void shutdownTruffleBridge() {
<span class="pc bpc" id="L913" title="1 of 2 branches missed.">        if (truffleBridge != null) {</span>
<span class="nc" id="L914">            truffleBridge.shutdown();</span>
        }
<span class="fc" id="L916">    }</span>

    /**
     * @deprecated use #newInstance()
     */
    public static Ruby getDefaultInstance() {
<span class="nc" id="L922">        return newInstance();</span>
    }

    @Deprecated
    public static Ruby getCurrentInstance() {
<span class="nc" id="L927">        return null;</span>
    }

    @Deprecated
    public static void setCurrentInstance(Ruby runtime) {
<span class="nc" id="L932">    }</span>

    public int allocSymbolId() {
<span class="fc" id="L935">        return symbolLastId.incrementAndGet();</span>
    }
    public int allocModuleId() {
<span class="fc" id="L938">        return moduleLastId.incrementAndGet();</span>
    }
    public void addModule(RubyModule module) {
<span class="fc" id="L941">        synchronized (allModules) {</span>
<span class="fc" id="L942">            allModules.add(module);</span>
<span class="pc" id="L943">        }</span>
<span class="fc" id="L944">    }</span>
    public void eachModule(Function1&lt;Object, IRubyObject&gt; func) {
<span class="nc" id="L946">        synchronized (allModules) {</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">            for (RubyModule module : allModules) {</span>
<span class="nc" id="L948">                func.apply(module);</span>
<span class="nc" id="L949">            }</span>
<span class="nc" id="L950">        }</span>
<span class="nc" id="L951">    }</span>

    /**
     * Retrieve the module with the given name from the Object namespace.
     *
     * @param name The name of the module
     * @return The module or null if not found
     */
    public RubyModule getModule(String name) {
<span class="fc" id="L960">        return (RubyModule) objectClass.getConstantAt(name);</span>
    }

    @Deprecated
    public RubyModule fastGetModule(String internedName) {
<span class="nc" id="L965">        return getModule(internedName);</span>
    }

    /**
     * Retrieve the class with the given name from the Object namespace.
     *
     * @param name The name of the class
     * @return The class
     */
    public RubyClass getClass(String name) {
<span class="fc" id="L975">        return objectClass.getClass(name);</span>
    }

    /**
     * Retrieve the class with the given name from the Object namespace. The
     * module name must be an interned string, but this method will be faster
     * than the non-interned version.
     *
     * @param internedName the name of the class; &lt;em&gt;must&lt;/em&gt; be an interned String!
     * @return
     */
    @Deprecated
    public RubyClass fastGetClass(String internedName) {
<span class="nc" id="L988">        return getClass(internedName);</span>
    }

    /**
     * Define a new class under the Object namespace. Roughly equivalent to
     * rb_define_class in MRI.
     *
     * @param name The name for the new class
     * @param superClass The super class for the new class
     * @param allocator An ObjectAllocator instance that can construct
     * instances of the new class.
     * @return The new class
     */
    @Extension
    public RubyClass defineClass(String name, RubyClass superClass, ObjectAllocator allocator) {
<span class="fc" id="L1003">        return defineClassUnder(name, superClass, allocator, objectClass);</span>
    }

    /**
     * A variation of defineClass that allows passing in an array of subplementary
     * call sites for improving dynamic invocation performance.
     *
     * @param name The name for the new class
     * @param superClass The super class for the new class
     * @param allocator An ObjectAllocator instance that can construct
     * instances of the new class.
     * @return The new class
     */
    public RubyClass defineClass(String name, RubyClass superClass, ObjectAllocator allocator, CallSite[] callSites) {
<span class="nc" id="L1017">        return defineClassUnder(name, superClass, allocator, objectClass, callSites);</span>
    }

    /**
     * Define a new class with the given name under the given module or class
     * namespace. Roughly equivalent to rb_define_class_under in MRI.
     *
     * If the name specified is already bound, its value will be returned if:
     * * It is a class
     * * No new superclass is being defined
     *
     * @param name The name for the new class
     * @param superClass The super class for the new class
     * @param allocator An ObjectAllocator instance that can construct
     * instances of the new class.
     * @param parent The namespace under which to define the new class
     * @return The new class
     */
    @Extension
    public RubyClass defineClassUnder(String name, RubyClass superClass, ObjectAllocator allocator, RubyModule parent) {
<span class="fc" id="L1037">        return defineClassUnder(name, superClass, allocator, parent, null);</span>
    }

    /**
     * A variation of defineClassUnder that allows passing in an array of
     * supplementary call sites to improve dynamic invocation.
     *
     * @param name The name for the new class
     * @param superClass The super class for the new class
     * @param allocator An ObjectAllocator instance that can construct
     * instances of the new class.
     * @param parent The namespace under which to define the new class
     * @param callSites The array of call sites to add
     * @return The new class
     */
    public RubyClass defineClassUnder(String name, RubyClass superClass, ObjectAllocator allocator, RubyModule parent, CallSite[] callSites) {
<span class="fc" id="L1053">        IRubyObject classObj = parent.getConstantAt(name);</span>

<span class="fc bfc" id="L1055" title="All 2 branches covered.">        if (classObj != null) {</span>
<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">            if (!(classObj instanceof RubyClass)) throw newTypeError(name + &quot; is not a class&quot;);</span>
<span class="fc" id="L1057">            RubyClass klazz = (RubyClass)classObj;</span>
<span class="pc bpc" id="L1058" title="1 of 2 branches missed.">            if (klazz.getSuperClass().getRealClass() != superClass) {</span>
<span class="nc" id="L1059">                throw newNameError(name + &quot; is already defined&quot;, name);</span>
            }
            // If we define a class in Ruby, but later want to allow it to be defined in Java,
            // the allocator needs to be updated
<span class="pc bpc" id="L1063" title="1 of 2 branches missed.">            if (klazz.getAllocator() != allocator) {</span>
<span class="nc" id="L1064">                klazz.setAllocator(allocator);</span>
            }
<span class="fc" id="L1066">            return klazz;</span>
        }

<span class="fc bfc" id="L1069" title="All 2 branches covered.">        boolean parentIsObject = parent == objectClass;</span>

<span class="pc bpc" id="L1071" title="1 of 2 branches missed.">        if (superClass == null) {</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">            String className = parentIsObject ? name : parent.getName() + &quot;::&quot; + name;</span>
<span class="nc" id="L1073">            warnings.warn(ID.NO_SUPER_CLASS, &quot;no super class for `&quot; + className + &quot;', Object assumed&quot;);</span>

<span class="nc" id="L1075">            superClass = objectClass;</span>
        }

<span class="fc bfc" id="L1078" title="All 2 branches covered.">        return RubyClass.newClass(this, superClass, name, allocator, parent, !parentIsObject, callSites);</span>
    }

    /**
     * Define a new module under the Object namespace. Roughly equivalent to
     * rb_define_module in MRI.
     *
     * @param name The name of the new module
     * @returns The new module
     */
    @Extension
    public RubyModule defineModule(String name) {
<span class="fc" id="L1090">        return defineModuleUnder(name, objectClass);</span>
    }

    /**
     * Define a new module with the given name under the given module or
     * class namespace. Roughly equivalent to rb_define_module_under in MRI.
     *
     * @param name The name of the new module
     * @param parent The class or module namespace under which to define the
     * module
     * @returns The new module
     */
    @Extension
    public RubyModule defineModuleUnder(String name, RubyModule parent) {
<span class="fc" id="L1104">        IRubyObject moduleObj = parent.getConstantAt(name);</span>

<span class="fc bfc" id="L1106" title="All 2 branches covered.">        boolean parentIsObject = parent == objectClass;</span>

<span class="fc bfc" id="L1108" title="All 2 branches covered.">        if (moduleObj != null ) {</span>
<span class="pc bpc" id="L1109" title="1 of 2 branches missed.">            if (moduleObj.isModule()) return (RubyModule)moduleObj;</span>

<span class="nc bnc" id="L1111" title="All 2 branches missed.">            if (parentIsObject) {</span>
<span class="nc" id="L1112">                throw newTypeError(moduleObj.getMetaClass().getName() + &quot; is not a module&quot;);</span>
            } else {
<span class="nc" id="L1114">                throw newTypeError(parent.getName() + &quot;::&quot; + moduleObj.getMetaClass().getName() + &quot; is not a module&quot;);</span>
            }
        }

<span class="fc bfc" id="L1118" title="All 2 branches covered.">        return RubyModule.newModule(this, name, parent, !parentIsObject);</span>
    }

    /**
     * From Object, retrieve the named module. If it doesn't exist a
     * new module is created.
     *
     * @param name The name of the module
     * @returns The existing or new module
     */
    public RubyModule getOrCreateModule(String name) {
<span class="fc" id="L1129">        IRubyObject module = objectClass.getConstantAt(name);</span>
<span class="fc bfc" id="L1130" title="All 2 branches covered.">        if (module == null) {</span>
<span class="fc" id="L1131">            module = defineModule(name);</span>
<span class="pc bpc" id="L1132" title="1 of 2 branches missed.">        } else if (!module.isModule()) {</span>
<span class="nc" id="L1133">            throw newTypeError(name + &quot; is not a Module&quot;);</span>
        }

<span class="fc" id="L1136">        return (RubyModule) module;</span>
    }

    public KCode getKCode() {
<span class="fc" id="L1140">        return kcode;</span>
    }

    public void setKCode(KCode kcode) {
<span class="nc" id="L1144">        this.kcode = kcode;</span>
<span class="nc" id="L1145">    }</span>

    /** rb_define_global_const
     * Define a constant on the global namespace (i.e. Object) with the given
     * name and value.
     *
     * @param name the name
     * @param value the value
     */
    public void defineGlobalConstant(String name, IRubyObject value) {
<span class="fc" id="L1155">        objectClass.defineConstant(name, value);</span>
<span class="fc" id="L1156">    }</span>

    /**
     * Fetch a constant from the global namespace (i.e. Object) with the given
     * name.
     *
     * @param name the name
     * @return the value
     */
    public IRubyObject fetchGlobalConstant(String name) {
<span class="fc" id="L1166">        return objectClass.fetchConstant(name, false);</span>
    }

    public boolean isClassDefined(String name) {
<span class="nc bnc" id="L1170" title="All 2 branches missed.">        return getModule(name) != null;</span>
    }

    /**
     * This method is called immediately after constructing the Ruby instance.
     * The main thread is prepared for execution, all core classes and libraries
     * are initialized, and any libraries required on the command line are
     * loaded.
     */
    private void init() {
        // Construct key services
<span class="fc" id="L1181">        loadService = config.createLoadService(this);</span>
<span class="fc" id="L1182">        posix = POSIXFactory.getPOSIX(new JRubyPOSIXHandler(this), config.isNativeEnabled());</span>
<span class="fc" id="L1183">        javaSupport = new JavaSupport(this);</span>

<span class="fc" id="L1185">        executor = new ThreadPoolExecutor(</span>
                RubyInstanceConfig.POOL_MIN,
                RubyInstanceConfig.POOL_MAX,
                RubyInstanceConfig.POOL_TTL,
                TimeUnit.SECONDS,
                new SynchronousQueue&lt;Runnable&gt;(),
<span class="fc" id="L1191">                new DaemonThreadFactory(&quot;Ruby-&quot; + getRuntimeNumber() + &quot;-Worker&quot;));</span>

<span class="fc" id="L1193">        fiberExecutor = new ThreadPoolExecutor(</span>
                0,
                Integer.MAX_VALUE,
                RubyInstanceConfig.FIBER_POOL_TTL,
                TimeUnit.SECONDS,
                new SynchronousQueue&lt;Runnable&gt;(),
<span class="fc" id="L1199">                new DaemonThreadFactory(&quot;Ruby-&quot; + getRuntimeNumber() + &quot;-Fiber&quot;));</span>

        // initialize the root of the class hierarchy completely
<span class="fc" id="L1202">        initRoot();</span>

        // Set up the main thread in thread service
<span class="fc" id="L1205">        threadService.initMainThread();</span>

        // Get the main threadcontext (gets constructed for us)
<span class="fc" id="L1208">        ThreadContext tc = getCurrentContext();</span>

        // Construct the top-level execution frame and scope for the main thread
<span class="fc" id="L1211">        tc.prepareTopLevel(objectClass, topSelf);</span>

        // Initialize all the core classes
<span class="fc" id="L1214">        bootstrap();</span>

        // set up defined messages
<span class="fc" id="L1217">        initDefinedMessages();</span>

        // set up thread statuses
<span class="fc" id="L1220">        initThreadStatuses();</span>

        // Create an IR manager and a top-level IR scope and bind it to the top-level static-scope object
<span class="fc" id="L1223">        irManager = new IRManager();</span>
        // FIXME: This registers itself into static scope as a side-effect.  Let's make this
        // relationship handled either more directly or through a descriptice method
        // FIXME: We need a failing test case for this since removing it did not regress tests
<span class="fc" id="L1227">        new IRScriptBody(irManager, &quot;&quot;, tc.getCurrentScope().getStaticScope());</span>

        // Initialize the &quot;dummy&quot; class used as a marker
<span class="fc" id="L1230">        dummyClass = new RubyClass(this, classClass);</span>
<span class="fc" id="L1231">        dummyClass.freeze(tc);</span>

        // Create global constants and variables
<span class="fc" id="L1234">        RubyGlobal.createGlobals(tc, this);</span>

        // Prepare LoadService and load path
<span class="fc" id="L1237">        getLoadService().init(config.getLoadPaths());</span>

        // initialize builtin libraries
<span class="fc" id="L1240">        initBuiltins();</span>

        // load JRuby internals, which loads Java support
        // if we can't use reflection, 'jruby' and 'java' won't work; no load.
        boolean reflectionWorks;
        try {
<span class="fc" id="L1246">            ClassLoader.class.getDeclaredMethod(&quot;getResourceAsStream&quot;, String.class);</span>
<span class="fc" id="L1247">            reflectionWorks = true;</span>
<span class="nc" id="L1248">        } catch (Exception e) {</span>
<span class="nc" id="L1249">            reflectionWorks = false;</span>
<span class="fc" id="L1250">        }</span>

<span class="pc bpc" id="L1252" title="2 of 4 branches missed.">        if (!RubyInstanceConfig.DEBUG_PARSER &amp;&amp; reflectionWorks</span>
<span class="pc bpc" id="L1253" title="1 of 2 branches missed.">                &amp;&amp; getInstanceConfig().getCompileMode() != CompileMode.TRUFFLE) {</span>
<span class="fc" id="L1254">            loadService.require(&quot;jruby&quot;);</span>
        }

        // out of base boot mode
<span class="fc" id="L1258">        bootingCore = false;</span>

        // init Ruby-based kernel
<span class="pc bpc" id="L1261" title="1 of 2 branches missed.">        if (getInstanceConfig().getCompileMode() != CompileMode.TRUFFLE) {</span>
<span class="fc" id="L1262">            initRubyKernel();</span>
        }

        // everything booted, so SizedQueue should be available; set up root fiber
<span class="pc bpc" id="L1266" title="1 of 2 branches missed.">        if (getInstanceConfig().getCompileMode() != CompileMode.TRUFFLE) {</span>
<span class="fc" id="L1267">            ThreadFiber.initRootFiber(tc);</span>
        }

<span class="pc bpc" id="L1270" title="1 of 2 branches missed.">        if(config.isProfiling()) {</span>
            // additional twiddling for profiled mode
<span class="nc" id="L1272">            getLoadService().require(&quot;jruby/profiler/shutdown_hook&quot;);</span>

            // recache core methods, since they'll have profiling wrappers now
<span class="nc" id="L1275">            kernelModule.invalidateCacheDescendants(); // to avoid already-cached methods</span>
<span class="nc" id="L1276">            RubyKernel.recacheBuiltinMethods(this);</span>
<span class="nc" id="L1277">            RubyBasicObject.recacheBuiltinMethods(this);</span>
        }

<span class="pc bpc" id="L1280" title="1 of 2 branches missed.">        if (config.getLoadGemfile()) {</span>
<span class="nc" id="L1281">            loadService.loadFromClassLoader(getClassLoader(), &quot;jruby/bundler/startup.rb&quot;, false);</span>
        }

<span class="fc" id="L1284">        setNetworkStack();</span>

        // Done booting JRuby runtime
<span class="fc" id="L1287">        bootingRuntime = false;</span>

        // Require in all libraries specified on command line
<span class="fc bfc" id="L1290" title="All 2 branches covered.">        for (String scriptName : config.getRequiredLibraries()) {</span>
<span class="fc" id="L1291">            topSelf.callMethod(getCurrentContext(), &quot;require&quot;, RubyString.newString(this, scriptName));</span>
<span class="fc" id="L1292">        }</span>
<span class="fc" id="L1293">    }</span>

    private void bootstrap() {
<span class="fc" id="L1296">        initCore();</span>
<span class="fc" id="L1297">        initExceptions();</span>
<span class="fc" id="L1298">    }</span>

    private void initDefinedMessages() {
<span class="fc bfc" id="L1301" title="All 2 branches covered.">        for (DefinedMessage definedMessage : DefinedMessage.values()) {</span>
<span class="fc" id="L1302">            RubyString str = RubyString.newString(this, ByteList.create(definedMessage.getText()));</span>
<span class="fc" id="L1303">            str.setFrozen(true);</span>
<span class="fc" id="L1304">            definedMessages.put(definedMessage, str);</span>
        }
<span class="fc" id="L1306">    }</span>

    private void initThreadStatuses() {
<span class="fc bfc" id="L1309" title="All 2 branches covered.">        for (RubyThread.Status status : RubyThread.Status.values()) {</span>
<span class="fc" id="L1310">            RubyString str = RubyString.newString(this, status.bytes);</span>
<span class="fc" id="L1311">            str.setFrozen(true);</span>
<span class="fc" id="L1312">            threadStatuses.put(status, str);</span>
        }
<span class="fc" id="L1314">    }</span>

    private void initRoot() {
        // Bootstrap the top of the hierarchy
<span class="fc" id="L1318">        basicObjectClass = RubyClass.createBootstrapClass(this, &quot;BasicObject&quot;, null, RubyBasicObject.BASICOBJECT_ALLOCATOR);</span>
<span class="fc" id="L1319">        objectClass = RubyClass.createBootstrapClass(this, &quot;Object&quot;, basicObjectClass, RubyObject.OBJECT_ALLOCATOR);</span>
<span class="fc" id="L1320">        moduleClass = RubyClass.createBootstrapClass(this, &quot;Module&quot;, objectClass, RubyModule.MODULE_ALLOCATOR);</span>
<span class="fc" id="L1321">        classClass = RubyClass.createBootstrapClass(this, &quot;Class&quot;, moduleClass, RubyClass.CLASS_ALLOCATOR);</span>

<span class="fc" id="L1323">        basicObjectClass.setMetaClass(classClass);</span>
<span class="fc" id="L1324">        objectClass.setMetaClass(basicObjectClass);</span>
<span class="fc" id="L1325">        moduleClass.setMetaClass(classClass);</span>
<span class="fc" id="L1326">        classClass.setMetaClass(classClass);</span>

        RubyClass metaClass;
<span class="fc" id="L1329">        metaClass = basicObjectClass.makeMetaClass(classClass);</span>
<span class="fc" id="L1330">        metaClass = objectClass.makeMetaClass(metaClass);</span>
<span class="fc" id="L1331">        metaClass = moduleClass.makeMetaClass(metaClass);</span>
<span class="fc" id="L1332">        metaClass = classClass.makeMetaClass(metaClass);</span>

<span class="fc" id="L1334">        RubyBasicObject.createBasicObjectClass(this, basicObjectClass);</span>
<span class="fc" id="L1335">        RubyObject.createObjectClass(this, objectClass);</span>
<span class="fc" id="L1336">        RubyModule.createModuleClass(this, moduleClass);</span>
<span class="fc" id="L1337">        RubyClass.createClassClass(this, classClass);</span>

        // set constants now that they're initialized
<span class="fc" id="L1340">        basicObjectClass.setConstant(&quot;BasicObject&quot;, basicObjectClass);</span>
<span class="fc" id="L1341">        objectClass.setConstant(&quot;Object&quot;, objectClass);</span>
<span class="fc" id="L1342">        objectClass.setConstant(&quot;Class&quot;, classClass);</span>
<span class="fc" id="L1343">        objectClass.setConstant(&quot;Module&quot;, moduleClass);</span>

        // Initialize Kernel and include into Object
<span class="fc" id="L1346">        RubyModule kernel = RubyKernel.createKernelModule(this);</span>
<span class="fc" id="L1347">        objectClass.includeModule(kernelModule);</span>

        // In 1.9 and later, Kernel.gsub is defined only when '-p' or '-n' is given on the command line
<span class="fc bfc" id="L1350" title="All 2 branches covered.">        if (config.getKernelGsubDefined()) {</span>
<span class="fc" id="L1351">            kernel.addMethod(&quot;gsub&quot;, new JavaMethod(kernel, Visibility.PRIVATE, CallConfiguration.FrameFullScopeNone) {</span>

                @Override
                public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="nc bnc" id="L1355" title="All 3 branches missed.">                    switch (args.length) {</span>
                        case 1:
<span class="nc" id="L1357">                            return RubyKernel.gsub(context, self, args[0], block);</span>
                        case 2:
<span class="nc" id="L1359">                            return RubyKernel.gsub(context, self, args[0], args[1], block);</span>
                        default:
<span class="nc" id="L1361">                            throw newArgumentError(String.format(&quot;wrong number of arguments %d for 1..2&quot;, args.length));</span>
                    }
                }
            });
        }

        // Object is ready, create top self
<span class="fc" id="L1368">        topSelf = TopSelfFactory.createTopSelf(this);</span>

        // Pre-create all the core classes potentially referenced during startup
<span class="fc" id="L1371">        RubyNil.createNilClass(this);</span>
<span class="fc" id="L1372">        RubyBoolean.createFalseClass(this);</span>
<span class="fc" id="L1373">        RubyBoolean.createTrueClass(this);</span>

<span class="fc" id="L1375">        nilObject = new RubyNil(this);</span>
<span class="fc bfc" id="L1376" title="All 2 branches covered.">        for (int i=0; i&lt;NIL_PREFILLED_ARRAY_SIZE; i++) nilPrefilledArray[i] = nilObject;</span>
<span class="fc" id="L1377">        singleNilArray = new IRubyObject[] {nilObject};</span>

<span class="fc" id="L1379">        falseObject = new RubyBoolean.False(this);</span>
<span class="fc" id="L1380">        trueObject = new RubyBoolean.True(this);</span>
<span class="fc" id="L1381">    }</span>

    private void initCore() {
<span class="pc bpc" id="L1384" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Data&quot;)) {</span>
<span class="fc" id="L1385">            defineClass(&quot;Data&quot;, objectClass, ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR);</span>
        }

<span class="fc" id="L1388">        RubyComparable.createComparable(this);</span>
<span class="fc" id="L1389">        RubyEnumerable.createEnumerableModule(this);</span>
<span class="fc" id="L1390">        RubyString.createStringClass(this);</span>

<span class="fc" id="L1392">        encodingService = new EncodingService(this);</span>

<span class="fc" id="L1394">        RubySymbol.createSymbolClass(this);</span>

<span class="fc" id="L1396">        recursiveKey = newSymbol(&quot;__recursive_key__&quot;);</span>

<span class="pc bpc" id="L1398" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;ThreadGroup&quot;)) {</span>
<span class="fc" id="L1399">            RubyThreadGroup.createThreadGroupClass(this);</span>
        }
<span class="pc bpc" id="L1401" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Thread&quot;)) {</span>
<span class="fc" id="L1402">            RubyThread.createThreadClass(this);</span>
        }
<span class="pc bpc" id="L1404" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Exception&quot;)) {</span>
<span class="fc" id="L1405">            RubyException.createExceptionClass(this);</span>
        }

<span class="pc bpc" id="L1408" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Numeric&quot;)) {</span>
<span class="fc" id="L1409">            RubyNumeric.createNumericClass(this);</span>
        }
<span class="pc bpc" id="L1411" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Integer&quot;)) {</span>
<span class="fc" id="L1412">            RubyInteger.createIntegerClass(this);</span>
        }
<span class="pc bpc" id="L1414" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Fixnum&quot;)) {</span>
<span class="fc" id="L1415">            RubyFixnum.createFixnumClass(this);</span>
        }

<span class="fc" id="L1418">        RubyEncoding.createEncodingClass(this);</span>
<span class="fc" id="L1419">        RubyConverter.createConverterClass(this);</span>

<span class="fc" id="L1421">        encodingService.defineEncodings();</span>
<span class="fc" id="L1422">        encodingService.defineAliases();</span>

        // External should always have a value, but Encoding.external_encoding{,=} will lazily setup
<span class="fc" id="L1425">        String encoding = config.getExternalEncoding();</span>
<span class="fc bfc" id="L1426" title="All 4 branches covered.">        if (encoding != null &amp;&amp; !encoding.equals(&quot;&quot;)) {</span>
<span class="fc" id="L1427">            Encoding loadedEncoding = encodingService.loadEncoding(ByteList.create(encoding));</span>
<span class="pc bpc" id="L1428" title="1 of 2 branches missed.">            if (loadedEncoding == null) throw new MainExitException(1, &quot;unknown encoding name - &quot; + encoding);</span>
<span class="fc" id="L1429">            setDefaultExternalEncoding(loadedEncoding);</span>
<span class="fc" id="L1430">        } else {</span>
<span class="fc" id="L1431">            Encoding consoleEncoding = encodingService.getConsoleEncoding();</span>
<span class="pc bpc" id="L1432" title="1 of 2 branches missed.">            Encoding availableEncoding = consoleEncoding == null ? encodingService.getLocaleEncoding() : consoleEncoding;</span>
<span class="fc" id="L1433">            setDefaultExternalEncoding(availableEncoding);</span>
        }

<span class="fc" id="L1436">        encoding = config.getInternalEncoding();</span>
<span class="fc bfc" id="L1437" title="All 4 branches covered.">        if (encoding != null &amp;&amp; !encoding.equals(&quot;&quot;)) {</span>
<span class="fc" id="L1438">            Encoding loadedEncoding = encodingService.loadEncoding(ByteList.create(encoding));</span>
<span class="pc bpc" id="L1439" title="1 of 2 branches missed.">            if (loadedEncoding == null) throw new MainExitException(1, &quot;unknown encoding name - &quot; + encoding);</span>
<span class="fc" id="L1440">            setDefaultInternalEncoding(loadedEncoding);</span>
        }

<span class="pc bpc" id="L1443" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Complex&quot;)) {</span>
<span class="fc" id="L1444">            RubyComplex.createComplexClass(this);</span>
        }
<span class="pc bpc" id="L1446" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Rational&quot;)) {</span>
<span class="fc" id="L1447">            RubyRational.createRationalClass(this);</span>
        }

<span class="pc bpc" id="L1450" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Hash&quot;)) {</span>
<span class="fc" id="L1451">            RubyHash.createHashClass(this);</span>
        }
<span class="pc bpc" id="L1453" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Array&quot;)) {</span>
<span class="fc" id="L1454">            RubyArray.createArrayClass(this);</span>
<span class="fc" id="L1455">            emptyFrozenArray = newEmptyArray();</span>
<span class="fc" id="L1456">            emptyFrozenArray.setFrozen(true);</span>
        }
<span class="pc bpc" id="L1458" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Float&quot;)) {</span>
<span class="fc" id="L1459">            RubyFloat.createFloatClass(this);</span>
        }
<span class="pc bpc" id="L1461" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Bignum&quot;)) {</span>
<span class="fc" id="L1462">            RubyBignum.createBignumClass(this);</span>
            // RubyRandom depends on Bignum existence.
<span class="fc" id="L1464">            RubyRandom.createRandomClass(this);</span>
        }
<span class="fc" id="L1466">        ioClass = RubyIO.createIOClass(this);</span>

<span class="pc bpc" id="L1468" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Struct&quot;)) {</span>
<span class="fc" id="L1469">            RubyStruct.createStructClass(this);</span>
        }
<span class="pc bpc" id="L1471" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Tms&quot;)) {</span>
<span class="fc" id="L1472">            tmsStruct = RubyStruct.newInstance(structClass, new IRubyObject[]{newString(&quot;Tms&quot;), newSymbol(&quot;utime&quot;), newSymbol(&quot;stime&quot;), newSymbol(&quot;cutime&quot;), newSymbol(&quot;cstime&quot;)}, Block.NULL_BLOCK);</span>
        }

<span class="pc bpc" id="L1475" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Binding&quot;)) {</span>
<span class="fc" id="L1476">            RubyBinding.createBindingClass(this);</span>
        }
        // Math depends on all numeric types
<span class="pc bpc" id="L1479" title="1 of 2 branches missed.">        if (profile.allowModule(&quot;Math&quot;)) {</span>
<span class="fc" id="L1480">            RubyMath.createMathModule(this);</span>
        }
<span class="pc bpc" id="L1482" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Regexp&quot;)) {</span>
<span class="fc" id="L1483">            RubyRegexp.createRegexpClass(this);</span>
        }
<span class="pc bpc" id="L1485" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Range&quot;)) {</span>
<span class="fc" id="L1486">            RubyRange.createRangeClass(this);</span>
        }
<span class="pc bpc" id="L1488" title="1 of 2 branches missed.">        if (profile.allowModule(&quot;ObjectSpace&quot;)) {</span>
<span class="fc" id="L1489">            RubyObjectSpace.createObjectSpaceModule(this);</span>
        }
<span class="pc bpc" id="L1491" title="1 of 2 branches missed.">        if (profile.allowModule(&quot;GC&quot;)) {</span>
<span class="fc" id="L1492">            RubyGC.createGCModule(this);</span>
        }
<span class="pc bpc" id="L1494" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Proc&quot;)) {</span>
<span class="fc" id="L1495">            RubyProc.createProcClass(this);</span>
        }
<span class="pc bpc" id="L1497" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Method&quot;)) {</span>
<span class="fc" id="L1498">            RubyMethod.createMethodClass(this);</span>
        }
<span class="pc bpc" id="L1500" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;MatchData&quot;)) {</span>
<span class="fc" id="L1501">            RubyMatchData.createMatchDataClass(this);</span>
        }
<span class="pc bpc" id="L1503" title="1 of 2 branches missed.">        if (profile.allowModule(&quot;Marshal&quot;)) {</span>
<span class="fc" id="L1504">            RubyMarshal.createMarshalModule(this);</span>
        }
<span class="pc bpc" id="L1506" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Dir&quot;)) {</span>
<span class="fc" id="L1507">            RubyDir.createDirClass(this);</span>
        }
<span class="pc bpc" id="L1509" title="1 of 2 branches missed.">        if (profile.allowModule(&quot;FileTest&quot;)) {</span>
<span class="fc" id="L1510">            RubyFileTest.createFileTestModule(this);</span>
        }
        // depends on IO, FileTest
<span class="pc bpc" id="L1513" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;File&quot;)) {</span>
<span class="fc" id="L1514">            RubyFile.createFileClass(this);</span>
        }
<span class="pc bpc" id="L1516" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;File::Stat&quot;)) {</span>
<span class="fc" id="L1517">            RubyFileStat.createFileStatClass(this);</span>
        }
<span class="pc bpc" id="L1519" title="1 of 2 branches missed.">        if (profile.allowModule(&quot;Process&quot;)) {</span>
<span class="fc" id="L1520">            RubyProcess.createProcessModule(this);</span>
        }
<span class="pc bpc" id="L1522" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Time&quot;)) {</span>
<span class="fc" id="L1523">            RubyTime.createTimeClass(this);</span>
        }
<span class="pc bpc" id="L1525" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;UnboundMethod&quot;)) {</span>
<span class="fc" id="L1526">            RubyUnboundMethod.defineUnboundMethodClass(this);</span>
        }
<span class="pc bpc" id="L1528" title="1 of 2 branches missed.">        if (profile.allowModule(&quot;Signal&quot;)) {</span>
<span class="fc" id="L1529">            RubySignal.createSignal(this);</span>
        }
<span class="pc bpc" id="L1531" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Continuation&quot;)) {</span>
<span class="fc" id="L1532">            RubyContinuation.createContinuation(this);</span>
        }

<span class="pc bpc" id="L1535" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;Enumerator&quot;)) {</span>
<span class="fc" id="L1536">            RubyEnumerator.defineEnumerator(this);</span>
        }

        // Fiber depends on thread library, so we load it here
<span class="fc" id="L1540">        new ThreadLibrary().load(this, false);</span>

<span class="fc" id="L1542">        new ThreadFiberLibrary().load(this, false);</span>

<span class="fc" id="L1544">        TracePoint.createTracePointClass(this);</span>
<span class="fc" id="L1545">    }</span>

    public static final int NIL_PREFILLED_ARRAY_SIZE = RubyArray.ARRAY_DEFAULT_SIZE * 8;
<span class="fc" id="L1548">    private final IRubyObject nilPrefilledArray[] = new IRubyObject[NIL_PREFILLED_ARRAY_SIZE];</span>
    public IRubyObject[] getNilPrefilledArray() {
<span class="fc" id="L1550">        return nilPrefilledArray;</span>
    }

    private void initExceptions() {
<span class="fc" id="L1554">        standardError = defineClassIfAllowed(&quot;StandardError&quot;, exceptionClass);</span>
<span class="fc" id="L1555">        runtimeError = defineClassIfAllowed(&quot;RuntimeError&quot;, standardError);</span>
<span class="fc" id="L1556">        ioError = defineClassIfAllowed(&quot;IOError&quot;, standardError);</span>
<span class="fc" id="L1557">        scriptError = defineClassIfAllowed(&quot;ScriptError&quot;, exceptionClass);</span>
<span class="fc" id="L1558">        rangeError = defineClassIfAllowed(&quot;RangeError&quot;, standardError);</span>
<span class="fc" id="L1559">        signalException = defineClassIfAllowed(&quot;SignalException&quot;, exceptionClass);</span>

<span class="pc bpc" id="L1561" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;NameError&quot;)) {</span>
<span class="fc" id="L1562">            nameError = RubyNameError.createNameErrorClass(this, standardError);</span>
<span class="fc" id="L1563">            nameErrorMessage = RubyNameError.createNameErrorMessageClass(this, nameError);</span>
        }
<span class="pc bpc" id="L1565" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;NoMethodError&quot;)) {</span>
<span class="fc" id="L1566">            noMethodError = RubyNoMethodError.createNoMethodErrorClass(this, nameError);</span>
        }
<span class="pc bpc" id="L1568" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;SystemExit&quot;)) {</span>
<span class="fc" id="L1569">            systemExit = RubySystemExit.createSystemExitClass(this, exceptionClass);</span>
        }
<span class="pc bpc" id="L1571" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;LocalJumpError&quot;)) {</span>
<span class="fc" id="L1572">            localJumpError = RubyLocalJumpError.createLocalJumpErrorClass(this, standardError);</span>
        }
<span class="pc bpc" id="L1574" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;NativeException&quot;)) {</span>
<span class="fc" id="L1575">            nativeException = NativeException.createClass(this, runtimeError);</span>
        }
<span class="pc bpc" id="L1577" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;SystemCallError&quot;)) {</span>
<span class="fc" id="L1578">            systemCallError = RubySystemCallError.createSystemCallErrorClass(this, standardError);</span>
        }

<span class="fc" id="L1581">        fatal = defineClassIfAllowed(&quot;Fatal&quot;, exceptionClass);</span>
<span class="fc" id="L1582">        interrupt = defineClassIfAllowed(&quot;Interrupt&quot;, signalException);</span>
<span class="fc" id="L1583">        typeError = defineClassIfAllowed(&quot;TypeError&quot;, standardError);</span>
<span class="fc" id="L1584">        argumentError = defineClassIfAllowed(&quot;ArgumentError&quot;, standardError);</span>
<span class="fc" id="L1585">        indexError = defineClassIfAllowed(&quot;IndexError&quot;, standardError);</span>
<span class="fc" id="L1586">        stopIteration = defineClassIfAllowed(&quot;StopIteration&quot;, indexError);</span>
<span class="fc" id="L1587">        syntaxError = defineClassIfAllowed(&quot;SyntaxError&quot;, scriptError);</span>
<span class="fc" id="L1588">        loadError = defineClassIfAllowed(&quot;LoadError&quot;, scriptError);</span>
<span class="fc" id="L1589">        notImplementedError = defineClassIfAllowed(&quot;NotImplementedError&quot;, scriptError);</span>
<span class="fc" id="L1590">        securityError = defineClassIfAllowed(&quot;SecurityError&quot;, standardError);</span>
<span class="fc" id="L1591">        noMemoryError = defineClassIfAllowed(&quot;NoMemoryError&quot;, exceptionClass);</span>
<span class="fc" id="L1592">        regexpError = defineClassIfAllowed(&quot;RegexpError&quot;, standardError);</span>
<span class="fc" id="L1593">        interruptedRegexpError = defineClassIfAllowed(&quot;InterruptedRegexpError&quot;, regexpError); // Proposal to RubyCommons for interrupting Regexps</span>
<span class="fc" id="L1594">        eofError = defineClassIfAllowed(&quot;EOFError&quot;, ioError);</span>
<span class="fc" id="L1595">        threadError = defineClassIfAllowed(&quot;ThreadError&quot;, standardError);</span>
<span class="fc" id="L1596">        concurrencyError = defineClassIfAllowed(&quot;ConcurrencyError&quot;, threadError);</span>
<span class="fc" id="L1597">        systemStackError = defineClassIfAllowed(&quot;SystemStackError&quot;, exceptionClass);</span>
<span class="fc" id="L1598">        zeroDivisionError = defineClassIfAllowed(&quot;ZeroDivisionError&quot;, standardError);</span>
<span class="fc" id="L1599">        floatDomainError  = defineClassIfAllowed(&quot;FloatDomainError&quot;, rangeError);</span>

<span class="pc bpc" id="L1601" title="1 of 2 branches missed.">        if (profile.allowClass(&quot;EncodingError&quot;)) {</span>
<span class="fc" id="L1602">            encodingError = defineClass(&quot;EncodingError&quot;, standardError, standardError.getAllocator());</span>
<span class="fc" id="L1603">            encodingCompatibilityError = defineClassUnder(&quot;CompatibilityError&quot;, encodingError, encodingError.getAllocator(), encodingClass);</span>
<span class="fc" id="L1604">            invalidByteSequenceError = defineClassUnder(&quot;InvalidByteSequenceError&quot;, encodingError, encodingError.getAllocator(), encodingClass);</span>
<span class="fc" id="L1605">            invalidByteSequenceError.defineAnnotatedMethods(RubyConverter.EncodingErrorMethods.class);</span>
<span class="fc" id="L1606">            invalidByteSequenceError.defineAnnotatedMethods(RubyConverter.InvalidByteSequenceErrorMethods.class);</span>
<span class="fc" id="L1607">            undefinedConversionError = defineClassUnder(&quot;UndefinedConversionError&quot;, encodingError, encodingError.getAllocator(), encodingClass);</span>
<span class="fc" id="L1608">            undefinedConversionError.defineAnnotatedMethods(RubyConverter.EncodingErrorMethods.class);</span>
<span class="fc" id="L1609">            undefinedConversionError.defineAnnotatedMethods(RubyConverter.UndefinedConversionErrorMethods.class);</span>
<span class="fc" id="L1610">            converterNotFoundError = defineClassUnder(&quot;ConverterNotFoundError&quot;, encodingError, encodingError.getAllocator(), encodingClass);</span>
<span class="fc" id="L1611">            fiberError = defineClass(&quot;FiberError&quot;, standardError, standardError.getAllocator());</span>
        }
<span class="fc" id="L1613">        concurrencyError = defineClassIfAllowed(&quot;ConcurrencyError&quot;, threadError);</span>
<span class="fc" id="L1614">        keyError = defineClassIfAllowed(&quot;KeyError&quot;, indexError);</span>

<span class="fc" id="L1616">        mathDomainError = defineClassUnder(&quot;DomainError&quot;, argumentError, argumentError.getAllocator(), mathModule);</span>
<span class="fc" id="L1617">        inRecursiveListOperation.set(false);</span>

<span class="fc" id="L1619">        initErrno();</span>
<span class="fc" id="L1620">    }</span>

    private RubyClass defineClassIfAllowed(String name, RubyClass superClass) {
	// TODO: should probably apply the null object pattern for a
	// non-allowed class, rather than null
<span class="pc bpc" id="L1625" title="2 of 4 branches missed.">        if (superClass != null &amp;&amp; profile.allowClass(name)) {</span>
<span class="fc" id="L1626">            return defineClass(name, superClass, superClass.getAllocator());</span>
        }
<span class="nc" id="L1628">        return null;</span>
    }

<span class="fc" id="L1631">    private Map&lt;Integer, RubyClass&gt; errnos = new HashMap&lt;Integer, RubyClass&gt;();</span>

    public RubyClass getErrno(int n) {
<span class="fc" id="L1634">        return errnos.get(n);</span>
    }

    /**
     * Create module Errno's Variables.  We have this method since Errno does not have it's
     * own java class.
     */
    private void initErrno() {
<span class="pc bpc" id="L1642" title="1 of 2 branches missed.">        if (profile.allowModule(&quot;Errno&quot;)) {</span>
<span class="fc" id="L1643">            errnoModule = defineModule(&quot;Errno&quot;);</span>
            try {
                // define EAGAIN now, so that future EWOULDBLOCK will alias to it
                // see MRI's error.c and its explicit ordering of Errno definitions.
<span class="fc" id="L1647">                createSysErr(Errno.EAGAIN.intValue(), Errno.EAGAIN.name());</span>

<span class="fc bfc" id="L1649" title="All 2 branches covered.">                for (Errno e : Errno.values()) {</span>
<span class="fc" id="L1650">                    Constant c = (Constant) e;</span>
<span class="fc bfc" id="L1651" title="All 2 branches covered.">                    if (Character.isUpperCase(c.name().charAt(0))) {</span>
<span class="fc" id="L1652">                        createSysErr(c.intValue(), c.name());</span>
                    }
                }

                // map ENOSYS to NotImplementedError
<span class="fc" id="L1657">                errnos.put(Errno.ENOSYS.intValue(), notImplementedError);</span>
<span class="nc" id="L1658">            } catch (Exception e) {</span>
                // dump the trace and continue
                // this is currently only here for Android, which seems to have
                // bugs in its enumeration logic
                // http://code.google.com/p/android/issues/detail?id=2812
<span class="nc" id="L1663">                LOG.error(e.getMessage(), e);</span>
<span class="fc" id="L1664">            }</span>
        }
<span class="fc" id="L1666">    }</span>

    /**
     * Creates a system error.
     * @param i the error code (will probably use a java exception instead)
     * @param name of the error to define.
     **/
    private void createSysErr(int i, String name) {
<span class="pc bpc" id="L1674" title="1 of 2 branches missed.">        if(profile.allowClass(name)) {</span>
<span class="fc bfc" id="L1675" title="All 2 branches covered.">            if (errnos.get(i) == null) {</span>
<span class="fc" id="L1676">                RubyClass errno = getErrno().defineClassUnder(name, systemCallError, systemCallError.getAllocator());</span>
<span class="fc" id="L1677">                errnos.put(i, errno);</span>
<span class="fc" id="L1678">                errno.defineConstant(&quot;Errno&quot;, newFixnum(i));</span>
<span class="fc" id="L1679">            } else {</span>
                // already defined a class for this errno, reuse it (JRUBY-4747)
<span class="fc" id="L1681">                getErrno().setConstant(name, errnos.get(i));</span>
            }
        }
<span class="fc" id="L1684">    }</span>

    private void initBuiltins() {
        // We cannot load any .rb and debug new parser features
<span class="pc bpc" id="L1688" title="1 of 2 branches missed.">        if (RubyInstanceConfig.DEBUG_PARSER) return;</span>

<span class="fc" id="L1690">        addLazyBuiltin(&quot;java.rb&quot;, &quot;java&quot;, &quot;org.jruby.javasupport.Java&quot;);</span>
<span class="fc" id="L1691">        addLazyBuiltin(&quot;jruby.rb&quot;, &quot;jruby&quot;, &quot;org.jruby.ext.jruby.JRubyLibrary&quot;);</span>
<span class="fc" id="L1692">        addLazyBuiltin(&quot;jruby/util.rb&quot;, &quot;jruby/util&quot;, &quot;org.jruby.ext.jruby.JRubyUtilLibrary&quot;);</span>
<span class="fc" id="L1693">        addLazyBuiltin(&quot;jruby/type.rb&quot;, &quot;jruby/type&quot;, &quot;org.jruby.ext.jruby.JRubyTypeLibrary&quot;);</span>
<span class="fc" id="L1694">        addLazyBuiltin(&quot;nkf.jar&quot;, &quot;nkf&quot;, &quot;org.jruby.ext.nkf.NKFLibrary&quot;);</span>
<span class="fc" id="L1695">        addLazyBuiltin(&quot;stringio.jar&quot;, &quot;stringio&quot;, &quot;org.jruby.ext.stringio.StringIOLibrary&quot;);</span>
<span class="fc" id="L1696">        addLazyBuiltin(&quot;strscan.jar&quot;, &quot;strscan&quot;, &quot;org.jruby.ext.strscan.StringScannerLibrary&quot;);</span>
<span class="fc" id="L1697">        addLazyBuiltin(&quot;zlib.jar&quot;, &quot;zlib&quot;, &quot;org.jruby.ext.zlib.ZlibLibrary&quot;);</span>
<span class="fc" id="L1698">        addLazyBuiltin(&quot;thread.jar&quot;, &quot;thread&quot;, &quot;org.jruby.ext.thread.ThreadLibrary&quot;);</span>
<span class="fc" id="L1699">        addLazyBuiltin(&quot;thread.rb&quot;, &quot;thread&quot;, &quot;org.jruby.ext.thread.ThreadLibrary&quot;);</span>
<span class="fc" id="L1700">        addLazyBuiltin(&quot;digest.jar&quot;, &quot;digest.so&quot;, &quot;org.jruby.ext.digest.DigestLibrary&quot;);</span>
<span class="fc" id="L1701">        addLazyBuiltin(&quot;digest/md5.jar&quot;, &quot;digest/md5&quot;, &quot;org.jruby.ext.digest.MD5&quot;);</span>
<span class="fc" id="L1702">        addLazyBuiltin(&quot;digest/rmd160.jar&quot;, &quot;digest/rmd160&quot;, &quot;org.jruby.ext.digest.RMD160&quot;);</span>
<span class="fc" id="L1703">        addLazyBuiltin(&quot;digest/sha1.jar&quot;, &quot;digest/sha1&quot;, &quot;org.jruby.ext.digest.SHA1&quot;);</span>
<span class="fc" id="L1704">        addLazyBuiltin(&quot;digest/sha2.jar&quot;, &quot;digest/sha2&quot;, &quot;org.jruby.ext.digest.SHA2&quot;);</span>
<span class="fc" id="L1705">        addLazyBuiltin(&quot;bigdecimal.jar&quot;, &quot;bigdecimal&quot;, &quot;org.jruby.ext.bigdecimal.BigDecimalLibrary&quot;);</span>
<span class="fc" id="L1706">        addLazyBuiltin(&quot;io/wait.jar&quot;, &quot;io/wait&quot;, &quot;org.jruby.ext.io.wait.IOWaitLibrary&quot;);</span>
<span class="fc" id="L1707">        addLazyBuiltin(&quot;etc.jar&quot;, &quot;etc&quot;, &quot;org.jruby.ext.etc.EtcLibrary&quot;);</span>
<span class="fc" id="L1708">        addLazyBuiltin(&quot;weakref.rb&quot;, &quot;weakref&quot;, &quot;org.jruby.ext.weakref.WeakRefLibrary&quot;);</span>
<span class="fc" id="L1709">        addLazyBuiltin(&quot;native_delegate.jar&quot;, &quot;native_delegate&quot;, &quot;org.jruby.ext.delegate.NativeDelegateLibrary&quot;);</span>
<span class="fc" id="L1710">        addLazyBuiltin(&quot;timeout.rb&quot;, &quot;timeout&quot;, &quot;org.jruby.ext.timeout.Timeout&quot;);</span>
<span class="fc" id="L1711">        addLazyBuiltin(&quot;socket.jar&quot;, &quot;socket&quot;, &quot;org.jruby.ext.socket.SocketLibrary&quot;);</span>
<span class="fc" id="L1712">        addLazyBuiltin(&quot;rbconfig.rb&quot;, &quot;rbconfig&quot;, &quot;org.jruby.ext.rbconfig.RbConfigLibrary&quot;);</span>
<span class="fc" id="L1713">        addLazyBuiltin(&quot;jruby/serialization.rb&quot;, &quot;serialization&quot;, &quot;org.jruby.ext.jruby.JRubySerializationLibrary&quot;);</span>
<span class="fc" id="L1714">        addLazyBuiltin(&quot;ffi-internal.jar&quot;, &quot;ffi-internal&quot;, &quot;org.jruby.ext.ffi.FFIService&quot;);</span>
<span class="fc" id="L1715">        addLazyBuiltin(&quot;tempfile.jar&quot;, &quot;tempfile&quot;, &quot;org.jruby.ext.tempfile.TempfileLibrary&quot;);</span>
<span class="fc" id="L1716">        addLazyBuiltin(&quot;fcntl.rb&quot;, &quot;fcntl&quot;, &quot;org.jruby.ext.fcntl.FcntlLibrary&quot;);</span>
<span class="fc" id="L1717">        addLazyBuiltin(&quot;yecht.jar&quot;, &quot;yecht&quot;, &quot;YechtService&quot;);</span>
<span class="fc" id="L1718">        addLazyBuiltin(&quot;pathname.jar&quot;, &quot;pathname&quot;, &quot;org.jruby.ext.pathname.PathnameLibrary&quot;);</span>

<span class="fc" id="L1720">        addLazyBuiltin(&quot;mathn/complex.jar&quot;, &quot;mathn/complex&quot;, &quot;org.jruby.ext.mathn.Complex&quot;);</span>
<span class="fc" id="L1721">        addLazyBuiltin(&quot;mathn/rational.jar&quot;, &quot;mathn/rational&quot;, &quot;org.jruby.ext.mathn.Rational&quot;);</span>
<span class="fc" id="L1722">        addLazyBuiltin(&quot;psych.jar&quot;, &quot;psych&quot;, &quot;org.jruby.ext.psych.PsychLibrary&quot;);</span>
<span class="fc" id="L1723">        addLazyBuiltin(&quot;coverage.jar&quot;, &quot;coverage&quot;, &quot;org.jruby.ext.coverage.CoverageLibrary&quot;);</span>

        // TODO: implement something for these?
<span class="fc" id="L1726">        addBuiltinIfAllowed(&quot;continuation.rb&quot;, Library.DUMMY);</span>
<span class="fc" id="L1727">        addBuiltinIfAllowed(&quot;io/nonblock.rb&quot;, Library.DUMMY);</span>

        // for backward compatibility
<span class="fc" id="L1730">        loadService.provide(&quot;enumerator.jar&quot;); // can't be in RubyEnumerator because LoadService isn't ready then</span>
<span class="fc" id="L1731">        loadService.provide(&quot;rational.jar&quot;);</span>
<span class="fc" id="L1732">        loadService.provide(&quot;complex.jar&quot;);</span>

        // we define the classes at boot because we need them
<span class="fc" id="L1735">        addBuiltinIfAllowed(&quot;thread.rb&quot;, Library.DUMMY);</span>

<span class="pc bpc" id="L1737" title="1 of 2 branches missed.">        if(RubyInstanceConfig.NATIVE_NET_PROTOCOL) {</span>
<span class="nc" id="L1738">            addLazyBuiltin(&quot;net/protocol.rb&quot;, &quot;net/protocol&quot;, &quot;org.jruby.ext.net.protocol.NetProtocolBufferedIOLibrary&quot;);</span>
        }

<span class="fc" id="L1741">        addBuiltinIfAllowed(&quot;win32ole.jar&quot;, new Library() {</span>
            public void load(Ruby runtime, boolean wrap) throws IOException {
<span class="nc" id="L1743">                runtime.getLoadService().require(&quot;jruby/win32ole/stub&quot;);</span>
<span class="nc" id="L1744">            }</span>
        });
<span class="fc" id="L1746">    }</span>

    private void initRubyKernel() {
        // We cannot load any .rb and debug new parser features
<span class="pc bpc" id="L1750" title="1 of 2 branches missed.">        if (RubyInstanceConfig.DEBUG_PARSER) return;</span>

        // load Ruby parts of core
<span class="fc" id="L1753">        loadService.loadFromClassLoader(getClassLoader(), &quot;jruby/kernel.rb&quot;, false);</span>
<span class="fc" id="L1754">    }</span>

    private void addLazyBuiltin(String name, String shortName, String className) {
<span class="fc" id="L1757">        addBuiltinIfAllowed(name, new LateLoadingLibrary(shortName, className, getClassLoader()));</span>
<span class="fc" id="L1758">    }</span>

    private void addBuiltinIfAllowed(String name, Library lib) {
<span class="pc bpc" id="L1761" title="1 of 2 branches missed.">        if(profile.allowBuiltin(name)) {</span>
<span class="fc" id="L1762">            loadService.addBuiltinLibrary(name,lib);</span>
        }
<span class="fc" id="L1764">    }</span>

    public IRManager getIRManager() {
<span class="fc" id="L1767">        return irManager;</span>
    }

    /** Getter for property rubyTopSelf.
     * @return Value of property rubyTopSelf.
     */
    public IRubyObject getTopSelf() {
<span class="fc" id="L1774">        return topSelf;</span>
    }

    public IRubyObject getRootFiber() {
<span class="nc" id="L1778">        return rootFiber;</span>
    }

    public void setRootFiber(IRubyObject fiber) {
<span class="nc" id="L1782">        rootFiber = fiber;</span>
<span class="nc" id="L1783">    }</span>

    public void setCurrentDirectory(String dir) {
<span class="fc" id="L1786">        currentDirectory = dir;</span>
<span class="fc" id="L1787">    }</span>

    public String getCurrentDirectory() {
<span class="fc" id="L1790">        return currentDirectory;</span>
    }

    public void setCurrentLine(int line) {
<span class="fc" id="L1794">        currentLine = line;</span>
<span class="fc" id="L1795">    }</span>

    public int getCurrentLine() {
<span class="fc" id="L1798">        return currentLine;</span>
    }

    public void setArgsFile(IRubyObject argsFile) {
<span class="fc" id="L1802">        this.argsFile = argsFile;</span>
<span class="fc" id="L1803">    }</span>

    public IRubyObject getArgsFile() {
<span class="fc" id="L1806">        return argsFile;</span>
    }

    public RubyModule getEtc() {
<span class="fc" id="L1810">        return etcModule;</span>
    }

    public void setEtc(RubyModule etcModule) {
<span class="fc" id="L1814">        this.etcModule = etcModule;</span>
<span class="fc" id="L1815">    }</span>

    public RubyClass getObject() {
<span class="fc" id="L1818">        return objectClass;</span>
    }

    public RubyClass getBasicObject() {
<span class="fc" id="L1822">        return basicObjectClass;</span>
    }

    public RubyClass getModule() {
<span class="fc" id="L1826">        return moduleClass;</span>
    }

    public RubyClass getClassClass() {
<span class="fc" id="L1830">        return classClass;</span>
    }

    public RubyModule getKernel() {
<span class="fc" id="L1834">        return kernelModule;</span>
    }
    void setKernel(RubyModule kernelModule) {
<span class="fc" id="L1837">        this.kernelModule = kernelModule;</span>
<span class="fc" id="L1838">    }</span>

    ///////////////////////////////////////////////////////////////////////////
    // Cached DynamicMethod objects, used for direct dispatch or for short
    // circuiting dynamic invocation logic.
    ///////////////////////////////////////////////////////////////////////////

    public DynamicMethod getPrivateMethodMissing() {
<span class="fc" id="L1846">        return privateMethodMissing;</span>
    }

    public void setPrivateMethodMissing(DynamicMethod method) {
<span class="fc" id="L1850">        privateMethodMissing = method;</span>
<span class="fc" id="L1851">    }</span>

    public DynamicMethod getProtectedMethodMissing() {
<span class="fc" id="L1854">        return protectedMethodMissing;</span>
    }

    public void setProtectedMethodMissing(DynamicMethod method) {
<span class="fc" id="L1858">        protectedMethodMissing = method;</span>
<span class="fc" id="L1859">    }</span>

    public DynamicMethod getVariableMethodMissing() {
<span class="fc" id="L1862">        return variableMethodMissing;</span>
    }

    public void setVariableMethodMissing(DynamicMethod method) {
<span class="fc" id="L1866">        variableMethodMissing = method;</span>
<span class="fc" id="L1867">    }</span>

    public DynamicMethod getSuperMethodMissing() {
<span class="fc" id="L1870">        return superMethodMissing;</span>
    }

    public void setSuperMethodMissing(DynamicMethod method) {
<span class="fc" id="L1874">        superMethodMissing = method;</span>
<span class="fc" id="L1875">    }</span>

    public DynamicMethod getNormalMethodMissing() {
<span class="fc" id="L1878">        return normalMethodMissing;</span>
    }

    public void setNormalMethodMissing(DynamicMethod method) {
<span class="fc" id="L1882">        normalMethodMissing = method;</span>
<span class="fc" id="L1883">    }</span>

    public DynamicMethod getDefaultMethodMissing() {
<span class="fc" id="L1886">        return defaultMethodMissing;</span>
    }

    public void setDefaultMethodMissing(DynamicMethod method) {
<span class="fc" id="L1890">        defaultMethodMissing = method;</span>
<span class="fc" id="L1891">    }</span>

    public DynamicMethod getRespondToMethod() {
<span class="fc" id="L1894">        return respondTo;</span>
    }

    public void setRespondToMethod(DynamicMethod rtm) {
<span class="fc" id="L1898">        this.respondTo = rtm;</span>
<span class="fc" id="L1899">    }</span>

    public DynamicMethod getRespondToMissingMethod() {
<span class="fc" id="L1902">        return respondToMissing;</span>
    }

    public void setRespondToMissingMethod(DynamicMethod rtmm) {
<span class="fc" id="L1906">        this.respondToMissing = rtmm;</span>
<span class="fc" id="L1907">    }</span>

    public RubyClass getDummy() {
<span class="fc" id="L1910">        return dummyClass;</span>
    }

    public RubyModule getComparable() {
<span class="fc" id="L1914">        return comparableModule;</span>
    }
    void setComparable(RubyModule comparableModule) {
<span class="fc" id="L1917">        this.comparableModule = comparableModule;</span>
<span class="fc" id="L1918">    }</span>

    public RubyClass getNumeric() {
<span class="fc" id="L1921">        return numericClass;</span>
    }
    void setNumeric(RubyClass numericClass) {
<span class="fc" id="L1924">        this.numericClass = numericClass;</span>
<span class="fc" id="L1925">    }</span>

    public RubyClass getFloat() {
<span class="fc" id="L1928">        return floatClass;</span>
    }
    void setFloat(RubyClass floatClass) {
<span class="fc" id="L1931">        this.floatClass = floatClass;</span>
<span class="fc" id="L1932">    }</span>

    public RubyClass getInteger() {
<span class="fc" id="L1935">        return integerClass;</span>
    }
    void setInteger(RubyClass integerClass) {
<span class="fc" id="L1938">        this.integerClass = integerClass;</span>
<span class="fc" id="L1939">    }</span>

    public RubyClass getFixnum() {
<span class="fc" id="L1942">        return fixnumClass;</span>
    }
    void setFixnum(RubyClass fixnumClass) {
<span class="fc" id="L1945">        this.fixnumClass = fixnumClass;</span>
<span class="fc" id="L1946">    }</span>

    public RubyClass getComplex() {
<span class="fc" id="L1949">        return complexClass;</span>
    }
    void setComplex(RubyClass complexClass) {
<span class="fc" id="L1952">        this.complexClass = complexClass;</span>
<span class="fc" id="L1953">    }</span>

    public RubyClass getRational() {
<span class="fc" id="L1956">        return rationalClass;</span>
    }
    void setRational(RubyClass rationalClass) {
<span class="fc" id="L1959">        this.rationalClass = rationalClass;</span>
<span class="fc" id="L1960">    }</span>

    public RubyModule getEnumerable() {
<span class="fc" id="L1963">        return enumerableModule;</span>
    }
    void setEnumerable(RubyModule enumerableModule) {
<span class="fc" id="L1966">        this.enumerableModule = enumerableModule;</span>
<span class="fc" id="L1967">    }</span>

    public RubyClass getEnumerator() {
<span class="fc" id="L1970">        return enumeratorClass;</span>
    }
    void setEnumerator(RubyClass enumeratorClass) {
<span class="fc" id="L1973">        this.enumeratorClass = enumeratorClass;</span>
<span class="fc" id="L1974">    }</span>

    public RubyClass getYielder() {
<span class="fc" id="L1977">        return yielderClass;</span>
    }
    void setYielder(RubyClass yielderClass) {
<span class="fc" id="L1980">        this.yielderClass = yielderClass;</span>
<span class="fc" id="L1981">    }</span>

    public RubyClass getGenerator() {
<span class="fc" id="L1984">        return generatorClass;</span>
    }
    public void setGenerator(RubyClass generatorClass) {
<span class="fc" id="L1987">        this.generatorClass = generatorClass;</span>
<span class="fc" id="L1988">    }</span>

    public RubyClass getFiber() {
<span class="nc" id="L1991">        return fiberClass;</span>
    }
    public void setFiber(RubyClass fiberClass) {
<span class="fc" id="L1994">        this.fiberClass = fiberClass;</span>
<span class="fc" id="L1995">    }</span>

    public RubyClass getString() {
<span class="fc" id="L1998">        return stringClass;</span>
    }
    void setString(RubyClass stringClass) {
<span class="fc" id="L2001">        this.stringClass = stringClass;</span>
<span class="fc" id="L2002">    }</span>

    public RubyClass getEncoding() {
<span class="fc" id="L2005">        return encodingClass;</span>
    }
    void setEncoding(RubyClass encodingClass) {
<span class="fc" id="L2008">        this.encodingClass = encodingClass;</span>
<span class="fc" id="L2009">    }</span>

    public RubyClass getConverter() {
<span class="nc" id="L2012">        return converterClass;</span>
    }
    void setConverter(RubyClass converterClass) {
<span class="fc" id="L2015">        this.converterClass = converterClass;</span>
<span class="fc" id="L2016">    }</span>

    public RubyClass getSymbol() {
<span class="fc" id="L2019">        return symbolClass;</span>
    }
    void setSymbol(RubyClass symbolClass) {
<span class="fc" id="L2022">        this.symbolClass = symbolClass;</span>
<span class="fc" id="L2023">    }</span>

    public RubyClass getArray() {
<span class="fc" id="L2026">        return arrayClass;</span>
    }
    void setArray(RubyClass arrayClass) {
<span class="fc" id="L2029">        this.arrayClass = arrayClass;</span>
<span class="fc" id="L2030">    }</span>

    public RubyClass getHash() {
<span class="fc" id="L2033">        return hashClass;</span>
    }
    void setHash(RubyClass hashClass) {
<span class="fc" id="L2036">        this.hashClass = hashClass;</span>
<span class="fc" id="L2037">    }</span>

    public RubyClass getRange() {
<span class="fc" id="L2040">        return rangeClass;</span>
    }
    void setRange(RubyClass rangeClass) {
<span class="fc" id="L2043">        this.rangeClass = rangeClass;</span>
<span class="fc" id="L2044">    }</span>

    /** Returns the &quot;true&quot; instance from the instance pool.
     * @return The &quot;true&quot; instance.
     */
    public RubyBoolean getTrue() {
<span class="fc" id="L2050">        return trueObject;</span>
    }

    /** Returns the &quot;false&quot; instance from the instance pool.
     * @return The &quot;false&quot; instance.
     */
    public RubyBoolean getFalse() {
<span class="fc" id="L2057">        return falseObject;</span>
    }

    /** Returns the &quot;nil&quot; singleton instance.
     * @return &quot;nil&quot;
     */
    public IRubyObject getNil() {
<span class="fc" id="L2064">        return nilObject;</span>
    }

    public IRubyObject[] getSingleNilArray() {
<span class="nc" id="L2068">        return singleNilArray;</span>
    }

    public RubyClass getNilClass() {
<span class="fc" id="L2072">        return nilClass;</span>
    }
    void setNilClass(RubyClass nilClass) {
<span class="fc" id="L2075">        this.nilClass = nilClass;</span>
<span class="fc" id="L2076">    }</span>

    public RubyClass getTrueClass() {
<span class="fc" id="L2079">        return trueClass;</span>
    }
    void setTrueClass(RubyClass trueClass) {
<span class="fc" id="L2082">        this.trueClass = trueClass;</span>
<span class="fc" id="L2083">    }</span>

    public RubyClass getFalseClass() {
<span class="fc" id="L2086">        return falseClass;</span>
    }
    void setFalseClass(RubyClass falseClass) {
<span class="fc" id="L2089">        this.falseClass = falseClass;</span>
<span class="fc" id="L2090">    }</span>

    public RubyClass getProc() {
<span class="fc" id="L2093">        return procClass;</span>
    }
    void setProc(RubyClass procClass) {
<span class="fc" id="L2096">        this.procClass = procClass;</span>
<span class="fc" id="L2097">    }</span>

    public RubyClass getBinding() {
<span class="fc" id="L2100">        return bindingClass;</span>
    }
    void setBinding(RubyClass bindingClass) {
<span class="fc" id="L2103">        this.bindingClass = bindingClass;</span>
<span class="fc" id="L2104">    }</span>

    public RubyClass getMethod() {
<span class="fc" id="L2107">        return methodClass;</span>
    }
    void setMethod(RubyClass methodClass) {
<span class="fc" id="L2110">        this.methodClass = methodClass;</span>
<span class="fc" id="L2111">    }</span>

    public RubyClass getUnboundMethod() {
<span class="fc" id="L2114">        return unboundMethodClass;</span>
    }
    void setUnboundMethod(RubyClass unboundMethodClass) {
<span class="fc" id="L2117">        this.unboundMethodClass = unboundMethodClass;</span>
<span class="fc" id="L2118">    }</span>

    public RubyClass getMatchData() {
<span class="fc" id="L2121">        return matchDataClass;</span>
    }
    void setMatchData(RubyClass matchDataClass) {
<span class="fc" id="L2124">        this.matchDataClass = matchDataClass;</span>
<span class="fc" id="L2125">    }</span>

    public RubyClass getRegexp() {
<span class="fc" id="L2128">        return regexpClass;</span>
    }
    void setRegexp(RubyClass regexpClass) {
<span class="fc" id="L2131">        this.regexpClass = regexpClass;</span>
<span class="fc" id="L2132">    }</span>

    public RubyClass getTime() {
<span class="fc" id="L2135">        return timeClass;</span>
    }
    void setTime(RubyClass timeClass) {
<span class="fc" id="L2138">        this.timeClass = timeClass;</span>
<span class="fc" id="L2139">    }</span>

    public RubyModule getMath() {
<span class="fc" id="L2142">        return mathModule;</span>
    }
    void setMath(RubyModule mathModule) {
<span class="fc" id="L2145">        this.mathModule = mathModule;</span>
<span class="fc" id="L2146">    }</span>

    public RubyModule getMarshal() {
<span class="nc" id="L2149">        return marshalModule;</span>
    }
    void setMarshal(RubyModule marshalModule) {
<span class="fc" id="L2152">        this.marshalModule = marshalModule;</span>
<span class="fc" id="L2153">    }</span>

    public RubyClass getBignum() {
<span class="fc" id="L2156">        return bignumClass;</span>
    }
    void setBignum(RubyClass bignumClass) {
<span class="fc" id="L2159">        this.bignumClass = bignumClass;</span>
<span class="fc" id="L2160">    }</span>

    public RubyClass getDir() {
<span class="fc" id="L2163">        return dirClass;</span>
    }
    void setDir(RubyClass dirClass) {
<span class="fc" id="L2166">        this.dirClass = dirClass;</span>
<span class="fc" id="L2167">    }</span>

    public RubyClass getFile() {
<span class="fc" id="L2170">        return fileClass;</span>
    }
    void setFile(RubyClass fileClass) {
<span class="fc" id="L2173">        this.fileClass = fileClass;</span>
<span class="fc" id="L2174">    }</span>

    public RubyClass getFileStat() {
<span class="fc" id="L2177">        return fileStatClass;</span>
    }
    void setFileStat(RubyClass fileStatClass) {
<span class="fc" id="L2180">        this.fileStatClass = fileStatClass;</span>
<span class="fc" id="L2181">    }</span>

    public RubyModule getFileTest() {
<span class="nc" id="L2184">        return fileTestModule;</span>
    }
    void setFileTest(RubyModule fileTestModule) {
<span class="fc" id="L2187">        this.fileTestModule = fileTestModule;</span>
<span class="fc" id="L2188">    }</span>

    public RubyClass getIO() {
<span class="fc" id="L2191">        return ioClass;</span>
    }
    void setIO(RubyClass ioClass) {
<span class="nc" id="L2194">        this.ioClass = ioClass;</span>
<span class="nc" id="L2195">    }</span>

    public RubyClass getThread() {
<span class="fc" id="L2198">        return threadClass;</span>
    }
    void setThread(RubyClass threadClass) {
<span class="fc" id="L2201">        this.threadClass = threadClass;</span>
<span class="fc" id="L2202">    }</span>

    public RubyClass getThreadGroup() {
<span class="nc" id="L2205">        return threadGroupClass;</span>
    }
    void setThreadGroup(RubyClass threadGroupClass) {
<span class="fc" id="L2208">        this.threadGroupClass = threadGroupClass;</span>
<span class="fc" id="L2209">    }</span>

    public RubyThreadGroup getDefaultThreadGroup() {
<span class="fc" id="L2212">        return defaultThreadGroup;</span>
    }
    void setDefaultThreadGroup(RubyThreadGroup defaultThreadGroup) {
<span class="fc" id="L2215">        this.defaultThreadGroup = defaultThreadGroup;</span>
<span class="fc" id="L2216">    }</span>

    public RubyClass getContinuation() {
<span class="fc" id="L2219">        return continuationClass;</span>
    }
    void setContinuation(RubyClass continuationClass) {
<span class="fc" id="L2222">        this.continuationClass = continuationClass;</span>
<span class="fc" id="L2223">    }</span>

    public RubyClass getStructClass() {
<span class="fc" id="L2226">        return structClass;</span>
    }
    void setStructClass(RubyClass structClass) {
<span class="fc" id="L2229">        this.structClass = structClass;</span>
<span class="fc" id="L2230">    }</span>

    public RubyClass getRandomClass() {
<span class="fc" id="L2233">        return randomClass;</span>
    }
    void setRandomClass(RubyClass randomClass) {
<span class="fc" id="L2236">        this.randomClass = randomClass;</span>
<span class="fc" id="L2237">    }</span>

    public IRubyObject getTmsStruct() {
<span class="fc" id="L2240">        return tmsStruct;</span>
    }
    void setTmsStruct(RubyClass tmsStruct) {
<span class="nc" id="L2243">        this.tmsStruct = tmsStruct;</span>
<span class="nc" id="L2244">    }</span>

    public IRubyObject getPasswdStruct() {
<span class="fc" id="L2247">        return passwdStruct;</span>
    }
    public void setPasswdStruct(RubyClass passwdStruct) {
<span class="fc" id="L2250">        this.passwdStruct = passwdStruct;</span>
<span class="fc" id="L2251">    }</span>

    public IRubyObject getGroupStruct() {
<span class="fc" id="L2254">        return groupStruct;</span>
    }
    public void setGroupStruct(RubyClass groupStruct) {
<span class="fc" id="L2257">        this.groupStruct = groupStruct;</span>
<span class="fc" id="L2258">    }</span>

    public RubyModule getGC() {
<span class="nc" id="L2261">        return gcModule;</span>
    }
    void setGC(RubyModule gcModule) {
<span class="fc" id="L2264">        this.gcModule = gcModule;</span>
<span class="fc" id="L2265">    }</span>

    public RubyModule getObjectSpaceModule() {
<span class="fc" id="L2268">        return objectSpaceModule;</span>
    }
    void setObjectSpaceModule(RubyModule objectSpaceModule) {
<span class="fc" id="L2271">        this.objectSpaceModule = objectSpaceModule;</span>
<span class="fc" id="L2272">    }</span>

    public RubyModule getProcess() {
<span class="nc" id="L2275">        return processModule;</span>
    }
    void setProcess(RubyModule processModule) {
<span class="fc" id="L2278">        this.processModule = processModule;</span>
<span class="fc" id="L2279">    }</span>

    public RubyClass getProcStatus() {
<span class="fc" id="L2282">        return procStatusClass;</span>
    }
    void setProcStatus(RubyClass procStatusClass) {
<span class="fc" id="L2285">        this.procStatusClass = procStatusClass;</span>
<span class="fc" id="L2286">    }</span>

    public RubyModule getProcUID() {
<span class="nc" id="L2289">        return procUIDModule;</span>
    }
    void setProcUID(RubyModule procUIDModule) {
<span class="fc" id="L2292">        this.procUIDModule = procUIDModule;</span>
<span class="fc" id="L2293">    }</span>

    public RubyModule getProcGID() {
<span class="nc" id="L2296">        return procGIDModule;</span>
    }
    void setProcGID(RubyModule procGIDModule) {
<span class="fc" id="L2299">        this.procGIDModule = procGIDModule;</span>
<span class="fc" id="L2300">    }</span>

    public RubyModule getProcSysModule() {
<span class="nc" id="L2303">        return procSysModule;</span>
    }
    void setProcSys(RubyModule procSysModule) {
<span class="fc" id="L2306">        this.procSysModule = procSysModule;</span>
<span class="fc" id="L2307">    }</span>

    public RubyModule getPrecision() {
<span class="nc" id="L2310">        return precisionModule;</span>
    }
    void setPrecision(RubyModule precisionModule) {
<span class="nc" id="L2313">        this.precisionModule = precisionModule;</span>
<span class="nc" id="L2314">    }</span>

    public RubyHash getENV() {
<span class="fc" id="L2317">        return envObject;</span>
    }

    public void setENV(RubyHash env) {
<span class="fc" id="L2321">        envObject = env;</span>
<span class="fc" id="L2322">    }</span>

    public RubyClass getLocation() {
<span class="nc" id="L2325">        return locationClass;</span>
    }

    public void setLocation(RubyClass location) {
<span class="fc" id="L2329">        this.locationClass = location;</span>
<span class="fc" id="L2330">    }</span>

    public RubyModule getErrno() {
<span class="fc" id="L2333">        return errnoModule;</span>
    }

    public RubyClass getException() {
<span class="fc" id="L2337">        return exceptionClass;</span>
    }
    void setException(RubyClass exceptionClass) {
<span class="fc" id="L2340">        this.exceptionClass = exceptionClass;</span>
<span class="fc" id="L2341">    }</span>

    public RubyClass getNameError() {
<span class="fc" id="L2344">        return nameError;</span>
    }

    public RubyClass getNameErrorMessage() {
<span class="fc" id="L2348">        return nameErrorMessage;</span>
    }

    public RubyClass getNoMethodError() {
<span class="fc" id="L2352">        return noMethodError;</span>
    }

    public RubyClass getSignalException() {
<span class="nc" id="L2356">        return signalException;</span>
    }

    public RubyClass getRangeError() {
<span class="fc" id="L2360">        return rangeError;</span>
    }

    public RubyClass getSystemExit() {
<span class="fc" id="L2364">        return systemExit;</span>
    }

    public RubyClass getLocalJumpError() {
<span class="fc" id="L2368">        return localJumpError;</span>
    }

    public RubyClass getNativeException() {
<span class="nc" id="L2372">        return nativeException;</span>
    }

    public RubyClass getSystemCallError() {
<span class="fc" id="L2376">        return systemCallError;</span>
    }

    public RubyClass getKeyError() {
<span class="fc" id="L2380">        return keyError;</span>
    }

    public RubyClass getFatal() {
<span class="nc" id="L2384">        return fatal;</span>
    }

    public RubyClass getInterrupt() {
<span class="nc" id="L2388">        return interrupt;</span>
    }

    public RubyClass getTypeError() {
<span class="fc" id="L2392">        return typeError;</span>
    }

    public RubyClass getArgumentError() {
<span class="fc" id="L2396">        return argumentError;</span>
    }

    public RubyClass getIndexError() {
<span class="fc" id="L2400">        return indexError;</span>
    }

    public RubyClass getStopIteration() {
<span class="fc" id="L2404">        return stopIteration;</span>
    }

    public RubyClass getSyntaxError() {
<span class="fc" id="L2408">        return syntaxError;</span>
    }

    public RubyClass getStandardError() {
<span class="fc" id="L2412">        return standardError;</span>
    }

    public RubyClass getRuntimeError() {
<span class="fc" id="L2416">        return runtimeError;</span>
    }

    public RubyClass getIOError() {
<span class="fc" id="L2420">        return ioError;</span>
    }

    public RubyClass getLoadError() {
<span class="fc" id="L2424">        return loadError;</span>
    }

    public RubyClass getNotImplementedError() {
<span class="fc" id="L2428">        return notImplementedError;</span>
    }

    public RubyClass getSecurityError() {
<span class="fc" id="L2432">        return securityError;</span>
    }

    public RubyClass getNoMemoryError() {
<span class="nc" id="L2436">        return noMemoryError;</span>
    }

    public RubyClass getRegexpError() {
<span class="fc" id="L2440">        return regexpError;</span>
    }

    public RubyClass getInterruptedRegexpError() {
<span class="nc" id="L2444">        return interruptedRegexpError;</span>
    }

    public RubyClass getEOFError() {
<span class="fc" id="L2448">        return eofError;</span>
    }

    public RubyClass getThreadError() {
<span class="fc" id="L2452">        return threadError;</span>
    }

    public RubyClass getConcurrencyError() {
<span class="nc" id="L2456">        return concurrencyError;</span>
    }

    public RubyClass getSystemStackError() {
<span class="nc" id="L2460">        return systemStackError;</span>
    }

    public RubyClass getZeroDivisionError() {
<span class="fc" id="L2464">        return zeroDivisionError;</span>
    }

    public RubyClass getFloatDomainError() {
<span class="fc" id="L2468">        return floatDomainError;</span>
    }

    public RubyClass getMathDomainError() {
<span class="fc" id="L2472">        return mathDomainError;</span>
    }

    public RubyClass getEncodingError() {
<span class="nc" id="L2476">        return encodingError;</span>
    }

    public RubyClass getEncodingCompatibilityError() {
<span class="fc" id="L2480">        return encodingCompatibilityError;</span>
    }

    public RubyClass getConverterNotFoundError() {
<span class="fc" id="L2484">        return converterNotFoundError;</span>
    }

    public RubyClass getFiberError() {
<span class="fc" id="L2488">        return fiberError;</span>
    }

    public RubyClass getUndefinedConversionError() {
<span class="fc" id="L2492">        return undefinedConversionError;</span>
    }

    public RubyClass getInvalidByteSequenceError() {
<span class="fc" id="L2496">        return invalidByteSequenceError;</span>
    }

    private RubyRandom.RandomType defaultRand;
    public RubyRandom.RandomType getDefaultRand() {
<span class="fc" id="L2501">        return defaultRand;</span>
    }

    public void setDefaultRand(RubyRandom.RandomType defaultRand) {
<span class="fc" id="L2505">        this.defaultRand = defaultRand;</span>
<span class="fc" id="L2506">    }</span>

    private RubyHash charsetMap;
    public RubyHash getCharsetMap() {
<span class="nc bnc" id="L2510" title="All 2 branches missed.">        if (charsetMap == null) charsetMap = new RubyHash(this);</span>
<span class="nc" id="L2511">        return charsetMap;</span>
    }

    /** Getter for property isVerbose.
     * @return Value of property isVerbose.
     */
    public IRubyObject getVerbose() {
<span class="fc" id="L2518">        return verboseValue;</span>
    }

    public boolean isVerbose() {
<span class="fc" id="L2522">        return verbose;</span>
    }

    public boolean warningsEnabled() {
<span class="fc" id="L2526">        return warningsEnabled;</span>
    }

    /** Setter for property isVerbose.
     * @param verbose New value of property isVerbose.
     */
    public void setVerbose(IRubyObject verbose) {
<span class="fc" id="L2533">        this.verbose = verbose.isTrue();</span>
<span class="fc" id="L2534">        this.verboseValue = verbose;</span>
<span class="fc bfc" id="L2535" title="All 2 branches covered.">        warningsEnabled = !verbose.isNil();</span>
<span class="fc" id="L2536">    }</span>

    /** Getter for property isDebug.
     * @return Value of property isDebug.
     */
    public IRubyObject getDebug() {
<span class="fc bfc" id="L2542" title="All 2 branches covered.">        return debug ? trueObject : falseObject;</span>
    }

    public boolean isDebug() {
<span class="fc" id="L2546">        return debug;</span>
    }

    /** Setter for property isDebug.
     * @param debug New value of property isDebug.
     */
    public void setDebug(IRubyObject debug) {
<span class="fc" id="L2553">        this.debug = debug.isTrue();</span>
<span class="fc" id="L2554">    }</span>

    public JavaSupport getJavaSupport() {
<span class="fc" id="L2557">        return javaSupport;</span>
    }

    public static ClassLoader getClassLoader() {
        // we try to getService the classloader that loaded JRuby, falling back on System
<span class="fc" id="L2562">        ClassLoader loader = Ruby.class.getClassLoader();</span>
<span class="pc bpc" id="L2563" title="1 of 2 branches missed.">        if (loader == null) {</span>
<span class="nc" id="L2564">            loader = ClassLoader.getSystemClassLoader();</span>
        }

<span class="fc" id="L2567">        return loader;</span>
    }

    /**
     * TODO the property {@link #jrubyClassLoader} will only be set in constructor. in the first call of
     * {@link #getJRubyClassLoader() getJRubyClassLoader}. So the field {@link #jrubyClassLoader} can be final
     * set in the constructor directly and we avoid the synchronized here.
     *
     * @return
     */
    public synchronized JRubyClassLoader getJRubyClassLoader() {
        // FIXME: Get rid of laziness and handle restricted access elsewhere
<span class="pc bpc" id="L2579" title="1 of 4 branches missed.">        if (!Ruby.isSecurityRestricted() &amp;&amp; jrubyClassLoader == null) {</span>
<span class="fc" id="L2580">            jrubyClassLoader = new JRubyClassLoader(config.getLoader());</span>

            // if jit code cache is used, we need to add the cache directory to the classpath
            // so the previously generated class files can be reused.
<span class="pc bpc" id="L2584" title="3 of 4 branches missed.">            if( config.JIT_CODE_CACHE != null &amp;&amp; !config.JIT_CODE_CACHE.trim().isEmpty() ) {</span>
<span class="nc" id="L2585">                File file = new File( config.JIT_CODE_CACHE );</span>

<span class="nc bnc" id="L2587" title="All 4 branches missed.">                if( file.exists() == false || file.isDirectory() == false ) {</span>
<span class="nc" id="L2588">                    getWarnings().warning(&quot;The jit.codeCache '&quot; + config.JIT_CODE_CACHE + &quot;' directory doesn't exit.&quot;);</span>
                } else {
                    try {
<span class="nc" id="L2591">                        URL url = file.toURI().toURL();</span>
<span class="nc" id="L2592">                        jrubyClassLoader.addURL( url );</span>
<span class="nc" id="L2593">                    } catch (MalformedURLException e) {</span>
<span class="nc" id="L2594">                        getWarnings().warning(&quot;Unable to add the jit.codeCache '&quot; + config.JIT_CODE_CACHE + &quot;' directory to the classpath.&quot; + e.getMessage());</span>
<span class="nc" id="L2595">                    }</span>
                }
            }
        }

<span class="fc" id="L2600">        return jrubyClassLoader;</span>
    }

    /** Defines a global variable
     */
    public void defineVariable(final GlobalVariable variable, org.jruby.internal.runtime.GlobalVariable.Scope scope) {
<span class="fc" id="L2606">        globalVariables.define(variable.name(), new IAccessor() {</span>
            @Override
            public IRubyObject getValue() {
<span class="fc" id="L2609">                return variable.get();</span>
            }

            @Override
            public IRubyObject setValue(IRubyObject newValue) {
<span class="fc" id="L2614">                return variable.set(newValue);</span>
            }
        }, scope);
<span class="fc" id="L2617">    }</span>

    /** defines a readonly global variable
     *
     */
    public void defineReadonlyVariable(String name, IRubyObject value, org.jruby.internal.runtime.GlobalVariable.Scope scope) {
<span class="fc" id="L2623">        globalVariables.defineReadonly(name, new ValueAccessor(value), scope);</span>
<span class="fc" id="L2624">    }</span>

    // Obsolete parseFile function
    public Node parseFile(InputStream in, String file, DynamicScope scope) {
<span class="nc" id="L2628">        return parseFile(in, file, scope, 0);</span>
    }

    // Modern variant of parsFile function above
    public ParseResult parseFile(String file, InputStream in, DynamicScope scope) {
<span class="fc" id="L2633">       return parseFile(file, in, scope, 0);</span>
    }

    // Obsolete parseFile function
    public Node parseFile(InputStream in, String file, DynamicScope scope, int lineNumber) {
<span class="nc" id="L2638">        addLoadParseToStats();</span>
<span class="nc" id="L2639">        return parseFileAndGetAST(in, file, scope, lineNumber, false);</span>
    }

    // Modern variant of parseFile function above
    public ParseResult parseFile(String file, InputStream in, DynamicScope scope, int lineNumber) {
<span class="fc" id="L2644">        addLoadParseToStats();</span>

<span class="pc bpc" id="L2646" title="1 of 2 branches missed.">        if (!RubyInstanceConfig.IR_READING) return parseFileAndGetAST(in, file, scope, lineNumber, false);</span>

        try {
            // Get IR from .ir file
<span class="nc" id="L2650">            return IRReader.load(getIRManager(), new IRReaderFile(getIRManager(), IRFileExpert.getIRPersistedFile(file)));</span>
<span class="nc" id="L2651">        } catch (IOException e) {</span>
            // FIXME: What is something actually throws IOException
<span class="nc" id="L2653">            return parseFileAndGetAST(in, file, scope, lineNumber, false);</span>
        }
    }

    // Obsolete parseFileFromMain function
    public Node parseFileFromMain(InputStream in, String file, DynamicScope scope) {
<span class="fc" id="L2659">        addLoadParseToStats();</span>

<span class="fc" id="L2661">        return parseFileFromMainAndGetAST(in, file, scope);</span>
    }

    // Modern variant of parseFileFromMain function above
    public ParseResult parseFileFromMain(String file, InputStream in, DynamicScope scope) {
<span class="fc" id="L2666">        addLoadParseToStats();</span>

<span class="pc bpc" id="L2668" title="1 of 2 branches missed.">        if (!RubyInstanceConfig.IR_READING) return parseFileFromMainAndGetAST(in, file, scope);</span>

        try {
<span class="nc" id="L2671">            return IRReader.load(getIRManager(), new IRReaderFile(getIRManager(), IRFileExpert.getIRPersistedFile(file)));</span>
<span class="nc" id="L2672">        } catch (IOException e) {</span>
<span class="nc" id="L2673">            System.out.println(e);</span>
<span class="nc" id="L2674">            e.printStackTrace();</span>
<span class="nc" id="L2675">            return parseFileFromMainAndGetAST(in, file, scope);</span>
        }
    }

     private Node parseFileFromMainAndGetAST(InputStream in, String file, DynamicScope scope) {
<span class="fc" id="L2680">         return parseFileAndGetAST(in, file, scope, 0, true);</span>
     }

     private Node parseFileAndGetAST(InputStream in, String file, DynamicScope scope, int lineNumber, boolean isFromMain) {
<span class="fc" id="L2684">         ParserConfiguration parserConfig =</span>
                 new ParserConfiguration(this, lineNumber, false, true, config);
<span class="fc" id="L2686">         setupSourceEncoding(parserConfig);</span>
<span class="fc" id="L2687">         return parser.parse(file, in, scope, parserConfig);</span>
     }

    public Node parseInline(InputStream in, String file, DynamicScope scope) {
<span class="fc" id="L2691">        addEvalParseToStats();</span>
<span class="fc" id="L2692">        ParserConfiguration parserConfig =</span>
                new ParserConfiguration(this, 0, false, true, false, config);
<span class="fc" id="L2694">        setupSourceEncoding(parserConfig);</span>
<span class="fc" id="L2695">        return parser.parse(file, in, scope, parserConfig);</span>
    }

    private void setupSourceEncoding(ParserConfiguration parserConfig) {
<span class="fc bfc" id="L2699" title="All 2 branches covered.">        if (config.getSourceEncoding() != null) {</span>
<span class="pc bpc" id="L2700" title="1 of 2 branches missed.">            if (config.isVerbose()) {</span>
<span class="nc" id="L2701">                config.getError().println(&quot;-K is specified; it is for 1.8 compatibility and may cause odd behavior&quot;);</span>
            }
<span class="fc" id="L2703">            parserConfig.setDefaultEncoding(getEncodingService().getEncodingFromString(config.getSourceEncoding()));</span>
        } else {
<span class="fc" id="L2705">            parserConfig.setDefaultEncoding(getEncodingService().getLocaleEncoding());</span>
        }
<span class="fc" id="L2707">    }</span>

    public Node parseEval(String content, String file, DynamicScope scope, int lineNumber) {
<span class="nc" id="L2710">        addEvalParseToStats();</span>
<span class="nc" id="L2711">        return parser.parse(file, content.getBytes(), scope, new ParserConfiguration(this, lineNumber, false, false, config));</span>
    }

    @Deprecated
    public Node parse(String content, String file, DynamicScope scope, int lineNumber,
            boolean extraPositionInformation) {
<span class="nc" id="L2717">        return parser.parse(file, content.getBytes(), scope, new ParserConfiguration(this,</span>
                lineNumber, extraPositionInformation, false, true, config));
    }

    public Node parseEval(ByteList content, String file, DynamicScope scope, int lineNumber) {
<span class="fc" id="L2722">        addEvalParseToStats();</span>
<span class="fc" id="L2723">        return parser.parse(file, content, scope, new ParserConfiguration(this,</span>
                lineNumber, false, false, false, config));
    }

    public Node parse(ByteList content, String file, DynamicScope scope, int lineNumber,
            boolean extraPositionInformation) {
<span class="nc" id="L2729">        addEvalParseToStats();</span>
<span class="nc" id="L2730">        return parser.parse(file, content, scope, new ParserConfiguration(this,</span>
                lineNumber, extraPositionInformation, false, true, config));
    }


    public ThreadService getThreadService() {
<span class="fc" id="L2736">        return threadService;</span>
    }

    public ThreadContext getCurrentContext() {
<span class="fc" id="L2740">        return threadService.getCurrentContext();</span>
    }

    /**
     * Returns the loadService.
     * @return ILoadService
     */
    public LoadService getLoadService() {
<span class="fc" id="L2748">        return loadService;</span>
    }

    /**
     * This is an internal encoding if actually specified via default_internal=
     * or passed in via -E.
     *
     * @return null or encoding
     */
    public Encoding getDefaultInternalEncoding() {
<span class="fc" id="L2758">        return defaultInternalEncoding;</span>
    }

    public void setDefaultInternalEncoding(Encoding defaultInternalEncoding) {
<span class="fc" id="L2762">        this.defaultInternalEncoding = defaultInternalEncoding;</span>
<span class="fc" id="L2763">    }</span>

    public Encoding getDefaultExternalEncoding() {
<span class="fc" id="L2766">        return defaultExternalEncoding;</span>
    }

    public void setDefaultExternalEncoding(Encoding defaultExternalEncoding) {
<span class="fc" id="L2770">        this.defaultExternalEncoding = defaultExternalEncoding;</span>
<span class="fc" id="L2771">    }</span>

    public EncodingService getEncodingService() {
<span class="fc" id="L2774">        return encodingService;</span>
    }

    public RubyWarnings getWarnings() {
<span class="fc" id="L2778">        return warnings;</span>
    }

    public PrintStream getErrorStream() {
        // FIXME: We can't guarantee this will always be a RubyIO...so the old code here is not safe
        /*java.io.OutputStream os = ((RubyIO) getGlobalVariables().getService(&quot;$stderr&quot;)).getOutStream();
        if(null != os) {
            return new PrintStream(os);
        } else {
            return new PrintStream(new org.jruby.util.SwallowingOutputStream());
        }*/
<span class="fc" id="L2789">        return new PrintStream(new IOOutputStream(getGlobalVariables().get(&quot;$stderr&quot;)));</span>
    }

    public InputStream getInputStream() {
<span class="fc" id="L2793">        return new IOInputStream(getGlobalVariables().get(&quot;$stdin&quot;));</span>
    }

    public PrintStream getOutputStream() {
<span class="fc" id="L2797">        return new PrintStream(new IOOutputStream(getGlobalVariables().get(&quot;$stdout&quot;)));</span>
    }

    public RubyModule getClassFromPath(String path) {
<span class="fc" id="L2801">        RubyModule c = getObject();</span>
<span class="pc bpc" id="L2802" title="2 of 4 branches missed.">        if (path.length() == 0 || path.charAt(0) == '#') {</span>
<span class="nc" id="L2803">            throw newTypeError(&quot;can't retrieve anonymous class &quot; + path);</span>
        }
<span class="fc" id="L2805">        int pbeg = 0, p = 0;</span>
<span class="fc bfc" id="L2806" title="All 2 branches covered.">        for(int l=path.length(); p&lt;l; ) {</span>
<span class="fc bfc" id="L2807" title="All 4 branches covered.">            while(p&lt;l &amp;&amp; path.charAt(p) != ':') {</span>
<span class="fc" id="L2808">                p++;</span>
            }
<span class="fc" id="L2810">            String str = path.substring(pbeg, p);</span>

<span class="pc bpc" id="L2812" title="1 of 4 branches missed.">            if(p&lt;l &amp;&amp; path.charAt(p) == ':') {</span>
<span class="pc bpc" id="L2813" title="2 of 4 branches missed.">                if(p+1 &lt; l &amp;&amp; path.charAt(p+1) != ':') {</span>
<span class="nc" id="L2814">                    throw newTypeError(&quot;undefined class/module &quot; + path.substring(pbeg,p));</span>
                }
<span class="fc" id="L2816">                p += 2;</span>
<span class="fc" id="L2817">                pbeg = p;</span>
            }

<span class="fc" id="L2820">            IRubyObject cc = c.getConstant(str);</span>
<span class="pc bpc" id="L2821" title="1 of 2 branches missed.">            if(!(cc instanceof RubyModule)) {</span>
<span class="nc" id="L2822">                throw newTypeError(&quot;&quot; + path + &quot; does not refer to class/module&quot;);</span>
            }
<span class="fc" id="L2824">            c = (RubyModule)cc;</span>
<span class="fc" id="L2825">        }</span>
<span class="fc" id="L2826">        return c;</span>
    }

    /** Prints an error with backtrace to the error stream.
     *
     * MRI: eval.c - error_print()
     *
     */
    public void printError(RubyException excp) {
<span class="nc bnc" id="L2835" title="All 4 branches missed.">        if (excp == null || excp.isNil()) {</span>
<span class="nc" id="L2836">            return;</span>
        }

<span class="nc" id="L2839">        PrintStream errorStream = getErrorStream();</span>
<span class="nc bnc" id="L2840" title="All 4 branches missed.">        String backtrace = config.getTraceType().printBacktrace(excp, errorStream == System.err &amp;&amp; getPosix().isatty(FileDescriptor.err));</span>
        try {
<span class="nc" id="L2842">            errorStream.print(backtrace);</span>
<span class="nc" id="L2843">        } catch (Exception e) {</span>
<span class="nc" id="L2844">            System.err.print(backtrace);</span>
<span class="nc" id="L2845">        }</span>
<span class="nc" id="L2846">    }</span>

    public void loadFile(String scriptName, InputStream in, boolean wrap) {
<span class="fc bfc" id="L2849" title="All 2 branches covered.">        IRubyObject self = wrap ? TopSelfFactory.createTopSelf(this) : getTopSelf();</span>
<span class="fc" id="L2850">        ThreadContext context = getCurrentContext();</span>
<span class="fc" id="L2851">        String file = context.getFile();</span>

        try {
<span class="fc" id="L2854">            ThreadContext.pushBacktrace(context, &quot;(root)&quot;, file, 0);</span>
<span class="fc" id="L2855">            context.preNodeEval(self);</span>
<span class="fc" id="L2856">            ParseResult parseResult = parseFile(scriptName, in, null);</span>

<span class="fc bfc" id="L2858" title="All 2 branches covered.">            if (wrap) {</span>
                // toss an anonymous module into the search path
<span class="fc" id="L2860">                ((RootNode) parseResult).getStaticScope().setModule(RubyModule.newModule(this));</span>
            }

<span class="fc" id="L2863">            runInterpreter(context, parseResult, self);</span>
<span class="nc" id="L2864">        } catch (JumpException.ReturnJump rj) {</span>
<span class="nc" id="L2865">            return;</span>
        } finally {
<span class="pc" id="L2867">            context.postNodeEval();</span>
<span class="pc" id="L2868">            ThreadContext.popBacktrace(context);</span>
<span class="fc" id="L2869">        }</span>
<span class="fc" id="L2870">    }</span>

    public void compileAndLoadFile(String filename, InputStream in, boolean wrap) {
<span class="nc" id="L2873">        InputStream readStream = in;</span>

        try {
<span class="nc" id="L2876">            Script script = null;</span>
<span class="nc" id="L2877">            ScriptAndCode scriptAndCode = null;</span>
<span class="nc" id="L2878">            String className = null;</span>

            try {
                // read full contents of file, hash it, and try to load that class first
<span class="nc" id="L2882">                ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L2883">                byte[] buffer = new byte[1024];</span>
                int num;
<span class="nc bnc" id="L2885" title="All 2 branches missed.">                while ((num = in.read(buffer)) &gt; -1) {</span>
<span class="nc" id="L2886">                    baos.write(buffer, 0, num);</span>
                }
<span class="nc" id="L2888">                buffer = baos.toByteArray();</span>
<span class="nc" id="L2889">                String hash = JITCompiler.getHashForBytes(buffer);</span>
<span class="nc" id="L2890">                className = JITCompiler.RUBY_JIT_PREFIX + &quot;.FILE_&quot; + hash;</span>

                // FIXME: duplicated from ClassCache
                Class contents;
                try {
<span class="nc" id="L2895">                    contents = jrubyClassLoader.loadClass(className);</span>
<span class="nc bnc" id="L2896" title="All 2 branches missed.">                    if (RubyInstanceConfig.JIT_LOADING_DEBUG) {</span>
<span class="nc" id="L2897">                        LOG.info(&quot;found jitted code for &quot; + filename + &quot; at class: &quot; + className);</span>
                    }
<span class="nc" id="L2899">                    script = (Script)contents.newInstance();</span>
<span class="nc" id="L2900">                    readStream = new ByteArrayInputStream(buffer);</span>
<span class="nc" id="L2901">                } catch (ClassNotFoundException cnfe) {</span>
<span class="nc bnc" id="L2902" title="All 2 branches missed.">                    if (RubyInstanceConfig.JIT_LOADING_DEBUG) {</span>
<span class="nc" id="L2903">                        LOG.info(&quot;no jitted code in classloader for file &quot; + filename + &quot; at class: &quot; + className);</span>
                    }
<span class="nc" id="L2905">                } catch (InstantiationException ie) {</span>
<span class="nc bnc" id="L2906" title="All 2 branches missed.">                    if (RubyInstanceConfig.JIT_LOADING_DEBUG) {</span>
<span class="nc" id="L2907">                        LOG.info(&quot;jitted code could not be instantiated for file &quot; + filename + &quot; at class: &quot; + className);</span>
                    }
<span class="nc" id="L2909">                } catch (IllegalAccessException iae) {</span>
<span class="nc bnc" id="L2910" title="All 2 branches missed.">                    if (RubyInstanceConfig.JIT_LOADING_DEBUG) {</span>
<span class="nc" id="L2911">                        LOG.info(&quot;jitted code could not be instantiated for file &quot; + filename + &quot; at class: &quot; + className);</span>
                    }
<span class="nc" id="L2913">                }</span>
<span class="nc" id="L2914">            } catch (IOException ioe) {</span>
                // TODO: log something?
<span class="nc" id="L2916">            }</span>

            // script was not found in cache above, so proceed to compile
<span class="nc" id="L2919">            Node scriptNode = parseFile(readStream, filename, null);</span>
<span class="nc bnc" id="L2920" title="All 2 branches missed.">            if (script == null) {</span>
<span class="nc" id="L2921">                scriptAndCode = tryCompile(scriptNode, new ClassDefininngJRubyClassLoader(jrubyClassLoader));</span>
<span class="nc bnc" id="L2922" title="All 2 branches missed.">                if (scriptAndCode != null) script = scriptAndCode.script();</span>
            }

<span class="nc bnc" id="L2925" title="All 2 branches missed.">            if (script == null) {</span>
<span class="nc" id="L2926">                failForcedCompile(scriptNode);</span>

<span class="nc" id="L2928">                runInterpreter(scriptNode);</span>
            } else {
<span class="nc" id="L2930">                runScript(script, wrap);</span>
            }
<span class="nc" id="L2932">        } catch (JumpException.ReturnJump rj) {</span>
<span class="nc" id="L2933">            return;</span>
<span class="nc" id="L2934">        }</span>
<span class="nc" id="L2935">    }</span>

    public void loadScript(Script script) {
<span class="nc" id="L2938">        loadScript(script, false);</span>
<span class="nc" id="L2939">    }</span>

    public void loadScript(Script script, boolean wrap) {
<span class="nc" id="L2942">        IRubyObject self = getTopSelf();</span>
<span class="nc" id="L2943">        ThreadContext context = getCurrentContext();</span>

        try {
<span class="nc" id="L2946">            script.load(context, self, wrap);</span>
<span class="nc" id="L2947">        } catch (JumpException.ReturnJump rj) {</span>
<span class="nc" id="L2948">            return;</span>
<span class="nc" id="L2949">        }</span>
<span class="nc" id="L2950">    }</span>

    /**
     * Load the given BasicLibraryService instance, wrapping it in Ruby framing
     * to ensure it is isolated from any parent scope.
     *
     * @param extName The name of the extension, to go on the frame wrapping it
     * @param extension The extension object to load
     * @param wrap Whether to use a new &quot;self&quot; for toplevel
     */
    public void loadExtension(String extName, BasicLibraryService extension, boolean wrap) {
<span class="nc bnc" id="L2961" title="All 2 branches missed.">        IRubyObject self = wrap ? TopSelfFactory.createTopSelf(this) : getTopSelf();</span>
<span class="nc" id="L2962">        ThreadContext context = getCurrentContext();</span>

        try {
<span class="nc" id="L2965">            context.preExtensionLoad(self);</span>

<span class="nc" id="L2967">            extension.basicLoad(this);</span>
<span class="nc" id="L2968">        } catch (IOException ioe) {</span>
<span class="nc" id="L2969">            throw newIOErrorFromException(ioe);</span>
<span class="nc" id="L2970">        } catch (JumpException.ReturnJump rj) {</span>
<span class="nc" id="L2971">            return;</span>
        } finally {
<span class="nc" id="L2973">            context.postNodeEval();</span>
<span class="nc" id="L2974">        }</span>
<span class="nc" id="L2975">    }</span>

    public void addBoundMethod(String className, String methodName, String rubyName) {
<span class="fc" id="L2978">        Map&lt;String, String&gt; javaToRuby = boundMethods.get(className);</span>
<span class="fc bfc" id="L2979" title="All 2 branches covered.">        if (javaToRuby == null) {</span>
<span class="fc" id="L2980">            javaToRuby = new HashMap&lt;String, String&gt;();</span>
<span class="fc" id="L2981">            boundMethods.put(className, javaToRuby);</span>
        }
<span class="fc" id="L2983">        javaToRuby.put(methodName, rubyName);</span>
<span class="fc" id="L2984">    }</span>

    public Map&lt;String, Map&lt;String, String&gt;&gt; getBoundMethods() {
<span class="fc" id="L2987">        return boundMethods;</span>
    }

    public void setJavaProxyClassFactory(JavaProxyClassFactory factory) {
<span class="fc" id="L2991">        this.javaProxyClassFactory = factory;</span>
<span class="fc" id="L2992">    }</span>

    public JavaProxyClassFactory getJavaProxyClassFactory() {
<span class="nc" id="L2995">        return javaProxyClassFactory;</span>
    }

<span class="fc" id="L2998">    public class CallTraceFuncHook extends EventHook {</span>
        private RubyProc traceFunc;
<span class="fc" id="L3000">        private EnumSet&lt;RubyEvent&gt; interest =</span>
<span class="fc" id="L3001">                EnumSet.allOf(RubyEvent.class);</span>

        public void setTraceFunc(RubyProc traceFunc) {
<span class="nc" id="L3004">            this.traceFunc = traceFunc;</span>
<span class="nc" id="L3005">        }</span>

        public void eventHandler(ThreadContext context, String eventName, String file, int line, String name, IRubyObject type) {
<span class="nc bnc" id="L3008" title="All 2 branches missed.">            if (!context.isWithinTrace()) {</span>
<span class="nc bnc" id="L3009" title="All 2 branches missed.">                if (file == null) file = &quot;(ruby)&quot;;</span>
<span class="nc bnc" id="L3010" title="All 2 branches missed.">                if (type == null) type = getNil();</span>

<span class="nc" id="L3012">                RubyBinding binding = RubyBinding.newBinding(Ruby.this, context.currentBinding());</span>

<span class="nc" id="L3014">                context.preTrace();</span>
                try {
<span class="nc" id="L3016">                    traceFunc.call(context, new IRubyObject[] {</span>
<span class="nc" id="L3017">                        newString(eventName), // event name</span>
<span class="nc" id="L3018">                        newString(file), // filename</span>
<span class="nc bnc" id="L3019" title="All 2 branches missed.">                        newFixnum(line), // line numbers should be 1-based</span>
<span class="nc" id="L3020">                        name != null ? newSymbol(name) : getNil(),</span>
                        binding,
                        type
                    });
                } finally {
<span class="nc" id="L3025">                    context.postTrace();</span>
<span class="nc" id="L3026">                }</span>
            }
<span class="nc" id="L3028">        }</span>

        @Override
        public boolean isInterestedInEvent(RubyEvent event) {
<span class="nc" id="L3032">            return interest.contains(event);</span>
        }
    };

<span class="fc" id="L3036">    private final CallTraceFuncHook callTraceFuncHook = new CallTraceFuncHook();</span>

    public synchronized void addEventHook(EventHook hook) {
<span class="nc bnc" id="L3039" title="All 2 branches missed.">        if (!RubyInstanceConfig.FULL_TRACE_ENABLED) {</span>
            // without full tracing, many events will not fire
<span class="nc" id="L3041">            getWarnings().warn(&quot;tracing (e.g. set_trace_func) will not capture all events without --debug flag&quot;);</span>
        }

<span class="nc" id="L3044">        EventHook[] hooks = eventHooks;</span>
<span class="nc" id="L3045">        EventHook[] newHooks = Arrays.copyOf(hooks, hooks.length + 1);</span>
<span class="nc" id="L3046">        newHooks[hooks.length] = hook;</span>
<span class="nc" id="L3047">        eventHooks = newHooks;</span>
<span class="nc" id="L3048">        hasEventHooks = true;</span>
<span class="nc" id="L3049">    }</span>

    public synchronized void removeEventHook(EventHook hook) {
<span class="nc" id="L3052">        EventHook[] hooks = eventHooks;</span>
<span class="nc bnc" id="L3053" title="All 2 branches missed.">        if (hooks.length == 0) return;</span>
<span class="nc" id="L3054">        EventHook[] newHooks = new EventHook[hooks.length - 1];</span>
<span class="nc" id="L3055">        boolean found = false;</span>
<span class="nc bnc" id="L3056" title="All 2 branches missed.">        for (int i = 0, j = 0; i &lt; hooks.length; i++) {</span>
<span class="nc bnc" id="L3057" title="All 6 branches missed.">            if (!found &amp;&amp; hooks[i] == hook &amp;&amp; !found) { // exclude first found</span>
<span class="nc" id="L3058">                found = true;</span>
<span class="nc" id="L3059">                continue;</span>
            }
<span class="nc" id="L3061">            newHooks[j] = hooks[i];</span>
<span class="nc" id="L3062">            j++;</span>
        }
<span class="nc" id="L3064">        eventHooks = newHooks;</span>
<span class="nc bnc" id="L3065" title="All 2 branches missed.">        hasEventHooks = newHooks.length &gt; 0;</span>
<span class="nc" id="L3066">    }</span>

    public void setTraceFunction(RubyProc traceFunction) {
<span class="nc" id="L3069">        removeEventHook(callTraceFuncHook);</span>

<span class="nc bnc" id="L3071" title="All 2 branches missed.">        if (traceFunction == null) {</span>
<span class="nc" id="L3072">            return;</span>
        }

<span class="nc" id="L3075">        callTraceFuncHook.setTraceFunc(traceFunction);</span>
<span class="nc" id="L3076">        addEventHook(callTraceFuncHook);</span>
<span class="nc" id="L3077">    }</span>

    public void callEventHooks(ThreadContext context, RubyEvent event, String file, int line, String name, IRubyObject type) {
<span class="nc bnc" id="L3080" title="All 2 branches missed.">        if (context.isEventHooksEnabled()) {</span>
<span class="nc bnc" id="L3081" title="All 2 branches missed.">            for (EventHook eventHook : eventHooks) {</span>
<span class="nc bnc" id="L3082" title="All 2 branches missed.">                if (eventHook.isInterestedInEvent(event)) {</span>
<span class="nc" id="L3083">                    eventHook.event(context, event, file, line, name, type);</span>
                }
            }
        }
<span class="nc" id="L3087">    }</span>

    public boolean hasEventHooks() {
<span class="fc" id="L3090">        return hasEventHooks;</span>
    }

    public GlobalVariables getGlobalVariables() {
<span class="fc" id="L3094">        return globalVariables;</span>
    }

    // For JSR 223 support: see http://scripting.java.net/
    public void setGlobalVariables(GlobalVariables globalVariables) {
<span class="nc" id="L3099">        this.globalVariables = globalVariables;</span>
<span class="nc" id="L3100">    }</span>

    /**
     * Push block onto exit stack.  When runtime environment exits
     * these blocks will be evaluated.
     *
     * @return the element that was pushed onto stack
     */
    public IRubyObject pushExitBlock(RubyProc proc) {
<span class="fc" id="L3109">        atExitBlocks.push(proc);</span>
<span class="fc" id="L3110">        return proc;</span>
    }

    // use this for JRuby-internal finalizers
    public void addInternalFinalizer(Finalizable finalizer) {
<span class="fc" id="L3115">        synchronized (internalFinalizersMutex) {</span>
<span class="fc bfc" id="L3116" title="All 2 branches covered.">            if (internalFinalizers == null) {</span>
<span class="fc" id="L3117">                internalFinalizers = new WeakHashMap&lt;Finalizable, Object&gt;();</span>
            }
<span class="fc" id="L3119">            internalFinalizers.put(finalizer, null);</span>
<span class="pc" id="L3120">        }</span>
<span class="fc" id="L3121">    }</span>

    // this method is for finalizers registered via ObjectSpace
    public void addFinalizer(Finalizable finalizer) {
<span class="fc" id="L3125">        synchronized (finalizersMutex) {</span>
<span class="fc bfc" id="L3126" title="All 2 branches covered.">            if (finalizers == null) {</span>
<span class="fc" id="L3127">                finalizers = new WeakHashMap&lt;Finalizable, Object&gt;();</span>
            }
<span class="fc" id="L3129">            finalizers.put(finalizer, null);</span>
<span class="pc" id="L3130">        }</span>
<span class="fc" id="L3131">    }</span>

    public void removeInternalFinalizer(Finalizable finalizer) {
<span class="nc" id="L3134">        synchronized (internalFinalizersMutex) {</span>
<span class="nc bnc" id="L3135" title="All 2 branches missed.">            if (internalFinalizers != null) {</span>
<span class="nc" id="L3136">                internalFinalizers.remove(finalizer);</span>
            }
<span class="nc" id="L3138">        }</span>
<span class="nc" id="L3139">    }</span>

    public void removeFinalizer(Finalizable finalizer) {
<span class="nc" id="L3142">        synchronized (finalizersMutex) {</span>
<span class="nc bnc" id="L3143" title="All 2 branches missed.">            if (finalizers != null) {</span>
<span class="nc" id="L3144">                finalizers.remove(finalizer);</span>
            }
<span class="nc" id="L3146">        }</span>
<span class="nc" id="L3147">    }</span>

    /**
     * Make sure Kernel#at_exit procs getService invoked on runtime shutdown.
     * This method needs to be explicitly called to work properly.
     * I thought about using finalize(), but that did not work and I
     * am not sure the runtime will be at a state to run procs by the
     * time Ruby is going away.  This method can contain any other
     * things that need to be cleaned up at shutdown.
     */
    public void tearDown() {
<span class="fc" id="L3158">        tearDown(true);</span>
<span class="fc" id="L3159">    }</span>

    // tearDown(boolean) has been added for embedding API. When an error
    // occurs in Ruby code, JRuby does system exit abruptly, no chance to
    // catch exception. This makes debugging really hard. This is why
    // tearDown(boolean) exists.
    public void tearDown(boolean systemExit) {
<span class="fc" id="L3166">        int status = 0;</span>

        // clear out threadlocals so they don't leak
<span class="fc" id="L3169">        recursive = new ThreadLocal&lt;Map&lt;String, RubyHash&gt;&gt;();</span>

<span class="fc" id="L3171">        ThreadContext context = getCurrentContext();</span>

        // FIXME: 73df3d230b9d92c7237d581c6366df1b92ad9b2b exposed no toplevel scope existing anymore (I think the
        // bogus scope I removed was playing surrogate toplevel scope and wallpapering this bug).  For now, add a
        // bogus scope back for at_exit block run.  This is buggy if at_exit is capturing vars.
<span class="fc bfc" id="L3176" title="All 2 branches covered.">        if (!context.hasAnyScopes()) {</span>
<span class="fc" id="L3177">            StaticScope topStaticScope = getStaticScopeFactory().newLocalScope(null);</span>
<span class="fc" id="L3178">            context.pushScope(new ManyVarsDynamicScope(topStaticScope, null));</span>
        }

<span class="fc bfc" id="L3181" title="All 2 branches covered.">        while (!atExitBlocks.empty()) {</span>
<span class="fc" id="L3182">            RubyProc proc = atExitBlocks.pop();</span>
            try {
<span class="fc" id="L3184">                proc.call(getCurrentContext(), IRubyObject.NULL_ARRAY);</span>
<span class="fc" id="L3185">            } catch (RaiseException rj) {</span>
<span class="fc" id="L3186">                RubyException raisedException = rj.getException();</span>
<span class="pc bpc" id="L3187" title="1 of 2 branches missed.">                if (!getSystemExit().isInstance(raisedException)) {</span>
<span class="nc" id="L3188">                    status = 1;</span>
<span class="nc" id="L3189">                    printError(raisedException);</span>
                } else {
<span class="fc" id="L3191">                    IRubyObject statusObj = raisedException.callMethod(</span>
<span class="fc" id="L3192">                            getCurrentContext(), &quot;status&quot;);</span>
<span class="pc bpc" id="L3193" title="2 of 4 branches missed.">                    if (statusObj != null &amp;&amp; !statusObj.isNil()) {</span>
<span class="fc" id="L3194">                        status = RubyNumeric.fix2int(statusObj);</span>
                    }
                }
<span class="fc" id="L3197">            }</span>
<span class="fc" id="L3198">        }</span>

        // Fetches (and unsets) the SIGEXIT handler, if one exists.
<span class="fc" id="L3201">        IRubyObject trapResult = RubySignal.__jtrap_osdefault_kernel(this.getNil(), this.newString(&quot;EXIT&quot;));</span>
<span class="pc bpc" id="L3202" title="1 of 2 branches missed.">        if (trapResult instanceof RubyArray) {</span>
<span class="fc" id="L3203">            IRubyObject[] trapResultEntries = ((RubyArray) trapResult).toJavaArray();</span>
<span class="fc" id="L3204">            IRubyObject exitHandlerProc = trapResultEntries[0];</span>
<span class="pc bpc" id="L3205" title="1 of 2 branches missed.">            if (exitHandlerProc instanceof RubyProc) {</span>
<span class="nc" id="L3206">                ((RubyProc) exitHandlerProc).call(this.getCurrentContext(), this.getSingleNilArray());</span>
            }
        }

<span class="fc bfc" id="L3210" title="All 2 branches covered.">        if (finalizers != null) {</span>
<span class="fc" id="L3211">            synchronized (finalizersMutex) {</span>
<span class="pc bpc" id="L3212" title="1 of 2 branches missed.">                for (Iterator&lt;Finalizable&gt; finalIter = new ArrayList&lt;Finalizable&gt;(finalizers.keySet()).iterator(); finalIter.hasNext();) {</span>
<span class="nc" id="L3213">                    Finalizable f = finalIter.next();</span>
<span class="nc bnc" id="L3214" title="All 2 branches missed.">                    if (f != null) {</span>
                        try {
<span class="nc" id="L3216">                            f.finalize();</span>
<span class="nc" id="L3217">                        } catch (Throwable t) {</span>
                            // ignore
<span class="nc" id="L3219">                        }</span>
                    }
<span class="nc" id="L3221">                    finalIter.remove();</span>
<span class="nc" id="L3222">                }</span>
<span class="pc" id="L3223">            }</span>
        }

<span class="fc" id="L3226">        synchronized (internalFinalizersMutex) {</span>
<span class="pc bpc" id="L3227" title="1 of 2 branches missed.">            if (internalFinalizers != null) {</span>
<span class="fc" id="L3228">                for (Iterator&lt;Finalizable&gt; finalIter = new ArrayList&lt;Finalizable&gt;(</span>
<span class="fc bfc" id="L3229" title="All 2 branches covered.">                        internalFinalizers.keySet()).iterator(); finalIter.hasNext();) {</span>
<span class="fc" id="L3230">                    Finalizable f = finalIter.next();</span>
<span class="pc bpc" id="L3231" title="1 of 2 branches missed.">                    if (f != null) {</span>
                        try {
<span class="fc" id="L3233">                            f.finalize();</span>
<span class="nc" id="L3234">                        } catch (Throwable t) {</span>
                            // ignore
<span class="fc" id="L3236">                        }</span>
                    }
<span class="fc" id="L3238">                    finalIter.remove();</span>
<span class="fc" id="L3239">                }</span>
            }
<span class="pc" id="L3241">        }</span>

<span class="fc" id="L3243">        getThreadService().disposeCurrentThread();</span>

<span class="fc" id="L3245">        getBeanManager().unregisterCompiler();</span>
<span class="fc" id="L3246">        getBeanManager().unregisterConfig();</span>
<span class="fc" id="L3247">        getBeanManager().unregisterParserStats();</span>
<span class="fc" id="L3248">        getBeanManager().unregisterMethodCache();</span>
<span class="fc" id="L3249">        getBeanManager().unregisterRuntime();</span>

<span class="fc" id="L3251">        getSelectorPool().cleanup();</span>

<span class="pc bpc" id="L3253" title="1 of 2 branches missed.">        if (getJRubyClassLoader() != null) {</span>
<span class="fc" id="L3254">            getJRubyClassLoader().tearDown(isDebug());</span>
        }

<span class="pc bpc" id="L3257" title="1 of 2 branches missed.">        if (config.isProfilingEntireRun()) {</span>
            // not using logging because it's formatted
<span class="nc" id="L3259">            ProfileCollection profileCollection = threadService.getMainThread().getContext().getProfileCollection();</span>
<span class="nc" id="L3260">            printProfileData(profileCollection);</span>
        }

<span class="pc bpc" id="L3263" title="2 of 4 branches missed.">        if (systemExit &amp;&amp; status != 0) {</span>
<span class="nc" id="L3264">            throw newSystemExit(status);</span>
        }

        // This is a rather gross way to ensure nobody else performs the same clearing of globalRuntime followed by
        // initializing a new runtime, which would cause our clear below to clear the wrong runtime. Synchronizing
        // against the class is a problem, but the overhead of teardown and creating new containers should outstrip
        // a global synchronize around a few field accesses. -CON
<span class="pc bpc" id="L3271" title="1 of 2 branches missed.">        if (this == globalRuntime) {</span>
<span class="fc" id="L3272">            synchronized (Ruby.class) {</span>
<span class="pc bpc" id="L3273" title="1 of 2 branches missed.">                if (this == globalRuntime) {</span>
<span class="fc" id="L3274">                    globalRuntime = null;</span>
                }
<span class="pc" id="L3276">            }</span>
        }
<span class="fc" id="L3278">    }</span>

    /**
     * TDOD remove the synchronized. Synchronization should be a implementation detail of the ProfilingService.
     * @param profileData
     */
    public synchronized void printProfileData( ProfileCollection profileData ) {
<span class="nc" id="L3285">        getProfilingService().newProfileReporter(getCurrentContext()).report(profileData);</span>
<span class="nc" id="L3286">    }</span>

    /**
     * Simple getter for #profilingServiceLookup to avoid direct property access
     * @return #profilingServiceLookup
     */
    private ProfilingServiceLookup getProfilingServiceLookup() {
<span class="nc" id="L3293">        return profilingServiceLookup;</span>
    }

    /**
     *
     * @return the, for this ruby instance, configured implementation of ProfilingService, or null
     */
    public ProfilingService getProfilingService() {
<span class="nc" id="L3301">        ProfilingServiceLookup lockup = getProfilingServiceLookup();</span>
<span class="nc bnc" id="L3302" title="All 2 branches missed.">        return lockup == null ? null : lockup.getService();</span>
    }

    // new factory methods ------------------------------------------------------------------------

    public RubyArray newEmptyArray() {
<span class="fc" id="L3308">        return RubyArray.newEmptyArray(this);</span>
    }

    public RubyArray newArray() {
<span class="fc" id="L3312">        return RubyArray.newArray(this);</span>
    }

    public RubyArray newArrayLight() {
<span class="nc" id="L3316">        return RubyArray.newArrayLight(this);</span>
    }

    public RubyArray newArray(IRubyObject object) {
<span class="fc" id="L3320">        return RubyArray.newArray(this, object);</span>
    }

    public RubyArray newArray(IRubyObject car, IRubyObject cdr) {
<span class="fc" id="L3324">        return RubyArray.newArray(this, car, cdr);</span>
    }

    public RubyArray newArray(IRubyObject... objects) {
<span class="fc" id="L3328">        return RubyArray.newArray(this, objects);</span>
    }

    public RubyArray newArrayNoCopy(IRubyObject... objects) {
<span class="fc" id="L3332">        return RubyArray.newArrayNoCopy(this, objects);</span>
    }

    public RubyArray newArrayNoCopyLight(IRubyObject... objects) {
<span class="fc" id="L3336">        return RubyArray.newArrayNoCopyLight(this, objects);</span>
    }

    public RubyArray newArray(List&lt;IRubyObject&gt; list) {
<span class="fc" id="L3340">        return RubyArray.newArray(this, list);</span>
    }

    public RubyArray newArray(int size) {
<span class="fc" id="L3344">        return RubyArray.newArray(this, size);</span>
    }

    public RubyArray getEmptyFrozenArray() {
<span class="nc" id="L3348">        return emptyFrozenArray;</span>
    }

    public RubyBoolean newBoolean(boolean value) {
<span class="fc bfc" id="L3352" title="All 2 branches covered.">        return value ? trueObject : falseObject;</span>
    }

    public RubyFileStat newFileStat(String filename, boolean lstat) {
<span class="fc" id="L3356">        return RubyFileStat.newFileStat(this, filename, lstat);</span>
    }

    public RubyFileStat newFileStat(FileDescriptor descriptor) {
<span class="nc" id="L3360">        return RubyFileStat.newFileStat(this, descriptor);</span>
    }

    public RubyFixnum newFixnum(long value) {
<span class="fc" id="L3364">        return RubyFixnum.newFixnum(this, value);</span>
    }

    public RubyFixnum newFixnum(int value) {
<span class="fc" id="L3368">        return RubyFixnum.newFixnum(this, value);</span>
    }

    public RubyFixnum newFixnum(Constant value) {
<span class="fc" id="L3372">        return RubyFixnum.newFixnum(this, value.intValue());</span>
    }

    public RubyFloat newFloat(double value) {
<span class="fc" id="L3376">        return RubyFloat.newFloat(this, value);</span>
    }

    public RubyNumeric newNumeric() {
<span class="nc" id="L3380">        return RubyNumeric.newNumeric(this);</span>
    }

    public RubyRational newRational(long num, long den) {
<span class="fc" id="L3384">        return RubyRational.newRationalRaw(this, newFixnum(num), newFixnum(den));</span>
    }

    public RubyRational newRationalReduced(long num, long den) {
<span class="fc" id="L3388">        return (RubyRational)RubyRational.newRationalConvert(getCurrentContext(), newFixnum(num), newFixnum(den));</span>
    }

    public RubyProc newProc(Block.Type type, Block block) {
<span class="fc bfc" id="L3392" title="All 4 branches covered.">        if (type != Block.Type.LAMBDA &amp;&amp; block.getProcObject() != null) return block.getProcObject();</span>

<span class="fc" id="L3394">        RubyProc proc =  RubyProc.newProc(this, block, type);</span>

<span class="fc" id="L3396">        return proc;</span>
    }

    public RubyProc newBlockPassProc(Block.Type type, Block block) {
<span class="nc bnc" id="L3400" title="All 4 branches missed.">        if (type != Block.Type.LAMBDA &amp;&amp; block.getProcObject() != null) return block.getProcObject();</span>

<span class="nc" id="L3402">        RubyProc proc =  RubyProc.newProc(this, block, type);</span>

<span class="nc" id="L3404">        return proc;</span>
    }

    public RubyBinding newBinding() {
<span class="fc" id="L3408">        return RubyBinding.newBinding(this, getCurrentContext().currentBinding());</span>
    }

    public RubyBinding newBinding(Binding binding) {
<span class="fc" id="L3412">        return RubyBinding.newBinding(this, binding);</span>
    }

    public RubyString newString() {
<span class="fc" id="L3416">        return RubyString.newString(this, new ByteList());</span>
    }

    public RubyString newString(String string) {
<span class="fc" id="L3420">        return RubyString.newString(this, string);</span>
    }

    public RubyString newString(ByteList byteList) {
<span class="fc" id="L3424">        return RubyString.newString(this, byteList);</span>
    }

    @Deprecated
    public RubyString newStringShared(ByteList byteList) {
<span class="nc" id="L3429">        return RubyString.newStringShared(this, byteList);</span>
    }

    public RubySymbol newSymbol(String name) {
<span class="fc" id="L3433">        return symbolTable.getSymbol(name);</span>
    }

    public RubySymbol newSymbol(ByteList name) {
<span class="fc" id="L3437">        return symbolTable.getSymbol(name);</span>
    }

    /**
     * Faster than {@link #newSymbol(String)} if you already have an interned
     * name String. Don't intern your string just to call this version - the
     * overhead of interning will more than wipe out any benefit from the faster
     * lookup.
     *
     * @param internedName the symbol name, &lt;em&gt;must&lt;/em&gt; be interned! if in
     *                     doubt, call {@link #newSymbol(String)} instead.
     * @return the symbol for name
     */
    public RubySymbol fastNewSymbol(String internedName) {
        //        assert internedName == internedName.intern() : internedName + &quot; is not interned&quot;;

<span class="fc" id="L3453">        return symbolTable.fastGetSymbol(internedName);</span>
    }

    public RubyTime newTime(long milliseconds) {
<span class="fc" id="L3457">        return RubyTime.newTime(this, milliseconds);</span>
    }

    public RaiseException newRuntimeError(String message) {
<span class="fc" id="L3461">        return newRaiseException(getRuntimeError(), message);</span>
    }

    public RaiseException newArgumentError(String message) {
<span class="fc" id="L3465">        return newRaiseException(getArgumentError(), message);</span>
    }

    public RaiseException newArgumentError(int got, int expected) {
<span class="fc" id="L3469">        return newRaiseException(getArgumentError(), &quot;wrong number of arguments (&quot; + got + &quot; for &quot; + expected + &quot;)&quot;);</span>
    }

    public RaiseException newArgumentError(String name, int got, int expected) {
<span class="fc" id="L3473">        return newRaiseException(getArgumentError(), &quot;wrong number of arguments calling `&quot; + name + &quot;` (&quot; + got + &quot; for &quot; + expected + &quot;)&quot;);</span>
    }

    public RaiseException newErrnoEBADFError() {
<span class="nc" id="L3477">        return newRaiseException(getErrno().getClass(&quot;EBADF&quot;), &quot;Bad file descriptor&quot;);</span>
    }

    public RaiseException newErrnoEISCONNError() {
<span class="nc" id="L3481">        return newRaiseException(getErrno().getClass(&quot;EISCONN&quot;), &quot;Socket is already connected&quot;);</span>
    }

    public RaiseException newErrnoEINPROGRESSError() {
<span class="nc" id="L3485">        return newRaiseException(getErrno().getClass(&quot;EINPROGRESS&quot;), &quot;Operation now in progress&quot;);</span>
    }

    public RaiseException newErrnoEINPROGRESSWritableError() {
<span class="nc" id="L3489">        return newLightweightErrnoException(getIO().getClass(&quot;EINPROGRESSWaitWritable&quot;), &quot;&quot;);</span>
    }

    public RaiseException newErrnoENOPROTOOPTError() {
<span class="nc" id="L3493">        return newRaiseException(getErrno().getClass(&quot;ENOPROTOOPT&quot;), &quot;Protocol not available&quot;);</span>
    }

    public RaiseException newErrnoEPIPEError() {
<span class="nc" id="L3497">        return newRaiseException(getErrno().getClass(&quot;EPIPE&quot;), &quot;Broken pipe&quot;);</span>
    }

    public RaiseException newErrnoECONNABORTEDError() {
<span class="nc" id="L3501">        return newRaiseException(getErrno().getClass(&quot;ECONNABORTED&quot;),</span>
                &quot;An established connection was aborted by the software in your host machine&quot;);
    }

    public RaiseException newErrnoECONNREFUSEDError() {
<span class="nc" id="L3506">        return newRaiseException(getErrno().getClass(&quot;ECONNREFUSED&quot;), &quot;Connection refused&quot;);</span>
    }

    public RaiseException newErrnoECONNRESETError() {
<span class="nc" id="L3510">        return newRaiseException(getErrno().getClass(&quot;ECONNRESET&quot;), &quot;Connection reset by peer&quot;);</span>
    }

    public RaiseException newErrnoEADDRINUSEError() {
<span class="nc" id="L3514">        return newRaiseException(getErrno().getClass(&quot;EADDRINUSE&quot;), &quot;Address in use&quot;);</span>
    }

    public RaiseException newErrnoEADDRINUSEError(String message) {
<span class="nc" id="L3518">        return newRaiseException(getErrno().getClass(&quot;EADDRINUSE&quot;), message);</span>
    }

    public RaiseException newErrnoEHOSTUNREACHError(String message) {
<span class="nc" id="L3522">        return newRaiseException(getErrno().getClass(&quot;EHOSTUNREACH&quot;), message);</span>
    }

    public RaiseException newErrnoEINVALError() {
<span class="fc" id="L3526">        return newRaiseException(getErrno().getClass(&quot;EINVAL&quot;), &quot;Invalid file&quot;);</span>
    }

    public RaiseException newErrnoELOOPError() {
<span class="nc" id="L3530">        return newRaiseException(getErrno().getClass(&quot;ELOOP&quot;), &quot;Too many levels of symbolic links&quot;);</span>
    }

    public RaiseException newErrnoEMFILEError() {
<span class="nc" id="L3534">        return newRaiseException(getErrno().getClass(&quot;EMFILE&quot;), &quot;Too many open files&quot;);</span>
    }

    public RaiseException newErrnoENFILEError() {
<span class="nc" id="L3538">        return newRaiseException(getErrno().getClass(&quot;ENFILE&quot;), &quot;Too many open files in system&quot;);</span>
    }

    public RaiseException newErrnoENOENTError() {
<span class="nc" id="L3542">        return newRaiseException(getErrno().getClass(&quot;ENOENT&quot;), &quot;File not found&quot;);</span>
    }

    public RaiseException newErrnoEACCESError(String message) {
<span class="fc" id="L3546">        return newRaiseException(getErrno().getClass(&quot;EACCES&quot;), message);</span>
    }

    public RaiseException newErrnoEAGAINError(String message) {
<span class="nc" id="L3550">        return newLightweightErrnoException(getErrno().getClass(&quot;EAGAIN&quot;), message);</span>
    }

    public RaiseException newErrnoEAGAINReadableError(String message) {
<span class="fc" id="L3554">        return newLightweightErrnoException(getModule(&quot;IO&quot;).getClass(&quot;EAGAINWaitReadable&quot;), message);</span>
    }

    public RaiseException newErrnoEAGAINWritableError(String message) {
<span class="nc" id="L3558">        return newLightweightErrnoException(getModule(&quot;IO&quot;).getClass(&quot;EAGAINWaitWritable&quot;), message);</span>
    }

    public RaiseException newErrnoEISDirError(String message) {
<span class="fc" id="L3562">        return newRaiseException(getErrno().getClass(&quot;EISDIR&quot;), message);</span>
    }

    public RaiseException newErrnoEPERMError(String name) {
<span class="nc" id="L3566">        return newRaiseException(getErrno().getClass(&quot;EPERM&quot;), &quot;Operation not permitted - &quot; + name);</span>
    }

    public RaiseException newErrnoEISDirError() {
<span class="nc" id="L3570">        return newErrnoEISDirError(&quot;Is a directory&quot;);</span>
    }

    public RaiseException newErrnoESPIPEError() {
<span class="nc" id="L3574">        return newRaiseException(getErrno().getClass(&quot;ESPIPE&quot;), &quot;Illegal seek&quot;);</span>
    }

    public RaiseException newErrnoEBADFError(String message) {
<span class="nc" id="L3578">        return newRaiseException(getErrno().getClass(&quot;EBADF&quot;), message);</span>
    }

    public RaiseException newErrnoEINPROGRESSError(String message) {
<span class="nc" id="L3582">        return newRaiseException(getErrno().getClass(&quot;EINPROGRESS&quot;), message);</span>
    }

    public RaiseException newErrnoEINPROGRESSWritableError(String message) {
<span class="nc" id="L3586">        return newLightweightErrnoException(getIO().getClass(&quot;EINPROGRESSWaitWritable&quot;), message);</span>
    }

    public RaiseException newErrnoEISCONNError(String message) {
<span class="nc" id="L3590">        return newRaiseException(getErrno().getClass(&quot;EISCONN&quot;), message);</span>
    }

    public RaiseException newErrnoEINVALError(String message) {
<span class="fc" id="L3594">        return newRaiseException(getErrno().getClass(&quot;EINVAL&quot;), message);</span>
    }

    public RaiseException newErrnoENOTDIRError(String message) {
<span class="fc" id="L3598">        return newRaiseException(getErrno().getClass(&quot;ENOTDIR&quot;), message);</span>
    }

    public RaiseException newErrnoENOTEMPTYError(String message) {
<span class="nc" id="L3602">        return newRaiseException(getErrno().getClass(&quot;ENOTEMPTY&quot;), message);</span>
    }

    public RaiseException newErrnoENOTSOCKError(String message) {
<span class="nc" id="L3606">        return newRaiseException(getErrno().getClass(&quot;ENOTSOCK&quot;), message);</span>
    }

    public RaiseException newErrnoENOTCONNError(String message) {
<span class="nc" id="L3610">        return newRaiseException(getErrno().getClass(&quot;ENOTCONN&quot;), message);</span>
    }

    public RaiseException newErrnoENOTCONNError() {
<span class="nc" id="L3614">        return newRaiseException(getErrno().getClass(&quot;ENOTCONN&quot;), &quot;Socket is not connected&quot;);</span>
    }

    public RaiseException newErrnoENOENTError(String message) {
<span class="fc" id="L3618">        return newRaiseException(getErrno().getClass(&quot;ENOENT&quot;), message);</span>
    }

    public RaiseException newErrnoESPIPEError(String message) {
<span class="nc" id="L3622">        return newRaiseException(getErrno().getClass(&quot;ESPIPE&quot;), message);</span>
    }

    public RaiseException newErrnoEEXISTError(String message) {
<span class="fc" id="L3626">        return newRaiseException(getErrno().getClass(&quot;EEXIST&quot;), message);</span>
    }

    public RaiseException newErrnoEDOMError(String message) {
<span class="nc" id="L3630">        return newRaiseException(getErrno().getClass(&quot;EDOM&quot;), &quot;Domain error - &quot; + message);</span>
    }

    public RaiseException newErrnoECHILDError() {
<span class="nc" id="L3634">        return newRaiseException(getErrno().getClass(&quot;ECHILD&quot;), &quot;No child processes&quot;);</span>
    }

    public RaiseException newErrnoEADDRNOTAVAILError(String message) {
<span class="nc" id="L3638">        return newRaiseException(getErrno().getClass(&quot;EADDRNOTAVAIL&quot;), message);</span>
    }

    public RaiseException newErrnoESRCHError() {
<span class="nc" id="L3642">        return newRaiseException(getErrno().getClass(&quot;ESRCH&quot;), null);</span>
    }

    public RaiseException newErrnoEWOULDBLOCKError() {
<span class="nc" id="L3646">        return newRaiseException(getErrno().getClass(&quot;EWOULDBLOCK&quot;), null);</span>
    }

    public RaiseException newErrnoEDESTADDRREQError(String func) {
<span class="nc" id="L3650">        return newRaiseException(getErrno().getClass(&quot;EDESTADDRREQ&quot;), func);</span>
    }

    public RaiseException newIndexError(String message) {
<span class="fc" id="L3654">        return newRaiseException(getIndexError(), message);</span>
    }

    public RaiseException newSecurityError(String message) {
<span class="fc" id="L3658">        return newRaiseException(getSecurityError(), message);</span>
    }

    public RaiseException newSystemCallError(String message) {
<span class="nc" id="L3662">        return newRaiseException(getSystemCallError(), message);</span>
    }

    public RaiseException newKeyError(String message) {
<span class="fc" id="L3666">        return newRaiseException(getKeyError(), message);</span>
    }

    public RaiseException newErrnoEINTRError() {
<span class="nc" id="L3670">        return newRaiseException(getErrno().getClass(&quot;EINTR&quot;), &quot;Interrupted&quot;);</span>
    }

    public RaiseException newErrnoFromLastPOSIXErrno() {
<span class="fc" id="L3674">        RubyClass errnoClass = getErrno(getPosix().errno());</span>
<span class="pc bpc" id="L3675" title="1 of 2 branches missed.">        if (errnoClass == null) errnoClass = systemCallError;</span>

<span class="fc" id="L3677">        return newRaiseException(errnoClass, null);</span>
    }

    public RaiseException newErrnoFromInt(int errno, String methodName, String message) {
<span class="pc bpc" id="L3681" title="5 of 6 branches missed.">        if (Platform.IS_WINDOWS &amp;&amp; (&quot;stat&quot;.equals(methodName) || &quot;lstat&quot;.equals(methodName))) {</span>
<span class="nc bnc" id="L3682" title="All 2 branches missed.">            if (errno == 20047) return newErrnoENOENTError(message); // boo:bar UNC stat failure</span>
<span class="nc bnc" id="L3683" title="All 2 branches missed.">            if (errno == Errno.ESRCH.intValue()) return newErrnoENOENTError(message); // ESRCH on stating &quot;&quot;</span>
        }

<span class="fc" id="L3686">        return newErrnoFromInt(errno, message);</span>
    }

    public RaiseException newErrnoFromInt(int errno, String message) {
<span class="fc" id="L3690">        RubyClass errnoClass = getErrno(errno);</span>
<span class="pc bpc" id="L3691" title="1 of 2 branches missed.">        if (errnoClass != null) {</span>
<span class="fc" id="L3692">            return newRaiseException(errnoClass, message);</span>
        } else {
<span class="nc" id="L3694">            return newSystemCallError(&quot;Unknown Error (&quot; + errno + &quot;) - &quot; + message);</span>
        }
    }

    public RaiseException newErrnoFromErrno(Errno errno, String message) {
<span class="pc bpc" id="L3699" title="2 of 4 branches missed.">        if (errno == null || errno == Errno.__UNKNOWN_CONSTANT__) {</span>
<span class="nc" id="L3700">            return newSystemCallError(message);</span>
        }
<span class="fc" id="L3702">        return newErrnoFromInt(errno.intValue(), message);</span>
    }

    public RaiseException newErrnoFromInt(int errno) {
<span class="fc" id="L3706">        Errno errnoObj = Errno.valueOf(errno);</span>
<span class="pc bpc" id="L3707" title="1 of 2 branches missed.">        if (errnoObj == null) {</span>
<span class="nc" id="L3708">            return newSystemCallError(&quot;Unknown Error (&quot; + errno + &quot;)&quot;);</span>
        }
<span class="fc" id="L3710">        String message = errnoObj.description();</span>
<span class="fc" id="L3711">        return newErrnoFromInt(errno, message);</span>
    }

<span class="fc" id="L3714">    private final static Pattern ADDR_NOT_AVAIL_PATTERN = Pattern.compile(&quot;assign.*address&quot;);</span>

    public RaiseException newErrnoEADDRFromBindException(BindException be) {
<span class="nc" id="L3717">		return newErrnoEADDRFromBindException(be, null);</span>
	}

    public RaiseException newErrnoEADDRFromBindException(BindException be, String contextMessage) {
<span class="nc" id="L3721">        String msg = be.getMessage();</span>
<span class="nc bnc" id="L3722" title="All 2 branches missed.">        if (msg == null) {</span>
<span class="nc" id="L3723">            msg = &quot;bind&quot;;</span>
        } else {
<span class="nc" id="L3725">            msg = &quot;bind - &quot; + msg;</span>
        }
<span class="nc bnc" id="L3727" title="All 2 branches missed.">        if (contextMessage != null) {</span>
<span class="nc" id="L3728">            msg = msg + contextMessage;</span>
        }
        // This is ugly, but what can we do, Java provides the same BindingException
        // for both EADDRNOTAVAIL and EADDRINUSE, so we differentiate the errors
        // based on BindException's message.
<span class="nc bnc" id="L3733" title="All 2 branches missed.">        if(ADDR_NOT_AVAIL_PATTERN.matcher(msg).find()) {</span>
<span class="nc" id="L3734">            return newErrnoEADDRNOTAVAILError(msg);</span>
        } else {
<span class="nc" id="L3736">            return newErrnoEADDRINUSEError(msg);</span>
        }
    }

    public RaiseException newTypeError(String message) {
<span class="fc" id="L3741">        return newRaiseException(getTypeError(), message);</span>
    }

    public RaiseException newThreadError(String message) {
<span class="fc" id="L3745">        return newRaiseException(getThreadError(), message);</span>
    }

    public RaiseException newConcurrencyError(String message) {
<span class="nc" id="L3749">        return newRaiseException(getConcurrencyError(), message);</span>
    }

    public RaiseException newSyntaxError(String message) {
<span class="fc" id="L3753">        return newRaiseException(getSyntaxError(), message);</span>
    }

    public RaiseException newRegexpError(String message) {
<span class="fc" id="L3757">        return newRaiseException(getRegexpError(), message);</span>
    }

    public RaiseException newInterruptedRegexpError(String message) {
<span class="nc" id="L3761">        return newRaiseException(getInterruptedRegexpError(), message);</span>
    }

    public RaiseException newRangeError(String message) {
<span class="fc" id="L3765">        return newRaiseException(getRangeError(), message);</span>
    }

    public RaiseException newNotImplementedError(String message) {
<span class="fc" id="L3769">        return newRaiseException(getNotImplementedError(), message);</span>
    }

    public RaiseException newInvalidEncoding(String message) {
<span class="nc" id="L3773">        return newRaiseException(fastGetClass(&quot;Iconv&quot;).getClass(&quot;InvalidEncoding&quot;), message);</span>
    }

    public RaiseException newIllegalSequence(String message) {
<span class="nc" id="L3777">        return newRaiseException(fastGetClass(&quot;Iconv&quot;).getClass(&quot;IllegalSequence&quot;), message);</span>
    }

    public RaiseException newNoMethodError(String message, String name, IRubyObject args) {
<span class="nc" id="L3781">        return new RaiseException(new RubyNoMethodError(this, getNoMethodError(), message, name, args), true);</span>
    }

    public RaiseException newNameError(String message, String name) {
<span class="fc" id="L3785">        return newNameError(message, name, null);</span>
    }

    // This name sucks and should be replaced by newNameErrorfor 9k.
    public RaiseException newNameErrorObject(String message, IRubyObject name) {
<span class="fc" id="L3790">        RubyException error = new RubyNameError(this, getNameError(), message, name);</span>

<span class="fc" id="L3792">        return new RaiseException(error, false);</span>
    }

    public RaiseException newNameError(String message, String name, Throwable origException) {
<span class="fc" id="L3796">        return newNameError(message, name, origException, false);</span>
    }

    public RaiseException newNameError(String message, String name, Throwable origException, boolean printWhenVerbose) {
<span class="fc bfc" id="L3800" title="All 2 branches covered.">        if (origException != null) {</span>
<span class="pc bpc" id="L3801" title="3 of 4 branches missed.">            if (printWhenVerbose &amp;&amp; isVerbose()) {</span>
<span class="nc" id="L3802">                LOG.error(origException.getMessage(), origException);</span>
<span class="fc bfc" id="L3803" title="All 2 branches covered.">            } else if (isDebug()) {</span>
<span class="fc" id="L3804">                LOG.debug(origException.getMessage(), origException);</span>
            }
        }

<span class="fc" id="L3808">        return new RaiseException(new RubyNameError(</span>
<span class="fc" id="L3809">                this, getNameError(), message, name), false);</span>
    }

    public RaiseException newLocalJumpError(RubyLocalJumpError.Reason reason, IRubyObject exitValue, String message) {
<span class="fc" id="L3813">        return new RaiseException(new RubyLocalJumpError(this, getLocalJumpError(), message, reason, exitValue), true);</span>
    }

    public RaiseException newLocalJumpErrorNoBlock() {
<span class="fc" id="L3817">        return newLocalJumpError(RubyLocalJumpError.Reason.NOREASON, getNil(), &quot;no block given&quot;);</span>
    }

    public RaiseException newRedoLocalJumpError() {
<span class="nc" id="L3821">        return newLocalJumpError(RubyLocalJumpError.Reason.REDO, getNil(), &quot;unexpected redo&quot;);</span>
    }

    public RaiseException newLoadError(String message) {
<span class="nc" id="L3825">        return newRaiseException(getLoadError(), message);</span>
    }

    public RaiseException newLoadError(String message, String path) {
<span class="fc" id="L3829">        RaiseException loadError = newRaiseException(getLoadError(), message);</span>
<span class="fc" id="L3830">        loadError.getException().setInstanceVariable(&quot;@path&quot;, newString(path));</span>
<span class="fc" id="L3831">        return loadError;</span>
    }

    public RaiseException newFrozenError(String objectType) {
<span class="fc" id="L3835">        return newFrozenError(objectType, false);</span>
    }

    public RaiseException newFrozenError(String objectType, boolean runtimeError) {
        // TODO: Should frozen error have its own distinct class?  If not should more share?
<span class="fc" id="L3840">        return newRaiseException(getRuntimeError(), &quot;can't modify frozen &quot; + objectType);</span>
    }

    public RaiseException newSystemStackError(String message) {
<span class="nc" id="L3844">        return newRaiseException(getSystemStackError(), message);</span>
    }

    public RaiseException newSystemStackError(String message, StackOverflowError soe) {
<span class="nc bnc" id="L3848" title="All 2 branches missed.">        if (getDebug().isTrue()) {</span>
<span class="nc" id="L3849">            LOG.debug(soe.getMessage(), soe);</span>
        }
<span class="nc" id="L3851">        return newRaiseException(getSystemStackError(), message);</span>
    }

    public RaiseException newSystemExit(int status) {
<span class="fc" id="L3855">        return new RaiseException(RubySystemExit.newInstance(this, status, &quot;exit&quot;));</span>
    }

    public RaiseException newSystemExit(int status, String message) {
<span class="fc" id="L3859">        return new RaiseException(RubySystemExit.newInstance(this, status, message));</span>
    }

    public RaiseException newIOError(String message) {
<span class="fc" id="L3863">        return newRaiseException(getIOError(), message);</span>
    }

    public RaiseException newStandardError(String message) {
<span class="nc" id="L3867">        return newRaiseException(getStandardError(), message);</span>
    }

    /**
     * Java does not give us enough information for specific error conditions
     * so we are reduced to divining them through string matches...
     *
     * TODO: Should ECONNABORTED get thrown earlier in the descriptor itself or is it ok to handle this late?
     * TODO: Should we include this into Errno code somewhere do we can use this from other places as well?
     */
    public RaiseException newIOErrorFromException(IOException e) {
<span class="nc bnc" id="L3878" title="All 4 branches missed.">        if (e instanceof ClosedChannelException || &quot;Bad file descriptor&quot;.equals(e.getMessage())) {</span>
<span class="nc" id="L3879">            throw newErrnoEBADFError();</span>
        }

        // TODO: this is kinda gross
<span class="nc bnc" id="L3883" title="All 2 branches missed.">        if(e.getMessage() != null) {</span>
<span class="nc" id="L3884">            String errorMessage = e.getMessage();</span>
            // All errors to sysread should be SystemCallErrors, but on a closed stream
            // Ruby returns an IOError.  Java throws same exception for all errors so
            // we resort to this hack...
<span class="nc bnc" id="L3888" title="All 2 branches missed.">            if (&quot;File not open&quot;.equals(errorMessage)) {</span>
<span class="nc" id="L3889">                return newIOError(e.getMessage());</span>
<span class="nc bnc" id="L3890" title="All 2 branches missed.">            } else if (&quot;An established connection was aborted by the software in your host machine&quot;.equals(errorMessage)) {</span>
<span class="nc" id="L3891">                return newErrnoECONNABORTEDError();</span>
<span class="nc bnc" id="L3892" title="All 2 branches missed.">            } else if (e.getMessage().equals(&quot;Broken pipe&quot;)) {</span>
<span class="nc" id="L3893">                return newErrnoEPIPEError();</span>
<span class="nc bnc" id="L3894" title="All 2 branches missed.">            } else if (&quot;Connection reset by peer&quot;.equals(e.getMessage())</span>
<span class="nc bnc" id="L3895" title="All 4 branches missed.">                    || &quot;An existing connection was forcibly closed by the remote host&quot;.equals(e.getMessage()) ||</span>
<span class="nc bnc" id="L3896" title="All 2 branches missed.">                    (Platform.IS_WINDOWS &amp;&amp; e.getMessage().contains(&quot;connection was aborted&quot;))) {</span>
<span class="nc" id="L3897">                return newErrnoECONNRESETError();</span>
<span class="nc bnc" id="L3898" title="All 2 branches missed.">            } else if (&quot;Too many levels of symbolic links&quot;.equals(e.getMessage())) {</span>
<span class="nc" id="L3899">                return newErrnoELOOPError();</span>
<span class="nc bnc" id="L3900" title="All 2 branches missed.">            } else if (&quot;Too many open files&quot;.equals(e.getMessage())) {</span>
<span class="nc" id="L3901">                return newErrnoEMFILEError();</span>
<span class="nc bnc" id="L3902" title="All 2 branches missed.">            } else if (&quot;Too many open files in system&quot;.equals(e.getMessage())) {</span>
<span class="nc" id="L3903">                return newErrnoENFILEError();</span>
            }
<span class="nc" id="L3905">            return newRaiseException(getIOError(), e.getMessage());</span>
        } else {
<span class="nc" id="L3907">            return newRaiseException(getIOError(), &quot;IO Error&quot;);</span>
        }
    }

    public RaiseException newTypeError(IRubyObject receivedObject, RubyClass expectedType) {
<span class="fc" id="L3912">        return newTypeError(receivedObject, expectedType.getName());</span>
    }

    public RaiseException newTypeError(IRubyObject receivedObject, RubyModule expectedType) {
<span class="nc" id="L3916">        return newTypeError(receivedObject, expectedType.getName());</span>
    }

    public RaiseException newTypeError(IRubyObject receivedObject, String expectedType) {
<span class="fc" id="L3920">        return newRaiseException(getTypeError(), &quot;wrong argument type &quot; +</span>
<span class="fc" id="L3921">                receivedObject.getMetaClass().getRealClass() + &quot; (expected &quot; + expectedType + &quot;)&quot;);</span>
    }

    public RaiseException newEOFError() {
<span class="fc" id="L3925">        return newRaiseException(getEOFError(), &quot;End of file reached&quot;);</span>
    }

    public RaiseException newEOFError(String message) {
<span class="nc" id="L3929">        return newRaiseException(getEOFError(), message);</span>
    }

    public RaiseException newZeroDivisionError() {
<span class="fc" id="L3933">        return newRaiseException(getZeroDivisionError(), &quot;divided by 0&quot;);</span>
    }

    public RaiseException newFloatDomainError(String message){
<span class="fc" id="L3937">        return newRaiseException(getFloatDomainError(), message);</span>
    }

    public RaiseException newMathDomainError(String message) {
<span class="fc" id="L3941">        return newRaiseException(getMathDomainError(), &quot;Numerical argument is out of domain - \&quot;&quot; + message + &quot;\&quot;&quot;);</span>
    }

    public RaiseException newEncodingError(String message){
<span class="nc" id="L3945">        return newRaiseException(getEncodingError(), message);</span>
    }

    public RaiseException newEncodingCompatibilityError(String message){
<span class="fc" id="L3949">        return newRaiseException(getEncodingCompatibilityError(), message);</span>
    }

    public RaiseException newConverterNotFoundError(String message) {
<span class="fc" id="L3953">        return newRaiseException(getConverterNotFoundError(), message);</span>
    }

    public RaiseException newFiberError(String message) {
<span class="fc" id="L3957">        return newRaiseException(getFiberError(), message);</span>
    }

    public RaiseException newUndefinedConversionError(String message) {
<span class="fc" id="L3961">        return newRaiseException(getUndefinedConversionError(), message);</span>
    }

    public RaiseException newInvalidByteSequenceError(String message) {
<span class="fc" id="L3965">        return newRaiseException(getInvalidByteSequenceError(), message);</span>
    }

    /**
     * @param exceptionClass
     * @param message
     * @return
     */
    public RaiseException newRaiseException(RubyClass exceptionClass, String message) {
<span class="fc" id="L3974">        return new RaiseException(this, exceptionClass, message, true);</span>
    }

    /**
     * Generate one of the ERRNO exceptions. This differs from the normal logic
     * by avoiding the generation of a backtrace. Many ERRNO values are expected,
     * such as EAGAIN, and JRuby pays a very high cost to generate backtraces that
     * are never used. The flags -Xerrno.backtrace=true or the property
     * jruby.errno.backtrace=true forces all errno exceptions to generate a backtrace.
     *
     * @param exceptionClass
     * @param message
     * @return
     */
    private RaiseException newLightweightErrnoException(RubyClass exceptionClass, String message) {
<span class="pc bpc" id="L3989" title="1 of 2 branches missed.">        if (RubyInstanceConfig.ERRNO_BACKTRACE) {</span>
<span class="nc" id="L3990">            return new RaiseException(this, exceptionClass, message, true);</span>
        } else {
<span class="fc" id="L3992">            return new RaiseException(this, exceptionClass, ERRNO_BACKTRACE_MESSAGE, RubyArray.newEmptyArray(this), true);</span>
        }
    }

    /**
     * Generate a StopIteration exception. This differs from the normal logic
     * by avoiding the generation of a backtrace. StopIteration is used by
     * Enumerator to end an external iteration, and so generating a full
     * backtrace is usually unreasonable overhead. The flag
     * -Xstop_iteration.backtrace=true or the property
     * jruby.stop_iteration.backtrace=true forces all StopIteration exceptions
     * to generate a backtrace.
     *
     * @param message the message for the exception
     */
    public RaiseException newLightweightStopIterationError(String message) {
<span class="pc bpc" id="L4008" title="1 of 2 branches missed.">        if (RubyInstanceConfig.STOPITERATION_BACKTRACE) {</span>
<span class="nc" id="L4009">            return new RaiseException(this, stopIteration, message, true);</span>
        } else {
<span class="fc" id="L4011">            return new RaiseException(this, stopIteration, STOPIERATION_BACKTRACE_MESSAGE, RubyArray.newEmptyArray(this), true);</span>
        }
    }

    // Equivalent of Data_Wrap_Struct
    public RubyObject.Data newData(RubyClass objectClass, Object sval) {
<span class="nc" id="L4017">        return new RubyObject.Data(this, objectClass, sval);</span>
    }

    public RubySymbol.SymbolTable getSymbolTable() {
<span class="fc" id="L4021">        return symbolTable;</span>
    }

    public ObjectSpace getObjectSpace() {
<span class="fc" id="L4025">        return objectSpace;</span>
    }

    public InputStream getIn() {
<span class="fc" id="L4029">        return in;</span>
    }

    public PrintStream getOut() {
<span class="fc" id="L4033">        return out;</span>
    }

    public PrintStream getErr() {
<span class="fc" id="L4037">        return err;</span>
    }

    public boolean isGlobalAbortOnExceptionEnabled() {
<span class="fc" id="L4041">        return globalAbortOnExceptionEnabled;</span>
    }

    public void setGlobalAbortOnExceptionEnabled(boolean enable) {
<span class="fc" id="L4045">        globalAbortOnExceptionEnabled = enable;</span>
<span class="fc" id="L4046">    }</span>

    public boolean isDoNotReverseLookupEnabled() {
<span class="nc" id="L4049">        return doNotReverseLookupEnabled;</span>
    }

    public void setDoNotReverseLookupEnabled(boolean b) {
<span class="nc" id="L4053">        doNotReverseLookupEnabled = b;</span>
<span class="nc" id="L4054">    }</span>

<span class="fc" id="L4056">    private ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; inspect = new ThreadLocal&lt;Map&lt;Object, Object&gt;&gt;();</span>
    public void registerInspecting(Object obj) {
<span class="fc" id="L4058">        Map&lt;Object, Object&gt; val = inspect.get();</span>
<span class="fc bfc" id="L4059" title="All 2 branches covered.">        if (val == null) inspect.set(val = new IdentityHashMap&lt;Object, Object&gt;());</span>
<span class="fc" id="L4060">        val.put(obj, null);</span>
<span class="fc" id="L4061">    }</span>

    public boolean isInspecting(Object obj) {
<span class="fc" id="L4064">        Map&lt;Object, Object&gt; val = inspect.get();</span>
<span class="fc bfc" id="L4065" title="All 2 branches covered.">        return val == null ? false : val.containsKey(obj);</span>
    }

    public void unregisterInspecting(Object obj) {
<span class="fc" id="L4069">        Map&lt;Object, Object&gt; val = inspect.get();</span>
<span class="pc bpc" id="L4070" title="1 of 2 branches missed.">        if (val != null ) val.remove(obj);</span>
<span class="fc" id="L4071">    }</span>

    public static interface RecursiveFunction {
        IRubyObject call(IRubyObject obj, boolean recur);
    }

    private static class RecursiveError extends Error implements Unrescuable {
<span class="fc" id="L4078">        public RecursiveError(Object tag) {</span>
<span class="fc" id="L4079">            this.tag = tag;</span>
<span class="fc" id="L4080">        }</span>
        public final Object tag;

        @Override
        public synchronized Throwable fillInStackTrace() {
<span class="fc" id="L4085">            return this;</span>
        }
    }

    private IRubyObject recursiveListAccess() {
<span class="fc" id="L4090">        Map&lt;String, RubyHash&gt; hash = recursive.get();</span>
<span class="fc" id="L4091">        String sym = getCurrentContext().getFrameName();</span>
<span class="fc" id="L4092">        IRubyObject list = getNil();</span>
<span class="fc bfc" id="L4093" title="All 2 branches covered.">        if(hash == null) {</span>
<span class="fc" id="L4094">            hash = new HashMap&lt;String, RubyHash&gt;();</span>
<span class="fc" id="L4095">            recursive.set(hash);</span>
        } else {
<span class="fc" id="L4097">            list = hash.get(sym);</span>
        }
<span class="fc bfc" id="L4099" title="All 4 branches covered.">        if(list == null || list.isNil()) {</span>
<span class="fc" id="L4100">            list = RubyHash.newHash(this);</span>
<span class="fc" id="L4101">            hash.put(sym, (RubyHash)list);</span>
        }
<span class="fc" id="L4103">        return list;</span>
    }

    private void recursiveListClear() {
<span class="fc" id="L4107">        Map&lt;String, RubyHash&gt; hash = recursive.get();</span>
<span class="pc bpc" id="L4108" title="1 of 2 branches missed.">        if(hash != null) {</span>
<span class="fc" id="L4109">            hash.clear();</span>
        }
<span class="fc" id="L4111">    }</span>

    private static class ExecRecursiveParams {
<span class="fc" id="L4114">        public ExecRecursiveParams() {}</span>
        public RecursiveFunction func;
        public IRubyObject list;
        public IRubyObject obj;
        public IRubyObject objid;
        public IRubyObject pairid;
    }

    private void recursivePush(IRubyObject list, IRubyObject obj, IRubyObject paired_obj) {
        IRubyObject pair_list;
<span class="pc bpc" id="L4124" title="1 of 2 branches missed.">        if(paired_obj == null) {</span>
<span class="fc" id="L4125">            ((RubyHash)list).op_aset(getCurrentContext(), obj, getTrue());</span>
<span class="nc bnc" id="L4126" title="All 2 branches missed.">        } else if((pair_list = ((RubyHash)list).fastARef(obj)) == null) {</span>
<span class="nc" id="L4127">            ((RubyHash)list).op_aset(getCurrentContext(), obj, paired_obj);</span>
        } else {
<span class="nc bnc" id="L4129" title="All 2 branches missed.">            if(!(pair_list instanceof RubyHash)) {</span>
<span class="nc" id="L4130">                IRubyObject other_paired_obj = pair_list;</span>
<span class="nc" id="L4131">                pair_list = RubyHash.newHash(this);</span>
<span class="nc" id="L4132">                ((RubyHash)pair_list).op_aset(getCurrentContext(), other_paired_obj, getTrue());</span>
<span class="nc" id="L4133">                ((RubyHash)list).op_aset(getCurrentContext(), obj, pair_list);</span>
            }
<span class="nc" id="L4135">            ((RubyHash)pair_list).op_aset(getCurrentContext(), paired_obj, getTrue());</span>
        }
<span class="fc" id="L4137">    }</span>

    private void recursivePop(IRubyObject list, IRubyObject obj, IRubyObject paired_obj) {
<span class="pc bpc" id="L4140" title="1 of 2 branches missed.">        if(paired_obj != null) {</span>
<span class="nc" id="L4141">            IRubyObject pair_list = ((RubyHash)list).fastARef(obj);</span>
<span class="nc bnc" id="L4142" title="All 2 branches missed.">            if(pair_list == null) {</span>
<span class="nc" id="L4143">                throw newTypeError(&quot;invalid inspect_tbl pair_list for &quot; + getCurrentContext().getFrameName());</span>
            }
<span class="nc bnc" id="L4145" title="All 2 branches missed.">            if(pair_list instanceof RubyHash) {</span>
<span class="nc" id="L4146">                ((RubyHash)pair_list).delete(getCurrentContext(), paired_obj, Block.NULL_BLOCK);</span>
<span class="nc bnc" id="L4147" title="All 2 branches missed.">                if(!((RubyHash)pair_list).isEmpty()) {</span>
<span class="nc" id="L4148">                    return;</span>
                }
            }
        }
<span class="fc" id="L4152">        ((RubyHash)list).delete(getCurrentContext(), obj, Block.NULL_BLOCK);</span>
<span class="fc" id="L4153">    }</span>

    private boolean recursiveCheck(IRubyObject list, IRubyObject obj_id, IRubyObject paired_obj_id) {
<span class="fc" id="L4156">        IRubyObject pair_list = ((RubyHash)list).fastARef(obj_id);</span>
<span class="fc bfc" id="L4157" title="All 2 branches covered.">        if(pair_list == null) {</span>
<span class="fc" id="L4158">            return false;</span>
        }
<span class="pc bpc" id="L4160" title="1 of 2 branches missed.">        if(paired_obj_id != null) {</span>
<span class="nc bnc" id="L4161" title="All 2 branches missed.">            if(!(pair_list instanceof RubyHash)) {</span>
<span class="nc bnc" id="L4162" title="All 2 branches missed.">                if(pair_list != paired_obj_id) {</span>
<span class="nc" id="L4163">                    return false;</span>
                }
            } else {
<span class="nc" id="L4166">                IRubyObject paired_result = ((RubyHash)pair_list).fastARef(paired_obj_id);</span>
<span class="nc bnc" id="L4167" title="All 4 branches missed.">                if(paired_result == null || paired_result.isNil()) {</span>
<span class="nc" id="L4168">                    return false;</span>
                }
            }
        }
<span class="fc" id="L4172">        return true;</span>
    }

    // exec_recursive_i
    private IRubyObject execRecursiveI(ExecRecursiveParams p) {
<span class="fc" id="L4177">        IRubyObject result = null;</span>
<span class="fc" id="L4178">        recursivePush(p.list, p.objid, p.pairid);</span>
        try {
<span class="fc" id="L4180">            result = p.func.call(p.obj, false);</span>
        } finally {
<span class="fc" id="L4182">            recursivePop(p.list, p.objid, p.pairid);</span>
<span class="fc" id="L4183">        }</span>
<span class="fc" id="L4184">        return result;</span>
    }

    // exec_recursive
    private IRubyObject execRecursiveInternal(RecursiveFunction func, IRubyObject obj, IRubyObject pairid, boolean outer) {
<span class="fc" id="L4189">        ExecRecursiveParams p = new ExecRecursiveParams();</span>
<span class="fc" id="L4190">        p.list = recursiveListAccess();</span>
<span class="fc" id="L4191">        p.objid = obj.id();</span>
<span class="fc bfc" id="L4192" title="All 4 branches covered.">        boolean outermost = outer &amp;&amp; !recursiveCheck(p.list, recursiveKey, null);</span>
<span class="fc bfc" id="L4193" title="All 2 branches covered.">        if(recursiveCheck(p.list, p.objid, pairid)) {</span>
<span class="pc bpc" id="L4194" title="2 of 4 branches missed.">            if(outer &amp;&amp; !outermost) {</span>
<span class="fc" id="L4195">                throw new RecursiveError(p.list);</span>
            }
<span class="nc" id="L4197">            return func.call(obj, true);</span>
        } else {
<span class="fc" id="L4199">            IRubyObject result = null;</span>
<span class="fc" id="L4200">            p.func = func;</span>
<span class="fc" id="L4201">            p.obj = obj;</span>
<span class="fc" id="L4202">            p.pairid = pairid;</span>

<span class="fc bfc" id="L4204" title="All 2 branches covered.">            if(outermost) {</span>
<span class="fc" id="L4205">                recursivePush(p.list, recursiveKey, null);</span>
                try {
<span class="fc" id="L4207">                    result = execRecursiveI(p);</span>
<span class="fc" id="L4208">                } catch(RecursiveError e) {</span>
<span class="pc bpc" id="L4209" title="1 of 2 branches missed.">                    if(e.tag != p.list) {</span>
<span class="nc" id="L4210">                        throw e;</span>
                    } else {
<span class="fc" id="L4212">                        result = p.list;</span>
                    }
<span class="fc" id="L4214">                }</span>
<span class="fc" id="L4215">                recursivePop(p.list, recursiveKey, null);</span>
<span class="fc bfc" id="L4216" title="All 2 branches covered.">                if(result == p.list) {</span>
<span class="fc" id="L4217">                    result = func.call(obj, true);</span>
                }
            } else {
<span class="fc" id="L4220">                result = execRecursiveI(p);</span>
            }

<span class="fc" id="L4223">            return result;</span>
        }
    }

    /**
     * Perform a recursive walk on the given object using the given function.
     *
     * Do not call this method directly unless you know you're within a call
     * to {@link Ruby#recursiveListOperation(java.util.concurrent.Callable) recursiveListOperation},
     * which will ensure the thread-local recursion tracking data structs are
     * cleared.
     *
     * MRI: rb_exec_recursive
     *
     * Calls func(obj, arg, recursive), where recursive is non-zero if the
     * current method is called recursively on obj
     *
     * @param func
     * @param obj
     * @return
     */
    public IRubyObject execRecursive(RecursiveFunction func, IRubyObject obj) {
<span class="pc bpc" id="L4245" title="1 of 2 branches missed.">        if (!inRecursiveListOperation.get()) {</span>
<span class="nc" id="L4246">            throw newThreadError(&quot;BUG: execRecursive called outside recursiveListOperation&quot;);</span>
        }
<span class="fc" id="L4248">        return execRecursiveInternal(func, obj, null, false);</span>
    }

    /**
     * Perform a recursive walk on the given object using the given function.
     * Treat this as the outermost call, cleaning up recursive structures.
     *
     * MRI: rb_exec_recursive_outer
     *
     * If recursion is detected on the current method and obj, the outermost
     * func will be called with (obj, arg, Qtrue). All inner func will be
     * short-circuited using throw.
     *
     * @param func
     * @param obj
     * @return
     */
    public IRubyObject execRecursiveOuter(RecursiveFunction func, IRubyObject obj) {
        try {
<span class="fc" id="L4267">            return execRecursiveInternal(func, obj, null, true);</span>
        } finally {
<span class="fc" id="L4269">            recursiveListClear();</span>
        }
    }

    /**
     * Begin a recursive walk that may make one or more calls to
     * {@link Ruby#execRecursive(org.jruby.Ruby.RecursiveFunction, org.jruby.runtime.builtin.IRubyObject) execRecursive}.
     * Clean up recursive structures once complete.
     *
     * @param body
     * @param &lt;T&gt;
     * @return
     */
    public &lt;T extends IRubyObject&gt; T recursiveListOperation(Callable&lt;T&gt; body) {
        try {
<span class="fc" id="L4284">            inRecursiveListOperation.set(true);</span>
<span class="fc" id="L4285">            return body.call();</span>
<span class="nc" id="L4286">        } catch (Exception e) {</span>
<span class="nc" id="L4287">            Helpers.throwException(e);</span>
<span class="nc" id="L4288">            return null; // not reached</span>
        } finally {
<span class="pc" id="L4290">            recursiveListClear();</span>
<span class="pc" id="L4291">            inRecursiveListOperation.set(false);</span>
        }
    }

    public boolean isObjectSpaceEnabled() {
<span class="fc" id="L4296">        return objectSpaceEnabled;</span>
    }

    public void setObjectSpaceEnabled(boolean objectSpaceEnabled) {
<span class="nc" id="L4300">        this.objectSpaceEnabled = objectSpaceEnabled;</span>
<span class="nc" id="L4301">    }</span>

    // You cannot set siphashEnabled property except via RubyInstanceConfig to avoid mixing hash functions.
    public boolean isSiphashEnabled() {
<span class="fc" id="L4305">        return siphashEnabled;</span>
    }

    public long getStartTime() {
<span class="nc" id="L4309">        return startTime;</span>
    }

    public Profile getProfile() {
<span class="fc" id="L4313">        return profile;</span>
    }

    public String getJRubyHome() {
<span class="fc" id="L4317">        return config.getJRubyHome();</span>
    }

    public void setJRubyHome(String home) {
<span class="nc" id="L4321">        config.setJRubyHome(home);</span>
<span class="nc" id="L4322">    }</span>

    public RubyInstanceConfig getInstanceConfig() {
<span class="fc" id="L4325">        return config;</span>
    }

    public boolean is2_0() {
<span class="nc" id="L4329">        return true;</span>
    }

    /** GET_VM_STATE_VERSION */
    public long getGlobalState() {
<span class="nc" id="L4334">        synchronized(this) {</span>
<span class="nc" id="L4335">            return globalState;</span>
<span class="nc" id="L4336">        }</span>
    }

    /** INC_VM_STATE_VERSION */
    public void incGlobalState() {
<span class="nc" id="L4341">        synchronized(this) {</span>
<span class="nc" id="L4342">            globalState = (globalState+1) &amp; 0x8fffffff;</span>
<span class="nc" id="L4343">        }</span>
<span class="nc" id="L4344">    }</span>

    public static boolean isSecurityRestricted() {
<span class="fc" id="L4347">        return securityRestricted;</span>
    }

    public static void setSecurityRestricted(boolean restricted) {
<span class="nc" id="L4351">        securityRestricted = restricted;</span>
<span class="nc" id="L4352">    }</span>

    public POSIX getPosix() {
<span class="fc" id="L4355">        return posix;</span>
    }

    public void setRecordSeparatorVar(GlobalVariable recordSeparatorVar) {
<span class="fc" id="L4359">        this.recordSeparatorVar = recordSeparatorVar;</span>
<span class="fc" id="L4360">    }</span>

    public GlobalVariable getRecordSeparatorVar() {
<span class="fc" id="L4363">        return recordSeparatorVar;</span>
    }

    public ExecutorService getExecutor() {
<span class="nc" id="L4367">        return executor;</span>
    }

    public ExecutorService getFiberExecutor() {
<span class="fc" id="L4371">        return fiberExecutor;</span>
    }

    public Map&lt;String, DateTimeZone&gt; getTimezoneCache() {
<span class="fc" id="L4375">        return timeZoneCache;</span>
    }

    @Deprecated
    public int getConstantGeneration() {
<span class="nc" id="L4380">        return -1;</span>
    }

    public Invalidator getConstantInvalidator(String constantName) {
<span class="fc" id="L4384">        Invalidator invalidator = constantNameInvalidators.get(constantName);</span>
<span class="fc bfc" id="L4385" title="All 2 branches covered.">        if (invalidator != null) {</span>
<span class="fc" id="L4386">            return invalidator;</span>
        } else {
<span class="fc" id="L4388">            return addConstantInvalidator(constantName);</span>
        }
    }

    private Invalidator addConstantInvalidator(String constantName) {
<span class="fc" id="L4393">        Invalidator invalidator = OptoFactory.newConstantInvalidator();</span>
<span class="fc" id="L4394">        constantNameInvalidators.putIfAbsent(constantName, invalidator);</span>

        // fetch the invalidator back from the ConcurrentHashMap to ensure that
        // only one invalidator for a given constant name is ever used:
<span class="fc" id="L4398">        return constantNameInvalidators.get(constantName);</span>
    }

    public Invalidator getCheckpointInvalidator() {
<span class="nc" id="L4402">        return checkpointInvalidator;</span>
    }

    public &lt;E extends Enum&lt;E&gt;&gt; void loadConstantSet(RubyModule module, Class&lt;E&gt; enumClass) {
<span class="fc bfc" id="L4406" title="All 2 branches covered.">        for (E e : EnumSet.allOf(enumClass)) {</span>
<span class="fc" id="L4407">            Constant c = (Constant) e;</span>
<span class="fc bfc" id="L4408" title="All 2 branches covered.">            if (Character.isUpperCase(c.name().charAt(0))) {</span>
<span class="fc" id="L4409">                module.setConstant(c.name(), newFixnum(c.intValue()));</span>
            }
<span class="fc" id="L4411">        }</span>
<span class="fc" id="L4412">    }</span>
    public void loadConstantSet(RubyModule module, String constantSetName) {
<span class="fc bfc" id="L4414" title="All 2 branches covered.">        for (Constant c : ConstantSet.getConstantSet(constantSetName)) {</span>
<span class="pc bpc" id="L4415" title="1 of 2 branches missed.">            if (Character.isUpperCase(c.name().charAt(0))) {</span>
<span class="fc" id="L4416">                module.setConstant(c.name(), newFixnum(c.intValue()));</span>
            }
<span class="fc" id="L4418">        }</span>
<span class="fc" id="L4419">    }</span>

    /**
     * Get a new serial number for a new DynamicMethod instance
     * @return a new serial number
     */
    public long getNextDynamicMethodSerial() {
<span class="fc" id="L4426">        return dynamicMethodSerial.getAndIncrement();</span>
    }

    /**
     * Get a new generation number for a module or class.
     *
     * @return a new generation number
     */
    public int getNextModuleGeneration() {
<span class="fc" id="L4435">        return moduleGeneration.incrementAndGet();</span>
    }

    /**
     * Get the global object used to synchronize class-hierarchy modifications like
     * cache invalidation, subclass sets, and included hierarchy sets.
     *
     * @return The object to use for locking when modifying the hierarchy
     */
    public Object getHierarchyLock() {
<span class="fc" id="L4445">        return hierarchyLock;</span>
    }

    /**
     * Get the runtime-global selector pool
     *
     * @return a SelectorPool from which to getService Selector instances
     */
    public SelectorPool getSelectorPool() {
<span class="fc" id="L4454">        return selectorPool;</span>
    }

    /**
     * Get the core class RuntimeCache instance, for doing dynamic calls from
     * core class methods.
     */
    public RuntimeCache getRuntimeCache() {
<span class="fc" id="L4462">        return runtimeCache;</span>
    }

    /**
     * Get the list of method holders for methods being profiled.
     * @return all known profiled methods
     * @deprecated This should be an implementation detail of the ProfilingService and should remove from the Ruby class.
     */
    @Deprecated
    public ProfiledMethods getProfiledMethods() {
<span class="nc" id="L4472">        return profiledMethods;</span>
    }

    /**
     * Add a method, so it can be printed out later.
     *
     * @param name the name of the method
     * @param method
     * @deprecated This should be an implementation detail of the ProfilingService and should remove from the Ruby class.
     */
    @Deprecated
    void addProfiledMethod(final String name, final DynamicMethod method) {
<span class="pc bpc" id="L4484" title="1 of 2 branches missed.">        if (!config.isProfiling()) return;</span>
<span class="nc bnc" id="L4485" title="All 2 branches missed.">        if (method.isUndefined()) return;</span>

<span class="nc" id="L4487">        getProfiledMethods().addProfiledMethod( name, method );</span>

<span class="nc" id="L4489">    }</span>

    /**
     * Increment the count of exceptions generated by code in this runtime.
     */
    public void incrementExceptionCount() {
<span class="fc" id="L4495">        exceptionCount.incrementAndGet();</span>
<span class="fc" id="L4496">    }</span>

    /**
     * Get the current exception count.
     *
     * @return he current exception count
     */
    public int getExceptionCount() {
<span class="nc" id="L4504">        return exceptionCount.get();</span>
    }

    /**
     * Increment the count of backtraces generated by code in this runtime.
     */
    public void incrementBacktraceCount() {
<span class="fc" id="L4511">        backtraceCount.incrementAndGet();</span>
<span class="fc" id="L4512">    }</span>

    /**
     * Get the current backtrace count.
     *
     * @return the current backtrace count
     */
    public int getBacktraceCount() {
<span class="nc" id="L4520">        return backtraceCount.get();</span>
    }

    /**
     * Increment the count of backtraces generated for warnings in this runtime.
     */
    public void incrementWarningCount() {
<span class="fc" id="L4527">        warningCount.incrementAndGet();</span>
<span class="fc" id="L4528">    }</span>

    /**
     * Get the current backtrace count.
     *
     * @return the current backtrace count
     */
    public int getWarningCount() {
<span class="nc" id="L4536">        return warningCount.get();</span>
    }

    /**
     * Increment the count of backtraces generated by code in this runtime.
     */
    public void incrementCallerCount() {
<span class="fc" id="L4543">        callerCount.incrementAndGet();</span>
<span class="fc" id="L4544">    }</span>

    /**
     * Get the current backtrace count.
     *
     * @return the current backtrace count
     */
    public int getCallerCount() {
<span class="nc" id="L4552">        return callerCount.get();</span>
    }

    /**
     * Mark Fixnum as reopened
     */
    public void reopenFixnum() {
<span class="fc" id="L4559">        fixnumInvalidator.invalidate();</span>
<span class="fc" id="L4560">        fixnumReopened = true;</span>
<span class="fc" id="L4561">    }</span>

    /**
     * Retrieve the invalidator for Fixnum reopening
     */
    public Invalidator getFixnumInvalidator() {
<span class="nc" id="L4567">        return fixnumInvalidator;</span>
    }

    /**
     * Whether the Float class has been reopened and modified
     */
    public boolean isFixnumReopened() {
<span class="fc" id="L4574">        return fixnumReopened;</span>
    }

    /**
     * Mark Float as reopened
     */
    public void reopenFloat() {
<span class="nc" id="L4581">        floatInvalidator.invalidate();</span>
<span class="nc" id="L4582">        floatReopened = true;</span>
<span class="nc" id="L4583">    }</span>

    /**
     * Retrieve the invalidator for Float reopening
     */
    public Invalidator getFloatInvalidator() {
<span class="nc" id="L4589">        return floatInvalidator;</span>
    }

    /**
     * Whether the Float class has been reopened and modified
     */
    public boolean isFloatReopened() {
<span class="fc" id="L4596">        return floatReopened;</span>
    }

    public boolean isBootingCore() {
<span class="fc" id="L4600">        return bootingCore;</span>
    }

    public boolean isBooting() {
<span class="fc" id="L4604">        return bootingRuntime;</span>
    }

    public CoverageData getCoverageData() {
<span class="fc" id="L4608">        return coverageData;</span>
    }

    public Random getRandom() {
<span class="fc" id="L4612">        return random;</span>
    }

    public long getHashSeedK0() {
<span class="fc" id="L4616">        return hashSeedK0;</span>
    }

    public long getHashSeedK1() {
<span class="nc" id="L4620">        return hashSeedK1;</span>
    }

    public StaticScopeFactory getStaticScopeFactory() {
<span class="fc" id="L4624">        return staticScopeFactory;</span>
    }

    public FFI getFFI() {
<span class="fc" id="L4628">        return ffi;</span>
    }

    public void setFFI(FFI ffi) {
<span class="fc" id="L4632">        this.ffi = ffi;</span>
<span class="fc" id="L4633">    }</span>

    public RubyString getDefinedMessage(DefinedMessage definedMessage) {
<span class="fc" id="L4636">        return definedMessages.get(definedMessage);</span>
    }

    public RubyString getThreadStatus(RubyThread.Status status) {
<span class="fc" id="L4640">        return threadStatuses.get(status);</span>
    }

    /**
     * Given a Ruby string, cache a frozen, duplicated copy of it, or find an
     * existing copy already prepared. This is used to reduce in-memory
     * duplication of pre-frozen or known-frozen strings.
     *
     * Note that this cache does some sync against the Ruby instance. This
     * could cause contention under heavy concurrent load, so a reexamination
     * of this design might be warranted.
     *
     * @param string the string to freeze-dup if an equivalent does not already exist
     * @return the freeze-duped version of the string
     */
    public RubyString freezeAndDedupString(RubyString string) {
<span class="fc bfc" id="L4656" title="All 2 branches covered.">        if (string.getMetaClass().isSingleton()) {</span>
            // never cache a singleton
<span class="fc" id="L4658">            RubyString duped = string.strDup(this);</span>
<span class="fc" id="L4659">            duped.setFrozen(true);</span>
<span class="fc" id="L4660">            return duped;</span>
        }

<span class="fc" id="L4663">        WeakReference&lt;RubyString&gt; dedupedRef = dedupMap.get(string);</span>
        RubyString deduped;

<span class="pc bpc" id="L4666" title="1 of 4 branches missed.">        if (dedupedRef == null || (deduped = dedupedRef.get()) == null) {</span>
<span class="fc" id="L4667">            deduped = string.strDup(this);</span>
<span class="fc" id="L4668">            deduped.setFrozen(true);</span>
<span class="fc" id="L4669">            dedupMap.put(string, new WeakReference&lt;RubyString&gt;(deduped));</span>
        }
<span class="fc" id="L4671">        return deduped;</span>
    }

    public int getRuntimeNumber() {
<span class="fc" id="L4675">        return runtimeNumber;</span>
    }

    private void setNetworkStack() {
        try {
<span class="pc bpc" id="L4680" title="1 of 2 branches missed.">            if (config.getIPv4Preferred()) {</span>
<span class="fc" id="L4681">                System.setProperty(&quot;java.net.preferIPv4Stack&quot;, &quot;true&quot;);</span>
            } else {
<span class="nc" id="L4683">                System.setProperty(&quot;java.net.preferIPv4Stack&quot;, &quot;false&quot;);</span>
            }
<span class="nc" id="L4685">        } catch (AccessControlException ace) {</span>
<span class="nc bnc" id="L4686" title="All 2 branches missed.">            if (isVerbose()) {</span>
<span class="nc" id="L4687">                LOG.warn(&quot;warning: unable to set network stack system property due &quot;</span>
                        + &quot;to security restrictions, please set it manually as JVM &quot;
                        + &quot;parameter (-Djava.net.preferIPv4Stack=true|false)&quot;);
            }
<span class="fc" id="L4691">        }</span>
<span class="fc" id="L4692">    }</span>

    /**
     * @see org.jruby.compiler.Constantizable
     */
    @Override
    public Object constant() {
<span class="nc" id="L4699">        return constant;</span>
    }

    @Deprecated
    public int getSafeLevel() {
<span class="nc" id="L4704">        return 0;</span>
    }

    @Deprecated
    public void setSafeLevel(int safeLevel) {
<span class="nc" id="L4709">    }</span>

    @Deprecated
    public void checkSafeString(IRubyObject object) {
<span class="nc" id="L4713">    }</span>

    @Deprecated
    public void secure(int level) {
<span class="nc" id="L4717">    }</span>

    // Parser stats methods
    private void addLoadParseToStats() {
<span class="pc bpc" id="L4721" title="1 of 2 branches missed.">        if (parserStats != null) parserStats.addLoadParse();</span>
<span class="fc" id="L4722">    }</span>

    private void addEvalParseToStats() {
<span class="pc bpc" id="L4725" title="1 of 2 branches missed.">        if (parserStats != null) parserStats.addEvalParse();</span>
<span class="fc" id="L4726">    }</span>

    private void addJRubyModuleParseToStats() {
<span class="nc bnc" id="L4729" title="All 2 branches missed.">        if (parserStats != null) parserStats.addJRubyModuleParse();</span>
<span class="nc" id="L4730">    }</span>

    @Deprecated
    public CallbackFactory callbackFactory(Class&lt;?&gt; type) {
<span class="nc" id="L4734">        throw new RuntimeException(&quot;callback-style handles are no longer supported in JRuby&quot;);</span>
    }

    @Deprecated
    public boolean is1_8() {
<span class="fc" id="L4739">        return false;</span>
    }

    @Deprecated
    public boolean is1_9() {
<span class="fc" id="L4744">        return true;</span>
    }

    public FilenoUtil getFilenoUtil() {
<span class="fc" id="L4748">        return filenoUtil;</span>
    }

<span class="fc" id="L4751">    private final ConcurrentHashMap&lt;String, Invalidator&gt; constantNameInvalidators =</span>
        new ConcurrentHashMap&lt;String, Invalidator&gt;(
            16    /* default initial capacity */,
            0.75f /* default load factory */,
            1     /* concurrency level - mostly reads here so this can be 1 */);

    private final Invalidator checkpointInvalidator;
    private final ThreadService threadService;

    private POSIX posix;

<span class="fc" id="L4762">    private final ObjectSpace objectSpace = new ObjectSpace();</span>

<span class="fc" id="L4764">    private final RubySymbol.SymbolTable symbolTable = new RubySymbol.SymbolTable(this);</span>

<span class="fc" id="L4766">    private static final EventHook[] EMPTY_HOOKS = new EventHook[0];</span>
<span class="fc" id="L4767">    private volatile EventHook[] eventHooks = new EventHook[0];</span>
    private boolean hasEventHooks;
<span class="fc" id="L4769">    private boolean globalAbortOnExceptionEnabled = false;</span>
<span class="fc" id="L4770">    private boolean doNotReverseLookupEnabled = false;</span>
    private volatile boolean objectSpaceEnabled;
    private boolean siphashEnabled;

<span class="fc" id="L4774">    private long globalState = 1;</span>

    // Default objects
    private IRubyObject topSelf;
    private IRubyObject rootFiber;
    private RubyNil nilObject;
    private IRubyObject[] singleNilArray;
    private RubyBoolean trueObject;
    private RubyBoolean falseObject;
<span class="fc" id="L4783">    final RubyFixnum[] fixnumCache = new RubyFixnum[2 * RubyFixnum.CACHE_OFFSET];</span>
<span class="fc" id="L4784">    final Object[] fixnumConstants = new Object[fixnumCache.length];</span>

    private boolean verbose, warningsEnabled, debug;
    private IRubyObject verboseValue;

    private RubyThreadGroup defaultThreadGroup;

    /**
     * All the core classes we keep hard references to. These are here largely
     * so that if someone redefines String or Array we won't start blowing up
     * creating strings and arrays internally. They also provide much faster
     * access than going through normal hash lookup on the Object class.
     */
    private RubyClass
           basicObjectClass, objectClass, moduleClass, classClass, nilClass, trueClass,
            falseClass, numericClass, floatClass, integerClass, fixnumClass,
            complexClass, rationalClass, enumeratorClass, yielderClass, fiberClass, generatorClass,
            arrayClass, hashClass, rangeClass, stringClass, encodingClass, converterClass, symbolClass,
            procClass, bindingClass, methodClass, unboundMethodClass,
            matchDataClass, regexpClass, timeClass, bignumClass, dirClass,
            fileClass, fileStatClass, ioClass, threadClass, threadGroupClass,
            continuationClass, structClass, tmsStruct, passwdStruct,
            groupStruct, procStatusClass, exceptionClass, runtimeError, ioError,
            scriptError, nameError, nameErrorMessage, noMethodError, signalException,
            rangeError, dummyClass, systemExit, localJumpError, nativeException,
            systemCallError, fatal, interrupt, typeError, argumentError, indexError, stopIteration,
            syntaxError, standardError, loadError, notImplementedError, securityError, noMemoryError,
            regexpError, eofError, threadError, concurrencyError, systemStackError, zeroDivisionError, floatDomainError, mathDomainError,
            encodingError, encodingCompatibilityError, converterNotFoundError, undefinedConversionError,
            invalidByteSequenceError, fiberError, randomClass, keyError, locationClass, interruptedRegexpError;

    /**
     * All the core modules we keep direct references to, for quick access and
     * to ensure they remain available.
     */
    private RubyModule
            kernelModule, comparableModule, enumerableModule, mathModule,
            marshalModule, etcModule, fileTestModule, gcModule,
            objectSpaceModule, processModule, procUIDModule, procGIDModule,
            procSysModule, precisionModule, errnoModule;

    private DynamicMethod privateMethodMissing, protectedMethodMissing, variableMethodMissing,
            superMethodMissing, normalMethodMissing, defaultMethodMissing, respondTo, respondToMissing;

    // record separator var, to speed up io ops that use it
    private GlobalVariable recordSeparatorVar;

    // former java.lang.System concepts now internalized for MVM
    private volatile String currentDirectory;

    // The &quot;current line&quot; global variable
<span class="fc" id="L4835">    private volatile int currentLine = 0;</span>

    private volatile IRubyObject argsFile;

<span class="fc" id="L4839">    private final long startTime = System.currentTimeMillis();</span>

    private final RubyInstanceConfig config;

    private InputStream in;
    private PrintStream out;
    private PrintStream err;

    // Java support
    private JavaSupport javaSupport;
    private JRubyClassLoader jrubyClassLoader;

    // Management/monitoring
    private BeanManager beanManager;

    // Parser stats
    private ParserStats parserStats;

    // Compilation
    private final JITCompiler jitCompiler;

    private TruffleBridge truffleBridge;

    // Note: this field and the following static initializer
    // must be located be in this order!
<span class="fc" id="L4864">    private volatile static boolean securityRestricted = false;</span>
    static {
<span class="pc bpc" id="L4866" title="1 of 2 branches missed.">        if (SafePropertyAccessor.isSecurityProtected(&quot;jruby.reflected.handles&quot;)) {</span>
            // can't read non-standard properties
<span class="nc" id="L4868">            securityRestricted = true;</span>
        } else {
<span class="fc" id="L4870">            SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L4871" title="1 of 2 branches missed.">            if (sm != null) {</span>
                try {
<span class="nc" id="L4873">                    sm.checkCreateClassLoader();</span>
<span class="nc" id="L4874">                } catch (SecurityException se) {</span>
                    // can't create custom classloaders
<span class="nc" id="L4876">                    securityRestricted = true;</span>
<span class="nc" id="L4877">                }</span>
            }
        }
    }

<span class="fc" id="L4882">    private final Parser parser = new Parser(this);</span>

    private LoadService loadService;

    private Encoding defaultInternalEncoding, defaultExternalEncoding;
    private EncodingService encodingService;

<span class="fc" id="L4889">    private GlobalVariables globalVariables = new GlobalVariables(this);</span>
<span class="fc" id="L4890">    private final RubyWarnings warnings = new RubyWarnings(this);</span>

    // Contains a list of all blocks (as Procs) that should be called when
    // the runtime environment exits.
<span class="fc" id="L4894">    private final Stack&lt;RubyProc&gt; atExitBlocks = new Stack&lt;RubyProc&gt;();</span>

    private Profile profile;

<span class="fc" id="L4898">    private KCode kcode = KCode.NONE;</span>

    // Atomic integers for symbol and method IDs
<span class="fc" id="L4901">    private final AtomicInteger symbolLastId = new AtomicInteger(128);</span>
<span class="fc" id="L4902">    private final AtomicInteger moduleLastId = new AtomicInteger(0);</span>

    // Weak map of all Modules in the system (and by extension, all Classes
<span class="fc" id="L4905">    private final Set&lt;RubyModule&gt; allModules = new WeakHashSet&lt;RubyModule&gt;();</span>

<span class="fc" id="L4907">    private final Map&lt;String, DateTimeZone&gt; timeZoneCache = new HashMap&lt;String,DateTimeZone&gt;();</span>
    /**
     * A list of &quot;external&quot; finalizers (the ones, registered via ObjectSpace),
     * weakly referenced, to be executed on tearDown.
     */
    private Map&lt;Finalizable, Object&gt; finalizers;

    /**
     * A list of JRuby-internal finalizers,  weakly referenced,
     * to be executed on tearDown.
     */
    private Map&lt;Finalizable, Object&gt; internalFinalizers;

    // mutex that controls modifications of user-defined finalizers
<span class="fc" id="L4921">    private final Object finalizersMutex = new Object();</span>

    // mutex that controls modifications of internal finalizers
<span class="fc" id="L4924">    private final Object internalFinalizersMutex = new Object();</span>

    // A thread pool to use for executing this runtime's Ruby threads
    private ExecutorService executor;

    // A thread pool to use for running fibers
    private ExecutorService fiberExecutor;

    // A global object lock for class hierarchy mutations
<span class="fc" id="L4933">    private final Object hierarchyLock = new Object();</span>

    // An atomic long for generating DynamicMethod serial numbers
<span class="fc" id="L4936">    private final AtomicLong dynamicMethodSerial = new AtomicLong(1);</span>

    // An atomic int for generating class generation numbers
<span class="fc" id="L4939">    private final AtomicInteger moduleGeneration = new AtomicInteger(1);</span>

    // A list of Java class+method names to include in backtraces
<span class="fc" id="L4942">    private final Map&lt;String, Map&lt;String, String&gt;&gt; boundMethods = new HashMap();</span>

    // A soft pool of selectors for blocking IO operations
<span class="fc" id="L4945">    private final SelectorPool selectorPool = new SelectorPool();</span>

    // A global cache for Java-to-Ruby calls
    private final RuntimeCache runtimeCache;

    // The method objects for serial numbers
    private final ProfiledMethods profiledMethods;

    // Message for Errno exceptions that will not generate a backtrace
    public static final String ERRNO_BACKTRACE_MESSAGE = &quot;errno backtraces disabled; run with -Xerrno.backtrace=true to enable&quot;;

    // Message for Errno exceptions that will not generate a backtrace
    public static final String STOPIERATION_BACKTRACE_MESSAGE = &quot;StopIteration backtraces disabled; run with -Xstop_iteration.backtrace=true to enable&quot;;

    // Count of RaiseExceptions generated by code running in this runtime
<span class="fc" id="L4960">    private final AtomicInteger exceptionCount = new AtomicInteger();</span>

    // Count of exception backtraces generated by code running in this runtime
<span class="fc" id="L4963">    private final AtomicInteger backtraceCount = new AtomicInteger();</span>

    // Count of Kernel#caller backtraces generated by code running in this runtime
<span class="fc" id="L4966">    private final AtomicInteger callerCount = new AtomicInteger();</span>

    // Count of built-in warning backtraces generated by code running in this runtime
<span class="fc" id="L4969">    private final AtomicInteger warningCount = new AtomicInteger();</span>

<span class="fc" id="L4971">    private Invalidator</span>
<span class="fc" id="L4972">            fixnumInvalidator = OptoFactory.newGlobalInvalidator(0),</span>
<span class="fc" id="L4973">            floatInvalidator = OptoFactory.newGlobalInvalidator(0);</span>
    private boolean fixnumReopened, floatReopened;

<span class="fc" id="L4976">    private volatile boolean bootingCore = true;</span>
<span class="fc" id="L4977">    private volatile boolean bootingRuntime = true;</span>

    private RubyHash envObject;

<span class="fc" id="L4981">    private final CoverageData coverageData = new CoverageData();</span>

    /** The &quot;global&quot; runtime. Set to the first runtime created, normally. */
    private static volatile Ruby globalRuntime;

    /** The &quot;thread local&quot; runtime. Set to the global runtime if unset. */
<span class="fc" id="L4987">    private static ThreadLocal&lt;Ruby&gt; threadLocalRuntime = new ThreadLocal&lt;Ruby&gt;();</span>

    /** The runtime-local random number generator. Uses SecureRandom if permissions allow. */
    private final Random random;

    /** The runtime-local seed for hash randomization */
    private long hashSeedK0;
    private long hashSeedK1;

    private StaticScopeFactory staticScopeFactory;

    private IRManager irManager;

    // structures and such for recursive operations
<span class="fc" id="L5001">    private ThreadLocal&lt;Map&lt;String, RubyHash&gt;&gt; recursive = new ThreadLocal&lt;Map&lt;String, RubyHash&gt;&gt;();</span>
    private RubySymbol recursiveKey;
<span class="fc" id="L5003">    private ThreadLocal&lt;Boolean&gt; inRecursiveListOperation = new ThreadLocal&lt;Boolean&gt;();</span>

    private FFI ffi;

    private JavaProxyClassFactory javaProxyClassFactory;

    /** Used to find the ProfilingService implementation to use. If profiling is disabled it's null */
    private final ProfilingServiceLookup profilingServiceLookup;

<span class="fc" id="L5012">    private EnumMap&lt;DefinedMessage, RubyString&gt; definedMessages = new EnumMap&lt;DefinedMessage, RubyString&gt;(DefinedMessage.class);</span>
<span class="fc" id="L5013">    private EnumMap&lt;RubyThread.Status, RubyString&gt; threadStatuses = new EnumMap&lt;RubyThread.Status, RubyString&gt;(RubyThread.Status.class);</span>

    private interface ObjectSpacer {
        public void addToObjectSpace(Ruby runtime, boolean useObjectSpace, IRubyObject object);
    }

<span class="fc" id="L5019">    private static final ObjectSpacer DISABLED_OBJECTSPACE = new ObjectSpacer() {</span>
        @Override
        public void addToObjectSpace(Ruby runtime, boolean useObjectSpace, IRubyObject object) {
<span class="fc" id="L5022">        }</span>
    };

<span class="fc" id="L5025">    private static final ObjectSpacer ENABLED_OBJECTSPACE = new ObjectSpacer() {</span>
        @Override
        public void addToObjectSpace(Ruby runtime, boolean useObjectSpace, IRubyObject object) {
<span class="nc bnc" id="L5028" title="All 2 branches missed.">            if (useObjectSpace) runtime.objectSpace.add(object);</span>
<span class="nc" id="L5029">        }</span>
    };

    private final ObjectSpacer objectSpacer;

    public void addToObjectSpace(boolean useObjectSpace, IRubyObject object) {
<span class="fc" id="L5035">        objectSpacer.addToObjectSpace(this, useObjectSpace, object);</span>
<span class="fc" id="L5036">    }</span>

    private RubyArray emptyFrozenArray;

    /**
     * A map from Ruby string data to a pre-frozen global version of that string.
     *
     * Access must be synchronized.
     */
<span class="fc" id="L5045">    private WeakHashMap&lt;RubyString, WeakReference&lt;RubyString&gt;&gt; dedupMap = new WeakHashMap&lt;RubyString, WeakReference&lt;RubyString&gt;&gt;();</span>

<span class="fc" id="L5047">    private static final AtomicInteger RUNTIME_NUMBER = new AtomicInteger(0);</span>
<span class="fc" id="L5048">    private final int runtimeNumber = RUNTIME_NUMBER.getAndIncrement();</span>

    private final Config configBean;
    private final org.jruby.management.Runtime runtimeBean;

<span class="fc" id="L5053">    private final FilenoUtil filenoUtil = new FilenoUtil();</span>

    /**
     * A representation of this runtime as a JIT-optimizable constant. Used for e.g. invokedynamic binding of runtime
     * accesses.
     */
    private final Object constant;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>