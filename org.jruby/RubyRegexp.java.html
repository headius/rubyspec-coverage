<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RubyRegexp.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby</a> &gt; <span class="el_source">RubyRegexp.java</span></div><h1>RubyRegexp.java</h1><pre class="source lang-java linenums">/***** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2001 Alan Moore &lt;alan_moore@gmx.net&gt;
 * Copyright (C) 2001-2002 Benoit Cerrina &lt;b.cerrina@wanadoo.fr&gt;
 * Copyright (C) 2001-2004 Jan Arne Petersen &lt;jpetersen@uni-bonn.de&gt;
 * Copyright (C) 2002-2004 Anders Bengtsson &lt;ndrsbngtssn@yahoo.se&gt;
 * Copyright (C) 2004-2005 Thomas E Enebo &lt;enebo@acm.org&gt;
 * Copyright (C) 2004 Stefan Matthias Aust &lt;sma@3plus4.de&gt;
 * Copyright (C) 2005 David Corbin &lt;dcorbin@users.sourceforge.net&gt;
 * Copyright (C) 2006 Nick Sieger &lt;nicksieger@gmail.com&gt;
 * Copyright (C) 2006 Miguel Covarrubias &lt;mlcovarrubias@gmail.com&gt;
 * 
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby;

import static org.jruby.anno.FrameField.BACKREF;
import static org.jruby.anno.FrameField.LASTLINE;

import org.jcodings.Encoding;
import org.jcodings.specific.ASCIIEncoding;
import org.jcodings.specific.USASCIIEncoding;
import org.jcodings.specific.UTF8Encoding;
import org.joni.Matcher;
import org.joni.NameEntry;
import org.joni.Option;
import org.joni.Regex;
import org.joni.Region;
import org.joni.Syntax;
import org.joni.exception.JOniException;
import org.jruby.anno.JRubyClass;
import org.jruby.anno.JRubyMethod;
import org.jruby.common.IRubyWarnings.ID;
import org.jruby.exceptions.RaiseException;
import org.jruby.parser.ReOptions;
import org.jruby.runtime.Block;
import org.jruby.runtime.ClassIndex;
import org.jruby.runtime.ObjectAllocator;
import org.jruby.runtime.ThreadContext;
import org.jruby.runtime.Visibility;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.runtime.encoding.EncodingCapable;
import org.jruby.runtime.encoding.MarshalEncoding;
import org.jruby.runtime.marshal.MarshalStream;
import org.jruby.runtime.marshal.UnmarshalStream;
import org.jruby.util.ByteList;
import org.jruby.util.KCode;
import org.jruby.util.Pack;
import org.jruby.util.RegexpOptions;
import org.jruby.util.Sprintf;
import org.jruby.util.StringSupport;
import org.jruby.util.TypeConverter;
import org.jruby.util.io.EncodingUtils;
import org.jruby.util.collections.WeakValuedMap;

import java.util.Iterator;

@JRubyClass(name=&quot;Regexp&quot;)
public class RubyRegexp extends RubyObject implements ReOptions, EncodingCapable, MarshalEncoding {
    private Regex pattern;
<span class="fc" id="L82">    private ByteList str = ByteList.EMPTY_BYTELIST;</span>
    private RegexpOptions options;

    public static final int ARG_ENCODING_FIXED     =   16;
    public static final int ARG_ENCODING_NONE      =   32;

    public void setLiteral() {
<span class="fc" id="L89">        options.setLiteral(true);</span>
<span class="fc" id="L90">    }</span>

    public void clearLiteral() {
<span class="nc" id="L93">        options.setLiteral(false);</span>
<span class="nc" id="L94">    }</span>

    public boolean isLiteral() {
<span class="fc" id="L97">        return options.isLiteral();</span>
    }

    public boolean isKCodeDefault() {
<span class="nc" id="L101">        return options.isKcodeDefault();</span>
    }

    public void setEncodingNone() {
<span class="fc" id="L105">        options.setEncodingNone(true);</span>
<span class="fc" id="L106">    }</span>
    
    public void clearEncodingNone() {
<span class="nc" id="L109">        options.setEncodingNone(false);</span>
<span class="nc" id="L110">    }</span>

    public boolean isEncodingNone() {
<span class="fc" id="L113">        return options.isEncodingNone();</span>
    }

    public KCode getKCode() {
<span class="fc" id="L117">        return options.getKCode();</span>
    }

    @Override
    public Encoding getEncoding() {
<span class="fc" id="L122">        return pattern.getEncoding();</span>
    }

    @Override
    public void setEncoding(Encoding encoding) {
        // FIXME: Which encoding should be changed here?  
        // FIXME: transcode?
<span class="fc" id="L129">    }</span>

    @Override
    public boolean shouldMarshalEncoding() {
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        return getEncoding() != ASCIIEncoding.INSTANCE;</span>
    }

    @Override
    public Encoding getMarshalEncoding() {
<span class="fc" id="L138">        return getEncoding();</span>
    }
    // FIXME: Maybe these should not be static?
<span class="fc" id="L141">    static final WeakValuedMap&lt;ByteList, Regex&gt; patternCache = new WeakValuedMap();</span>
<span class="fc" id="L142">    static final WeakValuedMap&lt;ByteList, Regex&gt; quotedPatternCache = new WeakValuedMap();</span>
<span class="fc" id="L143">    static final WeakValuedMap&lt;ByteList, Regex&gt; preprocessedPatternCache = new WeakValuedMap();</span>

    private static Regex makeRegexp(Ruby runtime, ByteList bytes, RegexpOptions options, Encoding enc) {
        try {
<span class="fc" id="L147">            int p = bytes.getBegin();</span>
<span class="fc" id="L148">            return new Regex(bytes.getUnsafeBytes(), p, p + bytes.getRealSize(), options.toJoniOptions(), enc, Syntax.DEFAULT, runtime.getWarnings());</span>
<span class="nc" id="L149">        } catch (Exception e) {</span>
<span class="nc" id="L150">            raiseRegexpError19(runtime, bytes, enc, options, e.getMessage());</span>
<span class="nc" id="L151">            return null; // not reached</span>
        }
    }

    static Regex getRegexpFromCache(Ruby runtime, ByteList bytes, Encoding enc, RegexpOptions options) {
<span class="fc" id="L156">        Regex regex = patternCache.get(bytes);</span>
<span class="fc bfc" id="L157" title="All 6 branches covered.">        if (regex != null &amp;&amp; regex.getEncoding() == enc &amp;&amp; regex.getOptions() == options.toJoniOptions()) return regex;</span>
<span class="fc" id="L158">        regex = makeRegexp(runtime, bytes, options, enc);</span>
<span class="fc" id="L159">        regex.setUserObject(bytes);</span>
<span class="fc" id="L160">        patternCache.put(bytes, regex);</span>
<span class="fc" id="L161">        return regex;</span>
    }

    static Regex getQuotedRegexpFromCache(Ruby runtime, ByteList bytes, Encoding enc, RegexpOptions options) {
<span class="nc" id="L165">        Regex regex = quotedPatternCache.get(bytes);</span>
<span class="nc bnc" id="L166" title="All 6 branches missed.">        if (regex != null &amp;&amp; regex.getEncoding() == enc &amp;&amp; regex.getOptions() == options.toJoniOptions()) return regex;</span>
<span class="nc" id="L167">        ByteList quoted = quote(bytes, enc);</span>
<span class="nc" id="L168">        regex = makeRegexp(runtime, quoted, options, enc);</span>
<span class="nc" id="L169">        regex.setUserObject(quoted);</span>
<span class="nc" id="L170">        quotedPatternCache.put(bytes, regex);</span>
<span class="nc" id="L171">        return regex;</span>
    }

    static Regex getQuotedRegexpFromCache19(Ruby runtime, ByteList bytes, RegexpOptions options, boolean asciiOnly) {
<span class="fc" id="L175">        Regex regex = quotedPatternCache.get(bytes);</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">        Encoding enc = asciiOnly ? USASCIIEncoding.INSTANCE : bytes.getEncoding();</span>
<span class="pc bpc" id="L177" title="2 of 6 branches missed.">        if (regex != null &amp;&amp; regex.getEncoding() == enc &amp;&amp; regex.getOptions() == options.toJoniOptions()) return regex;</span>
<span class="fc" id="L178">        ByteList quoted = quote19(bytes, asciiOnly);</span>
<span class="fc" id="L179">        regex = makeRegexp(runtime, quoted, options, quoted.getEncoding());</span>
<span class="fc" id="L180">        regex.setUserObject(quoted);</span>
<span class="fc" id="L181">        quotedPatternCache.put(bytes, regex);</span>
<span class="fc" id="L182">        return regex;</span>
    }

    private static Regex getPreprocessedRegexpFromCache(Ruby runtime, ByteList bytes, Encoding enc, RegexpOptions options, ErrorMode mode) {
<span class="fc" id="L186">        Regex regex = preprocessedPatternCache.get(bytes);</span>
<span class="fc bfc" id="L187" title="All 6 branches covered.">        if (regex != null &amp;&amp; regex.getEncoding() == enc &amp;&amp; regex.getOptions() == options.toJoniOptions()) return regex;</span>
<span class="fc" id="L188">        ByteList preprocessed = preprocess(runtime, bytes, enc, new Encoding[]{null}, ErrorMode.RAISE);</span>
<span class="fc" id="L189">        regex = makeRegexp(runtime, preprocessed, options, enc);</span>
<span class="fc" id="L190">        regex.setUserObject(preprocessed);</span>
<span class="fc" id="L191">        preprocessedPatternCache.put(bytes, regex);</span>
<span class="fc" id="L192">        return regex;</span>
    }

    public static RubyClass createRegexpClass(Ruby runtime) {
<span class="fc" id="L196">        RubyClass regexpClass = runtime.defineClass(&quot;Regexp&quot;, runtime.getObject(), REGEXP_ALLOCATOR);</span>
<span class="fc" id="L197">        runtime.setRegexp(regexpClass);</span>

<span class="fc" id="L199">        regexpClass.setClassIndex(ClassIndex.REGEXP);</span>
<span class="fc" id="L200">        regexpClass.setReifiedClass(RubyRegexp.class);</span>
        
<span class="fc" id="L202">        regexpClass.kindOf = new RubyModule.JavaClassKindOf(RubyRegexp.class);</span>

<span class="fc" id="L204">        regexpClass.defineConstant(&quot;IGNORECASE&quot;, runtime.newFixnum(RE_OPTION_IGNORECASE));</span>
<span class="fc" id="L205">        regexpClass.defineConstant(&quot;EXTENDED&quot;, runtime.newFixnum(RE_OPTION_EXTENDED));</span>
<span class="fc" id="L206">        regexpClass.defineConstant(&quot;MULTILINE&quot;, runtime.newFixnum(RE_OPTION_MULTILINE));</span>

<span class="fc" id="L208">        regexpClass.defineConstant(&quot;FIXEDENCODING&quot;, runtime.newFixnum(ARG_ENCODING_FIXED));</span>
<span class="fc" id="L209">        regexpClass.defineConstant(&quot;NOENCODING&quot;, runtime.newFixnum(ARG_ENCODING_NONE));</span>

<span class="fc" id="L211">        regexpClass.defineAnnotatedMethods(RubyRegexp.class);</span>
<span class="fc" id="L212">        regexpClass.getSingletonClass().defineAlias(&quot;compile&quot;, &quot;new&quot;);</span>

<span class="fc" id="L214">        return regexpClass;</span>
    }

<span class="fc" id="L217">    private static ObjectAllocator REGEXP_ALLOCATOR = new ObjectAllocator() {</span>
        @Override
        public IRubyObject allocate(Ruby runtime, RubyClass klass) {
<span class="fc" id="L220">            return new RubyRegexp(runtime, klass);</span>
        }
    };
    
    public static int matcherSearch(Ruby runtime, Matcher matcher, int start, int range, int option) {
        try {
<span class="fc" id="L226">            RubyThread thread = runtime.getCurrentContext().getThread();</span>
<span class="fc" id="L227">            SearchMatchTask task = new SearchMatchTask(thread, matcher, start, range, option, false);</span>
<span class="fc" id="L228">            thread.executeBlockingTask(task);</span>
<span class="fc" id="L229">            return task.retval;</span>
<span class="nc" id="L230">        } catch (InterruptedException e) {</span>
<span class="nc" id="L231">            throw runtime.newInterruptedRegexpError(&quot;Regexp Interrupted&quot;);</span>
        }
    }
    
    public static int matcherMatch(Ruby runtime, Matcher matcher, int start, int range, int option) {
        try {
<span class="nc" id="L237">            RubyThread thread = runtime.getCurrentContext().getThread();</span>
<span class="nc" id="L238">            SearchMatchTask task = new SearchMatchTask(thread, matcher, start, range, option, true);</span>
<span class="nc" id="L239">            thread.executeBlockingTask(task);</span>
<span class="nc" id="L240">            return task.retval;</span>
<span class="nc" id="L241">        } catch (InterruptedException e) {</span>
<span class="nc" id="L242">            throw runtime.newInterruptedRegexpError(&quot;Regexp Interrupted&quot;);</span>
        }
    }
    
    private static class SearchMatchTask implements RubyThread.BlockingTask {
        int retval;
        final RubyThread thread;
        final Matcher matcher;
        final int start;
        final int range;
        final int option;
        final boolean match;
        
<span class="fc" id="L255">        SearchMatchTask(RubyThread thread, Matcher matcher, int start, int range, int option, boolean match) {</span>
<span class="fc" id="L256">            this.thread = thread;</span>
<span class="fc" id="L257">            this.matcher = matcher;</span>
<span class="fc" id="L258">            this.start = start;</span>
<span class="fc" id="L259">            this.range = range;</span>
<span class="fc" id="L260">            this.option = option;</span>
<span class="fc" id="L261">            this.match = match;</span>
<span class="fc" id="L262">        }</span>
        
        @Override
        public void run() throws InterruptedException {
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">            retval = match ?</span>
<span class="pc" id="L267">                    matcher.matchInterruptible(start, range, option) :</span>
<span class="fc" id="L268">                    matcher.searchInterruptible(start, range, option);</span>
<span class="fc" id="L269">        }</span>

        @Override
        public void wakeup() {
<span class="nc" id="L273">            thread.getNativeThread().interrupt();</span>
<span class="nc" id="L274">        }</span>
    }

    @Override
    public ClassIndex getNativeClassIndex() {
<span class="fc" id="L279">        return ClassIndex.REGEXP;</span>
    }

    /** used by allocator
     */
    private RubyRegexp(Ruby runtime, RubyClass klass) {
<span class="fc" id="L285">        super(runtime, klass);</span>
<span class="fc" id="L286">        this.options = new RegexpOptions();</span>
<span class="fc" id="L287">    }</span>

    /** default constructor
     */
    private RubyRegexp(Ruby runtime) {
<span class="fc" id="L292">        super(runtime, runtime.getRegexp());</span>
<span class="fc" id="L293">        this.options = new RegexpOptions();</span>
<span class="fc" id="L294">    }</span>

    private RubyRegexp(Ruby runtime, ByteList str) {
<span class="fc" id="L297">        this(runtime);</span>
<span class="fc" id="L298">        str.getClass();</span>
<span class="fc" id="L299">        this.str = str;</span>
<span class="fc" id="L300">        this.pattern = getRegexpFromCache(runtime, str, getEncoding(runtime, str), RegexpOptions.NULL_OPTIONS);</span>
<span class="fc" id="L301">    }</span>

    private RubyRegexp(Ruby runtime, ByteList str, RegexpOptions options) {
<span class="fc" id="L304">        this(runtime);</span>
<span class="fc" id="L305">        str.getClass();</span>

<span class="fc" id="L307">        initializeCommon19(str, str.getEncoding(), options);</span>
<span class="fc" id="L308">    }</span>

    private Encoding getEncoding(Ruby runtime, ByteList str) {
<span class="fc" id="L311">        return str.getEncoding();</span>
    }

    // used only by the compiler/interpreter (will set the literal flag)
    public static RubyRegexp newRegexp(Ruby runtime, String pattern, RegexpOptions options) {
<span class="fc" id="L316">        return newRegexp(runtime, ByteList.create(pattern), options);</span>
    }

    // used only by the compiler/interpreter (will set the literal flag)
    public static RubyRegexp newRegexp(Ruby runtime, ByteList pattern, int options) {
<span class="nc" id="L321">        return newRegexp(runtime, pattern, RegexpOptions.fromEmbeddedOptions(options));</span>
    }

    // used only by the compiler/interpreter (will set the literal flag)
    public static RubyRegexp newRegexp(Ruby runtime, ByteList pattern, RegexpOptions options) {
        try {
<span class="fc" id="L327">            return new RubyRegexp(runtime, pattern, (RegexpOptions)options.clone());</span>
<span class="fc" id="L328">        } catch (RaiseException re) {</span>
<span class="fc" id="L329">            throw runtime.newSyntaxError(re.getMessage());</span>
        }
    }

    // used only by the compiler/interpreter (will set the literal flag)
    public static RubyRegexp newDRegexp(Ruby runtime, RubyString pattern, RegexpOptions options) {
        try {
<span class="fc" id="L336">            return new RubyRegexp(runtime, pattern.getByteList(), (RegexpOptions)options.clone());</span>
<span class="fc" id="L337">        } catch (RaiseException re) {</span>
<span class="fc" id="L338">            throw runtime.newRegexpError(re.getMessage());</span>
        }
    }

    // used only by the compiler/interpreter (will set the literal flag)
    public static RubyRegexp newDRegexp(Ruby runtime, RubyString pattern, int joniOptions) {
        try {
<span class="nc" id="L345">            RegexpOptions options = RegexpOptions.fromJoniOptions(joniOptions);</span>
<span class="nc" id="L346">            return new RubyRegexp(runtime, pattern.getByteList(), options);</span>
<span class="nc" id="L347">        } catch (RaiseException re) {</span>
<span class="nc" id="L348">            throw runtime.newRegexpError(re.getMessage());</span>
        }
    }

    // used only by the compiler/interpreter (will set the literal flag)
    public static RubyRegexp newDRegexpEmbedded(Ruby runtime, RubyString pattern, int embeddedOptions) {
        try {
<span class="nc" id="L355">            RegexpOptions options = RegexpOptions.fromEmbeddedOptions(embeddedOptions);</span>
            // FIXME: Massive hack (fix in DRegexpNode too for interpreter)
<span class="nc bnc" id="L357" title="All 2 branches missed.">            if (pattern.getEncoding() == USASCIIEncoding.INSTANCE) {</span>
<span class="nc" id="L358">                pattern.setEncoding(ASCIIEncoding.INSTANCE);</span>
            }
<span class="nc" id="L360">            return new RubyRegexp(runtime, pattern.getByteList(), options);</span>
<span class="nc" id="L361">        } catch (RaiseException re) {</span>
<span class="nc" id="L362">            throw runtime.newRegexpError(re.getMessage());</span>
        }
    }
    
    public static RubyRegexp newDRegexpEmbedded19(Ruby runtime, IRubyObject[] strings, int embeddedOptions) {
        try {
<span class="nc" id="L368">            RegexpOptions options = RegexpOptions.fromEmbeddedOptions(embeddedOptions);</span>
<span class="nc" id="L369">            RubyString pattern = preprocessDRegexp(runtime, strings, options);</span>
            
<span class="nc" id="L371">            return new RubyRegexp(runtime, pattern.getByteList(), options);</span>
<span class="nc" id="L372">        } catch (RaiseException re) {</span>
<span class="nc" id="L373">            throw runtime.newRegexpError(re.getMessage());</span>
        }
        
    }
    
    public static RubyRegexp newRegexp(Ruby runtime, ByteList pattern) {
<span class="fc" id="L379">        return new RubyRegexp(runtime, pattern);</span>
    }

    static RubyRegexp newRegexp(Ruby runtime, ByteList str, Regex pattern) {
<span class="nc" id="L383">        RubyRegexp regexp = new RubyRegexp(runtime);</span>
<span class="nc" id="L384">        str.getClass();</span>
<span class="nc" id="L385">        regexp.str = str;</span>
<span class="nc" id="L386">        regexp.options = RegexpOptions.fromJoniOptions(pattern.getOptions());</span>
<span class="nc" id="L387">        regexp.pattern = pattern;</span>
<span class="nc" id="L388">        return regexp;</span>
    }
    
    // internal usage (Complex/Rational)
    static RubyRegexp newDummyRegexp(Ruby runtime, Regex regex) {
<span class="fc" id="L393">        RubyRegexp regexp = new RubyRegexp(runtime);</span>
<span class="fc" id="L394">        regexp.pattern = regex;</span>
<span class="fc" id="L395">        regexp.str = ByteList.EMPTY_BYTELIST;</span>
<span class="fc" id="L396">        regexp.options.setFixed(true);</span>
<span class="fc" id="L397">        return regexp;</span>
    }

    /** rb_reg_options
     */
    public RegexpOptions getOptions() {
<span class="fc" id="L403">        check();</span>
<span class="fc" id="L404">        return options;</span>
    }

    public final Regex getPattern() {
<span class="fc" id="L408">        check();</span>
<span class="fc" id="L409">        return pattern;</span>
    }

    private static void encodingMatchError(Ruby runtime, Regex pattern, Encoding strEnc) {
<span class="fc" id="L413">        throw runtime.newEncodingCompatibilityError(&quot;incompatible encoding regexp match (&quot; +</span>
<span class="fc" id="L414">                pattern.getEncoding() + &quot; regexp with &quot; + strEnc + &quot; string)&quot;);</span>
    }

    private Encoding checkEncoding(RubyString str, boolean warn) {
<span class="fc bfc" id="L418" title="All 2 branches covered.">        if (str.scanForCodeRange() == StringSupport.CR_BROKEN) {</span>
<span class="fc" id="L419">            throw getRuntime().newArgumentError(&quot;invalid byte sequence in &quot; + str.getEncoding());</span>
        }
<span class="fc" id="L421">        check();</span>
<span class="fc" id="L422">        Encoding enc = str.getEncoding();</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">        if (!enc.isAsciiCompatible()) {</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">            if (enc != pattern.getEncoding()) encodingMatchError(getRuntime(), pattern, enc);</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">        } else if (options.isFixed()) {</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">            if (enc != pattern.getEncoding() &amp;&amp; </span>
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">               (!pattern.getEncoding().isAsciiCompatible() ||</span>
<span class="pc bfc" id="L428" title="All 2 branches covered.">               str.scanForCodeRange() != StringSupport.CR_7BIT)) encodingMatchError(getRuntime(), pattern, enc);</span>
<span class="fc" id="L429">            enc = pattern.getEncoding();</span>
        }
<span class="pc bpc" id="L431" title="3 of 8 branches missed.">        if (warn &amp;&amp; isEncodingNone() &amp;&amp; enc != ASCIIEncoding.INSTANCE &amp;&amp; str.scanForCodeRange() != StringSupport.CR_7BIT) {</span>
<span class="nc" id="L432">            getRuntime().getWarnings().warn(ID.REGEXP_MATCH_AGAINST_STRING, &quot;regexp match /.../n against to &quot; + enc + &quot; string&quot;);</span>
        }
<span class="fc" id="L434">        return enc;</span>
    }

    public final Regex preparePattern(RubyString str) {
<span class="fc" id="L438">        check();</span>
<span class="fc" id="L439">        Encoding enc = checkEncoding(str, true);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">        if (enc == pattern.getEncoding()) return pattern;</span>
<span class="fc" id="L441">        return getPreprocessedRegexpFromCache(getRuntime(), this.str, enc, options, ErrorMode.PREPROCESS);</span>
    }

    static Regex preparePattern(Ruby runtime, Regex pattern, RubyString str) {
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">        if (str.scanForCodeRange() == StringSupport.CR_BROKEN) {</span>
<span class="nc" id="L446">            throw runtime.newArgumentError(&quot;invalid byte sequence in &quot; + str.getEncoding());</span>
        }
<span class="fc" id="L448">        Encoding enc = str.getEncoding();</span>
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">        if (!enc.isAsciiCompatible()) {</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">            if (enc != pattern.getEncoding()) encodingMatchError(runtime, pattern, enc);</span>
        }
        // TODO: check for isKCodeDefault() somehow
//        if (warn &amp;&amp; isEncodingNone() &amp;&amp; enc != ASCIIEncoding.INSTANCE &amp;&amp; str.scanForCodeRange() != StringSupport.CR_7BIT) {
//            getRuntime().getWarnings().warn(ID.REGEXP_MATCH_AGAINST_STRING, &quot;regexp match /.../n against to &quot; + enc + &quot; string&quot;);
//        }
<span class="fc bfc" id="L456" title="All 2 branches covered.">        if (enc == pattern.getEncoding()) return pattern;</span>
<span class="fc" id="L457">        return getPreprocessedRegexpFromCache(runtime, (ByteList)pattern.getUserObject(), enc, RegexpOptions.fromJoniOptions(pattern.getOptions()), ErrorMode.PREPROCESS);</span>
    }

<span class="pc" id="L460">    private static enum ErrorMode {RAISE, PREPROCESS, DESC} </span>

    private static int raisePreprocessError(Ruby runtime, ByteList str, String err, ErrorMode mode) {
<span class="pc bnc" id="L463" title="All 3 branches missed.">        switch (mode) {</span>
        case RAISE:
<span class="nc" id="L465">            raiseRegexpError19(runtime, str, str.getEncoding(), RegexpOptions.NULL_OPTIONS, err);</span>
        case PREPROCESS:
<span class="nc" id="L467">            throw runtime.newArgumentError(&quot;regexp preprocess failed: &quot; + err);</span>
        case DESC:
            // silent ?
        }
<span class="nc" id="L471">        return 0;</span>
    }

    private static int readEscapedByte(Ruby runtime, byte[]to, int toP, byte[]bytes, int p, int end, ByteList str, ErrorMode mode) {
<span class="pc bpc" id="L475" title="2 of 4 branches missed.">        if (p == end || bytes[p++] != (byte)'\\') raisePreprocessError(runtime, str, &quot;too short escaped multibyte character&quot;, mode);</span>

<span class="fc" id="L477">        boolean metaPrefix = false, ctrlPrefix = false;</span>
<span class="fc" id="L478">        int code = 0;</span>
        while (true) {
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">            if (p == end) raisePreprocessError(runtime, str, &quot;too short escape sequence&quot;, mode);</span>

<span class="pc bpc" id="L482" title="11 of 14 branches missed.">            switch (bytes[p++]) {</span>
<span class="nc" id="L483">            case '\\': code = '\\'; break;</span>
<span class="nc" id="L484">            case 'n': code = '\n'; break;</span>
<span class="nc" id="L485">            case 't': code = '\t'; break;</span>
<span class="nc" id="L486">            case 'r': code = '\r'; break;</span>
<span class="nc" id="L487">            case 'f': code = '\f'; break;</span>
<span class="nc" id="L488">            case 'v': code = '\013'; break;</span>
<span class="nc" id="L489">            case 'a': code = '\007'; break;</span>
<span class="nc" id="L490">            case 'e': code = '\033'; break;</span>

            /* \OOO */
            case '0': case '1': case '2': case '3':
            case '4': case '5': case '6': case '7':
<span class="fc" id="L495">                p--;</span>
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">                int olen = end &lt; p + 3 ? end - p : 3;</span>
<span class="fc" id="L497">                code = StringSupport.scanOct(bytes, p, olen);</span>
<span class="fc" id="L498">                p += StringSupport.octLength(bytes, p, olen);</span>
<span class="fc" id="L499">                break;</span>

            case 'x': /* \xHH */
<span class="fc bfc" id="L502" title="All 2 branches covered.">                int hlen = end &lt; p + 2 ? end - p : 2;</span>
<span class="fc" id="L503">                code = StringSupport.scanHex(bytes, p, hlen);</span>
<span class="fc" id="L504">                int len = StringSupport.hexLength(bytes, p, hlen);</span>
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">                if (len &lt; 1) raisePreprocessError(runtime, str, &quot;invalid hex escape&quot;, mode);</span>
<span class="fc" id="L506">                p += len;</span>
<span class="fc" id="L507">                break;</span>

            case 'M': /* \M-X, \M-\C-X, \M-\cX */
<span class="nc bnc" id="L510" title="All 2 branches missed.">                if (metaPrefix) raisePreprocessError(runtime, str, &quot;duplicate meta escape&quot;, mode);</span>
<span class="nc" id="L511">                metaPrefix = true;</span>
<span class="nc bnc" id="L512" title="All 6 branches missed.">                if (p + 1 &lt; end &amp;&amp; bytes[p++] == (byte)'-' &amp;&amp; (bytes[p] &amp; 0x80) == 0) {</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">                    if (bytes[p] == (byte)'\\') {</span>
<span class="nc" id="L514">                        p++;</span>
<span class="nc" id="L515">                        continue;</span>
                    } else {
<span class="nc" id="L517">                        code = bytes[p++] &amp; 0xff;</span>
<span class="nc" id="L518">                        break;</span>
                    }
                }
<span class="nc" id="L521">                raisePreprocessError(runtime, str, &quot;too short meta escape&quot;, mode);</span>

            case 'C': /* \C-X, \C-\M-X */
<span class="nc bnc" id="L524" title="All 4 branches missed.">                if (p == end || bytes[p++] != (byte)'-') raisePreprocessError(runtime, str, &quot;too short control escape&quot;, mode);</span>

            case 'c': /* \cX, \c\M-X */
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">                if (ctrlPrefix) raisePreprocessError(runtime, str, &quot;duplicate control escape&quot;, mode);</span>
<span class="fc" id="L528">                ctrlPrefix = true;</span>
<span class="pc bpc" id="L529" title="2 of 4 branches missed.">                if (p &lt; end &amp;&amp; (bytes[p] &amp; 0x80) == 0) {</span>
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">                    if (bytes[p] == (byte)'\\') {</span>
<span class="nc" id="L531">                        p++;</span>
<span class="nc" id="L532">                        continue;</span>
                    } else {
<span class="fc" id="L534">                        code = bytes[p++] &amp; 0xff;</span>
<span class="fc" id="L535">                        break;</span>
                    }
                }
<span class="nc" id="L538">                raisePreprocessError(runtime, str, &quot;too short control escape&quot;, mode);</span>
            default:
<span class="nc" id="L540">                raisePreprocessError(runtime, str, &quot;unexpected escape sequence&quot;, mode);</span>
            } // switch

<span class="pc bpc" id="L543" title="2 of 4 branches missed.">            if (code &lt; 0 || code &gt; 0xff) raisePreprocessError(runtime, str, &quot;invalid escape code&quot;, mode);</span>

<span class="fc bfc" id="L545" title="All 2 branches covered.">            if (ctrlPrefix) code &amp;= 0x1f;</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">            if (metaPrefix) code |= 0x80;</span>

<span class="fc" id="L548">            to[toP] = (byte)code;</span>
<span class="fc" id="L549">            return p;</span>
        } // while
    }

    /**
     * Unescape escaped non-ascii character at start position, appending all
     * to the given bytelist if provided.
     * 
     * @param runtime current runtime
     * @param to output bytelist; if null, no appending will be done
     * @param bytes incoming bytes
     * @param p start position
     * @param end end position
     * @param enc bytes' encoding
     * @param encp out param for fixed encoding
     * @param str original bytes wrapper
     * @param mode error mode
     * @return new position after performing unescaping
     */
    // MRI: unescape_escapted_nonascii
    private static int unescapeEscapedNonAscii(Ruby runtime, ByteList to, byte[]bytes, int p, int end, Encoding enc, Encoding[]encp, ByteList str, ErrorMode mode) {
<span class="fc" id="L570">        byte[]chBuf = new byte[enc.maxLength()];</span>
<span class="fc" id="L571">        int chLen = 0;</span>

<span class="fc" id="L573">        p = readEscapedByte(runtime, chBuf, chLen++, bytes, p, end, str, mode);</span>
<span class="pc bpc" id="L574" title="1 of 4 branches missed.">        while (chLen &lt; enc.maxLength() &amp;&amp; StringSupport.preciseLength(enc, chBuf, 0, chLen) &lt; -1) { // MBCLEN_NEEDMORE_P</span>
<span class="nc" id="L575">            p = readEscapedByte(runtime, chBuf, chLen++, bytes, p, end, str, mode);</span>
        }

<span class="fc" id="L578">        int cl = StringSupport.preciseLength(enc, chBuf, 0, chLen);</span>
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">        if (cl == -1) {</span>
<span class="nc" id="L580">            raisePreprocessError(runtime, str, &quot;invalid multibyte escape&quot;, mode); // MBCLEN_INVALID_P</span>
        }

<span class="pc bpc" id="L583" title="1 of 4 branches missed.">        if (chLen &gt; 1 || (chBuf[0] &amp; 0x80) != 0) {</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">            if (to != null) to.append(chBuf, 0, chLen);</span>

<span class="fc bfc" id="L586" title="All 2 branches covered.">            if (encp[0] == null) {</span>
<span class="fc" id="L587">                encp[0] = enc;</span>
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">            } else if (encp[0] != enc) {</span>
<span class="nc" id="L589">                raisePreprocessError(runtime, str, &quot;escaped non ASCII character in UTF-8 regexp&quot;, mode);</span>
            }
        } else {
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">            if (to != null) Sprintf.sprintf(runtime, to, &quot;\\x%02X&quot;, chBuf[0] &amp; 0xff);</span>
        }
<span class="fc" id="L594">        return p;</span>
    }

    private static void checkUnicodeRange(Ruby runtime, int code, ByteList str, ErrorMode mode) {
        // Unicode is can be only 21 bits long, int is enough
<span class="pc bpc" id="L599" title="4 of 6 branches missed.">        if ((0xd800 &lt;= code &amp;&amp; code &lt;= 0xdfff) /* Surrogates */ || 0x10ffff &lt; code) {</span>
<span class="nc" id="L600">            raisePreprocessError(runtime, str, &quot;invalid Unicode range&quot;, mode);</span>
        }
<span class="fc" id="L602">    }</span>

    /**
     * Append the given utf8 characters to the buffer, if given, checking for
     * errors along the way.
     * 
     * @param runtime current runtime
     * @param to output buffer; if null, no appending will be done
     * @param code utf8 character code
     * @param enc output param for new encoding
     * @param str original wrapper of source bytes
     * @param mode error mode
     */
    private static void appendUtf8(Ruby runtime, ByteList to, int code, Encoding[] enc, ByteList str, ErrorMode mode) {
<span class="fc" id="L616">        checkUnicodeRange(runtime, code, str, mode);</span>

<span class="fc bfc" id="L618" title="All 2 branches covered.">        if (code &lt; 0x80) {</span>
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">            if (to != null) Sprintf.sprintf(runtime, to, &quot;\\x%02X&quot;, code);</span>
        } else {
<span class="pc bpc" id="L621" title="1 of 2 branches missed.">            if (to != null) {</span>
<span class="fc" id="L622">                to.ensure(to.getRealSize() + 6);</span>
<span class="fc" id="L623">                to.setRealSize(to.getRealSize() + Pack.utf8Decode(runtime, to.getUnsafeBytes(), to.getBegin() + to.getRealSize(), code));</span>
            }
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">            if (enc[0] == null) {</span>
<span class="fc" id="L626">                enc[0] = UTF8Encoding.INSTANCE;</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">            } else if (!(enc[0] instanceof UTF8Encoding)) { // do not load the class if not used</span>
<span class="nc" id="L628">                raisePreprocessError(runtime, str, &quot;UTF-8 character in non UTF-8 regexp&quot;, mode);</span>
            }
        }
<span class="fc" id="L631">    }</span>
    
    /**
     * Unescape unicode characters at given offset, appending to the given
     * out buffer if provided.
     * 
     * @param runtime current runtime
     * @param to output buffer; if null, no appending will be done
     * @param bytes input bytes
     * @param p start position
     * @param end end position
     * @param encp out param for fixed encoding
     * @param str original bytes wrapper
     * @param mode error mode
     * @return new position after unescaping
     */
    private static int unescapeUnicodeList(Ruby runtime, ByteList to, byte[]bytes, int p, int end, Encoding[]encp, ByteList str, ErrorMode mode) {
<span class="pc bpc" id="L648" title="2 of 4 branches missed.">        while (p &lt; end &amp;&amp; ASCIIEncoding.INSTANCE.isSpace(bytes[p] &amp; 0xff)) p++;</span>

<span class="fc" id="L650">        boolean hasUnicode = false; </span>
        while (true) {
<span class="fc" id="L652">            int code = StringSupport.scanHex(bytes, p, end - p);</span>
<span class="fc" id="L653">            int len = StringSupport.hexLength(bytes, p, end - p);</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">            if (len == 0) break;</span>
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">            if (len &gt; 6) raisePreprocessError(runtime, str, &quot;invalid Unicode range&quot;, mode);</span>
<span class="fc" id="L656">            p += len;</span>
<span class="pc bpc" id="L657" title="1 of 2 branches missed.">            if (to != null) appendUtf8(runtime, to, code, encp, str, mode);</span>
<span class="fc" id="L658">            hasUnicode = true;</span>
<span class="pc bpc" id="L659" title="2 of 4 branches missed.">            while (p &lt; end &amp;&amp; ASCIIEncoding.INSTANCE.isSpace(bytes[p] &amp; 0xff)) p++;</span>
<span class="fc" id="L660">        }</span>

<span class="pc bpc" id="L662" title="1 of 2 branches missed.">        if (!hasUnicode) raisePreprocessError(runtime, str, &quot;invalid Unicode list&quot;, mode); </span>
<span class="fc" id="L663">        return p;</span>
    }

    /**
     * Unescape unicode BMP char at given offset, appending to the specified
     * buffer if non-null.
     * 
     * @param runtime current runtime
     * @param to output buffer; if null, no appending will be done
     * @param bytes input bytes
     * @param p start position
     * @param end end position
     * @param encp out param for fixed encoding
     * @param str original bytes wrapper
     * @param mode error mode
     * @return new position after unescaping
     */
    private static int unescapeUnicodeBmp(Ruby runtime, ByteList to, byte[] bytes, int p, int end, Encoding[] encp, ByteList str, ErrorMode mode) {
<span class="nc bnc" id="L681" title="All 2 branches missed.">        if (p + 4 &gt; end) raisePreprocessError(runtime, str, &quot;invalid Unicode escape&quot;, mode);</span>
<span class="nc" id="L682">        int code = StringSupport.scanHex(bytes, p, 4);</span>
<span class="nc" id="L683">        int len = StringSupport.hexLength(bytes, p, 4);</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">        if (len != 4) raisePreprocessError(runtime, str, &quot;invalid Unicode escape&quot;, mode);</span>
<span class="nc" id="L685">        appendUtf8(runtime, to, code, encp, str, mode);</span>
<span class="nc" id="L686">        return p + 4;</span>
    }

    /**
     * Unescape non-ascii elements in the given string, appending the results
     * to the given bytelist if provided.
     * 
     * @param runtime current runtime
     * @param to output bytelist; if null, no appending will be done
     * @param bytes the bytes to unescape
     * @param p starting position
     * @param end ending position
     * @param enc bytes' encoding
     * @param encp out param for fixed encoding
     * @param str original wrapper for the bytes
     * @param mode error mode
     * @return whether any propery elements were encountered while walking
     */
    private static boolean unescapeNonAscii(Ruby runtime, ByteList to, byte[]bytes, int p, int end, Encoding enc, Encoding[]encp, ByteList str, ErrorMode mode) {
<span class="fc" id="L705">        boolean hasProperty = false;</span>

<span class="fc bfc" id="L707" title="All 2 branches covered.">        while (p &lt; end) {</span>
<span class="fc" id="L708">            int cl = StringSupport.preciseLength(enc, bytes, p, end);</span>
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">            if (cl &lt;= 0) raisePreprocessError(runtime, str, &quot;invalid multibyte character&quot;, mode);</span>
<span class="fc bfc" id="L710" title="All 4 branches covered.">            if (cl &gt; 1 || (bytes[p] &amp; 0x80) != 0) {</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">                if (to != null) to.append(bytes, p, cl);</span>
<span class="fc" id="L712">                p += cl;</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">                if (encp[0] == null) {</span>
<span class="fc" id="L714">                    encp[0] = enc;</span>
<span class="pc bpc" id="L715" title="1 of 2 branches missed.">                } else if (encp[0] != enc) {</span>
<span class="nc" id="L716">                    raisePreprocessError(runtime, str, &quot;non ASCII character in UTF-8 regexp&quot;, mode);</span>
                }
                continue;
            }
            int c;
<span class="fc bfc" id="L721" title="All 2 branches covered.">            switch (c = bytes[p++] &amp; 0xff) {</span>
            case '\\':
<span class="pc bpc" id="L723" title="1 of 2 branches missed.">                if (p == end) raisePreprocessError(runtime, str, &quot;too short escape sequence&quot;, mode);</span>

<span class="fc bfc" id="L725" title="All 5 branches covered.">                switch (c = bytes[p++] &amp; 0xff) {</span>
                case '1': case '2': case '3':
                case '4': case '5': case '6': case '7': /* \O, \OO, \OOO or backref */
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">                    if (StringSupport.scanOct(bytes, p - 1, end - (p - 1)) &lt;= 0177) {</span>
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">                        if (to != null) to.append('\\').append(c);</span>
                        break;
                    }

                case '0': /* \0, \0O, \0OO */
                case 'x': /* \xHH */
                case 'c': /* \cX, \c\M-X */
                case 'C': /* \C-X, \C-\M-X */
                case 'M': /* \M-X, \M-\C-X, \M-\cX */
<span class="fc" id="L738">                    p = unescapeEscapedNonAscii(runtime, to, bytes, p - 2, end, enc, encp, str, mode);</span>
<span class="fc" id="L739">                    break;</span>

                case 'u':
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">                    if (p == end) raisePreprocessError(runtime, str, &quot;too short escape sequence&quot;, mode);</span>
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">                    if (bytes[p] == (byte)'{') { /* \\u{H HH HHH HHHH HHHHH HHHHHH ...} */</span>
<span class="fc" id="L744">                        p++;</span>
<span class="fc" id="L745">                        p = unescapeUnicodeList(runtime, to, bytes, p, end, encp, str, mode);</span>
<span class="pc bpc" id="L746" title="2 of 4 branches missed.">                        if (p == end || bytes[p++] != (byte)'}') raisePreprocessError(runtime, str, &quot;invalid Unicode list&quot;, mode);</span>
                    } else { /* \\uHHHH */
<span class="nc" id="L748">                        p = unescapeUnicodeBmp(runtime, to, bytes, p, end, encp, str, mode);</span>
                    }
<span class="nc" id="L750">                    break;</span>
                case 'p': /* \p{Hiragana} */
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">                    if (encp[0] == null) hasProperty = true;</span>
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">                    if (to != null) to.append('\\').append(c);</span>
                    break;

                default:
<span class="fc bfc" id="L757" title="All 2 branches covered.">                    if (to != null) to.append('\\').append(c);</span>
                    break;
                } // inner switch
                break;

            default:
<span class="fc bfc" id="L763" title="All 2 branches covered.">                if (to != null) to.append(c);</span>
            } // switch
<span class="fc" id="L765">        } // while</span>
<span class="fc" id="L766">        return hasProperty;</span>
    }


    /**
     * Preprocess the given string for use in regexp, raising errors for encoding
     * incompatibilities that arise.
     * 
     * This version produces a new unescaped version of the string based on
     * fixes performed while walking.
     * 
     * @param runtime current runtime
     * @param str string to preprocess
     * @param enc string's encoding
     * @param fixedEnc new encoding after fixing
     * @param mode mode of errors
     * @return a new unescaped string
     */
    private static ByteList preprocess(Ruby runtime, ByteList str, Encoding enc, Encoding[]fixedEnc, ErrorMode mode) {
<span class="fc" id="L785">        ByteList to = new ByteList(str.getRealSize());</span>

<span class="fc bfc" id="L787" title="All 2 branches covered.">        if (enc.isAsciiCompatible()) {</span>
<span class="fc" id="L788">            fixedEnc[0] = null;</span>
        } else {
<span class="fc" id="L790">            fixedEnc[0] = enc;</span>
<span class="fc" id="L791">            to.setEncoding(enc);</span>
        }

<span class="fc" id="L794">        boolean hasProperty = unescapeNonAscii(runtime, to, str.getUnsafeBytes(), str.getBegin(), str.getBegin() + str.getRealSize(), enc, fixedEnc, str, mode);</span>
<span class="pc bpc" id="L795" title="1 of 4 branches missed.">        if (hasProperty &amp;&amp; fixedEnc[0] == null) fixedEnc[0] = enc;</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">        if (fixedEnc[0] != null) to.setEncoding(fixedEnc[0]);</span>
<span class="fc" id="L797">        return to;</span>
    }

    /**
     * Preprocess the given string for use in regexp, raising errors for encoding
     * incompatibilities that arise.
     * 
     * This version does not produce a new, unescaped version of the bytelist,
     * and simply does the string-walking portion of the logic.
     * 
     * @param runtime current runtime
     * @param str string to preprocess
     * @param enc string's encoding
     * @param fixedEnc new encoding after fixing
     * @param mode mode of errors
     */
    private static void preprocessLight(Ruby runtime, ByteList str, Encoding enc, Encoding[]fixedEnc, ErrorMode mode) {
<span class="pc bpc" id="L814" title="1 of 2 branches missed.">        if (enc.isAsciiCompatible()) {</span>
<span class="fc" id="L815">            fixedEnc[0] = null;</span>
        } else {
<span class="nc" id="L817">            fixedEnc[0] = enc;</span>
        }

<span class="fc" id="L820">        boolean hasProperty = unescapeNonAscii(runtime, null, str.getUnsafeBytes(), str.getBegin(), str.getBegin() + str.getRealSize(), enc, fixedEnc, str, mode);</span>
<span class="pc bpc" id="L821" title="3 of 4 branches missed.">        if (hasProperty &amp;&amp; fixedEnc[0] == null) fixedEnc[0] = enc;</span>
<span class="fc" id="L822">    }</span>

    public static void preprocessCheck(Ruby runtime, ByteList bytes) {
<span class="fc" id="L825">        preprocess(runtime, bytes, bytes.getEncoding(), new Encoding[]{null}, ErrorMode.RAISE);</span>
<span class="fc" id="L826">    }</span>

    public static RubyString preprocessDRegexp(Ruby runtime, RubyString[] strings, int embeddedOptions) {
<span class="nc" id="L829">        return preprocessDRegexp(runtime, strings, RegexpOptions.fromEmbeddedOptions(embeddedOptions));</span>
    }
    
    // rb_reg_preprocess_dregexp
    public static RubyString preprocessDRegexp(Ruby runtime, IRubyObject[] strings, RegexpOptions options) {
<span class="fc" id="L834">        RubyString string = null;</span>
<span class="fc" id="L835">        Encoding regexpEnc = null;</span>
<span class="fc" id="L836">        Encoding[] fixedEnc = new Encoding[1];</span>
        
<span class="fc bfc" id="L838" title="All 2 branches covered.">        for (int i = 0; i &lt; strings.length; i++) {</span>
<span class="fc" id="L839">            RubyString str = strings[i].convertToString();</span>
<span class="fc" id="L840">            Encoding strEnc = str.getEncoding();</span>
            
<span class="fc bfc" id="L842" title="All 4 branches covered.">            if (options.isEncodingNone() &amp;&amp; strEnc != ASCIIEncoding.INSTANCE) {</span>
<span class="pc bpc" id="L843" title="1 of 2 branches missed.">                if (str.scanForCodeRange() != StringSupport.CR_7BIT) {</span>
<span class="nc" id="L844">                    throw runtime.newRegexpError(&quot;/.../n has a non escaped non ASCII character in non ASCII-8BIT script&quot;);</span>
                }
<span class="fc" id="L846">                strEnc = ASCIIEncoding.INSTANCE;</span>
            }
            
            // This used to call preprocess, but the resulting bytelist was not
            // used. Since the preprocessing error-checking can be done without
            // creating a new bytelist, I added a &quot;light&quot; path.
<span class="fc" id="L852">            RubyRegexp.preprocessLight(runtime, str.getByteList(), strEnc, fixedEnc, RubyRegexp.ErrorMode.PREPROCESS);</span>
            
<span class="fc bfc" id="L854" title="All 2 branches covered.">            if (fixedEnc[0] != null) {</span>
<span class="pc bpc" id="L855" title="3 of 4 branches missed.">                if (regexpEnc != null &amp;&amp; regexpEnc != fixedEnc[0]) {</span>
<span class="nc" id="L856">                    throw runtime.newRegexpError(&quot;encoding mismatch in dynamic regexp: &quot; + new String(regexpEnc.getName()) + &quot; and &quot; + new String(fixedEnc[0].getName()));</span>
                }
<span class="fc" id="L858">                regexpEnc = fixedEnc[0];</span>
            }
            
<span class="fc bfc" id="L861" title="All 2 branches covered.">            if (string == null) {</span>
<span class="fc" id="L862">                string = (RubyString)str.dup();</span>
            } else {
<span class="fc" id="L864">                string.append19(str);</span>
            }
        }
        
<span class="fc bfc" id="L868" title="All 2 branches covered.">        if (regexpEnc != null) {</span>
<span class="fc" id="L869">            string.setEncoding(regexpEnc);</span>
        }

<span class="fc" id="L872">        return string;</span>
    }

    private void check() {
<span class="fc bfc" id="L876" title="All 2 branches covered.">        if (pattern == null) throw getRuntime().newTypeError(&quot;uninitialized Regexp&quot;);</span>
<span class="fc" id="L877">    }</span>

    @JRubyMethod(meta = true)
    public static IRubyObject try_convert(ThreadContext context, IRubyObject recv, IRubyObject args) {
<span class="fc" id="L881">        return TypeConverter.convertToTypeWithCheck(args, context.runtime.getRegexp(), &quot;to_regexp&quot;);</span>
    }

    /** rb_reg_s_quote
     * 
     */
    @JRubyMethod(name = {&quot;quote&quot;, &quot;escape&quot;}, meta = true)
    public static IRubyObject quote19(ThreadContext context, IRubyObject recv, IRubyObject arg) {
<span class="fc" id="L889">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L890">        RubyString str = operandCheck(runtime, arg);</span>
<span class="fc" id="L891">        return RubyString.newStringShared(runtime, quote19(str.getByteList(), str.isAsciiOnly()));</span>
    }

    /** rb_reg_quote
     *
     */
    private static ByteList quote(ByteList bs, Encoding enc) {
<span class="nc" id="L898">        int p = bs.getBegin();</span>
<span class="nc" id="L899">        int end = p + bs.getRealSize();</span>
<span class="nc" id="L900">        byte[]bytes = bs.getUnsafeBytes();</span>

        metaFound: do {
<span class="nc bnc" id="L903" title="All 2 branches missed.">            for(; p &lt; end; p++) {</span>
<span class="nc" id="L904">                int c = bytes[p] &amp; 0xff;</span>
<span class="nc" id="L905">                int cl = enc.length(bytes, p, end);</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">                if (cl != 1) {</span>
<span class="nc bnc" id="L907" title="All 4 branches missed.">                    while (cl-- &gt; 0 &amp;&amp; p &lt; end) p++;</span>
<span class="nc" id="L908">                    p--;</span>
<span class="nc" id="L909">                    continue;</span>
                }
<span class="nc bnc" id="L911" title="All 2 branches missed.">                switch (c) {</span>
                case '[': case ']': case '{': case '}':
                case '(': case ')': case '|': case '-':
                case '*': case '.': case '\\':
                case '?': case '+': case '^': case '$':
                case ' ': case '#':
                case '\t': case '\f': case '\n': case '\r':
<span class="nc" id="L918">                    break metaFound;</span>
                }
            }
<span class="nc" id="L921">            return bs;</span>
        } while (false);

<span class="nc" id="L924">        ByteList result = new ByteList(end * 2);</span>
<span class="nc" id="L925">        byte[]obytes = result.getUnsafeBytes();</span>
<span class="nc" id="L926">        int op = p - bs.getBegin();</span>
<span class="nc" id="L927">        System.arraycopy(bytes, bs.getBegin(), obytes, 0, op);</span>

<span class="nc bnc" id="L929" title="All 2 branches missed.">        for(; p &lt; end; p++) {</span>
<span class="nc" id="L930">            int c = bytes[p] &amp; 0xff;</span>
<span class="nc" id="L931">            int cl = enc.length(bytes, p, end);</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">            if (cl != 1) {</span>
<span class="nc bnc" id="L933" title="All 4 branches missed.">                while (cl-- &gt; 0 &amp;&amp; p &lt; end) obytes[op++] = bytes[p++];</span>
<span class="nc" id="L934">                p--;</span>
<span class="nc" id="L935">                continue;</span>
            }

<span class="nc bnc" id="L938" title="All 7 branches missed.">            switch (c) {</span>
            case '[': case ']': case '{': case '}':
            case '(': case ')': case '|': case '-':
            case '*': case '.': case '\\':
            case '?': case '+': case '^': case '$':
<span class="nc" id="L943">            case '#': obytes[op++] = '\\'; break;</span>
<span class="nc" id="L944">            case ' ': obytes[op++] = '\\'; obytes[op++] = ' '; continue;</span>
<span class="nc" id="L945">            case '\t':obytes[op++] = '\\'; obytes[op++] = 't'; continue;</span>
<span class="nc" id="L946">            case '\n':obytes[op++] = '\\'; obytes[op++] = 'n'; continue;</span>
<span class="nc" id="L947">            case '\r':obytes[op++] = '\\'; obytes[op++] = 'r'; continue;</span>
<span class="nc" id="L948">            case '\f':obytes[op++] = '\\'; obytes[op++] = 'f'; continue;</span>
            }
<span class="nc" id="L950">            obytes[op++] = (byte)c;</span>
        }

<span class="nc" id="L953">        result.setRealSize(op);</span>
<span class="nc" id="L954">        return result;</span>
    }

    private static final int QUOTED_V = 11;
    public static ByteList quote19(ByteList bs, boolean asciiOnly) {
<span class="fc" id="L959">        int p = bs.getBegin();</span>
<span class="fc" id="L960">        int end = p + bs.getRealSize();</span>
<span class="fc" id="L961">        byte[]bytes = bs.getUnsafeBytes();</span>
<span class="fc" id="L962">        Encoding enc = bs.getEncoding();</span>

        metaFound: do {
<span class="fc bfc" id="L965" title="All 2 branches covered.">            while (p &lt; end) {</span>
                final int c;
                final int cl;
<span class="fc bfc" id="L968" title="All 2 branches covered.">                if (enc.isAsciiCompatible()) {</span>
<span class="fc" id="L969">                    cl = 1;</span>
<span class="fc" id="L970">                    c = bytes[p] &amp; 0xff;</span>
                } else {
<span class="fc" id="L972">                    cl = StringSupport.preciseLength(enc, bytes, p, end);</span>
<span class="fc" id="L973">                    c = enc.mbcToCode(bytes, p, end);</span>
                }

<span class="fc bfc" id="L976" title="All 2 branches covered.">                if (!Encoding.isAscii(c)) {</span>
<span class="fc" id="L977">                    p += StringSupport.length(enc, bytes, p, end);</span>
<span class="fc" id="L978">                    continue;</span>
                }
                
<span class="fc bfc" id="L981" title="All 2 branches covered.">                switch (c) {</span>
                case '[': case ']': case '{': case '}':
                case '(': case ')': case '|': case '-':
                case '*': case '.': case '\\':
                case '?': case '+': case '^': case '$':
                case ' ': case '#':
                case '\t': case '\f': case QUOTED_V: case '\n': case '\r':
<span class="fc" id="L988">                    break metaFound;</span>
                }
<span class="fc" id="L990">                p += cl;</span>
<span class="fc" id="L991">            }</span>
<span class="fc bfc" id="L992" title="All 2 branches covered.">            if (asciiOnly) {</span>
<span class="fc" id="L993">                ByteList tmp = bs.shallowDup();</span>
<span class="fc" id="L994">                tmp.setEncoding(USASCIIEncoding.INSTANCE);</span>
<span class="fc" id="L995">                return tmp;</span>
            }
<span class="fc" id="L997">            return bs;</span>
        } while (false);

<span class="fc" id="L1000">        ByteList result = new ByteList(end * 2);</span>
<span class="pc bpc" id="L1001" title="1 of 2 branches missed.">        result.setEncoding(asciiOnly ? USASCIIEncoding.INSTANCE : bs.getEncoding());</span>
<span class="fc" id="L1002">        byte[]obytes = result.getUnsafeBytes();</span>
<span class="fc" id="L1003">        int op = p - bs.getBegin();</span>
<span class="fc" id="L1004">        System.arraycopy(bytes, bs.getBegin(), obytes, 0, op);</span>

<span class="fc bfc" id="L1006" title="All 2 branches covered.">        while (p &lt; end) {</span>
            final int c;
            final int cl;
<span class="pc bpc" id="L1009" title="1 of 2 branches missed.">            if (enc.isAsciiCompatible()) {</span>
<span class="fc" id="L1010">                cl = 1;</span>
<span class="fc" id="L1011">                c = bytes[p] &amp; 0xff;</span>
            } else {
<span class="nc" id="L1013">                cl = StringSupport.preciseLength(enc, bytes, p, end);</span>
<span class="nc" id="L1014">                c = enc.mbcToCode(bytes, p, end);</span>
            }

<span class="pc bpc" id="L1017" title="1 of 2 branches missed.">            if (!Encoding.isAscii(c)) {</span>
<span class="nc" id="L1018">                int n = StringSupport.length(enc, bytes, p, end);</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">                while (n-- &gt; 0) obytes[op++] = bytes[p++];</span>
                continue;
            }
<span class="fc" id="L1022">            p += cl;</span>
<span class="pc bpc" id="L1023" title="1 of 8 branches missed.">            switch (c) {</span>
            case '[': case ']': case '{': case '}':
            case '(': case ')': case '|': case '-':
            case '*': case '.': case '\\':
            case '?': case '+': case '^': case '$':
            case '#': 
<span class="fc" id="L1029">                op += enc.codeToMbc('\\', obytes, op);</span>
<span class="fc" id="L1030">                break;</span>
            case ' ':
<span class="fc" id="L1032">                op += enc.codeToMbc('\\', obytes, op);</span>
<span class="fc" id="L1033">                op += enc.codeToMbc(' ', obytes, op);</span>
<span class="fc" id="L1034">                continue;</span>
            case '\t':
<span class="fc" id="L1036">                op += enc.codeToMbc('\\', obytes, op);</span>
<span class="fc" id="L1037">                op += enc.codeToMbc('t', obytes, op);</span>
<span class="fc" id="L1038">                continue;</span>
            case '\n':
<span class="fc" id="L1040">                op += enc.codeToMbc('\\', obytes, op);</span>
<span class="fc" id="L1041">                op += enc.codeToMbc('n', obytes, op);</span>
<span class="fc" id="L1042">                continue;</span>
            case '\r':
<span class="fc" id="L1044">                op += enc.codeToMbc('\\', obytes, op);</span>
<span class="fc" id="L1045">                op += enc.codeToMbc('r', obytes, op);</span>
<span class="fc" id="L1046">                continue;</span>
            case '\f':
<span class="fc" id="L1048">                op += enc.codeToMbc('\\', obytes, op);</span>
<span class="fc" id="L1049">                op += enc.codeToMbc('f', obytes, op);</span>
<span class="fc" id="L1050">                continue;</span>
            case QUOTED_V:
<span class="nc" id="L1052">                op += enc.codeToMbc('\\', obytes, op);</span>
<span class="nc" id="L1053">                op += enc.codeToMbc('v', obytes, op);</span>
<span class="nc" id="L1054">                continue;</span>
            }
<span class="fc" id="L1056">            op += enc.codeToMbc(c, obytes, op);</span>
<span class="fc" id="L1057">        }</span>

<span class="fc" id="L1059">        result.setRealSize(op);</span>
<span class="fc" id="L1060">        return result;</span>
    }

    /** rb_reg_s_last_match / match_getter
    *
    */
    @JRubyMethod(name = &quot;last_match&quot;, meta = true, reads = BACKREF)
    public static IRubyObject last_match_s(ThreadContext context, IRubyObject recv) {
<span class="fc" id="L1068">        IRubyObject match = context.getBackRef();</span>
<span class="fc bfc" id="L1069" title="All 2 branches covered.">        if (match instanceof RubyMatchData) ((RubyMatchData)match).use();</span>
<span class="fc" id="L1070">        return match;</span>
    }

    /** rb_reg_s_last_match
    *
    */
    @JRubyMethod(name = &quot;last_match&quot;, meta = true, reads = BACKREF)
    public static IRubyObject last_match_s(ThreadContext context, IRubyObject recv, IRubyObject nth) {
<span class="fc" id="L1078">        IRubyObject match = context.getBackRef();</span>
<span class="pc bpc" id="L1079" title="1 of 2 branches missed.">        if (match.isNil()) return match;</span>
<span class="fc" id="L1080">        return nth_match(((RubyMatchData)match).backrefNumber(nth), match);</span>
    }

    /** rb_reg_s_union
    *
    */
    public static IRubyObject union(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="nc" id="L1087">        return union19(context, recv, args);</span>
    }

    @JRubyMethod(name = &quot;union&quot;, rest = true, meta = true)
    public static IRubyObject union19(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
        IRubyObject obj;
<span class="fc bfc" id="L1093" title="All 4 branches covered.">        if (args.length == 1 &amp;&amp; !(obj = args[0].checkArrayType()).isNil()) {</span>
<span class="fc" id="L1094">            RubyArray ary = (RubyArray)obj;</span>
<span class="fc" id="L1095">            IRubyObject[]tmp = new IRubyObject[ary.size()];</span>
<span class="fc" id="L1096">            ary.copyInto(tmp, 0);</span>
<span class="fc" id="L1097">            args = tmp;</span>
        }

<span class="fc" id="L1100">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L1101" title="All 2 branches covered.">        if (args.length == 0) {</span>
<span class="fc" id="L1102">            return runtime.getRegexp().newInstance(context, runtime.newString(&quot;(?!)&quot;), Block.NULL_BLOCK);</span>
<span class="fc bfc" id="L1103" title="All 2 branches covered.">        } else if (args.length == 1) {</span>
<span class="fc" id="L1104">            IRubyObject re = TypeConverter.convertToTypeWithCheck(args[0], runtime.getRegexp(), &quot;to_regexp&quot;);</span>
<span class="pc bpc" id="L1105" title="1 of 2 branches missed.">            return !re.isNil() ? re : newRegexp(runtime, ((RubyString)quote19(context, recv, args[0])).getByteList());</span>
        } else {
<span class="fc" id="L1107">            boolean hasAsciiOnly = false;</span>
<span class="fc" id="L1108">            RubyString source = runtime.newString();</span>
<span class="fc" id="L1109">            Encoding hasAsciiCompatFixed = null;</span>
<span class="fc" id="L1110">            Encoding hasAsciiIncompat = null;</span>

<span class="fc bfc" id="L1112" title="All 2 branches covered.">            for(int i = 0; i &lt; args.length; i++) {</span>
<span class="fc" id="L1113">                IRubyObject e = args[i];</span>
<span class="fc bfc" id="L1114" title="All 2 branches covered.">                if (i &gt; 0) source.cat((byte)'|');</span>
<span class="fc" id="L1115">                IRubyObject v = TypeConverter.convertToTypeWithCheck(args[i], runtime.getRegexp(), &quot;to_regexp&quot;);</span>
                Encoding enc;
<span class="fc bfc" id="L1117" title="All 2 branches covered.">                if (!v.isNil()) {</span>
<span class="fc" id="L1118">                    RubyRegexp regex = (RubyRegexp) v;</span>
<span class="fc" id="L1119">                    enc = regex.getEncoding();</span>
<span class="fc bfc" id="L1120" title="All 2 branches covered.">                    if (!enc.isAsciiCompatible()) {</span>
<span class="fc bfc" id="L1121" title="All 2 branches covered.">                        if (hasAsciiIncompat == null) { // First regexp of union sets kcode.</span>
<span class="fc" id="L1122">                            hasAsciiIncompat = enc;</span>
<span class="pc bpc" id="L1123" title="1 of 2 branches missed.">                        } else if (hasAsciiIncompat != enc) { // n kcode doesn't match first one</span>
<span class="fc" id="L1124">                            throw runtime.newArgumentError(&quot;incompatible encodings: &quot; + hasAsciiIncompat + &quot; and &quot; + enc);</span>
                        }
<span class="fc bfc" id="L1126" title="All 2 branches covered.">                    } else if (regex.getOptions().isFixed()) {</span>
<span class="fc bfc" id="L1127" title="All 2 branches covered.">                        if (hasAsciiCompatFixed == null) { // First regexp of union sets kcode.</span>
<span class="fc" id="L1128">                            hasAsciiCompatFixed = enc;</span>
<span class="pc bpc" id="L1129" title="1 of 2 branches missed.">                        } else if (hasAsciiCompatFixed != enc) { // n kcode doesn't match first one</span>
<span class="fc" id="L1130">                            throw runtime.newArgumentError(&quot;incompatible encodings: &quot; + hasAsciiCompatFixed + &quot; and &quot; + enc);</span>
                        }
                    } else {
<span class="fc" id="L1133">                        hasAsciiOnly = true;</span>
                    }
<span class="fc" id="L1135">                    v = regex.to_s();</span>
<span class="fc" id="L1136">                } else {</span>
<span class="fc" id="L1137">                    RubyString str = args[i].convertToString();</span>
<span class="fc" id="L1138">                    enc = str.getEncoding();</span>

<span class="fc bfc" id="L1140" title="All 2 branches covered.">                    if (!enc.isAsciiCompatible()) {</span>
<span class="fc bfc" id="L1141" title="All 2 branches covered.">                        if (hasAsciiIncompat == null) { // First regexp of union sets kcode.</span>
<span class="fc" id="L1142">                            hasAsciiIncompat = enc;</span>
<span class="pc bpc" id="L1143" title="1 of 2 branches missed.">                        } else if (hasAsciiIncompat != enc) { // n kcode doesn't match first one</span>
<span class="fc" id="L1144">                            throw runtime.newArgumentError(&quot;incompatible encodings: &quot; + hasAsciiIncompat + &quot; and &quot; + enc);</span>
                        }
<span class="fc bfc" id="L1146" title="All 2 branches covered.">                    } else if (str.isAsciiOnly()) {</span>
<span class="fc" id="L1147">                        hasAsciiOnly = true;</span>
                    } else {
<span class="fc bfc" id="L1149" title="All 2 branches covered.">                        if (hasAsciiCompatFixed == null) { // First regexp of union sets kcode.</span>
<span class="fc" id="L1150">                            hasAsciiCompatFixed = enc;</span>
<span class="fc bfc" id="L1151" title="All 2 branches covered.">                        } else if (hasAsciiCompatFixed != enc) { // n kcode doesn't match first one</span>
<span class="fc" id="L1152">                            throw runtime.newArgumentError(&quot;incompatible encodings: &quot; + hasAsciiCompatFixed + &quot; and &quot; + enc);</span>
                        }
                    }
<span class="fc" id="L1155">                    v = quote19(context, recv, str);</span>
                }

<span class="fc bfc" id="L1158" title="All 2 branches covered.">                if (hasAsciiIncompat != null) {</span>
<span class="fc bfc" id="L1159" title="All 2 branches covered.">                    if (hasAsciiOnly) {</span>
<span class="fc" id="L1160">                        throw runtime.newArgumentError(&quot;ASCII incompatible encoding: &quot; + hasAsciiIncompat);</span>
                    }
<span class="fc bfc" id="L1162" title="All 2 branches covered.">                    if (hasAsciiCompatFixed != null) {</span>
<span class="fc" id="L1163">                        throw runtime.newArgumentError(&quot;incompatible encodings: &quot; + hasAsciiIncompat + &quot; and &quot; + hasAsciiCompatFixed);</span>
                    }
                }

                // Enebo: not sure why this is needed.
<span class="fc bfc" id="L1168" title="All 2 branches covered.">                if (i == 0) source.setEncoding(enc);</span>
<span class="fc" id="L1169">                source.append(v);</span>
            }
<span class="pc bpc" id="L1171" title="1 of 2 branches missed.">            if (hasAsciiIncompat != null) {</span>
<span class="nc" id="L1172">                source.setEncoding(hasAsciiIncompat);</span>
<span class="fc bfc" id="L1173" title="All 2 branches covered.">            } else if (hasAsciiCompatFixed != null) {</span>
<span class="fc" id="L1174">                source.setEncoding(hasAsciiCompatFixed);</span>
            } else {
<span class="fc" id="L1176">                source.setEncoding(ASCIIEncoding.INSTANCE);</span>
            }
<span class="fc" id="L1178">            return runtime.getRegexp().newInstance(context, source, Block.NULL_BLOCK);</span>
        }
    }

    // rb_enc_reg_raise
    private static void raiseRegexpError19(Ruby runtime, ByteList bytes, Encoding enc, RegexpOptions options, String err) {
        // TODO: we loose encoding information here, fix it
<span class="fc" id="L1185">        throw runtime.newRegexpError(err + &quot;: &quot; + regexpDescription19(runtime, bytes, options, enc));</span>
    }

    // rb_enc_reg_error_desc
    static ByteList regexpDescription19(Ruby runtime, ByteList bytes, RegexpOptions options, Encoding enc) {
<span class="fc" id="L1190">        return regexpDescription19(runtime, bytes.getUnsafeBytes(), bytes.getBegin(), bytes.getRealSize(), options, enc);</span>
    }
    private static ByteList regexpDescription19(Ruby runtime, byte[] s, int start, int len, RegexpOptions options, Encoding enc) {
<span class="fc" id="L1193">        ByteList description = new ByteList();</span>
<span class="fc" id="L1194">        description.setEncoding(enc);</span>
<span class="fc" id="L1195">        description.append((byte)'/');</span>
<span class="fc" id="L1196">        Encoding resultEnc = runtime.getDefaultInternalEncoding();</span>
<span class="pc bpc" id="L1197" title="1 of 2 branches missed.">        if (resultEnc == null) resultEnc = runtime.getDefaultExternalEncoding();</span>
        
<span class="fc" id="L1199">        appendRegexpString19(runtime, description, s, start, len, enc, resultEnc);</span>
<span class="fc" id="L1200">        description.append((byte)'/');</span>
<span class="fc" id="L1201">        appendOptions(description, options);</span>
<span class="fc bfc" id="L1202" title="All 2 branches covered.">        if (options.isEncodingNone()) description.append((byte) 'n');</span>
<span class="fc" id="L1203">        return description; </span>
    }

    /** rb_reg_init_copy
     */
    @JRubyMethod(required = 1, visibility = Visibility.PRIVATE)
    @Override
    public IRubyObject initialize_copy(IRubyObject re) {
<span class="pc bpc" id="L1211" title="1 of 2 branches missed.">        if (this == re) return this;</span>
<span class="fc" id="L1212">        checkFrozen();</span>

<span class="pc bpc" id="L1214" title="1 of 2 branches missed.">        if (getMetaClass().getRealClass() != re.getMetaClass().getRealClass()) {</span>
<span class="nc" id="L1215">            throw getRuntime().newTypeError(&quot;wrong argument type&quot;);</span>
        }

<span class="fc" id="L1218">        RubyRegexp regexp = (RubyRegexp)re;</span>
<span class="fc" id="L1219">        regexp.check();</span>

<span class="fc" id="L1221">        return initializeCommon19(regexp.str, regexp.str.getEncoding(), regexp.getOptions());</span>
    }
    
    private int objectAsJoniOptions(IRubyObject arg) {
<span class="fc bfc" id="L1225" title="All 2 branches covered.">        if (arg instanceof RubyFixnum) return RubyNumeric.fix2int(arg);</span>
<span class="fc bfc" id="L1226" title="All 2 branches covered.">        if (arg.isTrue()) return RE_OPTION_IGNORECASE;</span>
        
<span class="fc" id="L1228">        return 0;</span>
    }

    public IRubyObject initialize_m(IRubyObject arg) {
<span class="nc" id="L1232">        return initialize_m19(arg);</span>
    }
    
    public IRubyObject initialize_m(IRubyObject arg0, IRubyObject arg1) {
<span class="nc" id="L1236">        return initialize_m19(arg0, arg1);</span>
    }
    
    public IRubyObject initialize_m(IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {
<span class="nc" id="L1240">        return initialize_m19(arg0, arg1, arg2);</span>
    }

    @JRubyMethod(name = &quot;initialize&quot;, visibility = Visibility.PRIVATE)
    public IRubyObject initialize_m19(IRubyObject arg) {
<span class="fc bfc" id="L1245" title="All 2 branches covered.">        if (arg instanceof RubyRegexp) return initializeByRegexp19((RubyRegexp)arg);</span>
<span class="fc" id="L1246">        return initializeCommon19(arg.convertToString(), new RegexpOptions());</span>
    }

    @JRubyMethod(name = &quot;initialize&quot;, visibility = Visibility.PRIVATE)
    public IRubyObject initialize_m19(IRubyObject arg0, IRubyObject arg1) {
<span class="fc bfc" id="L1251" title="All 2 branches covered.">        if (arg0 instanceof RubyRegexp) {</span>
<span class="fc" id="L1252">            getRuntime().getWarnings().warn(ID.REGEXP_IGNORED_FLAGS, &quot;flags ignored&quot;);</span>
<span class="fc" id="L1253">            return initializeByRegexp19((RubyRegexp)arg0);</span>
        }
        
<span class="fc" id="L1256">        return initializeCommon19(arg0.convertToString(), </span>
<span class="fc" id="L1257">                RegexpOptions.fromJoniOptions(objectAsJoniOptions(arg1)));</span>
    }

    @JRubyMethod(name = &quot;initialize&quot;, visibility = Visibility.PRIVATE)
    public IRubyObject initialize_m19(IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {
<span class="pc bpc" id="L1262" title="1 of 2 branches missed.">        if (arg0 instanceof RubyRegexp) {</span>
<span class="nc" id="L1263">            getRuntime().getWarnings().warn(ID.REGEXP_IGNORED_FLAGS, &quot;flags ignored&quot;);            </span>
<span class="nc" id="L1264">            return initializeByRegexp19((RubyRegexp)arg0);</span>
        }

<span class="fc" id="L1267">        RegexpOptions newOptions = RegexpOptions.fromJoniOptions(objectAsJoniOptions(arg1));</span>

<span class="pc bpc" id="L1269" title="1 of 2 branches missed.">        if (!arg2.isNil()) {</span>
<span class="fc" id="L1270">            ByteList kcodeBytes = arg2.convertToString().getByteList();</span>
<span class="pc bpc" id="L1271" title="1 of 4 branches missed.">            if ((kcodeBytes.getRealSize() &gt; 0 &amp;&amp; kcodeBytes.getUnsafeBytes()[kcodeBytes.getBegin()] == 'n') ||</span>
<span class="pc bpc" id="L1272" title="1 of 4 branches missed.">                (kcodeBytes.getRealSize() &gt; 1 &amp;&amp; kcodeBytes.getUnsafeBytes()[kcodeBytes.getBegin() + 1] == 'N')) {</span>
<span class="fc" id="L1273">                return initializeCommon19(arg0.convertToString().getByteList(), ASCIIEncoding.INSTANCE, newOptions);</span>
            } else {
<span class="fc" id="L1275">                getRuntime().getWarnings().warn(&quot;encoding option is ignored - &quot; + kcodeBytes);</span>
            }
        }
<span class="fc" id="L1278">        return initializeCommon19(arg0.convertToString(), newOptions);</span>
    }

    private IRubyObject initializeByRegexp19(RubyRegexp regexp) {
<span class="fc" id="L1282">        regexp.check();</span>
//        System.out.println(&quot;str: &quot; + regexp.str + &quot;, ENC: &quot; + regexp.getEncoding() + &quot;, OPT: &quot; + regexp.getOptions());
//        System.out.println(&quot;KCODE: &quot; + regexp.kcode);
        // Clone and toggle flags since this is no longer a literal regular expression
        // but it did come from one.
<span class="fc" id="L1287">        RegexpOptions newOptions = (RegexpOptions) regexp.getOptions().clone();</span>
<span class="fc" id="L1288">        newOptions.setLiteral(false);</span>
<span class="fc" id="L1289">        return initializeCommon19(regexp.str, regexp.getEncoding(), newOptions);</span>
    }

    // rb_reg_initialize_str
    private RubyRegexp initializeCommon19(RubyString str, RegexpOptions options) {
<span class="fc bfc" id="L1294" title="All 2 branches covered.">        if (isLiteral()) throw getRuntime().newSecurityError(&quot;can't modify literal regexp&quot;);</span>
<span class="fc" id="L1295">        ByteList bytes = str.getByteList();</span>
<span class="fc" id="L1296">        Encoding enc = bytes.getEncoding();</span>
<span class="pc bpc" id="L1297" title="1 of 2 branches missed.">        if (options.isEncodingNone()) {</span>
<span class="nc bnc" id="L1298" title="All 2 branches missed.">            if (enc != ASCIIEncoding.INSTANCE) {</span>
<span class="nc bnc" id="L1299" title="All 2 branches missed.">                if (str.scanForCodeRange() != StringSupport.CR_7BIT) {</span>
<span class="nc" id="L1300">                    raiseRegexpError19(getRuntime(), bytes, enc, options, &quot;/.../n has a non escaped non ASCII character in non ASCII-8BIT script&quot;);</span>
                }
<span class="nc" id="L1302">                enc = ASCIIEncoding.INSTANCE;</span>
            }
        }
<span class="fc" id="L1305">        return initializeCommon19(bytes, enc, options);</span>
    }

    // rb_reg_initialize
    private RubyRegexp initializeCommon19(ByteList bytes, Encoding enc, RegexpOptions options) {
<span class="fc" id="L1310">        Ruby runtime = getRuntime();</span>
<span class="fc" id="L1311">        this.options = options;</span>

<span class="fc" id="L1313">        checkFrozen();</span>
        // FIXME: Something unsets this bit, but we aren't...be more permissive until we figure this out
        //if (isLiteral()) throw runtime.newSecurityError(&quot;can't modify literal regexp&quot;);
<span class="fc bfc" id="L1316" title="All 2 branches covered.">        if (pattern != null) throw runtime.newTypeError(&quot;already initialized regexp&quot;);</span>
<span class="pc bpc" id="L1317" title="1 of 2 branches missed.">        if (enc.isDummy()) raiseRegexpError19(runtime, bytes, enc, options, &quot;can't make regexp with dummy encoding&quot;);</span>
        
<span class="fc" id="L1319">        Encoding[]fixedEnc = new Encoding[]{null};</span>
<span class="fc" id="L1320">        ByteList unescaped = preprocess(runtime, bytes, enc, fixedEnc, ErrorMode.RAISE);</span>
<span class="fc bfc" id="L1321" title="All 2 branches covered.">        if (fixedEnc[0] != null) {</span>
<span class="pc bpc" id="L1322" title="3 of 6 branches missed.">            if ((fixedEnc[0] != enc &amp;&amp; options.isFixed()) ||</span>
<span class="pc bpc" id="L1323" title="1 of 2 branches missed.">               (fixedEnc[0] != ASCIIEncoding.INSTANCE &amp;&amp; options.isEncodingNone())) {</span>
<span class="nc" id="L1324">                   raiseRegexpError19(runtime, bytes, enc, options, &quot;incompatible character encoding&quot;);</span>
            }
<span class="fc bfc" id="L1326" title="All 2 branches covered.">            if (fixedEnc[0] != ASCIIEncoding.INSTANCE) {</span>
<span class="fc" id="L1327">                options.setFixed(true);</span>
<span class="fc" id="L1328">                enc = fixedEnc[0];</span>
            }
<span class="fc bfc" id="L1330" title="All 2 branches covered.">        } else if (!options.isFixed()) {</span>
<span class="fc" id="L1331">            enc = USASCIIEncoding.INSTANCE;</span>
        }

<span class="fc bfc" id="L1334" title="All 2 branches covered.">        if (fixedEnc[0] != null) options.setFixed(true);</span>
<span class="fc bfc" id="L1335" title="All 2 branches covered.">        if (options.isEncodingNone()) setEncodingNone();</span>

<span class="fc" id="L1337">        pattern = getRegexpFromCache(runtime, unescaped, enc, options);</span>
<span class="fc" id="L1338">        bytes.getClass();</span>
<span class="fc" id="L1339">        str = bytes;</span>
<span class="fc" id="L1340">        return this;</span>
    }

    @JRubyMethod
    @Override
    public RubyFixnum hash() {
<span class="fc" id="L1346">        check();</span>
<span class="fc" id="L1347">        int hash = pattern.getOptions();</span>
<span class="fc" id="L1348">        int len = str.getRealSize();</span>
<span class="fc" id="L1349">        int p = str.getBegin();</span>
<span class="fc" id="L1350">        byte[]bytes = str.getUnsafeBytes();</span>
<span class="fc bfc" id="L1351" title="All 2 branches covered.">        while (len-- &gt; 0) {</span>
<span class="fc" id="L1352">            hash = hash * 33 + bytes[p++];</span>
        }
<span class="fc" id="L1354">        return getRuntime().newFixnum(hash + (hash &gt;&gt; 5));</span>
    }

    @JRubyMethod(name = {&quot;==&quot;, &quot;eql?&quot;}, required = 1)
    @Override
    public IRubyObject op_equal(ThreadContext context, IRubyObject other) {
<span class="pc bpc" id="L1360" title="1 of 2 branches missed.">        if (this == other) {</span>
<span class="nc" id="L1361">            return context.runtime.getTrue();</span>
        }
<span class="pc bpc" id="L1363" title="1 of 2 branches missed.">        if (!(other instanceof RubyRegexp)) {</span>
<span class="nc" id="L1364">            return context.runtime.getFalse();</span>
        }
<span class="fc" id="L1366">        RubyRegexp otherRegex = (RubyRegexp)other;</span>
        
<span class="fc" id="L1368">        check();</span>
<span class="fc" id="L1369">        otherRegex.check();</span>

<span class="fc bfc" id="L1371" title="All 2 branches covered.">        return context.runtime.newBoolean(str.equal(otherRegex.str) &amp;&amp;</span>
<span class="fc bfc" id="L1372" title="All 2 branches covered.">                getOptions().equals(otherRegex.options));</span>
    }

    public IRubyObject op_match2(ThreadContext context) {
<span class="nc" id="L1376">        return op_match2_19(context);</span>
    }

    @JRubyMethod(name = &quot;~&quot;, reads = {LASTLINE, BACKREF}, writes = BACKREF)
    public IRubyObject op_match2_19(ThreadContext context) {
<span class="fc" id="L1381">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L1382">        IRubyObject line = context.getLastLine();</span>
<span class="fc bfc" id="L1383" title="All 2 branches covered.">        if (line instanceof RubyString) {</span>
<span class="fc" id="L1384">            IRubyObject[] holder = {context.nil};</span>
<span class="fc" id="L1385">            int start = search19(context, (RubyString)line, 0, false, holder);</span>
<span class="fc" id="L1386">            context.setBackRef(holder[0]);</span>
<span class="pc bpc" id="L1387" title="1 of 2 branches missed.">            if (start &lt; 0) return runtime.getNil();</span>
<span class="fc" id="L1388">            return runtime.newFixnum(start);</span>
        }
<span class="fc" id="L1390">        context.setBackRef(runtime.getNil());</span>
<span class="fc" id="L1391">        return runtime.getNil();</span>
    }

    /** rb_reg_eqq
     * 
     */

    public IRubyObject eqq(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L1399">        return eqq19(context, arg);</span>
    }

    @JRubyMethod(name = &quot;===&quot;, required = 1, writes = BACKREF)
    public IRubyObject eqq19(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L1404">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L1405">        arg = operandNoCheck(arg);</span>
<span class="pc bpc" id="L1406" title="1 of 2 branches missed.">        if (arg.isNil()) {</span>
<span class="nc" id="L1407">            context.setBackRef(arg);</span>
<span class="nc" id="L1408">            return runtime.getFalse();</span>
        }
<span class="fc" id="L1410">        IRubyObject[] holder = {context.nil};</span>
<span class="fc" id="L1411">        int start = search19(context, (RubyString)arg, 0, false, holder);</span>
<span class="fc" id="L1412">        context.setBackRef(holder[0]);</span>
<span class="fc bfc" id="L1413" title="All 2 branches covered.">        return (start &lt; 0) ? runtime.getFalse() : runtime.getTrue();</span>
    }
    
    /** rb_reg_match
     * 
     */
    @Override
    public IRubyObject op_match(ThreadContext context, IRubyObject str) {
<span class="nc" id="L1421">        return op_match19(context, str);</span>
    }
    
    @JRubyMethod(name = &quot;=~&quot;, required = 1, writes = BACKREF)
    @Override
    public IRubyObject op_match19(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L1427">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L1428" title="All 2 branches covered.">        if (arg.isNil()) {</span>
<span class="fc" id="L1429">            context.setBackRef(context.nil);</span>
<span class="fc" id="L1430">            return arg;</span>
        }
<span class="fc" id="L1432">        RubyString str = operandCheck(runtime, arg);</span>
<span class="fc" id="L1433">        IRubyObject[] holder = {context.nil};</span>
<span class="fc" id="L1434">        int pos = matchPos(context, str, 0, holder);</span>
<span class="fc" id="L1435">        context.setBackRef(holder[0]);</span>
<span class="fc bfc" id="L1436" title="All 2 branches covered.">        if (pos &lt; 0) return runtime.getNil();</span>
<span class="fc" id="L1437">        return RubyFixnum.newFixnum(runtime, str.subLength(pos));</span>
    }

    /** rb_reg_match_m
     * 
     */
    public IRubyObject match_m(ThreadContext context, IRubyObject str) {
<span class="nc" id="L1444">        return match_m19(context, str, Block.NULL_BLOCK);</span>
    }

    @JRubyMethod(name = &quot;match&quot;, reads = BACKREF)
    public IRubyObject match_m19(ThreadContext context, IRubyObject str, Block block) {
<span class="fc" id="L1449">        return match19Common(context, str, 0, true, block);</span>
    }
    
    public IRubyObject match_m19(ThreadContext context, IRubyObject str, boolean useBackref, Block block) {
<span class="fc" id="L1453">        return match19Common(context, str, 0, useBackref, block);</span>
    }

    @JRubyMethod(name = &quot;match&quot;, reads = BACKREF)
    public IRubyObject match_m19(ThreadContext context, IRubyObject str, IRubyObject pos, Block block) {
<span class="fc" id="L1458">        return match19Common(context, str, RubyNumeric.num2int(pos), true, block);</span>
    }

    private IRubyObject match19Common(ThreadContext context, IRubyObject arg, int pos, boolean setBackref, Block block) {
<span class="fc bfc" id="L1462" title="All 2 branches covered.">        if (arg.isNil()) {</span>
<span class="pc bpc" id="L1463" title="1 of 2 branches missed.">            if (setBackref) context.setBackRef(arg);</span>
<span class="fc" id="L1464">            return arg;</span>
        }
<span class="fc" id="L1466">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L1467">        RubyString _str = operandCheck(runtime, arg);</span>
        
<span class="fc" id="L1469">        IRubyObject[] holder = {context.nil};</span>
<span class="fc bfc" id="L1470" title="All 2 branches covered.">        if (matchPos(context, _str, pos, holder) &lt; 0) {</span>
<span class="fc bfc" id="L1471" title="All 2 branches covered.">            if (setBackref) context.setBackRef(runtime.getNil());</span>
<span class="fc" id="L1472">            return runtime.getNil();</span>
        }

<span class="fc" id="L1475">        IRubyObject backref = holder[0];</span>
<span class="fc bfc" id="L1476" title="All 2 branches covered.">        if (setBackref) context.setBackRef(backref);</span>
<span class="fc bfc" id="L1477" title="All 2 branches covered.">        if (block.isGiven()) return block.yield(context, backref);</span>
<span class="fc" id="L1478">        return backref;</span>
    }

    private int matchPos(ThreadContext context, RubyString str, int pos, IRubyObject[] holder) {
<span class="fc bfc" id="L1482" title="All 2 branches covered.">        if (pos != 0) {</span>
<span class="fc bfc" id="L1483" title="All 2 branches covered.">            if (pos &lt; 0) {</span>
<span class="fc" id="L1484">                pos += str.strLength();</span>
<span class="pc bpc" id="L1485" title="1 of 2 branches missed.">                if (pos &lt; 0) return pos;</span>
            }
<span class="fc" id="L1487">            pos = StringSupport.offset(str, pos);</span>
        }
<span class="fc" id="L1489">        return search19(context, str, pos, false, holder);</span>
    }

    /** rb_reg_search
     */
    public final int search(ThreadContext context, RubyString str, int pos, boolean reverse, IRubyObject[] holder) {
<span class="nc" id="L1495">        check();</span>
<span class="nc" id="L1496">        ByteList value = str.getByteList();</span>

<span class="nc bnc" id="L1498" title="All 4 branches missed.">        if (pos &lt;= value.getRealSize() &amp;&amp; pos &gt;= 0) {</span>
<span class="nc" id="L1499">            int realSize = value.getRealSize();</span>
<span class="nc" id="L1500">            int begin = value.getBegin();</span>
<span class="nc" id="L1501">            Matcher matcher = pattern.matcher(value.getUnsafeBytes(), begin, begin + realSize);</span>

<span class="nc bnc" id="L1503" title="All 2 branches missed.">            int result = matcherSearch(context.runtime, matcher, begin + pos, begin + (reverse ? 0 : realSize), Option.NONE);</span>
<span class="nc bnc" id="L1504" title="All 2 branches missed.">            if (result &gt;= 0) {</span>
<span class="nc" id="L1505">                RubyMatchData matchData = createMatchData(context, str, matcher, pattern);</span>
<span class="nc" id="L1506">                matchData.regexp = this;</span>
<span class="nc" id="L1507">                matchData.infectBy(this);</span>
<span class="nc bnc" id="L1508" title="All 2 branches missed.">                if (holder != null) holder[0] = matchData;</span>
<span class="nc" id="L1509">                return result;</span>
            }
        }

<span class="nc bnc" id="L1513" title="All 2 branches missed.">        if (holder != null) holder[0] = context.nil;</span>
<span class="nc" id="L1514">        return -1;</span>
    }

    static final RubyMatchData createMatchData(ThreadContext context, RubyString str, Matcher matcher, Regex pattern) {
<span class="fc" id="L1518">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L1519">        final RubyMatchData match = new RubyMatchData(runtime);</span>

        // FIXME: This is pretty gross; we should have a cleaner initialization
        // that doesn't depend on package-visible fields and ideally is atomic,
        // probably using an immutable structure we replace all at once.

        // The region must be cloned because a subsequent match will update the
        // region, resulting in the MatchData created here pointing at the
        // incorrect region (capture/group).
<span class="fc" id="L1528">        Region region = matcher.getRegion(); // lazy, null when no groups defined</span>
<span class="fc bfc" id="L1529" title="All 2 branches covered.">        match.regs = region == null ? null : region.clone();</span>
<span class="fc" id="L1530">        match.begin = matcher.getBegin();</span>
<span class="fc" id="L1531">        match.end = matcher.getEnd();</span>
<span class="fc" id="L1532">        match.pattern = pattern;</span>
<span class="fc" id="L1533">        match.str = (RubyString)str.strDup(runtime).freeze(context);</span>

<span class="fc" id="L1535">        match.infectBy(str);</span>

<span class="fc" id="L1537">        return match;</span>
    }

    public final int search19(ThreadContext context, RubyString str, int pos, boolean reverse, IRubyObject[] holder) {
<span class="fc" id="L1541">        check();</span>
<span class="fc" id="L1542">        ByteList value = str.getByteList();</span>

<span class="pc bpc" id="L1544" title="2 of 4 branches missed.">        if (pos &lt;= value.getRealSize() &amp;&amp; pos &gt;= 0) {</span>
<span class="fc" id="L1545">            int realSize = value.getRealSize();</span>
<span class="fc" id="L1546">            int begin = value.getBegin();</span>
<span class="fc" id="L1547">            Matcher matcher = preparePattern(str).matcher(value.getUnsafeBytes(), begin, begin + realSize);</span>

<span class="fc bfc" id="L1549" title="All 2 branches covered.">            int result = matcherSearch(context.runtime, matcher, begin + pos, begin + (reverse ? 0 : realSize), Option.NONE);</span>
<span class="fc bfc" id="L1550" title="All 2 branches covered.">            if (result &gt;= 0) {</span>
<span class="fc" id="L1551">                RubyMatchData matchData = createMatchData19(context, str, matcher, pattern);</span>
<span class="fc" id="L1552">                matchData.charOffsetUpdated = false;</span>
<span class="fc" id="L1553">                matchData.regexp = this;</span>
<span class="fc" id="L1554">                matchData.infectBy(this);</span>
<span class="pc bpc" id="L1555" title="1 of 2 branches missed.">                if (holder != null) holder[0] = matchData;</span>
<span class="fc" id="L1556">                return result;</span>
            }
        }
        
<span class="pc bpc" id="L1560" title="1 of 2 branches missed.">        if (holder != null) holder[0] = context.nil;</span>
<span class="fc" id="L1561">        return -1;</span>
    }

    static final RubyMatchData createMatchData19(ThreadContext context, RubyString str, Matcher matcher, Regex pattern) {
<span class="fc" id="L1565">        RubyMatchData match = createMatchData(context, str, matcher, pattern);</span>
<span class="fc" id="L1566">        match.charOffsetUpdated = false;</span>
<span class="fc" id="L1567">        return match;</span>
    }

    @JRubyMethod
    public IRubyObject options() {
<span class="fc" id="L1572">        return getRuntime().newFixnum(getOptions().toOptions());</span>
    }

    @JRubyMethod(name = &quot;casefold?&quot;)
    public IRubyObject casefold_p(ThreadContext context) {
<span class="fc" id="L1577">        check();</span>
<span class="fc" id="L1578">        return context.runtime.newBoolean(getOptions().isIgnorecase());</span>
    }

    /** rb_reg_source
     * 
     */
    @JRubyMethod
    public IRubyObject source() {
<span class="fc" id="L1586">        check();</span>
<span class="fc" id="L1587">        RubyString _str = RubyString.newStringShared(getRuntime(), this.str);</span>
<span class="pc bpc" id="L1588" title="1 of 2 branches missed.">        if (isTaint()) _str.setTaint(true);</span>
<span class="fc" id="L1589">        return _str;</span>
    }

    final int length() {
<span class="fc" id="L1593">        return str.getRealSize();</span>
    }

    /** rb_reg_inspect
     *
     */
    @Override
    public IRubyObject inspect() {
<span class="nc" id="L1601">        return inspect19();</span>
    }

    @JRubyMethod(name = &quot;inspect&quot;)
    public IRubyObject inspect19() {
<span class="pc bpc" id="L1606" title="1 of 2 branches missed.">        if (pattern == null) return anyToString();</span>
<span class="fc" id="L1607">        return RubyString.newString(getRuntime(), regexpDescription19(getRuntime(), str, options, str.getEncoding()));</span>
    }

    private final static int EMBEDDABLE = RE_OPTION_MULTILINE|RE_OPTION_IGNORECASE|RE_OPTION_EXTENDED;

    @JRubyMethod
    @Override
    public IRubyObject to_s() {
<span class="fc" id="L1615">        check();</span>

<span class="fc" id="L1617">        Ruby runtime = getRuntime();</span>
<span class="fc" id="L1618">        RegexpOptions newOptions = (RegexpOptions)options.clone();</span>
<span class="fc" id="L1619">        int p = str.getBegin();</span>
<span class="fc" id="L1620">        int len = str.getRealSize();</span>
<span class="fc" id="L1621">        byte[] bytes = str.getUnsafeBytes();</span>

<span class="fc" id="L1623">        ByteList result = new ByteList(len);</span>
<span class="fc" id="L1624">        result.append((byte)'(').append((byte)'?');</span>

        again: do {
<span class="pc bpc" id="L1627" title="1 of 6 branches missed.">            if (len &gt;= 4 &amp;&amp; bytes[p] == '(' &amp;&amp; bytes[p + 1] == '?') {</span>
<span class="fc" id="L1628">                boolean err = true;</span>
<span class="fc" id="L1629">                p += 2;</span>
<span class="pc bpc" id="L1630" title="1 of 2 branches missed.">                if ((len -= 2) &gt; 0) {</span>
                    do {
<span class="fc bfc" id="L1632" title="All 2 branches covered.">                        if (bytes[p] == 'm') {</span>
<span class="fc" id="L1633">                            newOptions.setMultiline(true);</span>
<span class="fc bfc" id="L1634" title="All 2 branches covered.">                        } else if (bytes[p] == 'i') {</span>
<span class="fc" id="L1635">                            newOptions.setIgnorecase(true);</span>
<span class="fc bfc" id="L1636" title="All 2 branches covered.">                        } else if (bytes[p] == 'x') {</span>
<span class="fc" id="L1637">                            newOptions.setExtended(true);</span>
                        } else {
                            break;
                        }
<span class="fc" id="L1641">                        p++;</span>
<span class="pc bpc" id="L1642" title="1 of 2 branches missed.">                    } while (--len &gt; 0);</span>
                }
<span class="pc bpc" id="L1644" title="1 of 4 branches missed.">                if (len &gt; 1 &amp;&amp; bytes[p] == '-') {</span>
<span class="fc" id="L1645">                    ++p;</span>
<span class="fc" id="L1646">                    --len;</span>
                    do {
<span class="fc bfc" id="L1648" title="All 2 branches covered.">                        if (bytes[p] == 'm') {</span>
<span class="fc" id="L1649">                            newOptions.setMultiline(false);</span>
<span class="fc bfc" id="L1650" title="All 2 branches covered.">                        } else if (bytes[p] == 'i') {</span>
<span class="fc" id="L1651">                            newOptions.setIgnorecase(false);</span>
<span class="fc bfc" id="L1652" title="All 2 branches covered.">                        } else if (bytes[p] == 'x') {</span>
<span class="fc" id="L1653">                            newOptions.setExtended(false);</span>
                        } else {
                            break;
                        }
<span class="fc" id="L1657">                        p++;</span>
<span class="pc bpc" id="L1658" title="1 of 2 branches missed.">                    } while (--len &gt; 0);</span>
                }

<span class="pc bpc" id="L1661" title="1 of 2 branches missed.">                if (bytes[p] == ')') {</span>
<span class="nc" id="L1662">                    --len;</span>
<span class="nc" id="L1663">                    ++p;</span>
<span class="nc" id="L1664">                    continue again;</span>
                }

<span class="fc bfc" id="L1667" title="All 4 branches covered.">                if (bytes[p] == ':' &amp;&amp; bytes[p + len - 1] == ')') {</span>
                    try {
<span class="fc" id="L1669">                        new Regex(bytes, ++p, p + (len -= 2), Option.DEFAULT, getEncoding(runtime, str), Syntax.DEFAULT);</span>
<span class="fc" id="L1670">                        err = false;</span>
<span class="fc" id="L1671">                    } catch (JOniException e) {</span>
<span class="fc" id="L1672">                        err = true;</span>
<span class="fc" id="L1673">                    }</span>
                }

<span class="fc bfc" id="L1676" title="All 2 branches covered.">                if (err) {</span>
<span class="fc" id="L1677">                    newOptions = options;</span>
<span class="fc" id="L1678">                    p = str.getBegin();</span>
<span class="fc" id="L1679">                    len = str.getRealSize();</span>
                }
            }

<span class="fc" id="L1683">            appendOptions(result, newOptions);</span>

<span class="fc bfc" id="L1685" title="All 2 branches covered.">            if (!newOptions.isEmbeddable()) {</span>
<span class="fc" id="L1686">                result.append((byte)'-');</span>
<span class="fc bfc" id="L1687" title="All 2 branches covered.">                if (!newOptions.isMultiline()) result.append((byte)'m');</span>
<span class="fc bfc" id="L1688" title="All 2 branches covered.">                if (!newOptions.isIgnorecase()) result.append((byte)'i');</span>
<span class="fc bfc" id="L1689" title="All 2 branches covered.">                if (!newOptions.isExtended()) result.append((byte)'x');</span>
            }
<span class="fc" id="L1691">            result.append((byte)':');</span>
<span class="fc" id="L1692">            appendRegexpString19(runtime, result, bytes, p, len, getEncoding(runtime, str), null);</span>
            
<span class="fc" id="L1694">            result.append((byte)')');</span>
<span class="fc" id="L1695">            return RubyString.newString(getRuntime(), result, getEncoding()).infectBy(this);</span>
        } while (true);
    }

    // rb_reg_expr_str
    private static void appendRegexpString(Ruby runtime, ByteList to, byte[]bytes, int start, int len, Encoding enc) {
<span class="nc" id="L1701">        int p = start;</span>
<span class="nc" id="L1702">        int end = p + len;</span>
<span class="nc" id="L1703">        boolean needEscape = false;</span>
<span class="nc bnc" id="L1704" title="All 2 branches missed.">        if (enc.isAsciiCompatible()) {</span>
<span class="nc bnc" id="L1705" title="All 2 branches missed.">            while (p &lt; end) {</span>
<span class="nc" id="L1706">                int c = bytes[p] &amp; 0xff;</span>
<span class="nc bnc" id="L1707" title="All 6 branches missed.">                if (c == '/' || (!enc.isPrint(c) &amp;&amp; enc.length(bytes, p, end) == 1)) {</span>
<span class="nc" id="L1708">                    needEscape = true;</span>
<span class="nc" id="L1709">                    break;</span>
                }
<span class="nc" id="L1711">                p += enc.length(bytes, p, end);</span>
<span class="nc" id="L1712">            }</span>
        } else {
<span class="nc" id="L1714">            needEscape = true;</span>
        }
        
<span class="nc bnc" id="L1717" title="All 2 branches missed.">        if (!needEscape) {</span>
<span class="nc" id="L1718">            to.append(bytes, start, len);</span>
        } else {
<span class="nc" id="L1720">            p = start; </span>
<span class="nc bnc" id="L1721" title="All 2 branches missed.">            while (p &lt; end) {</span>
<span class="nc" id="L1722">                int c = bytes[p] &amp; 0xff;</span>
<span class="nc bnc" id="L1723" title="All 2 branches missed.">                if (c == '\\') {</span>
<span class="nc" id="L1724">                    int n = enc.length(bytes, p + 1, end) + 1;</span>
<span class="nc" id="L1725">                    to.append(bytes, p, n);</span>
<span class="nc" id="L1726">                    p += n;</span>
<span class="nc" id="L1727">                    continue;</span>
<span class="nc bnc" id="L1728" title="All 2 branches missed.">                } else if (c == '/') {</span>
<span class="nc" id="L1729">                    to.append((byte)'\\');</span>
<span class="nc" id="L1730">                    to.append(bytes, p, 1);</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">                } else if (enc.length(bytes, p, end) != 1) {</span>
<span class="nc" id="L1732">                    to.append(bytes, p, enc.length(bytes, p, end));</span>
<span class="nc" id="L1733">                    p += enc.length(bytes, p, end);</span>
<span class="nc" id="L1734">                    continue;</span>
<span class="nc bnc" id="L1735" title="All 2 branches missed.">                } else if (enc.isPrint(c)) {</span>
<span class="nc" id="L1736">                    to.append(bytes, p, 1);</span>
<span class="nc bnc" id="L1737" title="All 2 branches missed.">                } else if (!enc.isSpace(c)) {</span>
<span class="nc" id="L1738">                    Sprintf.sprintf(runtime, to, &quot;\\%03o&quot;, bytes[p] &amp; 0377);</span>
                } else {
<span class="nc" id="L1740">                    to.append(bytes, p, 1);</span>
                }
<span class="nc" id="L1742">                p++;</span>
<span class="nc" id="L1743">            }</span>
        }
<span class="nc" id="L1745">    }</span>

    private static void appendRegexpString19(Ruby runtime, ByteList to, byte[]bytes, int start, int len, Encoding enc, Encoding resEnc) {
<span class="fc" id="L1748">        int p = start;</span>
<span class="fc" id="L1749">        int end = p + len;</span>
<span class="fc" id="L1750">        boolean needEscape = false;</span>
<span class="fc bfc" id="L1751" title="All 2 branches covered.">        while (p &lt; end) {</span>
            final int c;
            final int cl;
<span class="fc bfc" id="L1754" title="All 2 branches covered.">            if (enc.isAsciiCompatible()) {</span>
<span class="fc" id="L1755">                cl = 1;</span>
<span class="fc" id="L1756">                c = bytes[p] &amp; 0xff;</span>
            } else {
<span class="fc" id="L1758">                cl = StringSupport.preciseLength(enc, bytes, p, end);</span>
<span class="fc" id="L1759">                c = enc.mbcToCode(bytes, p, end);</span>
            }

<span class="fc bfc" id="L1762" title="All 2 branches covered.">            if (!Encoding.isAscii(c)) {</span>
<span class="fc" id="L1763">                p += StringSupport.length(enc, bytes, p, end);</span>
<span class="fc bfc" id="L1764" title="All 4 branches covered.">            } else if (c != '/' &amp;&amp; enc.isPrint(c)) {</span>
<span class="fc" id="L1765">                p += cl;</span>
            } else {
<span class="fc" id="L1767">                needEscape = true;</span>
<span class="fc" id="L1768">                break;</span>
            }
<span class="fc" id="L1770">        }</span>
<span class="fc bfc" id="L1771" title="All 2 branches covered.">        if (!needEscape) {</span>
<span class="fc" id="L1772">            to.append(bytes, start, len);</span>
        } else {
<span class="fc" id="L1774">            boolean isUnicode = StringSupport.isUnicode(enc);</span>
<span class="fc" id="L1775">            p = start; </span>
<span class="fc bfc" id="L1776" title="All 2 branches covered.">            while (p &lt; end) {</span>
                final int c;
                final int cl;
<span class="pc bpc" id="L1779" title="1 of 2 branches missed.">                if (enc.isAsciiCompatible()) {</span>
<span class="fc" id="L1780">                    cl = 1;</span>
<span class="fc" id="L1781">                    c = bytes[p] &amp; 0xff;</span>
                } else {
<span class="nc" id="L1783">                    cl = StringSupport.preciseLength(enc, bytes, p, end);</span>
<span class="nc" id="L1784">                    c = enc.mbcToCode(bytes, p, end);</span>
                }
                
<span class="pc bpc" id="L1787" title="1 of 4 branches missed.">                if (c == '\\' &amp;&amp; p + cl &lt; end) {</span>
<span class="fc" id="L1788">                    int n = cl + StringSupport.length(enc, bytes, p + cl, end);</span>
<span class="fc" id="L1789">                    to.append(bytes, p, n);</span>
<span class="fc" id="L1790">                    p += n;</span>
<span class="fc" id="L1791">                    continue;</span>
<span class="fc bfc" id="L1792" title="All 2 branches covered.">                } else if (c == '/') {</span>
<span class="fc" id="L1793">                    to.append((byte) '\\');</span>
<span class="fc" id="L1794">                    to.append(bytes, p, cl);</span>
<span class="pc bpc" id="L1795" title="1 of 2 branches missed.">                } else if (!Encoding.isAscii(c)) {</span>
<span class="nc" id="L1796">                    int l = StringSupport.preciseLength(enc, bytes, p, end);</span>
<span class="nc bnc" id="L1797" title="All 2 branches missed.">                    if (l &lt;= 0) {</span>
<span class="nc" id="L1798">                        l = 1;</span>
<span class="nc" id="L1799">                        Sprintf.sprintf(runtime, to, &quot;\\x%02X&quot;, c);</span>
<span class="nc bnc" id="L1800" title="All 2 branches missed.">                    } else if (resEnc != null) {</span>
<span class="nc" id="L1801">                        int code = enc.mbcToCode(bytes, p, end);</span>
<span class="nc" id="L1802">                        Sprintf.sprintf(runtime, to , StringSupport.escapedCharFormat(code, isUnicode), code);</span>
<span class="nc" id="L1803">                    } else {</span>
<span class="nc" id="L1804">                        to.append(bytes, p, l);</span>
                    }
<span class="nc" id="L1806">                    p += l;</span>

<span class="nc" id="L1808">                    continue;    </span>
<span class="fc bfc" id="L1809" title="All 2 branches covered.">                } else if (enc.isPrint(c)) {</span>
<span class="fc" id="L1810">                    to.append(bytes, p, cl);</span>
<span class="pc bpc" id="L1811" title="1 of 2 branches missed.">                } else if (!enc.isSpace(c)) {</span>
<span class="nc" id="L1812">                    Sprintf.sprintf(runtime, to, &quot;\\x%02X&quot;, c);</span>
                } else {
<span class="fc" id="L1814">                    to.append(bytes, p, cl);</span>
                }
<span class="fc" id="L1816">                p += cl;</span>
<span class="fc" id="L1817">            }</span>
        }
<span class="fc" id="L1819">    }</span>
    
    // option_to_str
    private static void appendOptions(ByteList to, RegexpOptions options) {
<span class="fc bfc" id="L1823" title="All 2 branches covered.">        if (options.isMultiline()) to.append((byte)'m');</span>
<span class="fc bfc" id="L1824" title="All 2 branches covered.">        if (options.isIgnorecase()) to.append((byte)'i');</span>
<span class="fc bfc" id="L1825" title="All 2 branches covered.">        if (options.isExtended()) to.append((byte)'x');</span>
<span class="fc" id="L1826">    }</span>

<span class="fc" id="L1828">    private static String[] NO_NAMES = new String[] {}; //TODO: Perhaps we have another empty string arr</span>
    public String[] getNames() {
<span class="fc" id="L1830">        int nameLength = pattern.numberOfNames();</span>
<span class="fc bfc" id="L1831" title="All 2 branches covered.">        if (nameLength == 0) return NO_NAMES;</span>

<span class="fc" id="L1833">        String[] names = new String[nameLength];</span>
<span class="fc" id="L1834">        int j = 0;</span>
<span class="fc bfc" id="L1835" title="All 2 branches covered.">        for (Iterator&lt;NameEntry&gt; i = pattern.namedBackrefIterator(); i.hasNext();) {</span>
<span class="fc" id="L1836">            NameEntry e = i.next();</span>
<span class="fc" id="L1837">            names[j++] = new String(e.name, e.nameP, e.nameEnd - e.nameP).intern();</span>
<span class="fc" id="L1838">        }</span>

<span class="fc" id="L1840">        return names;</span>
    }

    /** rb_reg_names
     * 
     */
    @JRubyMethod
    public IRubyObject names(ThreadContext context) {
<span class="fc" id="L1848">        check();</span>
<span class="fc bfc" id="L1849" title="All 2 branches covered.">        if (pattern.numberOfNames() == 0) return getRuntime().newEmptyArray();</span>

<span class="fc" id="L1851">        RubyArray ary = context.runtime.newArray(pattern.numberOfNames());</span>
<span class="fc bfc" id="L1852" title="All 2 branches covered.">        for (Iterator&lt;NameEntry&gt; i = pattern.namedBackrefIterator(); i.hasNext();) {</span>
<span class="fc" id="L1853">            NameEntry e = i.next();</span>
<span class="fc" id="L1854">            ary.append(RubyString.newStringShared(getRuntime(), e.name, e.nameP, e.nameEnd - e.nameP));</span>
<span class="fc" id="L1855">        }</span>
<span class="fc" id="L1856">        return ary;</span>
    }

    /** rb_reg_named_captures
     * 
     */
    @JRubyMethod
    public IRubyObject named_captures(ThreadContext context) {
<span class="fc" id="L1864">        check();</span>
<span class="fc" id="L1865">        RubyHash hash = RubyHash.newHash(getRuntime());</span>
<span class="fc bfc" id="L1866" title="All 2 branches covered.">        if (pattern.numberOfNames() == 0) return hash;</span>

<span class="fc bfc" id="L1868" title="All 2 branches covered.">        for (Iterator&lt;NameEntry&gt; i = pattern.namedBackrefIterator(); i.hasNext();) {</span>
<span class="fc" id="L1869">            NameEntry e = i.next();</span>
<span class="fc" id="L1870">            int[]backrefs = e.getBackRefs();</span>
<span class="fc" id="L1871">            RubyArray ary = getRuntime().newArray(backrefs.length);</span>

<span class="fc bfc" id="L1873" title="All 2 branches covered.">            for (int backref : backrefs) ary.append(RubyFixnum.newFixnum(getRuntime(), backref));</span>
<span class="fc" id="L1874">            hash.fastASet(RubyString.newStringShared(getRuntime(), e.name, e.nameP, e.nameEnd - e.nameP).freeze(context), ary);</span>
<span class="fc" id="L1875">        }</span>
<span class="fc" id="L1876">        return hash;</span>
    }

    @JRubyMethod
    public IRubyObject encoding(ThreadContext context) {
<span class="pc bpc" id="L1881" title="1 of 2 branches missed.">        Encoding enc = (pattern == null) ? str.getEncoding() : pattern.getEncoding();</span>
<span class="fc" id="L1882">        return context.runtime.getEncodingService().getEncoding(enc);</span>
    }

    @JRubyMethod(name = &quot;fixed_encoding?&quot;)
    public IRubyObject fixed_encoding_p(ThreadContext context) {
<span class="fc" id="L1887">        return context.runtime.newBoolean(options.isFixed());</span>
    }

    /** rb_reg_nth_match
    *
    */
    public static IRubyObject nth_match(int nth, IRubyObject match) {
<span class="fc bfc" id="L1894" title="All 2 branches covered.">        if (match.isNil()) return match;</span>
<span class="fc" id="L1895">        RubyMatchData m = (RubyMatchData)match;</span>
<span class="fc" id="L1896">        m.check();</span>

<span class="fc" id="L1898">        Ruby runtime = m.getRuntime();</span>

        final int start, end;
<span class="fc bfc" id="L1901" title="All 2 branches covered.">        if (m.regs == null) {</span>
<span class="pc bpc" id="L1902" title="4 of 6 branches missed.">            if (nth &gt;= 1 || (nth &lt; 0 &amp;&amp; ++nth &lt;= 0)) return runtime.getNil();</span>
<span class="fc" id="L1903">            start = m.begin;</span>
<span class="fc" id="L1904">            end = m.end;</span>
        } else {
<span class="fc bfc" id="L1906" title="All 6 branches covered.">            if (nth &gt;= m.regs.numRegs || (nth &lt; 0 &amp;&amp; (nth+=m.regs.numRegs) &lt;= 0)) return runtime.getNil();</span>
<span class="fc" id="L1907">            start = m.regs.beg[nth];</span>
<span class="fc" id="L1908">            end = m.regs.end[nth];</span>
        }

<span class="fc bfc" id="L1911" title="All 2 branches covered.">        if (start == -1) return runtime.getNil();</span>

<span class="fc" id="L1913">        RubyString str = m.str.makeShared19(runtime, m.str.getType(), start, end - start);</span>
<span class="fc" id="L1914">        str.infectBy(m);</span>
<span class="fc" id="L1915">        return str;</span>
    }

    /** rb_reg_last_match
     *
     */
    public static IRubyObject last_match(IRubyObject match) {
<span class="fc" id="L1922">        return nth_match(0, match);</span>
    }

    /** rb_reg_match_pre
     *
     */
    public static IRubyObject match_pre(IRubyObject match) {
<span class="pc bpc" id="L1929" title="1 of 2 branches missed.">        if (match.isNil()) return match;</span>
<span class="fc" id="L1930">        RubyMatchData m = (RubyMatchData)match;</span>
<span class="fc" id="L1931">        m.check();</span>

<span class="fc" id="L1933">        Ruby runtime = m.getRuntime();</span>
<span class="pc bpc" id="L1934" title="1 of 2 branches missed.">        if (m.begin == -1) runtime.getNil(); </span>
<span class="fc" id="L1935">        return m.str.makeShared19(runtime, m.str.getType(), 0,  m.begin).infectBy(m);</span>
    }

    /** rb_reg_match_post
     *
     */
    public static IRubyObject match_post(IRubyObject match) {
<span class="pc bpc" id="L1942" title="1 of 2 branches missed.">        if (match.isNil()) return match;</span>
<span class="fc" id="L1943">        RubyMatchData m = (RubyMatchData)match;</span>
<span class="fc" id="L1944">        m.check();</span>

<span class="fc" id="L1946">        Ruby runtime = m.getRuntime();</span>
<span class="pc bpc" id="L1947" title="1 of 2 branches missed.">        if (m.begin == -1) return runtime.getNil();</span>
<span class="fc" id="L1948">        return m.str.makeShared19(runtime, m.str.getType(), m.end, m.str.getByteList().getRealSize() - m.end).infectBy(m);</span>
    }

    /** rb_reg_match_last
     *
     */
    public static IRubyObject match_last(IRubyObject match) {
<span class="pc bpc" id="L1955" title="1 of 2 branches missed.">        if (match.isNil()) return match;</span>
<span class="fc" id="L1956">        RubyMatchData m = (RubyMatchData)match;</span>
<span class="fc" id="L1957">        m.check();</span>

<span class="pc bpc" id="L1959" title="2 of 4 branches missed.">        if (m.regs == null || m.regs.beg[0] == -1) return match.getRuntime().getNil();</span>

        int i;
<span class="pc bpc" id="L1962" title="1 of 4 branches missed.">        for (i = m.regs.numRegs - 1; m.regs.beg[i] == -1 &amp;&amp; i &gt; 0; i--);</span>
<span class="pc bpc" id="L1963" title="1 of 2 branches missed.">        if (i == 0) return match.getRuntime().getNil();</span>
        
<span class="fc" id="L1965">        return nth_match(i, match);</span>
    }

    // MRI: ASCGET macro from rb_reg_regsub
    private static final int ASCGET(boolean acompat, byte[] sBytes, int s, int e, int[] cl, Encoding strEnc) {
<span class="pc bpc" id="L1970" title="1 of 2 branches missed.">        if (acompat) {</span>
<span class="fc" id="L1971">            cl[0] = 1;</span>
<span class="pc bpc" id="L1972" title="1 of 2 branches missed.">            return Encoding.isAscii(sBytes[s]) ? sBytes[s] &amp; 0xFF : -1;</span>
        } else {
<span class="nc" id="L1974">            return EncodingUtils.encAscget(sBytes, s, e, cl, strEnc);</span>
        }
    }

    // rb_reg_regsub
    static RubyString regsub19(ThreadContext context, RubyString str, RubyString src, Matcher matcher, Regex pattern) {
<span class="fc" id="L1980">        Ruby runtime = str.getRuntime();</span>

<span class="fc" id="L1982">        RubyString val = null;</span>
        int p, s, e;
<span class="fc" id="L1984">        int no = 0, clen[] = {0};</span>
<span class="fc" id="L1985">        Encoding strEnc = EncodingUtils.encGet(context, str);</span>
<span class="fc" id="L1986">        Encoding srcEnc = EncodingUtils.encGet(context, src);</span>
<span class="fc" id="L1987">        boolean acompat = EncodingUtils.encAsciicompat(strEnc);</span>

<span class="fc" id="L1989">        Region regs = matcher.getRegion();</span>
<span class="fc" id="L1990">        ByteList bs = str.getByteList();</span>
<span class="fc" id="L1991">        ByteList srcbs = src.getByteList();</span>
<span class="fc" id="L1992">        byte[] sBytes = bs.getUnsafeBytes();</span>

<span class="fc" id="L1994">        p = s = bs.getBegin();</span>
<span class="fc" id="L1995">        e = p + bs.getRealSize();</span>

<span class="fc bfc" id="L1997" title="All 2 branches covered.">        while (s &lt; e) {</span>
<span class="fc" id="L1998">            int c = ASCGET(acompat, sBytes, s, e, clen, strEnc);</span>

<span class="pc bpc" id="L2000" title="1 of 2 branches missed.">            if (c == -1) {</span>
<span class="nc" id="L2001">                s += StringSupport.length(strEnc, sBytes, s, e);</span>
<span class="nc" id="L2002">                continue;</span>
            }
<span class="fc" id="L2004">            int ss = s;</span>
<span class="fc" id="L2005">            s += clen[0];</span>

<span class="fc bfc" id="L2007" title="All 4 branches covered.">            if (c != '\\' || s == e) continue;</span>

<span class="fc bfc" id="L2009" title="All 2 branches covered.">            if (val == null) {</span>
<span class="fc" id="L2010">                val = RubyString.newString(str.getRuntime(), new ByteList(ss - p));</span>
            }
<span class="fc" id="L2012">            EncodingUtils.encStrBufCat(runtime, val, sBytes, p, ss - p, strEnc);</span>

<span class="fc" id="L2014">            c = ASCGET(acompat, sBytes, s, e, clen, strEnc);</span>

<span class="pc bpc" id="L2016" title="1 of 2 branches missed.">            if (c == -1) {</span>
<span class="nc" id="L2017">                s += StringSupport.length(strEnc, sBytes, s, e);</span>
<span class="nc" id="L2018">                EncodingUtils.encStrBufCat(runtime, val, sBytes, ss, s - ss, strEnc);</span>
<span class="nc" id="L2019">                p = s;</span>
<span class="nc" id="L2020">                continue;</span>
            }
<span class="fc" id="L2022">            s += clen[0];</span>

<span class="fc" id="L2024">            p = s;</span>
<span class="fc bfc" id="L2025" title="All 8 branches covered.">            switch (c) {</span>
            case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
<span class="pc bpc" id="L2028" title="1 of 2 branches missed.">                if (pattern.noNameGroupIsActive(Syntax.RUBY)) {</span>
<span class="fc" id="L2029">                    no = c - '0';</span>
<span class="fc" id="L2030">                    break;</span>
                } else {
                    continue;
                }
            case 'k':
<span class="pc bpc" id="L2035" title="2 of 4 branches missed.">                if (s &lt; e &amp;&amp; ASCGET(acompat, sBytes, s, e, clen, strEnc) == '&lt;') {</span>
<span class="fc" id="L2036">                    int name = s + clen[0];</span>
<span class="fc" id="L2037">                    int nameEnd = name;</span>
<span class="pc bpc" id="L2038" title="1 of 2 branches missed.">                    while (nameEnd &lt; e) {</span>
<span class="fc" id="L2039">                        c = ASCGET(acompat, sBytes, nameEnd, e, clen, strEnc);</span>
<span class="fc bfc" id="L2040" title="All 2 branches covered.">                        if (c == '&gt;') break;</span>
<span class="pc bpc" id="L2041" title="1 of 2 branches missed.">                        nameEnd += c == -1 ? StringSupport.length(strEnc, sBytes, nameEnd, e) : clen[0];</span>
                    }
<span class="pc bpc" id="L2043" title="1 of 2 branches missed.">                    if (nameEnd &lt; e) {</span>
                        try {
<span class="fc" id="L2045">                            no = pattern.nameToBackrefNumber(sBytes, name, nameEnd, regs);</span>
<span class="nc" id="L2046">                        } catch (JOniException je) {</span>
<span class="nc" id="L2047">                            throw str.getRuntime().newIndexError(je.getMessage());</span>
<span class="fc" id="L2048">                        }</span>
<span class="fc" id="L2049">                        p = s = nameEnd + clen[0];</span>
<span class="fc" id="L2050">                        break;</span>
                    } else {
<span class="nc" id="L2052">                        throw str.getRuntime().newRuntimeError(&quot;invalid group name reference format&quot;);</span>
                    }
                }

<span class="nc" id="L2056">                EncodingUtils.encStrBufCat(runtime, val, sBytes, ss, s - ss, strEnc);</span>
<span class="nc" id="L2057">                continue;</span>
            case '0': case '&amp;':
<span class="fc" id="L2059">                no = 0;</span>
<span class="fc" id="L2060">                break;</span>
            case '`':
<span class="fc" id="L2062">                EncodingUtils.encStrBufCat(runtime, val, srcbs.getUnsafeBytes(), srcbs.getBegin(), matcher.getBegin(), srcEnc);</span>
<span class="fc" id="L2063">                continue;</span>
            case '\'':
<span class="fc" id="L2065">                EncodingUtils.encStrBufCat(runtime, val, srcbs.getUnsafeBytes(), srcbs.getBegin() + matcher.getEnd(), srcbs.getRealSize() - matcher.getEnd(), srcEnc);</span>
<span class="fc" id="L2066">                continue;</span>
            case '+':
<span class="fc bfc" id="L2068" title="All 2 branches covered.">                if (regs != null) {</span>
<span class="fc" id="L2069">                    no = regs.numRegs - 1;</span>
<span class="pc bpc" id="L2070" title="1 of 4 branches missed.">                    while (regs.beg[no] == -1 &amp;&amp; no &gt; 0) no--;</span>
                }
<span class="fc bfc" id="L2072" title="All 2 branches covered.">                if (no == 0) continue;</span>
                break;
            case '\\':
<span class="fc" id="L2075">                EncodingUtils.encStrBufCat(runtime, val, sBytes, s - clen[0], clen[0], strEnc);</span>
<span class="fc" id="L2076">                continue;</span>
            default:
<span class="fc" id="L2078">                EncodingUtils.encStrBufCat(runtime, val, sBytes, ss, s - ss, strEnc);</span>
<span class="fc" id="L2079">                continue;</span>
            }

<span class="fc bfc" id="L2082" title="All 2 branches covered.">            if (regs != null) {</span>
<span class="pc bpc" id="L2083" title="1 of 2 branches missed.">                if (no &gt;= 0) {</span>
<span class="pc bpc" id="L2084" title="1 of 2 branches missed.">                    if (no &gt;= regs.numRegs) continue;</span>
<span class="fc bfc" id="L2085" title="All 2 branches covered.">                    if (regs.beg[no] == -1) continue;</span>
<span class="fc" id="L2086">                    EncodingUtils.encStrBufCat(runtime, val, srcbs.getUnsafeBytes(), srcbs.getBegin() + regs.beg[no], regs.end[no] - regs.beg[no], srcEnc);</span>
                }
            } else {
<span class="pc bpc" id="L2089" title="1 of 4 branches missed.">                if (no != 0 || matcher.getBegin() == -1) continue;</span>
<span class="fc" id="L2090">                EncodingUtils.encStrBufCat(runtime, val, srcbs.getUnsafeBytes(), srcbs.getBegin() + matcher.getBegin(), matcher.getEnd() - matcher.getBegin(), srcEnc);</span>
            }
<span class="fc" id="L2092">        }</span>

<span class="fc bfc" id="L2094" title="All 2 branches covered.">        if (val == null) return str;</span>
<span class="fc bfc" id="L2095" title="All 2 branches covered.">        if (p &lt; e) EncodingUtils.encStrBufCat(runtime, val, sBytes, p, e - p, strEnc);</span>
<span class="fc" id="L2096">        return val;</span>
    }

    final int adjustStartPos19(RubyString str, int pos, boolean reverse) {
<span class="fc" id="L2100">        return adjustStartPosInternal(str, checkEncoding(str, false), pos, reverse);</span>
    }

    final int adjustStartPos(RubyString str, int pos, boolean reverse) {
<span class="nc" id="L2104">        return adjustStartPosInternal(str, pattern.getEncoding(), pos, reverse);</span>
    }

    private final int adjustStartPosInternal(RubyString str, Encoding enc, int pos, boolean reverse) {
<span class="fc" id="L2108">        check();</span>

<span class="fc" id="L2110">        ByteList value = str.getByteList();</span>
<span class="fc" id="L2111">        int len = value.getRealSize();</span>
<span class="pc bpc" id="L2112" title="1 of 6 branches missed.">        if (pos &gt; 0 &amp;&amp; enc.maxLength() != 1 &amp;&amp; pos &lt; len) {</span>
<span class="fc" id="L2113">            int start = value.getBegin();</span>
<span class="fc bfc" id="L2114" title="All 4 branches covered.">            if ((reverse ? -pos : len - pos) &gt; 0) {</span>
<span class="fc" id="L2115">                return enc.rightAdjustCharHead(value.getUnsafeBytes(), start, start + pos, start + len) - start;</span>
            } else {
<span class="fc" id="L2117">                return enc.leftAdjustCharHead(value.getUnsafeBytes(), start, start + pos, start + len) - start;</span>
            }
        }

<span class="fc" id="L2121">        return pos;</span>
    }

    private static IRubyObject operandNoCheck(IRubyObject str) {
<span class="fc bfc" id="L2125" title="All 2 branches covered.">        if (str instanceof RubySymbol) return ((RubySymbol)str).to_s();</span>
<span class="fc" id="L2126">        return str.checkStringType();</span>
    }

    private static RubyString operandCheck(Ruby runtime, IRubyObject str) {
<span class="fc bfc" id="L2130" title="All 2 branches covered.">        if (str instanceof RubySymbol) return (RubyString)((RubySymbol)str).to_s();</span>
<span class="fc" id="L2131">        IRubyObject tmp = str.checkStringType();</span>
<span class="fc bfc" id="L2132" title="All 2 branches covered.">        if (tmp.isNil()) throw runtime.newTypeError(&quot;can't convert &quot; + str.getMetaClass() + &quot; into String&quot;);</span>
<span class="fc" id="L2133">        return (RubyString)tmp;</span>
    }

    public static RubyRegexp unmarshalFrom(UnmarshalStream input) throws java.io.IOException {
<span class="fc" id="L2137">        RubyRegexp result = newRegexp(input.getRuntime(), input.unmarshalString(), RegexpOptions.fromJoniOptions(input.readSignedByte()));</span>
<span class="fc" id="L2138">        input.registerLinkTarget(result);</span>
<span class="fc" id="L2139">        return result;</span>
    }

    public static void marshalTo(RubyRegexp regexp, MarshalStream output) throws java.io.IOException {
<span class="fc" id="L2143">        output.registerLinkTarget(regexp);</span>
<span class="fc" id="L2144">        output.writeString(regexp.str);</span>
        
<span class="fc" id="L2146">        int options = regexp.pattern.getOptions() &amp; EMBEDDABLE;</span>

<span class="fc bfc" id="L2148" title="All 2 branches covered.">        if (regexp.getOptions().isFixed()) options |= ARG_ENCODING_FIXED;</span>
        
<span class="fc" id="L2150">        output.writeByte(options);</span>
<span class="fc" id="L2151">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>