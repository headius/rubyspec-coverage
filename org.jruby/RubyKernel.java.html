<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RubyKernel.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby</a> &gt; <span class="el_source">RubyKernel.java</span></div><h1>RubyKernel.java</h1><pre class="source lang-java linenums">/*
 ***** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2001 Chad Fowler &lt;chadfowler@chadfowler.com&gt;
 * Copyright (C) 2001 Alan Moore &lt;alan_moore@gmx.net&gt;
 * Copyright (C) 2001-2002 Benoit Cerrina &lt;b.cerrina@wanadoo.fr&gt;
 * Copyright (C) 2001-2004 Jan Arne Petersen &lt;jpetersen@uni-bonn.de&gt;
 * Copyright (C) 2002-2006 Thomas E Enebo &lt;enebo@acm.org&gt;
 * Copyright (C) 2002-2004 Anders Bengtsson &lt;ndrsbngtssn@yahoo.se&gt;
 * Copyright (C) 2004-2005 Charles O Nutter &lt;headius@headius.com&gt;
 * Copyright (C) 2004 Stefan Matthias Aust &lt;sma@3plus4.de&gt;
 * Copyright (C) 2005 Kiel Hodges &lt;jruby-devel@selfsosoft.com&gt;
 * Copyright (C) 2006 Evan Buswell &lt;evan@heron.sytes.net&gt;
 * Copyright (C) 2006 Ola Bini &lt;ola@ologix.com&gt;
 * Copyright (C) 2006 Michael Studman &lt;codehaus@michaelstudman.com&gt;
 * Copyright (C) 2006 Miguel Covarrubias &lt;mlcovarrubias@gmail.com&gt;
 * Copyright (C) 2007 Nick Sieger &lt;nicksieger@gmail.com&gt;
 * Copyright (C) 2008 Joseph LaFata &lt;joe@quibb.org&gt;
 * 
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby;

import org.jruby.anno.FrameField;
import org.jruby.anno.JRubyMethod;
import org.jruby.anno.JRubyModule;
import org.jruby.common.IRubyWarnings.ID;
import org.jruby.exceptions.MainExitException;
import org.jruby.exceptions.RaiseException;
import org.jruby.internal.runtime.methods.CallConfiguration;
import org.jruby.internal.runtime.methods.DynamicMethod;
import org.jruby.internal.runtime.methods.JavaMethod.JavaMethodNBlock;
import org.jruby.ir.interpreter.Interpreter;
import org.jruby.java.proxies.ConcreteJavaProxy;
import org.jruby.platform.Platform;
import org.jruby.runtime.Binding;
import org.jruby.runtime.Block;
import org.jruby.runtime.CallType;
import org.jruby.runtime.Helpers;
import org.jruby.runtime.ThreadContext;
import org.jruby.runtime.Visibility;
import org.jruby.runtime.backtrace.RubyStackTraceElement;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.runtime.load.IAutoloadMethod;
import org.jruby.util.ByteList;
import org.jruby.util.ConvertBytes;
import org.jruby.util.IdUtil;
import org.jruby.util.ShellLauncher;
import org.jruby.util.TypeConverter;
import org.jruby.util.cli.Options;
import org.jruby.util.io.OpenFile;
import org.jruby.util.io.PopenExecutor;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;

import static org.jruby.RubyEnumerator.enumeratorizeWithSize;
import static org.jruby.anno.FrameField.BLOCK;
import static org.jruby.anno.FrameField.FILENAME;
import static org.jruby.anno.FrameField.LASTLINE;
import static org.jruby.anno.FrameField.METHODNAME;
import static org.jruby.runtime.Visibility.PRIVATE;
import static org.jruby.runtime.Visibility.PROTECTED;
import static org.jruby.runtime.Visibility.PUBLIC;
import static org.jruby.RubyEnumerator.SizeFn;
import static org.jruby.anno.FrameField.*;

/**
 * Note: For CVS history, see KernelModule.java.
 */
@JRubyModule(name=&quot;Kernel&quot;)
<span class="nc" id="L96">public class RubyKernel {</span>
<span class="fc" id="L97">    public final static Class&lt;?&gt; IRUBY_OBJECT = IRubyObject.class;</span>

    public static abstract class MethodMissingMethod extends JavaMethodNBlock {
        public MethodMissingMethod(RubyModule implementationClass) {
<span class="fc" id="L101">            super(implementationClass, Visibility.PRIVATE, CallConfiguration.FrameFullScopeNone);</span>
<span class="fc" id="L102">        }</span>

        @Override
        public IRubyObject call(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="nc" id="L106">            return methodMissing(context, self, clazz, name, args, block);</span>
        }

        public abstract IRubyObject methodMissing(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block);

    }
    public static RubyModule createKernelModule(Ruby runtime) {
<span class="fc" id="L113">        RubyModule module = runtime.defineModule(&quot;Kernel&quot;);</span>
<span class="fc" id="L114">        runtime.setKernel(module);</span>

<span class="fc" id="L116">        module.defineAnnotatedMethods(RubyKernel.class);</span>
        
<span class="fc" id="L118">        module.setFlag(RubyObject.USER7_F, false); //Kernel is the only Module that doesn't need an implementor</span>

<span class="fc" id="L120">        runtime.setPrivateMethodMissing(new MethodMissingMethod(module) {</span>
            @Override
            public IRubyObject methodMissing(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="nc" id="L123">                return RubyKernel.methodMissing(context, self, name, PRIVATE, CallType.NORMAL, args, block);</span>
            }
        });

<span class="fc" id="L127">        runtime.setProtectedMethodMissing(new MethodMissingMethod(module) {</span>
            @Override
            public IRubyObject methodMissing(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="nc" id="L130">                return RubyKernel.methodMissing(context, self, name, PROTECTED, CallType.NORMAL, args, block);</span>
            }
        });

<span class="fc" id="L134">        runtime.setVariableMethodMissing(new MethodMissingMethod(module) {</span>
            @Override
            public IRubyObject methodMissing(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="nc" id="L137">                return RubyKernel.methodMissing(context, self, name, PUBLIC, CallType.VARIABLE, args, block);</span>
            }
        });

<span class="fc" id="L141">        runtime.setSuperMethodMissing(new MethodMissingMethod(module) {</span>
            @Override
            public IRubyObject methodMissing(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="nc" id="L144">                return RubyKernel.methodMissing(context, self, name, PUBLIC, CallType.SUPER, args, block);</span>
            }
        });

<span class="fc" id="L148">        runtime.setNormalMethodMissing(new MethodMissingMethod(module) {</span>
            @Override
            public IRubyObject methodMissing(ThreadContext context, IRubyObject self, RubyModule clazz, String name, IRubyObject[] args, Block block) {
<span class="nc" id="L151">                return RubyKernel.methodMissing(context, self, name, PUBLIC, CallType.NORMAL, args, block);</span>
            }
        });

<span class="fc" id="L155">        recacheBuiltinMethods(runtime);</span>

<span class="fc" id="L157">        return module;</span>
    }

    /**
     * Cache built-in versions of several core methods, to improve performance by using identity comparison (==) rather
     * than going ahead with dynamic dispatch.
     *
     * @param runtime
     */
    static void recacheBuiltinMethods(Ruby runtime) {
<span class="fc" id="L167">        RubyModule module = runtime.getKernel();</span>

<span class="fc" id="L169">        runtime.setRespondToMethod(module.searchMethod(&quot;respond_to?&quot;));</span>
<span class="fc" id="L170">        runtime.setRespondToMissingMethod(module.searchMethod(&quot;respond_to_missing?&quot;));</span>
<span class="fc" id="L171">    }</span>

    @JRubyMethod(module = true, visibility = PRIVATE)
    public static IRubyObject at_exit(ThreadContext context, IRubyObject recv, Block block) {
<span class="fc" id="L175">        return context.runtime.pushExitBlock(context.runtime.newProc(Block.Type.PROC, block));</span>
    }

    @JRubyMethod(name = &quot;autoload?&quot;, required = 1, module = true, visibility = PRIVATE)
    public static IRubyObject autoload_p(ThreadContext context, final IRubyObject recv, IRubyObject symbol) {
<span class="fc" id="L180">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L181">        final RubyModule module = getModuleForAutoload(runtime, recv);</span>
<span class="fc" id="L182">        String name = symbol.asJavaString();</span>
        
<span class="fc" id="L184">        String file = module.getAutoloadFile(name);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        return (file == null) ? runtime.getNil() : runtime.newString(file);</span>
    }

    @JRubyMethod(required = 2, module = true, visibility = PRIVATE)
    public static IRubyObject autoload(final IRubyObject recv, IRubyObject symbol, IRubyObject file) {
<span class="fc" id="L190">        Ruby runtime = recv.getRuntime(); </span>
<span class="fc" id="L191">        String nonInternedName = symbol.asJavaString();</span>
        
<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (!IdUtil.isValidConstantName(nonInternedName)) {</span>
<span class="fc" id="L194">            throw runtime.newNameError(&quot;autoload must be constant name&quot;, nonInternedName);</span>
        }

<span class="fc" id="L197">        final RubyString fileString = RubyFile.get_path(runtime.getCurrentContext(), file);</span>
        
<span class="fc bfc" id="L199" title="All 2 branches covered.">        if (fileString.isEmpty()) throw runtime.newArgumentError(&quot;empty file name&quot;);</span>
        
<span class="fc" id="L201">        final String baseName = symbol.asJavaString().intern(); // interned, OK for &quot;fast&quot; methods</span>
<span class="fc" id="L202">        final RubyModule module = getModuleForAutoload(runtime, recv);</span>
        
<span class="fc" id="L204">        IRubyObject existingValue = module.fetchConstant(baseName); </span>
<span class="fc bfc" id="L205" title="All 4 branches covered.">        if (existingValue != null &amp;&amp; existingValue != RubyObject.UNDEF) return runtime.getNil();</span>

<span class="fc" id="L207">        module.defineAutoload(baseName, new IAutoloadMethod() {</span>
            @Override
            public String file() {
<span class="fc" id="L210">                return fileString.asJavaString();</span>
            }

            @Override
            public void load(Ruby runtime) {
<span class="fc bfc" id="L215" title="All 2 branches covered.">                if (runtime.getLoadService().autoloadRequire(file())) {</span>
                    // Do not finish autoloading by cyclic autoload 
<span class="fc" id="L217">                    module.finishAutoload(baseName);</span>
                }
<span class="fc" id="L219">            }</span>
        });
<span class="fc" id="L221">        return runtime.getNil();</span>
    }

    private static RubyModule getModuleForAutoload(Ruby runtime, IRubyObject recv) {
<span class="fc bfc" id="L225" title="All 2 branches covered.">        RubyModule module = recv instanceof RubyModule ? (RubyModule) recv : recv.getMetaClass().getRealClass();</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">        if (module == runtime.getKernel()) {</span>
            // special behavior if calling Kernel.autoload directly
<span class="fc" id="L228">            module = runtime.getObject().getSingletonClass();</span>
        }
<span class="fc" id="L230">        return module;</span>
    }

    public static IRubyObject method_missing(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="nc" id="L234">        Visibility lastVis = context.getLastVisibility();</span>
<span class="nc" id="L235">        CallType lastCallType = context.getLastCallType();</span>

<span class="nc bnc" id="L237" title="All 4 branches missed.">        if (args.length == 0 || !(args[0] instanceof RubySymbol)) {</span>
<span class="nc" id="L238">            throw context.runtime.newArgumentError(&quot;no id given&quot;);</span>
        }

<span class="nc" id="L241">        return methodMissingDirect(context, recv, (RubySymbol)args[0], lastVis, lastCallType, args, block);</span>
    }

    protected static IRubyObject methodMissingDirect(ThreadContext context, IRubyObject recv, RubySymbol symbol, Visibility lastVis, CallType lastCallType, IRubyObject[] args, Block block) {
<span class="fc" id="L245">        Ruby runtime = context.runtime;</span>
        
        // create a lightweight thunk
<span class="fc" id="L248">        IRubyObject msg = new RubyNameError.RubyNameErrorMessage(runtime,</span>
                                                                 recv,
                                                                 symbol,
                                                                 lastVis,
                                                                 lastCallType);
        final IRubyObject[]exArgs;
        final RubyClass exc;
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (lastCallType != CallType.VARIABLE) {</span>
<span class="fc" id="L256">            exc = runtime.getNoMethodError();</span>
<span class="fc" id="L257">            exArgs = new IRubyObject[]{msg, symbol, RubyArray.newArrayNoCopy(runtime, args, 1)};</span>
        } else {
<span class="nc" id="L259">            exc = runtime.getNameError();</span>
<span class="nc" id="L260">            exArgs = new IRubyObject[]{msg, symbol};</span>
        }

<span class="fc" id="L263">        throw new RaiseException((RubyException)exc.newInstance(context, exArgs, Block.NULL_BLOCK));</span>
    }

    public static IRubyObject methodMissing(ThreadContext context, IRubyObject recv, String name, Visibility lastVis, CallType lastCallType, IRubyObject[] args, Block block) {
<span class="fc" id="L267">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L268">        RubySymbol symbol = runtime.newSymbol(name);</span>

        // create a lightweight thunk
<span class="fc" id="L271">        IRubyObject msg = new RubyNameError.RubyNameErrorMessage(runtime,</span>
                                                                 recv,
                                                                 symbol,
                                                                 lastVis,
                                                                 lastCallType);
        final IRubyObject[]exArgs;
        final RubyClass exc;
<span class="fc bfc" id="L278" title="All 2 branches covered.">        if (lastCallType != CallType.VARIABLE) {</span>
<span class="fc" id="L279">            exc = runtime.getNoMethodError();</span>
<span class="fc" id="L280">            exArgs = new IRubyObject[]{msg, symbol, RubyArray.newArrayNoCopy(runtime, args)};</span>
        } else {
<span class="fc" id="L282">            exc = runtime.getNameError();</span>
<span class="fc" id="L283">            exArgs = new IRubyObject[]{msg, symbol};</span>
        }

<span class="fc" id="L286">        throw new RaiseException((RubyException)exc.newInstance(context, exArgs, Block.NULL_BLOCK));</span>
    }
    

    private static IRubyObject[] popenArgs(Ruby runtime, String pipedArg, IRubyObject[] args) {
<span class="nc" id="L291">            IRubyObject command = runtime.newString(pipedArg.substring(1));</span>

<span class="nc bnc" id="L293" title="All 2 branches missed.">            if (args.length &gt;= 2) return new IRubyObject[] { command, args[1] };</span>

<span class="nc" id="L295">            return new IRubyObject[] { command };</span>
    }
    
    public static IRubyObject open(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="nc" id="L299">        return open19(context, recv, args, block);</span>
    }

    @JRubyMethod(name = &quot;open&quot;, required = 1, optional = 3, module = true, visibility = PRIVATE)
<span class="fc" id="L303">    public static IRubyObject open19(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {Ruby runtime = context.runtime;</span>
        //        ID to_open = 0;
<span class="fc" id="L305">        boolean redirect = false;</span>
<span class="fc" id="L306">        int argc = args.length;</span>

<span class="pc bpc" id="L308" title="1 of 2 branches missed.">        if (argc &gt;= 1) {</span>
            //            CONST_ID(to_open, &quot;to_open&quot;);
<span class="fc bfc" id="L310" title="All 2 branches covered.">            if (args[0].respondsTo(&quot;to_open&quot;)) {</span>
<span class="fc" id="L311">                redirect = true;</span>
            } else {
<span class="fc" id="L313">                IRubyObject tmp = args[0];</span>
<span class="fc" id="L314">                tmp = RubyFile.get_path(context, tmp);</span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">                if (tmp.isNil()) {</span>
<span class="nc" id="L316">                    redirect = true;</span>
                } else {
<span class="fc" id="L318">                    IRubyObject cmd = PopenExecutor.checkPipeCommand(context, tmp);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">                    if (!cmd.isNil()) {</span>
<span class="fc" id="L320">                        args[0] = cmd;</span>
<span class="fc" id="L321">                        return PopenExecutor.popen(context, args, runtime.getIO(), block);</span>
                    }
                }
            }
        }
<span class="fc bfc" id="L326" title="All 2 branches covered.">        if (redirect) {</span>
<span class="fc" id="L327">            IRubyObject io = args[0].callMethod(context, &quot;to_open&quot;, Arrays.copyOfRange(args, 1, args.length));</span>

<span class="fc" id="L329">            RubyIO.ensureYieldClose(context, io, block);</span>
<span class="fc" id="L330">            return io;</span>
        }
<span class="fc" id="L332">        return RubyIO.open(context, runtime.getFile(), args, block);</span>
    }

    @JRubyMethod(module = true, visibility = PRIVATE)
    public static IRubyObject getc(ThreadContext context, IRubyObject recv) {
<span class="nc" id="L337">        context.runtime.getWarnings().warn(ID.DEPRECATED_METHOD, &quot;getc is obsolete; use STDIN.getc instead&quot;);</span>
<span class="nc" id="L338">        IRubyObject defin = context.runtime.getGlobalVariables().get(&quot;$stdin&quot;);</span>
<span class="nc" id="L339">        return defin.callMethod(context, &quot;getc&quot;);</span>
    }

    @JRubyMethod(optional = 1, module = true, visibility = PRIVATE)
    public static IRubyObject gets(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="fc" id="L344">        return RubyArgsFile.gets(context, context.runtime.getArgsFile(), args);</span>
    }

    @JRubyMethod(optional = 1, module = true, visibility = PRIVATE)
    public static IRubyObject abort(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="fc" id="L349">        Ruby runtime = context.runtime;</span>

<span class="fc" id="L351">        RubyString message = null;</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">        if(args.length == 1) {</span>
<span class="fc" id="L353">            message = args[0].convertToString();</span>
<span class="fc" id="L354">            runtime.getGlobalVariables().get(&quot;$stderr&quot;).callMethod(context, &quot;puts&quot;, message);</span>
        }
        
<span class="nc" id="L357">        exit(runtime, new IRubyObject[] { runtime.getFalse(), message }, false);</span>
<span class="nc" id="L358">        return runtime.getNil(); // not reached</span>
    }

    // MRI: rb_f_array
    @JRubyMethod(name = &quot;Array&quot;, required = 1, module = true, visibility = PRIVATE)
    public static IRubyObject new_array(ThreadContext context, IRubyObject recv, IRubyObject object) {
<span class="fc" id="L364">        return TypeConverter.rb_Array(context, object);</span>
    }

    @JRubyMethod(name = &quot;Complex&quot;, module = true, visibility = PRIVATE)
    public static IRubyObject new_complex(ThreadContext context, IRubyObject recv) {
<span class="nc" id="L369">        return Helpers.invoke(context, context.runtime.getComplex(), &quot;convert&quot;);</span>
    }
    @JRubyMethod(name = &quot;Complex&quot;, module = true, visibility = PRIVATE)
    public static IRubyObject new_complex(ThreadContext context, IRubyObject recv, IRubyObject arg) {
<span class="fc" id="L373">        return Helpers.invoke(context, context.runtime.getComplex(), &quot;convert&quot;, arg);</span>
    }
    @JRubyMethod(name = &quot;Complex&quot;, module = true, visibility = PRIVATE)
    public static IRubyObject new_complex(ThreadContext context, IRubyObject recv, IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L377">        return Helpers.invoke(context, context.runtime.getComplex(), &quot;convert&quot;, arg0, arg1);</span>
    }
    
    @JRubyMethod(name = &quot;Rational&quot;, module = true, visibility = PRIVATE)
    public static IRubyObject new_rational(ThreadContext context, IRubyObject recv) {
<span class="nc" id="L382">        return Helpers.invoke(context, context.runtime.getRational(), &quot;convert&quot;);</span>
    }
    @JRubyMethod(name = &quot;Rational&quot;, module = true, visibility = PRIVATE)
    public static IRubyObject new_rational(ThreadContext context, IRubyObject recv, IRubyObject arg) {
<span class="fc" id="L386">        return Helpers.invoke(context, context.runtime.getRational(), &quot;convert&quot;, arg);</span>
    }
    @JRubyMethod(name = &quot;Rational&quot;, module = true, visibility = PRIVATE)
    public static IRubyObject new_rational(ThreadContext context, IRubyObject recv, IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L390">        return Helpers.invoke(context, context.runtime.getRational(), &quot;convert&quot;, arg0, arg1);</span>
    }

    public static RubyFloat new_float(IRubyObject recv, IRubyObject object) {
<span class="fc" id="L394">        return new_float19(recv, object);</span>
    }

    @JRubyMethod(name = &quot;Float&quot;, module = true, visibility = PRIVATE)
    public static RubyFloat new_float19(IRubyObject recv, IRubyObject object) {
<span class="fc" id="L399">        Ruby runtime = recv.getRuntime();</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">        if(object instanceof RubyFixnum){</span>
<span class="fc" id="L401">            return RubyFloat.newFloat(runtime, ((RubyFixnum)object).getDoubleValue());</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">        } else if (object instanceof RubyFloat) {</span>
<span class="fc" id="L403">            return (RubyFloat)object;</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">        } else if(object instanceof RubyBignum){</span>
<span class="fc" id="L405">            return RubyFloat.newFloat(runtime, RubyBignum.big2dbl((RubyBignum)object));</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">        } else if(object instanceof RubyString){</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">            if(((RubyString) object).getByteList().getRealSize() == 0){ // rb_cstr_to_dbl case</span>
<span class="fc" id="L408">                throw runtime.newArgumentError(&quot;invalid value for Float(): &quot; + object.inspect());</span>
            }
<span class="fc" id="L410">            RubyString arg = (RubyString)object;</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">            if (arg.toString().startsWith(&quot;0x&quot;)) {</span>
<span class="fc" id="L412">                return ConvertBytes.byteListToInum19(runtime, arg.getByteList(), 16, true).toFloat();</span>
            }
<span class="fc" id="L414">            return RubyNumeric.str2fnum19(runtime, arg,true);</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">        } else if(object.isNil()){</span>
<span class="fc" id="L416">            throw runtime.newTypeError(&quot;can't convert nil into Float&quot;);</span>
        } else {
<span class="fc" id="L418">            return (RubyFloat)TypeConverter.convertToType19(object, runtime.getFloat(), &quot;to_f&quot;);</span>
        }
    }
    
    @JRubyMethod(name = &quot;Hash&quot;, required = 1, module = true, visibility = PRIVATE)
    public static IRubyObject new_hash(ThreadContext context, IRubyObject recv, IRubyObject arg) {
        IRubyObject tmp;
<span class="fc" id="L425">        Ruby runtime = recv.getRuntime();</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">        if (arg.isNil()) return RubyHash.newHash(runtime);</span>
<span class="fc" id="L427">        tmp = TypeConverter.checkHashType(runtime, arg);</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">        if (tmp.isNil()) {</span>
<span class="pc bpc" id="L429" title="1 of 4 branches missed.">            if (arg instanceof RubyArray &amp;&amp; ((RubyArray) arg).isEmpty()) {</span>
<span class="fc" id="L430">                return RubyHash.newHash(runtime);</span>
            }
<span class="fc" id="L432">            throw runtime.newTypeError(&quot;can't convert &quot; + arg.getMetaClass() + &quot; into Hash&quot;);</span>
        }
<span class="fc" id="L434">        return tmp;</span>
    } 

    public static IRubyObject new_integer(ThreadContext context, IRubyObject recv, IRubyObject object) {
<span class="nc" id="L438">        return new_integer19(context, recv, object);</span>
    }

    @JRubyMethod(name = &quot;Integer&quot;, module = true, visibility = PRIVATE)
    public static IRubyObject new_integer19(ThreadContext context, IRubyObject recv, IRubyObject object) {
<span class="fc" id="L443">        return newIntegerCommon(context, object, 0);</span>
    }

    @JRubyMethod(name = &quot;Integer&quot;, module = true, visibility = PRIVATE)
    public static IRubyObject new_integer19(ThreadContext context, IRubyObject recv, IRubyObject object, IRubyObject base) {
<span class="fc" id="L448">        return newIntegerCommon(context, object, RubyNumeric.num2int(base));</span>
    }

    private static IRubyObject newIntegerCommon(ThreadContext context, IRubyObject object, int bs) {
<span class="fc" id="L452">        return TypeConverter.convertToInteger(context, object, bs);</span>
    }

    public static IRubyObject new_string(ThreadContext context, IRubyObject recv, IRubyObject object) {
<span class="nc" id="L456">        return new_string19(context, recv, object);</span>
    }

    @JRubyMethod(name = &quot;String&quot;, required = 1, module = true, visibility = PRIVATE)
    public static IRubyObject new_string19(ThreadContext context, IRubyObject recv, IRubyObject object) {
<span class="fc" id="L461">        return TypeConverter.convertToType19(object, context.runtime.getString(), &quot;to_s&quot;);</span>
    }

    // MRI: rb_f_p_internal
    @JRubyMethod(rest = true, module = true, visibility = PRIVATE)
    public static IRubyObject p(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="fc" id="L467">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L468">        int argc = args.length;</span>
        int i;
<span class="fc" id="L470">        IRubyObject ret = context.nil;</span>
<span class="fc" id="L471">        IRubyObject defout = runtime.getGlobalVariables().get(&quot;$&gt;&quot;);</span>
<span class="fc" id="L472">        IRubyObject defaultRS = context.runtime.getGlobalVariables().getDefaultSeparator();</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">        boolean defoutWriteBuiltin = defout instanceof RubyIO &amp;&amp;</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">                defout.getMetaClass().isMethodBuiltin(&quot;write&quot;);</span>

<span class="fc bfc" id="L476" title="All 2 branches covered.">        for (i=0; i&lt;argc; i++) {</span>
            // pulled out as rb_p in MRI
//            rb_p(argv[i]);
<span class="fc" id="L479">            IRubyObject obj = args[i];</span>
<span class="fc" id="L480">            IRubyObject str = RubyBasicObject.rbInspect(context, obj);</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">            if (defoutWriteBuiltin) {</span>
<span class="fc" id="L482">                ((RubyIO)defout).write(context, str, true);</span>
<span class="fc" id="L483">                ((RubyIO)defout).write(context, defaultRS, true);</span>
            }
            else {
<span class="fc" id="L486">                RubyIO.write(context, defout, str);</span>
<span class="fc" id="L487">                RubyIO.write(context, defout, defaultRS);</span>
            }
        }
<span class="fc bfc" id="L490" title="All 2 branches covered.">        if (argc == 1) {</span>
<span class="fc" id="L491">            ret = args[0];</span>
        }
<span class="fc bfc" id="L493" title="All 2 branches covered.">        else if (argc &gt; 1) {</span>
<span class="fc" id="L494">            ret = RubyArray.newArray(runtime, args);</span>
        }

<span class="fc bfc" id="L497" title="All 2 branches covered.">        if (defout instanceof RubyIO) {</span>
<span class="fc" id="L498">            ((RubyIO)defout).flush(context);</span>
        }
<span class="fc" id="L500">        return ret;</span>
    }

    @JRubyMethod(required = 1, module = true)
    public static IRubyObject public_method(ThreadContext context, IRubyObject recv, IRubyObject symbol) {
<span class="fc" id="L505">        return recv.getMetaClass().newMethod(recv, symbol.asJavaString(), true, PUBLIC, true, false);</span>
    }

    /** rb_f_putc
     */
    @JRubyMethod(required = 1, module = true, visibility = PRIVATE)
    public static IRubyObject putc(ThreadContext context, IRubyObject recv, IRubyObject ch) {
<span class="nc" id="L512">        IRubyObject defout = context.runtime.getGlobalVariables().get(&quot;$&gt;&quot;);</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">        if (recv == defout) {</span>
<span class="nc" id="L514">            return RubyIO.putc(context, recv, ch);</span>
        }
<span class="nc" id="L516">        return defout.callMethod(context, &quot;putc&quot;, ch);</span>
    }

    @JRubyMethod(module = true, visibility = PRIVATE)
    public static IRubyObject puts(ThreadContext context, IRubyObject recv) {
<span class="fc" id="L521">        IRubyObject defout = context.runtime.getGlobalVariables().get(&quot;$&gt;&quot;);</span>

<span class="pc bpc" id="L523" title="1 of 2 branches missed.">        if (recv == defout) {</span>
<span class="nc" id="L524">            return RubyIO.puts0(context, recv);</span>
        }

<span class="fc" id="L527">        return defout.callMethod(context, &quot;puts&quot;);</span>
    }

    @JRubyMethod(module = true, visibility = PRIVATE)
    public static IRubyObject puts(ThreadContext context, IRubyObject recv, IRubyObject arg0) {
<span class="fc" id="L532">        IRubyObject defout = context.runtime.getGlobalVariables().get(&quot;$&gt;&quot;);</span>

<span class="pc bpc" id="L534" title="1 of 2 branches missed.">        if (recv == defout) {</span>
<span class="nc" id="L535">            return RubyIO.puts1(context, recv, arg0);</span>
        }

<span class="fc" id="L538">        return defout.callMethod(context, &quot;puts&quot;, arg0);</span>
    }

    @JRubyMethod(module = true, visibility = PRIVATE)
    public static IRubyObject puts(ThreadContext context, IRubyObject recv, IRubyObject arg0, IRubyObject arg1) {
<span class="nc" id="L543">        IRubyObject defout = context.runtime.getGlobalVariables().get(&quot;$&gt;&quot;);</span>

<span class="nc bnc" id="L545" title="All 2 branches missed.">        if (recv == defout) {</span>
<span class="nc" id="L546">            return RubyIO.puts2(context, recv, arg0, arg1);</span>
        }

<span class="nc" id="L549">        return defout.callMethod(context, &quot;puts&quot;, new IRubyObject[]{arg0, arg1});</span>
    }

    @JRubyMethod(module = true, visibility = PRIVATE)
    public static IRubyObject puts(ThreadContext context, IRubyObject recv, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {
<span class="nc" id="L554">        IRubyObject defout = context.runtime.getGlobalVariables().get(&quot;$&gt;&quot;);</span>

<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (recv == defout) {</span>
<span class="nc" id="L557">            return RubyIO.puts3(context, recv, arg0, arg1, arg2);</span>
        }

<span class="nc" id="L560">        return defout.callMethod(context, &quot;puts&quot;, new IRubyObject[]{arg0, arg1, arg2});</span>
    }

    @JRubyMethod(rest = true, module = true, visibility = PRIVATE)
    public static IRubyObject puts(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="fc" id="L565">        IRubyObject defout = context.runtime.getGlobalVariables().get(&quot;$&gt;&quot;);</span>

<span class="pc bpc" id="L567" title="1 of 2 branches missed.">        if (recv == defout) {</span>
<span class="nc" id="L568">            return RubyIO.puts(context, recv, args);</span>
        }

<span class="fc" id="L571">        return defout.callMethod(context, &quot;puts&quot;, args);</span>
    }

    // rb_f_print
    @JRubyMethod(rest = true, module = true, visibility = PRIVATE, reads = LASTLINE)
    public static IRubyObject print(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="fc" id="L577">        RubyIO.print(context, context.runtime.getGlobalVariables().get(&quot;$&gt;&quot;), args);</span>
<span class="fc" id="L578">        return context.nil;</span>
    }

    // rb_f_printf
    @JRubyMethod(rest = true, module = true, visibility = PRIVATE)
    public static IRubyObject printf(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="fc" id="L584">        Ruby runtime = context.getRuntime();</span>
        IRubyObject out;
<span class="fc" id="L586">        int argc = args.length;</span>

<span class="pc bpc" id="L588" title="1 of 2 branches missed.">        if (argc == 0) return context.nil;</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">        if (args[0] instanceof RubyString) {</span>
<span class="fc" id="L590">            out = runtime.getGlobalVariables().get(&quot;$&gt;&quot;);</span>
        }
        else {
<span class="fc" id="L593">            out = args[0];</span>
<span class="fc" id="L594">            args = Arrays.copyOfRange(args, 1, args.length);</span>
<span class="fc" id="L595">            argc--;</span>
        }
<span class="fc" id="L597">        RubyIO.write(context, out, sprintf(context, recv, args));</span>

<span class="fc" id="L599">        return context.nil;</span>
    }

    @JRubyMethod(optional = 1, module = true, visibility = PRIVATE)
    public static IRubyObject readline(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="nc" id="L604">        IRubyObject line = gets(context, recv, args);</span>

<span class="nc bnc" id="L606" title="All 2 branches missed.">        if (line.isNil()) {</span>
<span class="nc" id="L607">            throw context.runtime.newEOFError();</span>
        }

<span class="nc" id="L610">        return line;</span>
    }

    @JRubyMethod(optional = 1, module = true, visibility = PRIVATE)
    public static IRubyObject readlines(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="nc" id="L615">        return RubyArgsFile.readlines(context, context.runtime.getArgsFile(), args);</span>
    }

    @JRubyMethod(name = &quot;respond_to_missing?&quot;, module = true)
    public static IRubyObject respond_to_missing_p(ThreadContext context, IRubyObject recv, IRubyObject symbol) {
<span class="nc" id="L620">        return context.runtime.getFalse();</span>
    }

    @JRubyMethod(name = &quot;respond_to_missing?&quot;, module = true)
    public static IRubyObject respond_to_missing_p(ThreadContext context, IRubyObject recv, IRubyObject symbol, IRubyObject isPrivate) {
<span class="fc" id="L625">        return context.runtime.getFalse();</span>
    }

    /** Returns value of $_.
     *
     * @throws TypeError if $_ is not a String or nil.
     * @return value of $_ as String.
     */
    private static RubyString getLastlineString(ThreadContext context, Ruby runtime) {
<span class="nc" id="L634">        IRubyObject line = context.getLastLine();</span>

<span class="nc bnc" id="L636" title="All 2 branches missed.">        if (line.isNil()) {</span>
<span class="nc" id="L637">            throw runtime.newTypeError(&quot;$_ value need to be String (nil given).&quot;);</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">        } else if (!(line instanceof RubyString)) {</span>
<span class="nc" id="L639">            throw runtime.newTypeError(&quot;$_ value need to be String (&quot; + line.getMetaClass().getName() + &quot; given).&quot;);</span>
        } else {
<span class="nc" id="L641">            return (RubyString) line;</span>
        }
    }

    @JRubyMethod(required = 1, optional = 3, module = true, visibility = PRIVATE)
    public static IRubyObject select(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="nc" id="L647">        return RubyIO.select(context, recv, args);</span>
    }

    @JRubyMethod(optional = 1, module = true, visibility = PRIVATE)
    public static IRubyObject sleep(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
        long milliseconds;

<span class="fc bfc" id="L654" title="All 2 branches covered.">        if (args.length == 0) {</span>
            // Zero sleeps forever
<span class="fc" id="L656">            milliseconds = 0;</span>
        } else {
<span class="fc bfc" id="L658" title="All 2 branches covered.">            if (!(args[0] instanceof RubyNumeric)) {</span>
<span class="fc" id="L659">                throw context.runtime.newTypeError(&quot;can't convert &quot; + args[0].getMetaClass().getName() + &quot;into time interval&quot;);</span>
            }
<span class="fc" id="L661">            milliseconds = (long) (args[0].convertToFloat().getDoubleValue() * 1000);</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">            if (milliseconds &lt; 0) {</span>
<span class="fc" id="L663">                throw context.runtime.newArgumentError(&quot;time interval must be positive&quot;);</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">            } else if (milliseconds == 0) {</span>
                // Explicit zero in MRI returns immediately
<span class="fc" id="L666">                return context.runtime.newFixnum(0);</span>
            }
        }
<span class="fc" id="L669">        long startTime = System.currentTimeMillis();</span>
        
<span class="fc" id="L671">        RubyThread rubyThread = context.getThread();</span>

        // Spurious wakeup-loop
        do {
<span class="fc" id="L675">            long loopStartTime = System.currentTimeMillis();</span>
            try {
                // We break if we know this sleep was explicitly woken up/interrupted
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">                if (!rubyThread.sleep(milliseconds)) break;</span>
<span class="nc" id="L679">            } catch (InterruptedException iExcptn) {</span>
<span class="fc" id="L680">            }</span>
<span class="fc" id="L681">            milliseconds -= (System.currentTimeMillis() - loopStartTime);</span>
<span class="pc bpc" id="L682" title="1 of 2 branches missed.">        } while (milliseconds &gt; 0);</span>

<span class="fc" id="L684">        return context.runtime.newFixnum(Math.round((System.currentTimeMillis() - startTime) / 1000.0));</span>
    }

    // FIXME: Add at_exit and finalizers to exit, then make exit_bang not call those.
    @JRubyMethod(optional = 1, module = true, visibility = PRIVATE)
    public static IRubyObject exit(IRubyObject recv, IRubyObject[] args) {
<span class="nc" id="L690">        exit(recv.getRuntime(), args, false);</span>
<span class="nc" id="L691">        return recv.getRuntime().getNil(); // not reached</span>
    }

    @JRubyMethod(name = &quot;exit!&quot;, optional = 1, module = true, visibility = PRIVATE)
    public static IRubyObject exit_bang(IRubyObject recv, IRubyObject[] args) {
<span class="nc" id="L696">        exit(recv.getRuntime(), args, true);</span>
<span class="nc" id="L697">        return recv.getRuntime().getNil(); // not reached</span>
    }

    private static void exit(Ruby runtime, IRubyObject[] args, boolean hard) {
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">        int status = hard ? 1 : 0;</span>
<span class="fc" id="L702">        String message = null;</span>

<span class="fc bfc" id="L704" title="All 2 branches covered.">        if (args.length &gt; 0) {</span>
<span class="fc" id="L705">            RubyObject argument = (RubyObject) args[0];</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">            if (argument instanceof RubyBoolean) {</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">                status = argument.isFalse() ? 1 : 0;</span>
            } else {
<span class="fc" id="L709">                status = RubyNumeric.fix2int(argument);</span>
            }
        }

<span class="fc bfc" id="L713" title="All 2 branches covered.">        if (args.length == 2) {</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">            if (args[1] instanceof RubyString) {</span>
<span class="fc" id="L715">                message = ((RubyString) args[1]).toString();</span>
            }
        }

<span class="pc bpc" id="L719" title="1 of 2 branches missed.">        if (hard) {</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">            if (runtime.getInstanceConfig().isHardExit()) {</span>
<span class="nc" id="L721">                System.exit(status);</span>
            } else {
<span class="nc" id="L723">                throw new MainExitException(status, true);</span>
            }
        } else {
<span class="fc bfc" id="L726" title="All 2 branches covered.">            if (message == null) {</span>
<span class="fc" id="L727">                throw runtime.newSystemExit(status);</span>
            } else {
<span class="fc" id="L729">                throw runtime.newSystemExit(status, message);</span>
            }
        }
<span class="nc" id="L732">    }</span>


    /** Returns an Array with the names of all global variables.
     *
     */
    public static RubyArray global_variables(ThreadContext context, IRubyObject recv) {
<span class="nc" id="L739">        return global_variables19(context, recv);</span>
    }

    // In 1.9, return symbols
    @JRubyMethod(name = &quot;global_variables&quot;, module = true, visibility = PRIVATE)
    public static RubyArray global_variables19(ThreadContext context, IRubyObject recv) {
<span class="fc" id="L745">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L746">        RubyArray globalVariables = runtime.newArray();</span>

<span class="fc bfc" id="L748" title="All 2 branches covered.">        for (String globalVariableName : runtime.getGlobalVariables().getNames()) {</span>
<span class="fc" id="L749">            globalVariables.append(runtime.newSymbol(globalVariableName));</span>
<span class="fc" id="L750">        }</span>

<span class="fc" id="L752">        return globalVariables;</span>
    }

    /** Returns an Array with the names of all local variables.
     *
     */
    public static RubyArray local_variables(ThreadContext context, IRubyObject recv) {
<span class="nc" id="L759">        return local_variables19(context, recv);</span>
    }

    @JRubyMethod(name = &quot;local_variables&quot;, module = true, visibility = PRIVATE)
    public static RubyArray local_variables19(ThreadContext context, IRubyObject recv) {
<span class="fc" id="L764">        final Ruby runtime = context.runtime;</span>
<span class="fc" id="L765">        RubyArray localVariables = runtime.newArray();</span>

<span class="fc bfc" id="L767" title="All 2 branches covered.">        for (String name: context.getCurrentScope().getAllNamesInScope()) {</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">            if (IdUtil.isLocal(name)) localVariables.append(runtime.newSymbol(name));</span>
        }

<span class="fc" id="L771">        return localVariables;</span>
    }
    
    public static RubyBinding binding(ThreadContext context, IRubyObject recv, Block block) {
<span class="nc" id="L775">        return binding19(context, recv, block);</span>
    }
    
    @JRubyMethod(name = &quot;binding&quot;, module = true, visibility = PRIVATE,
            reads = {LASTLINE, BACKREF, VISIBILITY, BLOCK, SELF, METHODNAME, LINE, JUMPTARGET, CLASS, FILENAME, SCOPE},
            writes = {LASTLINE, BACKREF, VISIBILITY, BLOCK, SELF, METHODNAME, LINE, JUMPTARGET, CLASS, FILENAME, SCOPE})
    public static RubyBinding binding19(ThreadContext context, IRubyObject recv, Block block) {
<span class="fc" id="L782">        return RubyBinding.newBinding(context.runtime, context.currentBinding());</span>
    }

    @JRubyMethod(name = {&quot;block_given?&quot;, &quot;iterator?&quot;}, module = true, visibility = PRIVATE, reads = BLOCK)
    public static RubyBoolean block_given_p(ThreadContext context, IRubyObject recv) {
<span class="fc" id="L787">        return context.runtime.newBoolean(context.getCurrentFrame().getBlock().isGiven());</span>
    }


    @Deprecated
    public static IRubyObject sprintf(IRubyObject recv, IRubyObject[] args) {
<span class="nc" id="L793">        return sprintf(recv.getRuntime().getCurrentContext(), recv, args);</span>
    }

    @JRubyMethod(name = {&quot;sprintf&quot;, &quot;format&quot;}, required = 1, rest = true, module = true, visibility = PRIVATE)
    public static IRubyObject sprintf(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="pc bpc" id="L798" title="1 of 2 branches missed.">        if (args.length == 0) {</span>
<span class="nc" id="L799">            throw context.runtime.newArgumentError(&quot;sprintf must have at least one argument&quot;);</span>
        }

<span class="fc" id="L802">        RubyString str = RubyString.stringValue(args[0]);</span>

        IRubyObject arg;
<span class="fc bfc" id="L805" title="All 4 branches covered.">        if (args.length == 2 &amp;&amp; args[1] instanceof RubyHash) {</span>
<span class="fc" id="L806">            arg = args[1];</span>
        } else {
<span class="fc" id="L808">            RubyArray newArgs = context.runtime.newArrayNoCopy(args);</span>
<span class="fc" id="L809">            newArgs.shift(context);</span>
<span class="fc" id="L810">            arg = newArgs;</span>
        }

<span class="fc" id="L813">        return str.op_format(context, arg);</span>
    }

    @JRubyMethod(name = {&quot;raise&quot;, &quot;fail&quot;}, optional = 3, module = true, visibility = PRIVATE, omit = true)
    public static IRubyObject raise(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="fc" id="L818">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L819">        int argc = args.length;</span>

<span class="fc" id="L821">        RubyHash opts = extract_raise_opts(context, args);</span>
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">        if (opts != null) argc--;</span>

        // Check for a Java exception
<span class="fc" id="L825">        ConcreteJavaProxy exception = null;</span>
<span class="fc bfc" id="L826" title="All 3 branches covered.">        switch (argc) {</span>
            case 0:
<span class="pc bpc" id="L828" title="1 of 2 branches missed.">                if (opts != null) {</span>
<span class="nc" id="L829">                    throw runtime.newArgumentError(&quot;only cause is given with no arguments&quot;);</span>
                }

<span class="pc bpc" id="L832" title="1 of 2 branches missed.">                if (runtime.getGlobalVariables().get(&quot;$!&quot;) instanceof ConcreteJavaProxy) {</span>
<span class="nc" id="L833">                    exception = (ConcreteJavaProxy)runtime.getGlobalVariables().get(&quot;$!&quot;);</span>
                }
                break;
            case 1:
<span class="pc bpc" id="L837" title="2 of 4 branches missed.">                if (args.length == 1 &amp;&amp; args[0] instanceof ConcreteJavaProxy) {</span>
<span class="nc" id="L838">                    exception = (ConcreteJavaProxy)args[0];</span>
                }
                break;
        }

<span class="pc bpc" id="L843" title="1 of 2 branches missed.">        if (exception != null) {</span>
            // looks like someone's trying to raise a Java exception. Let them.
<span class="nc" id="L845">            Object maybeThrowable = exception.getObject();</span>

<span class="nc bnc" id="L847" title="All 2 branches missed.">            if (maybeThrowable instanceof Throwable) {</span>
                // yes, we're cheating here.
<span class="nc" id="L849">                Helpers.throwException((Throwable)maybeThrowable);</span>
<span class="nc" id="L850">                return recv; // not reached</span>
            } else {
<span class="nc" id="L852">                throw runtime.newTypeError(&quot;can't raise a non-Throwable Java object&quot;);</span>
            }
        } else {
            // FIXME: Pass block down?
            RaiseException raise;
<span class="fc bfc" id="L857" title="All 4 branches covered.">            switch (argc) {</span>
                case 0:
<span class="fc" id="L859">                    IRubyObject lastException = runtime.getGlobalVariables().get(&quot;$!&quot;);</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">                    if (lastException.isNil()) {</span>
<span class="fc" id="L861">                        raise = new RaiseException(runtime, runtime.getRuntimeError(), &quot;&quot;, false);</span>
                    } else {
                        // non RubyException value is allowed to be assigned as $!.
<span class="fc" id="L864">                        raise = new RaiseException((RubyException) lastException);</span>
                    }
<span class="fc" id="L866">                    break;</span>
                case 1:
<span class="fc bfc" id="L868" title="All 2 branches covered.">                    if (args[0] instanceof RubyString) {</span>
<span class="fc" id="L869">                        raise = new RaiseException((RubyException) runtime.getRuntimeError().newInstance(context, args, block));</span>
                    } else {
<span class="fc" id="L871">                        raise = new RaiseException(convertToException(runtime, args[0], null));</span>
                    }
<span class="fc" id="L873">                    break;</span>
                case 2:
<span class="fc" id="L875">                    raise = new RaiseException(convertToException(runtime, args[0], args[1]));</span>
<span class="fc" id="L876">                    break;</span>
                default:
<span class="fc" id="L878">                    raise = new RaiseException(convertToException(runtime, args[0], args[1]), args[2]);</span>
                    break;
            }

<span class="pc bpc" id="L882" title="1 of 2 branches missed.">            if (runtime.getDebug().isTrue()) {</span>
<span class="nc" id="L883">                printExceptionSummary(context, runtime, raise.getException());</span>
            }

<span class="pc bpc" id="L886" title="1 of 2 branches missed.">            if (opts != null) {</span>
<span class="nc" id="L887">                IRubyObject cause = opts.op_aref(context, runtime.newSymbol(&quot;cause&quot;));</span>
<span class="nc" id="L888">                raise.getException().setCause(cause);</span>
            }

<span class="fc" id="L891">            throw raise;</span>
        }
    }

    private static RubyException convertToException(Ruby runtime, IRubyObject obj, IRubyObject optionalMessage) {
<span class="fc bfc" id="L896" title="All 2 branches covered.">        if (!obj.respondsTo(&quot;exception&quot;)) {</span>
<span class="fc" id="L897">            throw runtime.newTypeError(&quot;exception class/object expected&quot;);</span>
        }
        IRubyObject exception;
<span class="fc bfc" id="L900" title="All 2 branches covered.">        if (optionalMessage == null) {</span>
<span class="fc" id="L901">            exception = obj.callMethod(runtime.getCurrentContext(), &quot;exception&quot;);</span>
        } else {
<span class="fc" id="L903">            exception = obj.callMethod(runtime.getCurrentContext(), &quot;exception&quot;, optionalMessage);</span>
        }
        try {
<span class="fc" id="L906">            return (RubyException) exception;</span>
<span class="nc" id="L907">        } catch (ClassCastException cce) {</span>
<span class="nc" id="L908">            throw runtime.newTypeError(&quot;exception object expected&quot;);</span>
        }
    }

    private static void printExceptionSummary(ThreadContext context, Ruby runtime, RubyException rEx) {
<span class="nc" id="L913">        RubyStackTraceElement[] elements = rEx.getBacktraceElements();</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">        RubyStackTraceElement firstElement = elements.length &gt; 0 ? elements[0] : new RubyStackTraceElement(&quot;&quot;, &quot;&quot;, &quot;(empty)&quot;, 0, false);</span>
<span class="nc" id="L915">        String msg = String.format(&quot;Exception `%s' at %s:%s - %s\n&quot;,</span>
<span class="nc" id="L916">                rEx.getMetaClass(),</span>
<span class="nc" id="L917">                firstElement.getFileName(), firstElement.getLineNumber(),</span>
<span class="nc" id="L918">                TypeConverter.convertToType(rEx, runtime.getString(), &quot;to_s&quot;));</span>

<span class="nc" id="L920">        runtime.getErrorStream().print(msg);</span>
<span class="nc" id="L921">    }</span>

    private static RubyHash extract_raise_opts(ThreadContext context, IRubyObject[] args) {
        int i;
<span class="fc bfc" id="L925" title="All 2 branches covered.">        if (args.length &gt; 0) {</span>
<span class="fc" id="L926">            IRubyObject opt = args[args.length-1];</span>
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">            if (opt instanceof RubyHash) {</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">                if (!((RubyHash)opt).isEmpty()) {</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">                    if (!((RubyHash)opt).op_aref(context, context.runtime.newSymbol(&quot;cause&quot;)).isNil()) {</span>
<span class="nc" id="L930">                        return (RubyHash) opt;</span>
                    }
                }
            }
        }
<span class="fc" id="L935">        return null;</span>
    }

    /**
     * Require.
     * MRI allows to require ever .rb files or ruby extension dll (.so or .dll depending on system).
     * we allow requiring either .rb files or jars.
     * @param recv ruby object used to call require (any object will do and it won't be used anyway).
     * @param name the name of the file to require
     **/
    public static IRubyObject require(IRubyObject recv, IRubyObject name, Block block) {
<span class="nc" id="L946">        return require19(recv.getRuntime().getCurrentContext(), recv, name, block);</span>
    }

    @JRubyMethod(name = &quot;require&quot;, module = true, visibility = PRIVATE)
    public static IRubyObject require19(ThreadContext context, IRubyObject recv, IRubyObject name, Block block) {
<span class="fc" id="L951">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L952">        IRubyObject tmp = name.checkStringType();</span>
        
<span class="fc bfc" id="L954" title="All 2 branches covered.">        if (!tmp.isNil()) return requireCommon(runtime, recv, tmp, block);</span>

<span class="fc" id="L956">        return requireCommon(runtime, recv, RubyFile.get_path(context, name), block);</span>
    }

    private static IRubyObject requireCommon(Ruby runtime, IRubyObject recv, IRubyObject name, Block block) {
<span class="fc" id="L960">        return runtime.newBoolean(runtime.getLoadService().require(name.convertToString().toString()));</span>
    }

    public static IRubyObject load(IRubyObject recv, IRubyObject[] args, Block block) {
<span class="nc" id="L964">        return load19(recv.getRuntime().getCurrentContext(), recv, args, block);</span>
    }

    @JRubyMethod(name = &quot;load&quot;, required = 1, optional = 1, module = true, visibility = PRIVATE)
    public static IRubyObject load19(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="fc" id="L969">        return loadCommon(RubyFile.get_path(context, args[0]), context.runtime, args, block);</span>
    }

    private static IRubyObject loadCommon(IRubyObject fileName, Ruby runtime, IRubyObject[] args, Block block) {
<span class="fc" id="L973">        RubyString file = fileName.convertToString();</span>

<span class="fc bfc" id="L975" title="All 2 branches covered.">        boolean wrap = args.length == 2 ? args[1].isTrue() : false;</span>

<span class="fc" id="L977">        runtime.getLoadService().load(file.toString(), wrap);</span>

<span class="fc" id="L979">        return runtime.getTrue();</span>
    }

    public static IRubyObject eval(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="fc" id="L983">        return eval19(context, recv, args, block);</span>
    }

    @JRubyMethod(name = &quot;eval&quot;, required = 1, optional = 3, module = true, visibility = PRIVATE,
            reads = {LASTLINE, BACKREF, VISIBILITY, BLOCK, SELF, METHODNAME, LINE, JUMPTARGET, CLASS, FILENAME, SCOPE},
            writes = {LASTLINE, BACKREF, VISIBILITY, BLOCK, SELF, METHODNAME, LINE, JUMPTARGET, CLASS, FILENAME, SCOPE})
    public static IRubyObject eval19(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="fc" id="L990">        return evalCommon(context, recv, args, evalBinding19);</span>
    }

    private static IRubyObject evalCommon(ThreadContext context, IRubyObject recv, IRubyObject[] args, EvalBinding evalBinding) {
        // string to eval
<span class="fc" id="L995">        RubyString src = args[0].convertToString();</span>

<span class="pc bpc" id="L997" title="1 of 4 branches missed.">        boolean bindingGiven = args.length &gt; 1 &amp;&amp; !args[1].isNil();</span>
<span class="fc bfc" id="L998" title="All 2 branches covered.">        Binding binding = bindingGiven ? evalBinding.convertToBinding(args[1]) : context.currentBinding();</span>

<span class="fc bfc" id="L1000" title="All 2 branches covered.">        if (args.length &gt; 2) {</span>
            // file given, use it and force it into binding
<span class="fc" id="L1002">            binding.setFile(args[2].convertToString().toString());</span>

<span class="fc bfc" id="L1004" title="All 2 branches covered.">            if (args.length &gt; 3) {</span>
                // line given, use it and force it into binding
                // -1 because parser uses zero offsets and other code compensates
<span class="fc" id="L1007">                binding.setLine(((int) args[3].convertToInteger().getLongValue()) - 1);</span>
            } else {
                // filename given, but no line, start from the beginning.
<span class="fc" id="L1010">                binding.setLine(0);</span>
            }
<span class="fc bfc" id="L1012" title="All 2 branches covered.">        } else if (!bindingGiven) {  // no binding given, use (eval) and start from first line.</span>
<span class="fc" id="L1013">            binding.setFile(&quot;(eval)&quot;);</span>
<span class="fc" id="L1014">            binding.setLine(0);</span>
        }

        // set method to current frame's, which should be caller's
<span class="fc" id="L1018">        String frameName = context.getFrameName();</span>
<span class="fc bfc" id="L1019" title="All 2 branches covered.">        if (frameName != null) binding.setMethod(frameName);</span>

<span class="fc bfc" id="L1021" title="All 2 branches covered.">        if (bindingGiven) recv = binding.getSelf();</span>

<span class="fc" id="L1023">        return Interpreter.evalWithBinding(context, recv, src, binding);</span>
    }

<span class="fc" id="L1026">    private static abstract class EvalBinding {</span>
        public abstract Binding convertToBinding(IRubyObject scope);
    }

<span class="fc" id="L1030">    private static EvalBinding evalBinding19 = new EvalBinding() {</span>
        @Override
        public Binding convertToBinding(IRubyObject scope) {
<span class="fc bfc" id="L1033" title="All 2 branches covered.">            if (scope instanceof RubyBinding) {</span>
<span class="fc" id="L1034">                return ((RubyBinding)scope).getBinding().cloneForEval();</span>
            } else {
<span class="fc" id="L1036">                throw scope.getRuntime().newTypeError(&quot;wrong argument type &quot; + scope.getMetaClass() + &quot; (expected binding)&quot;);</span>
            }
        }
    };


    @JRubyMethod(module = true, visibility = PRIVATE)
    public static IRubyObject callcc(ThreadContext context, IRubyObject recv, Block block) {
<span class="fc" id="L1044">        RubyContinuation continuation = new RubyContinuation(context.runtime);</span>
<span class="fc" id="L1045">        return continuation.enter(context, continuation, block);</span>
    }

    public static IRubyObject caller(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="nc" id="L1049">        return caller20(context, recv, args, block);</span>
    }
    
    public static IRubyObject caller19(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="nc" id="L1053">        return caller20(context, recv, args, block);</span>
    }

    @JRubyMethod(name = &quot;caller&quot;, optional = 2, module = true, visibility = PRIVATE, omit = true)
    public static IRubyObject caller20(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="fc" id="L1058">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L1059">        Integer[] ll = levelAndLengthFromArgs(runtime, args, 1);</span>
<span class="fc" id="L1060">        Integer level = ll[0], length = ll[1];</span>

<span class="fc" id="L1062">        return context.createCallerBacktrace(level, length, Thread.currentThread().getStackTrace());</span>
    }
    
    @JRubyMethod(optional = 2, module = true, visibility = PRIVATE, omit = true)
    public static IRubyObject caller_locations(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="nc" id="L1067">        Ruby runtime = context.runtime;</span>
<span class="nc" id="L1068">        Integer[] ll = levelAndLengthFromArgs(runtime, args, 1);</span>
<span class="nc" id="L1069">        Integer level = ll[0], length = ll[1];</span>
        
<span class="nc" id="L1071">        return context.createCallerLocations(level, length, Thread.currentThread().getStackTrace());</span>
    }
    
    static Integer[] levelAndLengthFromArgs(Ruby runtime, IRubyObject[] args, int defaultLevel) {
        int level;
<span class="fc" id="L1076">        Integer length = null;</span>
<span class="pc bpc" id="L1077" title="1 of 2 branches missed.">        if (args.length &gt; 1) {</span>
<span class="nc" id="L1078">            level = RubyNumeric.fix2int(args[0]);</span>
<span class="nc" id="L1079">            length = RubyNumeric.fix2int(args[1]);</span>
<span class="pc bpc" id="L1080" title="3 of 4 branches missed.">        } else if (args.length &gt; 0 &amp;&amp; args[0] instanceof RubyRange) {</span>
<span class="nc" id="L1081">            RubyRange range = (RubyRange) args[0];</span>
<span class="nc" id="L1082">            ThreadContext context = runtime.getCurrentContext();</span>
<span class="nc" id="L1083">            level = RubyNumeric.fix2int(range.first(context));</span>
<span class="nc" id="L1084">            length = RubyNumeric.fix2int(range.last(context)) - level;</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">            if (!range.exclude_end_p().isTrue()){</span>
<span class="nc" id="L1086">                length++;</span>
            }
<span class="nc bnc" id="L1088" title="All 2 branches missed.">            length = length &lt; 0 ? 0 : length;</span>
<span class="pc bpc" id="L1089" title="1 of 2 branches missed.">        } else if (args.length &gt; 0) {</span>
<span class="nc" id="L1090">            level = RubyNumeric.fix2int(args[0]);</span>
        } else {
<span class="fc" id="L1092">            level = defaultLevel;</span>
        }

<span class="pc bpc" id="L1095" title="1 of 2 branches missed.">        if (level &lt; 0) {</span>
<span class="nc" id="L1096">            throw runtime.newArgumentError(&quot;negative level (&quot; + level + ')');</span>
        }
<span class="pc bpc" id="L1098" title="3 of 4 branches missed.">        if (length != null &amp;&amp; length &lt; 0) {</span>
<span class="nc" id="L1099">            throw runtime.newArgumentError(&quot;negative size (&quot; + length + ')');</span>
        }
        
<span class="fc" id="L1102">        return new Integer[] {level, length};</span>
    }

    public static IRubyObject rbCatch(ThreadContext context, IRubyObject recv, IRubyObject tag, Block block) {
<span class="nc" id="L1106">        return rbCatch19(context, recv, tag, block);</span>
    }

    @JRubyMethod(name = &quot;catch&quot;, module = true, visibility = PRIVATE)
    public static IRubyObject rbCatch19(ThreadContext context, IRubyObject recv, Block block) {
<span class="fc" id="L1111">        IRubyObject tag = new RubyObject(context.runtime.getObject());</span>
<span class="fc" id="L1112">        return rbCatch19Common(context, tag, block);</span>
    }

    @JRubyMethod(name = &quot;catch&quot;, module = true, visibility = PRIVATE)
    public static IRubyObject rbCatch19(ThreadContext context, IRubyObject recv, IRubyObject tag, Block block) {
<span class="fc" id="L1117">        return rbCatch19Common(context, tag, block);</span>
    }

    private static IRubyObject rbCatch19Common(ThreadContext context, IRubyObject tag, Block block) {
<span class="fc" id="L1121">        RubyContinuation rbContinuation = new RubyContinuation(context.runtime, tag);</span>
        try {
<span class="fc" id="L1123">            context.pushCatch(rbContinuation.getContinuation());</span>
<span class="fc" id="L1124">            return rbContinuation.enter(context, tag, block);</span>
        } finally {
<span class="fc" id="L1126">            context.popCatch();</span>
        }
    }

    public static IRubyObject rbThrow(ThreadContext context, IRubyObject recv, IRubyObject tag, Block block) {
<span class="nc" id="L1131">        return rbThrow19(context, recv, tag, block);</span>
    }

    public static IRubyObject rbThrow(ThreadContext context, IRubyObject recv, IRubyObject tag, IRubyObject arg, Block block) {
<span class="nc" id="L1135">        return rbThrow19(context, recv, tag, arg, block);</span>
    }

    @JRubyMethod(name = &quot;throw&quot;, module = true, visibility = PRIVATE)
    public static IRubyObject rbThrow19(ThreadContext context, IRubyObject recv, IRubyObject tag, Block block) {
<span class="nc" id="L1140">        return rbThrowInternal(context, tag, IRubyObject.NULL_ARRAY, block, uncaught19);</span>
    }

    @JRubyMethod(name = &quot;throw&quot;, module = true, visibility = PRIVATE)
    public static IRubyObject rbThrow19(ThreadContext context, IRubyObject recv, IRubyObject tag, IRubyObject arg, Block block) {
<span class="nc" id="L1145">        return rbThrowInternal(context, tag, new IRubyObject[] {arg}, block, uncaught19);</span>
    }

    private static IRubyObject rbThrowInternal(ThreadContext context, IRubyObject tag, IRubyObject[] args, Block block, Uncaught uncaught) {
<span class="fc" id="L1149">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L1150">        runtime.getGlobalVariables().set(&quot;$!&quot;, runtime.getNil());</span>

<span class="fc" id="L1152">        RubyContinuation.Continuation continuation = context.getActiveCatch(tag);</span>

<span class="fc bfc" id="L1154" title="All 2 branches covered.">        if (continuation != null) {</span>
<span class="fc" id="L1155">            continuation.args = args;</span>
<span class="fc" id="L1156">            throw continuation;</span>
        }

        // No catch active for this throw
        String message;
<span class="fc bfc" id="L1161" title="All 2 branches covered.">        if (tag instanceof RubyString) {</span>
<span class="fc" id="L1162">            message = &quot;uncaught throw `&quot; + tag + &quot;'&quot;;</span>
        } else {
<span class="fc" id="L1164">            message = &quot;uncaught throw &quot; + tag.inspect();</span>
        }
<span class="fc" id="L1166">        RubyThread currentThread = context.getThread();</span>

<span class="fc bfc" id="L1168" title="All 2 branches covered.">        if (currentThread == runtime.getThreadService().getMainThread()) {</span>
<span class="fc" id="L1169">            throw uncaught.uncaughtThrow(runtime, message, tag);</span>
        } else {
<span class="fc" id="L1171">            message += &quot; in thread 0x&quot; + Integer.toHexString(RubyInteger.fix2int(currentThread.id()));</span>
<span class="fc" id="L1172">            throw runtime.newArgumentError(message);</span>
        }
    }

<span class="pc" id="L1176">    private static abstract class Uncaught {</span>
        public abstract RaiseException uncaughtThrow(Ruby runtime, String message, IRubyObject tag);
    }

<span class="fc" id="L1180">    private static final Uncaught uncaught19 = new Uncaught() {</span>
        @Override
        public RaiseException uncaughtThrow(Ruby runtime, String message, IRubyObject tag) {
<span class="fc" id="L1183">            return runtime.newArgumentError(message);</span>
        }
    };
    
    @JRubyMethod(module = true, visibility = PRIVATE)
    public static IRubyObject warn(ThreadContext context, IRubyObject recv, IRubyObject message) {
<span class="fc" id="L1189">        Ruby runtime = context.runtime;</span>
        
<span class="fc bfc" id="L1191" title="All 2 branches covered.">        if (runtime.warningsEnabled()) {</span>
<span class="fc" id="L1192">            IRubyObject out = runtime.getGlobalVariables().get(&quot;$stderr&quot;);</span>
<span class="fc" id="L1193">            Helpers.invoke(context, out, &quot;write&quot;, message);</span>
<span class="fc" id="L1194">            Helpers.invoke(context, out, &quot;write&quot;, runtime.getGlobalVariables().getDefaultSeparator());</span>
        }
<span class="fc" id="L1196">        return runtime.getNil();</span>
    }

    @JRubyMethod(module = true, visibility = PRIVATE)
    public static IRubyObject set_trace_func(ThreadContext context, IRubyObject recv, IRubyObject trace_func, Block block) {
<span class="nc bnc" id="L1201" title="All 2 branches missed.">        if (trace_func.isNil()) {</span>
<span class="nc" id="L1202">            context.runtime.setTraceFunction(null);</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">        } else if (!(trace_func instanceof RubyProc)) {</span>
<span class="nc" id="L1204">            throw context.runtime.newTypeError(&quot;trace_func needs to be Proc.&quot;);</span>
        } else {
<span class="nc" id="L1206">            context.runtime.setTraceFunction((RubyProc) trace_func);</span>
        }
<span class="nc" id="L1208">        return trace_func;</span>
    }

    @JRubyMethod(required = 1, optional = 1, module = true, visibility = PRIVATE)
    public static IRubyObject trace_var(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="fc" id="L1213">        RubyProc proc = null;</span>
<span class="fc" id="L1214">        String var = args[0].toString();</span>
        // ignore if it's not a global var
<span class="pc bpc" id="L1216" title="1 of 2 branches missed.">        if (var.charAt(0) != '$') {</span>
<span class="nc" id="L1217">            return context.runtime.getNil();</span>
        }
<span class="fc bfc" id="L1219" title="All 2 branches covered.">        if (args.length == 1) {</span>
<span class="fc" id="L1220">            proc = RubyProc.newProc(context.runtime, block, Block.Type.PROC);</span>
        }
<span class="fc bfc" id="L1222" title="All 2 branches covered.">        if (args.length == 2) {</span>
<span class="fc" id="L1223">            proc = (RubyProc)TypeConverter.convertToType(args[1], context.runtime.getProc(), &quot;to_proc&quot;, true);</span>
        }

<span class="fc" id="L1226">        context.runtime.getGlobalVariables().setTraceVar(var, proc);</span>

<span class="fc" id="L1228">        return context.runtime.getNil();</span>
    }

    @JRubyMethod(required = 1, optional = 1, module = true, visibility = PRIVATE)
    public static IRubyObject untrace_var(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="pc bpc" id="L1233" title="1 of 2 branches missed.">        if (args.length == 0) {</span>
<span class="nc" id="L1234">            throw context.runtime.newArgumentError(0, 1);</span>
        }
<span class="fc" id="L1236">        String var = args[0].toString();</span>

        // ignore if it's not a global var
<span class="pc bpc" id="L1239" title="1 of 2 branches missed.">        if (var.charAt(0) != '$') {</span>
<span class="nc" id="L1240">            return context.runtime.getNil();</span>
        }
        
<span class="pc bpc" id="L1243" title="1 of 2 branches missed.">        if (args.length &gt; 1) {</span>
<span class="nc" id="L1244">            ArrayList&lt;IRubyObject&gt; success = new ArrayList&lt;IRubyObject&gt;();</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">            for (int i = 1; i &lt; args.length; i++) {</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">                if (context.runtime.getGlobalVariables().untraceVar(var, args[i])) {</span>
<span class="nc" id="L1247">                    success.add(args[i]);</span>
                }
            }
<span class="nc" id="L1250">            return RubyArray.newArray(context.runtime, success);</span>
        } else {
<span class="fc" id="L1252">            context.runtime.getGlobalVariables().untraceVar(var);</span>
        }

<span class="fc" id="L1255">        return context.runtime.getNil();</span>
    }

    @JRubyMethod(required = 1, optional = 1)
    public static IRubyObject define_singleton_method(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="pc bpc" id="L1260" title="1 of 2 branches missed.">        if (args.length == 0) {</span>
<span class="nc" id="L1261">            throw context.runtime.newArgumentError(0, 1);</span>
        }

<span class="fc" id="L1264">        RubyClass singleton_class = recv.getSingletonClass();</span>
<span class="fc bfc" id="L1265" title="All 2 branches covered.">        if (args.length &gt; 1) {</span>
<span class="fc" id="L1266">            IRubyObject arg1 = args[1];</span>
<span class="fc bfc" id="L1267" title="All 2 branches covered.">            if (context.runtime.getUnboundMethod().isInstance(args[1])) {</span>
<span class="fc" id="L1268">                RubyUnboundMethod method = (RubyUnboundMethod)arg1;</span>
<span class="fc" id="L1269">                RubyModule owner = (RubyModule)method.owner(context);</span>
<span class="pc bpc" id="L1270" title="1 of 2 branches missed.">                if (owner.isSingleton() &amp;&amp;</span>
<span class="pc bpc" id="L1271" title="1 of 4 branches missed.">                    !(recv.getMetaClass().isSingleton() &amp;&amp; recv.getMetaClass().isKindOfModule(owner))) {</span>

<span class="fc" id="L1273">                    throw context.runtime.newTypeError(&quot;can't bind singleton method to a different class&quot;);</span>
                }
            }
<span class="fc" id="L1276">            return singleton_class.define_method(context, args[0], args[1], block);</span>
        } else {
<span class="fc" id="L1278">            return singleton_class.define_method(context, args[0], block);</span>
        }
    }

    public static RubyProc proc(ThreadContext context, IRubyObject recv, Block block) {
<span class="nc" id="L1283">        return proc_1_9(context, recv, block);</span>
    }

    @JRubyMethod(module = true, visibility = PRIVATE)
    public static RubyProc lambda(ThreadContext context, IRubyObject recv, Block block) {
<span class="fc" id="L1288">        return context.runtime.newProc(Block.Type.LAMBDA, block);</span>
    }
    
    @JRubyMethod(name = &quot;proc&quot;, module = true, visibility = PRIVATE)
    public static RubyProc proc_1_9(ThreadContext context, IRubyObject recv, Block block) {
<span class="fc" id="L1293">        return context.runtime.newProc(Block.Type.PROC, block);</span>
    }

    @JRubyMethod(name = &quot;loop&quot;, module = true, visibility = PRIVATE)
    public static IRubyObject loop(ThreadContext context, IRubyObject recv, Block block) {
<span class="fc" id="L1298">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L1299" title="All 2 branches covered.">        if (!block.isGiven()) {</span>
<span class="fc" id="L1300">            return RubyEnumerator.enumeratorizeWithSize(context, recv, &quot;loop&quot;, loopSizeFn(context));</span>
        }
<span class="fc" id="L1302">        IRubyObject nil = runtime.getNil();</span>
<span class="fc" id="L1303">        RubyClass stopIteration = runtime.getStopIteration();</span>
<span class="fc" id="L1304">        IRubyObject oldExc = runtime.getGlobalVariables().get(&quot;$!&quot;);</span>
        try {
            while (true) {
<span class="fc" id="L1307">                block.yieldSpecific(context);</span>

<span class="fc" id="L1309">                context.pollThreadEvents();</span>
            }
<span class="fc" id="L1311">        } catch (RaiseException ex) {</span>
<span class="fc bfc" id="L1312" title="All 2 branches covered.">            if (!stopIteration.op_eqq(context, ex.getException()).isTrue()) {</span>
<span class="fc" id="L1313">                throw ex;</span>
            } else {
<span class="fc" id="L1315">                runtime.getGlobalVariables().set(&quot;$!&quot;, oldExc);</span>
            }
        }
<span class="fc" id="L1318">        return nil;</span>
    }

    private static SizeFn loopSizeFn(final ThreadContext context) {
<span class="fc" id="L1322">        return new SizeFn() {</span>
            @Override
            public IRubyObject size(IRubyObject[] args) {
<span class="nc" id="L1325">                return RubyFloat.newFloat(context.runtime, RubyFloat.INFINITY);</span>
            }
        };
    }

    @JRubyMethod(required = 2, optional = 1, module = true, visibility = PRIVATE)
    public static IRubyObject test(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="pc bpc" id="L1332" title="1 of 2 branches missed.">        if (args.length == 0) {</span>
<span class="nc" id="L1333">            throw context.runtime.newArgumentError(&quot;wrong number of arguments&quot;);</span>
        }

        int cmd;
<span class="pc bpc" id="L1337" title="1 of 2 branches missed.">        if (args[0] instanceof RubyFixnum) {</span>
<span class="nc" id="L1338">            cmd = (int)((RubyFixnum) args[0]).getLongValue();</span>
<span class="pc bpc" id="L1339" title="1 of 2 branches missed.">        } else if (args[0] instanceof RubyString &amp;&amp;</span>
<span class="pc bpc" id="L1340" title="1 of 2 branches missed.">                ((RubyString) args[0]).getByteList().length() &gt; 0) {</span>
            // MRI behavior: use first byte of string value if len &gt; 0
<span class="fc" id="L1342">            cmd = ((RubyString) args[0]).getByteList().charAt(0);</span>
        } else {
<span class="nc" id="L1344">            cmd = (int) args[0].convertToInteger().getLongValue();</span>
        }
        
        // MRI behavior: raise ArgumentError for 'unknown command' before
        // checking number of args.
<span class="pc bpc" id="L1349" title="1 of 2 branches missed.">        switch(cmd) {</span>
        case 'A': case 'b': case 'c': case 'C': case 'd': case 'e': case 'f': case 'g': case 'G': 
        case 'k': case 'M': case 'l': case 'o': case 'O': case 'p': case 'r': case 'R': case 's':
        case 'S': case 'u': case 'w': case 'W': case 'x': case 'X': case 'z': case '=': case '&lt;':
        case '&gt;': case '-':
<span class="fc" id="L1354">            break;</span>
        default:
<span class="nc" id="L1356">            throw context.runtime.newArgumentError(&quot;unknown command ?&quot; + (char) cmd);</span>
        }

        // MRI behavior: now check arg count

<span class="pc bpc" id="L1361" title="1 of 2 branches missed.">        switch(cmd) {</span>
        case '-': case '=': case '&lt;': case '&gt;':
<span class="nc bnc" id="L1363" title="All 2 branches missed.">            if (args.length != 3) {</span>
<span class="nc" id="L1364">                throw context.runtime.newArgumentError(args.length, 3);</span>
            }
            break;
        default:
<span class="pc bpc" id="L1368" title="1 of 2 branches missed.">            if (args.length != 2) {</span>
<span class="nc" id="L1369">                throw context.runtime.newArgumentError(args.length, 2);</span>
            }
            break;
        }
        
<span class="pc bpc" id="L1374" title="22 of 30 branches missed.">        switch (cmd) {</span>
        case 'A': // ?A  | Time    | Last access time for file1
<span class="nc" id="L1376">            return context.runtime.newFileStat(args[1].convertToString().toString(), false).atime();</span>
        case 'b': // ?b  | boolean | True if file1 is a block device
<span class="nc" id="L1378">            return RubyFileTest.blockdev_p(recv, args[1]);</span>
        case 'c': // ?c  | boolean | True if file1 is a character device
<span class="nc" id="L1380">            return RubyFileTest.chardev_p(recv, args[1]);</span>
        case 'C': // ?C  | Time    | Last change time for file1
<span class="nc" id="L1382">            return context.runtime.newFileStat(args[1].convertToString().toString(), false).ctime();</span>
        case 'd': // ?d  | boolean | True if file1 exists and is a directory
<span class="fc" id="L1384">            return RubyFileTest.directory_p(recv, args[1]);</span>
        case 'e': // ?e  | boolean | True if file1 exists
<span class="fc" id="L1386">            return RubyFileTest.exist_p(recv, args[1]);</span>
        case 'f': // ?f  | boolean | True if file1 exists and is a regular file
<span class="fc" id="L1388">            return RubyFileTest.file_p(recv, args[1]);</span>
        case 'g': // ?g  | boolean | True if file1 has the \CF{setgid} bit
<span class="nc" id="L1390">            return RubyFileTest.setgid_p(recv, args[1]);</span>
        case 'G': // ?G  | boolean | True if file1 exists and has a group ownership equal to the caller's group
<span class="nc" id="L1392">            return RubyFileTest.grpowned_p(recv, args[1]);</span>
        case 'k': // ?k  | boolean | True if file1 exists and has the sticky bit set
<span class="nc" id="L1394">            return RubyFileTest.sticky_p(recv, args[1]);</span>
        case 'M': // ?M  | Time    | Last modification time for file1
<span class="nc" id="L1396">            return context.runtime.newFileStat(args[1].convertToString().toString(), false).mtime();</span>
        case 'l': // ?l  | boolean | True if file1 exists and is a symbolic link
<span class="fc" id="L1398">            return RubyFileTest.symlink_p(recv, args[1]);</span>
        case 'o': // ?o  | boolean | True if file1 exists and is owned by the caller's effective uid
<span class="nc" id="L1400">            return RubyFileTest.owned_p(recv, args[1]);</span>
        case 'O': // ?O  | boolean | True if file1 exists and is owned by the caller's real uid 
<span class="nc" id="L1402">            return RubyFileTest.rowned_p(recv, args[1]);</span>
        case 'p': // ?p  | boolean | True if file1 exists and is a fifo
<span class="nc" id="L1404">            return RubyFileTest.pipe_p(recv, args[1]);</span>
        case 'r': // ?r  | boolean | True if file1 is readable by the effective uid/gid of the caller
<span class="fc" id="L1406">            return RubyFileTest.readable_p(recv, args[1]);</span>
        case 'R': // ?R  | boolean | True if file is readable by the real uid/gid of the caller
            // FIXME: Need to implement an readable_real_p in FileTest
<span class="fc" id="L1409">            return RubyFileTest.readable_p(recv, args[1]);</span>
        case 's': // ?s  | int/nil | If file1 has nonzero size, return the size, otherwise nil
<span class="nc" id="L1411">            return RubyFileTest.size_p(recv, args[1]);</span>
        case 'S': // ?S  | boolean | True if file1 exists and is a socket
<span class="nc" id="L1413">            return RubyFileTest.socket_p(recv, args[1]);</span>
        case 'u': // ?u  | boolean | True if file1 has the setuid bit set
<span class="nc" id="L1415">            return RubyFileTest.setuid_p(recv, args[1]);</span>
        case 'w': // ?w  | boolean | True if file1 exists and is writable by effective uid/gid
<span class="fc" id="L1417">            return RubyFileTest.writable_p(recv, args[1]);</span>
        case 'W': // ?W  | boolean | True if file1 exists and is writable by the real uid/gid
            // FIXME: Need to implement an writable_real_p in FileTest
<span class="fc" id="L1420">            return RubyFileTest.writable_p(recv, args[1]);</span>
        case 'x': // ?x  | boolean | True if file1 exists and is executable by the effective uid/gid
<span class="nc" id="L1422">            return RubyFileTest.executable_p(recv, args[1]);</span>
        case 'X': // ?X  | boolean | True if file1 exists and is executable by the real uid/gid
<span class="nc" id="L1424">            return RubyFileTest.executable_real_p(recv, args[1]);</span>
        case 'z': // ?z  | boolean | True if file1 exists and has a zero length
<span class="nc" id="L1426">            return RubyFileTest.zero_p(recv, args[1]);</span>
        case '=': // ?=  | boolean | True if the modification times of file1 and file2 are equal
<span class="nc" id="L1428">            return context.runtime.newFileStat(args[1].convertToString().toString(), false).mtimeEquals(args[2]);</span>
        case '&lt;': // ?&lt;  | boolean | True if the modification time of file1 is prior to that of file2
<span class="nc" id="L1430">            return context.runtime.newFileStat(args[1].convertToString().toString(), false).mtimeLessThan(args[2]);</span>
        case '&gt;': // ?&gt;  | boolean | True if the modification time of file1 is after that of file2
<span class="nc" id="L1432">            return context.runtime.newFileStat(args[1].convertToString().toString(), false).mtimeGreaterThan(args[2]);</span>
        case '-': // ?-  | boolean | True if file1 and file2 are identical
<span class="nc" id="L1434">            return RubyFileTest.identical_p(recv, args[1], args[2]);</span>
        default:
<span class="nc" id="L1436">            throw new InternalError(&quot;unreachable code reached!&quot;);</span>
        }
    }

    @JRubyMethod(name = &quot;`&quot;, required = 1, module = true, visibility = PRIVATE)
    public static IRubyObject backquote(ThreadContext context, IRubyObject recv, IRubyObject str) {
<span class="fc" id="L1442">        Ruby runtime = context.runtime;</span>

<span class="pc bpc" id="L1444" title="1 of 2 branches missed.">        if (runtime.getPosix().isNative()) {</span>
            IRubyObject port;
            IRubyObject result;
            OpenFile fptr;

<span class="fc" id="L1449">            str = str.convertToString();</span>
<span class="fc" id="L1450">            context.setLastExitStatus(context.nil);</span>
<span class="fc" id="L1451">            port = PopenExecutor.pipeOpen(context, str, &quot;r&quot;, OpenFile.READABLE|OpenFile.TEXTMODE, null);</span>
<span class="pc bpc" id="L1452" title="1 of 2 branches missed.">            if (port.isNil()) return RubyString.newEmptyString(runtime);</span>

<span class="fc" id="L1454">            fptr = ((RubyIO)port).getOpenFileChecked();</span>
<span class="fc" id="L1455">            result = fptr.readAll(context, fptr.remainSize(), context.nil);</span>
<span class="fc" id="L1456">            ((RubyIO)port).rbIoClose(runtime);</span>

<span class="fc" id="L1458">            return result;</span>
        }

<span class="nc" id="L1461">        RubyString string = str.convertToString();</span>
<span class="nc" id="L1462">        IRubyObject[] args = new IRubyObject[] {string};</span>
<span class="nc" id="L1463">        ByteArrayOutputStream output = new ByteArrayOutputStream();</span>
        long[] tuple;

        try {
            // NOTE: not searching executable path before invoking args
<span class="nc" id="L1468">            tuple = ShellLauncher.runAndWaitPid(runtime, args, output, false);</span>
<span class="nc" id="L1469">        } catch (Exception e) {</span>
<span class="nc" id="L1470">            tuple = new long[] {127, -1};</span>
<span class="nc" id="L1471">        }</span>

        // RubyStatus uses real native status now, so we unshift Java's shifted exit status
<span class="nc" id="L1474">        context.setLastExitStatus(RubyProcess.RubyStatus.newProcessStatus(runtime, tuple[0] &lt;&lt; 8, tuple[1]));</span>

<span class="nc" id="L1476">        byte[] out = output.toByteArray();</span>
<span class="nc" id="L1477">        int length = out.length;</span>

<span class="nc bnc" id="L1479" title="All 2 branches missed.">        if (Platform.IS_WINDOWS) {</span>
            // MRI behavior, replace '\r\n' by '\n'
<span class="nc" id="L1481">            int newPos = 0;</span>
            byte curr, next;
<span class="nc bnc" id="L1483" title="All 2 branches missed.">            for (int pos = 0; pos &lt; length; pos++) {</span>
<span class="nc" id="L1484">                curr = out[pos];</span>
<span class="nc bnc" id="L1485" title="All 2 branches missed.">                if (pos == length - 1) {</span>
<span class="nc" id="L1486">                    out[newPos++] = curr;</span>
<span class="nc" id="L1487">                    break;</span>
                }
<span class="nc" id="L1489">                next = out[pos + 1];</span>
<span class="nc bnc" id="L1490" title="All 4 branches missed.">                if (curr != '\r' || next != '\n') {</span>
<span class="nc" id="L1491">                    out[newPos++] = curr;</span>
                }
            }

            // trim the length
<span class="nc" id="L1496">            length = newPos;</span>
        }
<span class="nc" id="L1498">        ByteList buf = new ByteList(out, 0, length, runtime.getDefaultExternalEncoding(), false);</span>
<span class="nc" id="L1499">        RubyString newString = RubyString.newString(runtime, buf);</span>
        
<span class="nc" id="L1501">        return newString;</span>
    }

    @JRubyMethod(module = true, visibility = PRIVATE)
    public static IRubyObject srand(ThreadContext context, IRubyObject recv) {
<span class="fc" id="L1506">        return RubyRandom.srandCommon(context, recv);</span>
    }

    @JRubyMethod(module = true, visibility = PRIVATE)
    public static IRubyObject srand(ThreadContext context, IRubyObject recv, IRubyObject arg) {
<span class="fc" id="L1511">        return RubyRandom.srandCommon(context, recv, arg);</span>
    }

    public static IRubyObject rand18(ThreadContext context, IRubyObject recv, IRubyObject[] arg) {
<span class="nc" id="L1515">        return rand19(context, recv, arg);</span>
    }

    @JRubyMethod(name = &quot;rand&quot;, module = true, optional = 1, visibility = PRIVATE)
    public static IRubyObject rand19(ThreadContext context, IRubyObject recv, IRubyObject[] arg) {
<span class="fc" id="L1520">        return RubyRandom.randCommon19(context, recv, arg);</span>
    }

    @JRubyMethod(rest = true, module = true, visibility = PRIVATE)
    public static RubyFixnum spawn(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="nc" id="L1525">        return RubyProcess.spawn(context, recv, args);</span>
    }

    @JRubyMethod(required = 1, optional = 9, module = true, visibility = PRIVATE)
    public static IRubyObject syscall(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="nc" id="L1530">        throw context.runtime.newNotImplementedError(&quot;Kernel#syscall is not implemented in JRuby&quot;);</span>
    }

    public static IRubyObject system(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="nc" id="L1534">        return system19(context, recv, args);</span>
    }

    @JRubyMethod(name = &quot;system&quot;, required = 1, rest = true, module = true, visibility = PRIVATE)
    public static IRubyObject system19(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="fc" id="L1539">        Ruby runtime = context.runtime;</span>

<span class="pc bpc" id="L1541" title="1 of 2 branches missed.">        if (runtime.getPosix().isNative()) {</span>
            // MRI: rb_f_system
            long pid;
<span class="fc" id="L1544">            int[] status = new int[1];</span>

//            #if defined(SIGCLD) &amp;&amp; !defined(SIGCHLD)
//            # define SIGCHLD SIGCLD
//            #endif
//
//            #ifdef SIGCHLD
//            RETSIGTYPE (*chfunc)(int);

<span class="fc" id="L1553">            context.setLastExitStatus(context.nil);</span>
//            chfunc = signal(SIGCHLD, SIG_DFL);
//            #endif
<span class="fc" id="L1556">            PopenExecutor executor = new PopenExecutor();</span>
<span class="fc" id="L1557">            pid = executor.spawnInternal(context, args, null);</span>
//            #if defined(HAVE_FORK) || defined(HAVE_SPAWNV)
<span class="fc bfc" id="L1559" title="All 2 branches covered.">            if (pid &gt; 0) {</span>
                long ret;
<span class="fc" id="L1561">                ret = RubyProcess.waitpid(runtime, pid, 0);</span>
<span class="pc bpc" id="L1562" title="1 of 2 branches missed.">                if (ret == -1)</span>
<span class="nc" id="L1563">                    throw runtime.newErrnoFromInt(runtime.getPosix().errno(), &quot;Another thread waited the process started by system().&quot;);</span>
            }
//            #endif
//            #ifdef SIGCHLD
//            signal(SIGCHLD, chfunc);
//            #endif
<span class="fc bfc" id="L1569" title="All 2 branches covered.">            if (pid &lt; 0) {</span>
<span class="fc" id="L1570">                return runtime.getNil();</span>
            }
<span class="fc" id="L1572">            status[0] = (int)((RubyProcess.RubyStatus)context.getLastExitStatus()).getStatus();</span>
<span class="fc bfc" id="L1573" title="All 2 branches covered.">            if (status[0] == 0) return runtime.getTrue();</span>
<span class="fc" id="L1574">            return runtime.getFalse();</span>
        }

        // else old JDK logic
<span class="nc bnc" id="L1578" title="All 2 branches missed.">        if (args[0] instanceof RubyHash) {</span>
<span class="nc" id="L1579">            RubyHash env = (RubyHash) args[0].convertToHash();</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">            if (env != null) {</span>
<span class="nc" id="L1581">                runtime.getENV().merge_bang(context, env, Block.NULL_BLOCK);</span>
            }
            // drop the first element for calling systemCommon()
<span class="nc" id="L1584">            IRubyObject[] rest = new IRubyObject[args.length - 1];</span>
<span class="nc" id="L1585">            System.arraycopy(args, 1, rest, 0, args.length - 1);</span>
<span class="nc" id="L1586">            args = rest;</span>
        }
<span class="nc" id="L1588">        int resultCode = systemCommon(context, recv, args);</span>
<span class="nc bnc" id="L1589" title="All 3 branches missed.">        switch (resultCode) {</span>
<span class="nc" id="L1590">            case 0: return runtime.getTrue();</span>
<span class="nc" id="L1591">            case 127: return runtime.getNil();</span>
<span class="nc" id="L1592">            default: return runtime.getFalse();</span>
        }
    }

    private static int systemCommon(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="nc" id="L1597">        Ruby runtime = context.runtime;</span>
        long[] tuple;

        try {
<span class="nc" id="L1601">            IRubyObject lastArg = args[args.length - 1];</span>
<span class="nc bnc" id="L1602" title="All 2 branches missed.">            if (lastArg instanceof RubyHash) {</span>
<span class="nc" id="L1603">                runtime.getWarnings().warn(ID.UNSUPPORTED_SUBPROCESS_OPTION, &quot;system does not support options in JRuby yet: &quot; + lastArg.inspect());</span>
<span class="nc" id="L1604">                args = Arrays.copyOf(args, args.length - 1);</span>
            }
<span class="nc bnc" id="L1606" title="All 4 branches missed.">            if (! Platform.IS_WINDOWS &amp;&amp; args[args.length -1].asJavaString().matches(&quot;.*[^&amp;]&amp;\\s*&quot;)) {</span>
                // looks like we need to send process to the background
<span class="nc" id="L1608">                ShellLauncher.runWithoutWait(runtime, args);</span>
<span class="nc" id="L1609">                return 0;</span>
            }
<span class="nc" id="L1611">            tuple = ShellLauncher.runAndWaitPid(runtime, args);</span>
<span class="nc" id="L1612">        } catch (Exception e) {</span>
<span class="nc" id="L1613">            tuple = new long[] {127, -1};</span>
<span class="nc" id="L1614">        }</span>

        // RubyStatus uses real native status now, so we unshift Java's shifted exit status
<span class="nc" id="L1617">        context.setLastExitStatus(RubyProcess.RubyStatus.newProcessStatus(runtime, tuple[0] &lt;&lt; 8, tuple[1]));</span>
<span class="nc" id="L1618">        return (int)tuple[0];</span>
    }
    
    public static IRubyObject exec(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="nc" id="L1622">        Ruby runtime = context.runtime;</span>
        
<span class="nc" id="L1624">        return execCommon(runtime, null, args[0], null, args);</span>
    }

    /* Actual exec definition which calls this internal version is specified 
     * in /core/src/main/ruby/jruby/kernel/kernel.rb.
     */
    @JRubyMethod(required = 4, module = true, visibility = PRIVATE)
    public static IRubyObject _exec_internal(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="nc" id="L1632">        Ruby runtime = context.runtime;</span>
        
<span class="nc" id="L1634">        IRubyObject env = args[0];</span>
<span class="nc" id="L1635">        IRubyObject prog = args[1];</span>
<span class="nc" id="L1636">        IRubyObject options = args[2];</span>
<span class="nc" id="L1637">        RubyArray cmdArgs = (RubyArray)args[3];</span>

<span class="nc" id="L1639">        RubyIO.checkExecOptions(options);</span>

<span class="nc" id="L1641">        return execCommon(runtime, env, prog, options, cmdArgs.toJavaArray());</span>
    }
    
    private static IRubyObject execCommon(Ruby runtime, IRubyObject env, IRubyObject prog, IRubyObject options, IRubyObject[] args) {
        // This is a fairly specific hack for empty string, but it does the job
<span class="pc bpc" id="L1646" title="1 of 2 branches missed.">        if (args.length == 1) {</span>
<span class="fc" id="L1647">            RubyString command = args[0].convertToString();</span>
<span class="fc bfc" id="L1648" title="All 2 branches covered.">            if (command.isEmpty()) {</span>
<span class="fc" id="L1649">                throw runtime.newErrnoENOENTError(command.toString());</span>
            } else {
<span class="fc bfc" id="L1651" title="All 2 branches covered.">                for(byte b : command.getBytes()) {</span>
<span class="fc bfc" id="L1652" title="All 2 branches covered.">                    if (b == 0x00) {</span>
<span class="fc" id="L1653">                        throw runtime.newArgumentError(&quot;string contains null byte&quot;);</span>
                    }
                }
            }
        }

<span class="fc" id="L1659">        ThreadContext context = runtime.getCurrentContext();</span>
<span class="pc bpc" id="L1660" title="2 of 4 branches missed.">        if (env != null &amp;&amp; !env.isNil()) {</span>
<span class="nc" id="L1661">            RubyHash envMap = env.convertToHash();</span>
<span class="nc bnc" id="L1662" title="All 2 branches missed.">            if (envMap != null) {</span>
<span class="nc" id="L1663">                runtime.getENV().merge_bang(context, envMap, Block.NULL_BLOCK);</span>
            }
        }
        
<span class="fc" id="L1667">        boolean nativeFailed = false;</span>
<span class="fc" id="L1668">        boolean nativeExec = Options.NATIVE_EXEC.load();</span>
<span class="fc" id="L1669">        boolean jmxStopped = false;</span>
<span class="fc" id="L1670">        System.setProperty(&quot;user.dir&quot;, runtime.getCurrentDirectory());</span>

<span class="pc bpc" id="L1672" title="1 of 2 branches missed.">        if (nativeExec) {</span>
<span class="fc" id="L1673">            IRubyObject oldExc = runtime.getGlobalVariables().get(&quot;$!&quot;);</span>
            try {
<span class="nc" id="L1675">                ShellLauncher.LaunchConfig cfg = new ShellLauncher.LaunchConfig(runtime, args, true);</span>

                // Duplicated in part from ShellLauncher.runExternalAndWait
<span class="nc bnc" id="L1678" title="All 2 branches missed.">                if (cfg.shouldRunInShell()) {</span>
                    // execute command with sh -c
                    // this does shell expansion of wildcards
<span class="nc" id="L1681">                    cfg.verifyExecutableForShell();</span>
                } else {
<span class="nc" id="L1683">                    cfg.verifyExecutableForDirect();</span>
                }
<span class="nc" id="L1685">                String progStr = cfg.getExecArgs()[0];</span>

<span class="nc" id="L1687">                String[] argv = cfg.getExecArgs();</span>

                // attempt to shut down the JMX server
<span class="nc" id="L1690">                jmxStopped = runtime.getBeanManager().tryShutdownAgent();</span>

<span class="nc" id="L1692">                runtime.getPosix().chdir(System.getProperty(&quot;user.dir&quot;));</span>
                
<span class="nc bnc" id="L1694" title="All 2 branches missed.">                if (Platform.IS_WINDOWS) {</span>
                    // Windows exec logic is much more elaborate; exec() in jnr-posix attempts to duplicate it
<span class="nc" id="L1696">                    runtime.getPosix().exec(progStr, argv);</span>
                } else {
                    // TODO: other logic surrounding this call? In jnr-posix?
<span class="nc" id="L1699">                    ArrayList envStrings = new ArrayList();</span>
<span class="nc bnc" id="L1700" title="All 2 branches missed.">                    for (Map.Entry&lt;String, String&gt; envEntry : ((Map&lt;String, String&gt;)runtime.getENV()).entrySet()) {</span>
<span class="nc" id="L1701">                        envStrings.add(envEntry.getKey() + &quot;=&quot; + envEntry.getValue());</span>
<span class="nc" id="L1702">                    }</span>
<span class="nc" id="L1703">                    envStrings.add(null);</span>

<span class="nc" id="L1705">                    runtime.getPosix().execve(progStr, argv, (String[]) envStrings.toArray(new String[0]));</span>
                }

                // Only here because native exec could not exec (always -1)
<span class="nc" id="L1709">                nativeFailed = true;</span>
<span class="fc" id="L1710">            } catch (RaiseException e) {</span>
<span class="fc" id="L1711">                runtime.getGlobalVariables().set(&quot;$!&quot;, oldExc);</span>
<span class="nc" id="L1712">            } catch (Exception e) {</span>
<span class="nc" id="L1713">                throw runtime.newErrnoENOENTError(&quot;cannot execute: &quot; + e.getLocalizedMessage());</span>
<span class="pc" id="L1714">            }</span>
        }

        // if we get here, either native exec failed or we should try an in-process exec
<span class="nc bnc" id="L1718" title="All 2 branches missed.">        if (nativeFailed) {</span>
<span class="nc bnc" id="L1719" title="All 4 branches missed.">            if (jmxStopped &amp;&amp; runtime.getBeanManager().tryRestartAgent()) {</span>
<span class="nc" id="L1720">                runtime.registerMBeans();</span>
            }
<span class="nc" id="L1722">            throw runtime.newErrnoFromLastPOSIXErrno();</span>
        }
        
        // Fall back onto our existing code if native not available
        // FIXME: Make jnr-posix Pure-Java backend do this as well
<span class="nc" id="L1727">        int resultCode = ShellLauncher.execAndWait(runtime, args);</span>

<span class="nc" id="L1729">        exit(runtime, new IRubyObject[] {runtime.newFixnum(resultCode)}, true);</span>

        // not reached
<span class="nc" id="L1732">        return runtime.getNil();</span>
    }

    public static IRubyObject fork(ThreadContext context, IRubyObject recv, Block block) {
<span class="nc" id="L1736">        return fork19(context, recv, block);</span>
    }

    @JRubyMethod(name = &quot;fork&quot;, module = true, visibility = PRIVATE, notImplemented = true)
    public static IRubyObject fork19(ThreadContext context, IRubyObject recv, Block block) {
<span class="nc" id="L1741">        Ruby runtime = context.runtime;</span>
<span class="nc" id="L1742">        throw runtime.newNotImplementedError(&quot;fork is not available on this platform&quot;);</span>
    }

    @JRubyMethod(module = true, visibility = PRIVATE, reads = LASTLINE, writes = LASTLINE)
    public static IRubyObject gsub(ThreadContext context, IRubyObject recv, IRubyObject arg0, Block block) {
<span class="nc" id="L1747">        RubyString str = (RubyString) getLastlineString(context, context.runtime).dup();</span>

<span class="nc bnc" id="L1749" title="All 2 branches missed.">        if (!str.gsub_bang(context, arg0, block).isNil()) {</span>
<span class="nc" id="L1750">            context.setLastLine(str);</span>
        }

<span class="nc" id="L1753">        return str;</span>
    }

    @JRubyMethod(module = true, visibility = PRIVATE, reads = LASTLINE, writes = LASTLINE)
    public static IRubyObject gsub(ThreadContext context, IRubyObject recv, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="nc" id="L1758">        RubyString str = (RubyString) getLastlineString(context, context.runtime).dup();</span>

<span class="nc bnc" id="L1760" title="All 2 branches missed.">        if (!str.gsub_bang(context, arg0, arg1, block).isNil()) {</span>
<span class="nc" id="L1761">            context.setLastLine(str);</span>
        }

<span class="nc" id="L1764">        return str;</span>
    }

    @JRubyMethod(module = true)
    public static IRubyObject tap(ThreadContext context, IRubyObject recv, Block block) {
<span class="fc" id="L1769">        block.yield(context, recv);</span>
<span class="fc" id="L1770">        return recv;</span>
    }
    
    @JRubyMethod(name = {&quot;to_enum&quot;, &quot;enum_for&quot;}, optional = 1, rest = true)
    public static IRubyObject obj_to_enum(final ThreadContext context, IRubyObject self, IRubyObject[] args, final Block block) {
<span class="fc" id="L1775">        String method = &quot;each&quot;;</span>
<span class="fc" id="L1776">        SizeFn sizeFn = null;</span>

<span class="fc bfc" id="L1778" title="All 2 branches covered.">        if (args.length &gt; 0) {</span>
<span class="fc" id="L1779">            method = args[0].asJavaString();</span>
<span class="fc" id="L1780">            args = Arrays.copyOfRange(args, 1, args.length);</span>
        }

<span class="fc bfc" id="L1783" title="All 2 branches covered.">        if (block.isGiven()) {</span>
<span class="fc" id="L1784">            sizeFn = new SizeFn() {</span>
                @Override
                public IRubyObject size(IRubyObject[] args) {
<span class="fc" id="L1787">                    return block.call(context, args);</span>
                }
            };
        }

<span class="fc" id="L1792">        return enumeratorizeWithSize(context, self, method, args, sizeFn);</span>
    }

    @JRubyMethod(name = { &quot;__method__&quot;, &quot;__callee__&quot; }, module = true, visibility = PRIVATE, reads = METHODNAME, omit = true)
    public static IRubyObject __method__(ThreadContext context, IRubyObject recv) {
<span class="fc" id="L1797">        String frameName = context.getFrameName();</span>
<span class="fc bfc" id="L1798" title="All 2 branches covered.">        if (frameName == null) {</span>
<span class="fc" id="L1799">            return context.nil;</span>
        }
<span class="fc" id="L1801">        return context.runtime.newSymbol(frameName);</span>
    }
    
    @JRubyMethod(name = &quot;__dir__&quot;, module = true, visibility = PRIVATE, reads = FILENAME)
    public static IRubyObject __dir__(ThreadContext context, IRubyObject recv) {
<span class="fc" id="L1806">        String dir = RubyFile.dirname(context, new File(context.gatherCallerBacktrace()[1].getFileName()).getAbsolutePath());</span>
<span class="pc bpc" id="L1807" title="1 of 2 branches missed.">        if (dir == null) return context.nil;</span>
<span class="fc" id="L1808">        return RubyString.newString(context.runtime, dir);</span>
    }

    @JRubyMethod(module = true)
    public static IRubyObject singleton_class(IRubyObject recv) {
<span class="fc" id="L1813">        return recv.getSingletonClass();</span>
    }

    @JRubyMethod(rest = true)
    public static IRubyObject public_send(ThreadContext context, IRubyObject recv, IRubyObject[] args, Block block) {
<span class="pc bpc" id="L1818" title="1 of 2 branches missed.">        if (args.length == 0) {</span>
<span class="nc" id="L1819">            throw context.runtime.newArgumentError(&quot;no method name given&quot;);</span>
        }

<span class="fc" id="L1822">        String name = RubySymbol.objectToSymbolString(args[0]);</span>
<span class="fc" id="L1823">        int newArgsLength = args.length - 1;</span>

        IRubyObject[] newArgs;
<span class="fc bfc" id="L1826" title="All 2 branches covered.">        if (newArgsLength == 0) {</span>
<span class="fc" id="L1827">            newArgs = IRubyObject.NULL_ARRAY;</span>
        } else {
<span class="fc" id="L1829">            newArgs = new IRubyObject[newArgsLength];</span>
<span class="fc" id="L1830">            System.arraycopy(args, 1, newArgs, 0, newArgs.length);</span>
        }

<span class="fc" id="L1833">        DynamicMethod method = recv.getMetaClass().searchMethod(name);</span>

<span class="fc bfc" id="L1835" title="All 4 branches covered.">        if (method.isUndefined() || method.getVisibility() != PUBLIC) {</span>
<span class="nc" id="L1836">            return Helpers.callMethodMissing(context, recv, method.getVisibility(), name, CallType.NORMAL, newArgs, block);</span>
        }

<span class="fc" id="L1839">        return method.call(context, recv, recv.getMetaClass(), name, newArgs, block);</span>
    }

    /*
     * Moved binding of these methods here, since Kernel can be included into
     * BasicObject subclasses, and these methods must still work.
     * See JRUBY-4871 (because of RubyObject instead of RubyBasicObject cast)
     * BEGIN delegated bindings:
     */
    @JRubyMethod(name = &quot;eql?&quot;, required = 1)
    public static IRubyObject eql_p(IRubyObject self, IRubyObject obj) {
<span class="fc" id="L1850">        return ((RubyBasicObject)self).eql_p(obj);</span>
    }

    @JRubyMethod(name = &quot;===&quot;, required = 1)
    public static IRubyObject op_eqq(ThreadContext context, IRubyObject self, IRubyObject other) {
<span class="fc" id="L1855">        return ((RubyBasicObject)self).op_eqq(context, other);</span>
    }

    @JRubyMethod(name = &quot;&lt;=&gt;&quot;, required = 1)
    public static IRubyObject op_cmp(ThreadContext context, IRubyObject self, IRubyObject other) {
<span class="fc" id="L1860">        return ((RubyBasicObject)self).op_cmp(context, other);</span>
    }

    @JRubyMethod(name = &quot;initialize_copy&quot;, required = 1, visibility = PRIVATE)
    public static IRubyObject initialize_copy(IRubyObject self, IRubyObject original) {
<span class="fc" id="L1865">        return ((RubyBasicObject)self).initialize_copy(original);</span>
    }

    @JRubyMethod(name = &quot;initialize_clone&quot;, required = 1, visibility = Visibility.PRIVATE)
    public static IRubyObject initialize_clone(ThreadContext context, IRubyObject self, IRubyObject original) {
<span class="fc" id="L1870">        return self.callMethod(context, &quot;initialize_copy&quot;, original);</span>
    }

    @JRubyMethod(name = &quot;initialize_dup&quot;, required = 1, visibility = Visibility.PRIVATE)
    public static IRubyObject initialize_dup(ThreadContext context, IRubyObject self, IRubyObject original) {
<span class="fc" id="L1875">        return self.callMethod(context, &quot;initialize_copy&quot;, original);</span>
    }

    @JRubyMethod(name = &quot;respond_to?&quot;)
    public static IRubyObject respond_to_p19(IRubyObject self, IRubyObject mname) {
<span class="fc" id="L1880">        return ((RubyBasicObject)self).respond_to_p19(mname);</span>
    }

    @JRubyMethod(name = &quot;respond_to?&quot;)
    public static IRubyObject respond_to_p19(IRubyObject self, IRubyObject mname, IRubyObject includePrivate) {
<span class="fc" id="L1885">        return ((RubyBasicObject)self).respond_to_p19(mname, includePrivate);</span>
    }

    @JRubyMethod
    public static RubyFixnum hash(IRubyObject self) {
<span class="fc" id="L1890">        return ((RubyBasicObject)self).hash();</span>
    }

    @JRubyMethod(name = &quot;class&quot;)
    public static RubyClass type(IRubyObject self) {
<span class="fc" id="L1895">        return ((RubyBasicObject)self).type();</span>
    }

    @JRubyMethod(name = &quot;clone&quot;)
    public static IRubyObject rbClone(IRubyObject self) {
<span class="fc" id="L1900">        return ((RubyBasicObject)self).rbClone();</span>
    }

    @JRubyMethod
    public static IRubyObject dup(IRubyObject self) {
<span class="fc" id="L1905">        return ((RubyBasicObject)self).dup();</span>
    }

    @JRubyMethod(optional = 1)
    public static IRubyObject display(ThreadContext context, IRubyObject self, IRubyObject[] args) {
<span class="nc" id="L1910">        return ((RubyBasicObject)self).display(context, args);</span>
    }

    @JRubyMethod(name = {&quot;tainted?&quot;, &quot;untrusted?&quot;})
    public static RubyBoolean tainted_p(ThreadContext context, IRubyObject self) {
<span class="fc" id="L1915">        return ((RubyBasicObject)self).tainted_p(context);</span>
    }

    @JRubyMethod(name = {&quot;taint&quot;, &quot;untrust&quot;})
    public static IRubyObject taint(ThreadContext context, IRubyObject self) {
<span class="fc" id="L1920">        return ((RubyBasicObject)self).taint(context);</span>
    }

    @JRubyMethod(name = {&quot;untaint&quot;, &quot;trust&quot;})
    public static IRubyObject untaint(ThreadContext context, IRubyObject self) {
<span class="fc" id="L1925">        return ((RubyBasicObject)self).untaint(context);</span>
    }

    @JRubyMethod
    public static IRubyObject freeze(ThreadContext context, IRubyObject self) {
<span class="fc" id="L1930">        return ((RubyBasicObject)self).freeze(context);</span>
    }

    @JRubyMethod(name = &quot;frozen?&quot;)
    public static RubyBoolean frozen_p(ThreadContext context, IRubyObject self) {
<span class="fc" id="L1935">        return ((RubyBasicObject)self).frozen_p(context);</span>
    }

    @JRubyMethod(name = &quot;inspect&quot;)
    public static IRubyObject inspect(IRubyObject self) {
<span class="fc" id="L1940">        return ((RubyBasicObject)self).inspect();</span>
    }

    @JRubyMethod(name = &quot;instance_of?&quot;, required = 1)
    public static RubyBoolean instance_of_p(ThreadContext context, IRubyObject self, IRubyObject type) {
<span class="fc" id="L1945">        return ((RubyBasicObject)self).instance_of_p(context, type);</span>
    }

    @JRubyMethod(name = {&quot;kind_of?&quot;, &quot;is_a?&quot;}, required = 1)
    public static RubyBoolean kind_of_p(ThreadContext context, IRubyObject self, IRubyObject type) {
<span class="fc" id="L1950">        return ((RubyBasicObject)self).kind_of_p(context, type);</span>
    }

    @JRubyMethod(name = &quot;methods&quot;, optional = 1)
    public static IRubyObject methods19(ThreadContext context, IRubyObject self, IRubyObject[] args) {
<span class="fc" id="L1955">        return ((RubyBasicObject)self).methods19(context, args);</span>
    }

    @JRubyMethod(name = &quot;public_methods&quot;, optional = 1)
    public static IRubyObject public_methods19(ThreadContext context, IRubyObject self, IRubyObject[] args) {
<span class="fc" id="L1960">        return ((RubyBasicObject)self).public_methods19(context, args);</span>
    }

    @JRubyMethod(name = &quot;protected_methods&quot;, optional = 1)
    public static IRubyObject protected_methods19(ThreadContext context, IRubyObject self, IRubyObject[] args) {
<span class="fc" id="L1965">        return ((RubyBasicObject)self).protected_methods19(context, args);</span>
    }

    @JRubyMethod(name = &quot;private_methods&quot;, optional = 1)
    public static IRubyObject private_methods19(ThreadContext context, IRubyObject self, IRubyObject[] args) {
<span class="fc" id="L1970">        return ((RubyBasicObject)self).private_methods19(context, args);</span>
    }

    @JRubyMethod(name = &quot;singleton_methods&quot;, optional = 1)
    public static RubyArray singleton_methods19(ThreadContext context, IRubyObject self, IRubyObject[] args) {
<span class="fc" id="L1975">        return ((RubyBasicObject)self).singleton_methods19(context, args);</span>
    }

    @JRubyMethod(name = &quot;method&quot;, required = 1)
    public static IRubyObject method19(IRubyObject self, IRubyObject symbol) {
<span class="fc" id="L1980">        return ((RubyBasicObject)self).method19(symbol);</span>
    }

    @JRubyMethod(name = &quot;to_s&quot;)
    public static IRubyObject to_s(IRubyObject self) {
<span class="fc" id="L1985">        return ((RubyBasicObject)self).to_s();</span>
    }

    @JRubyMethod(name = &quot;extend&quot;, required = 1, rest = true)
    public static IRubyObject extend(IRubyObject self, IRubyObject[] args) {
<span class="fc" id="L1990">        return ((RubyBasicObject)self).extend(args);</span>
    }

    @JRubyMethod(name = {&quot;send&quot;}, omit = true)
    public static IRubyObject send19(ThreadContext context, IRubyObject self, IRubyObject arg0, Block block) {
<span class="fc" id="L1995">        return ((RubyBasicObject)self).send19(context, arg0, block);</span>
    }
    @JRubyMethod(name = {&quot;send&quot;}, omit = true)
    public static IRubyObject send19(ThreadContext context, IRubyObject self, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="fc" id="L1999">        return ((RubyBasicObject)self).send19(context, arg0, arg1, block);</span>
    }
    @JRubyMethod(name = {&quot;send&quot;}, omit = true)
    public static IRubyObject send19(ThreadContext context, IRubyObject self, IRubyObject arg0, IRubyObject arg1, IRubyObject arg2, Block block) {
<span class="nc" id="L2003">        return ((RubyBasicObject)self).send19(context, arg0, arg1, arg2, block);</span>
    }
    @JRubyMethod(name = {&quot;send&quot;}, required = 1, rest = true, omit = true)
    public static IRubyObject send19(ThreadContext context, IRubyObject self, IRubyObject[] args, Block block) {
<span class="fc" id="L2007">        return ((RubyBasicObject)self).send19(context, args, block);</span>
    }

    @JRubyMethod(name = &quot;nil?&quot;)
    public static IRubyObject nil_p(ThreadContext context, IRubyObject self) {
<span class="fc" id="L2012">        return ((RubyBasicObject)self).nil_p(context);</span>
    }

    public static IRubyObject op_match(ThreadContext context, IRubyObject self, IRubyObject arg) {
<span class="nc" id="L2016">        return op_match19(context, self, arg);</span>
    }

    @JRubyMethod(name = &quot;=~&quot;, required = 1, writes = FrameField.BACKREF)
    public static IRubyObject op_match19(ThreadContext context, IRubyObject self, IRubyObject arg) {
<span class="fc" id="L2021">        return ((RubyBasicObject)self).op_match19(context, arg);</span>
    }

    @JRubyMethod(name = &quot;!~&quot;, required = 1, writes = FrameField.BACKREF)
    public static IRubyObject op_not_match(ThreadContext context, IRubyObject self, IRubyObject arg) {
<span class="fc" id="L2026">        return ((RubyBasicObject)self).op_not_match(context, arg);</span>
    }

    @JRubyMethod(name = &quot;instance_variable_defined?&quot;, required = 1)
    public static IRubyObject instance_variable_defined_p(ThreadContext context, IRubyObject self, IRubyObject name) {
<span class="fc" id="L2031">        return ((RubyBasicObject)self).instance_variable_defined_p(context, name);</span>
    }

    @JRubyMethod(name = &quot;instance_variable_get&quot;, required = 1)
    public static IRubyObject instance_variable_get(ThreadContext context, IRubyObject self, IRubyObject name) {
<span class="fc" id="L2036">        return ((RubyBasicObject)self).instance_variable_get(context, name);</span>
    }

    @JRubyMethod(name = &quot;instance_variable_set&quot;, required = 2)
    public static IRubyObject instance_variable_set(IRubyObject self, IRubyObject name, IRubyObject value) {
<span class="fc" id="L2041">        return ((RubyBasicObject)self).instance_variable_set(name, value);</span>
    }

    @JRubyMethod(name = &quot;remove_instance_variable&quot;, required = 1)
    public static IRubyObject remove_instance_variable(ThreadContext context, IRubyObject self, IRubyObject name, Block block) {
<span class="fc" id="L2046">        return ((RubyBasicObject)self).remove_instance_variable(context, name, block);</span>
    }

    @JRubyMethod(name = &quot;instance_variables&quot;)
    public static RubyArray instance_variables19(ThreadContext context, IRubyObject self) {
<span class="fc" id="L2051">        return ((RubyBasicObject)self).instance_variables19(context);</span>
    }
    /* end delegated bindings */
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>