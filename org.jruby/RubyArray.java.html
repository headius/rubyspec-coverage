<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RubyArray.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby</a> &gt; <span class="el_source">RubyArray.java</span></div><h1>RubyArray.java</h1><pre class="source lang-java linenums">/*
 **** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2001 Alan Moore &lt;alan_moore@gmx.net&gt;
 * Copyright (C) 2001 Chad Fowler &lt;chadfowler@chadfowler.com&gt;
 * Copyright (C) 2001-2002 Benoit Cerrina &lt;b.cerrina@wanadoo.fr&gt;
 * Copyright (C) 2001-2004 Jan Arne Petersen &lt;jpetersen@uni-bonn.de&gt;
 * Copyright (C) 2002-2004 Anders Bengtsson &lt;ndrsbngtssn@yahoo.se&gt;
 * Copyright (C) 2002-2005 Thomas E Enebo &lt;enebo@acm.org&gt;
 * Copyright (C) 2004-2005 Charles O Nutter &lt;headius@headius.com&gt;
 * Copyright (C) 2004 Stefan Matthias Aust &lt;sma@3plus4.de&gt;
 * Copyright (C) 2006 Ola Bini &lt;Ola.Bini@ki.se&gt;
 * Copyright (C) 2006 Daniel Steer &lt;damian.steer@hp.com&gt;
 * 
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby;

import org.jcodings.Encoding;
import org.jcodings.specific.USASCIIEncoding;
import org.jruby.anno.JRubyClass;
import org.jruby.anno.JRubyMethod;
import org.jruby.common.IRubyWarnings.ID;
import org.jruby.java.util.ArrayUtils;
import org.jruby.javasupport.JavaUtil;
import org.jruby.runtime.Arity;
import org.jruby.runtime.Block;
import org.jruby.runtime.BlockBody;
import org.jruby.runtime.ClassIndex;
import org.jruby.runtime.Helpers;
import org.jruby.runtime.ObjectAllocator;
import org.jruby.runtime.ThreadContext;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.runtime.encoding.EncodingCapable;
import org.jruby.runtime.invokedynamic.MethodNames;
import org.jruby.runtime.marshal.MarshalStream;
import org.jruby.runtime.marshal.UnmarshalStream;
import org.jruby.util.ByteList;
import org.jruby.util.Pack;
import org.jruby.util.Qsort;
import org.jruby.util.RecursiveComparator;
import org.jruby.util.TypeConverter;

import java.io.IOException;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.RandomAccess;
import java.util.concurrent.Callable;

import static org.jruby.RubyEnumerator.enumeratorize;
import static org.jruby.RubyEnumerator.enumeratorizeWithSize;
import static org.jruby.runtime.Helpers.invokedynamic;
import static org.jruby.runtime.Helpers.memchr;
import static org.jruby.runtime.Visibility.PRIVATE;
import static org.jruby.runtime.invokedynamic.MethodNames.HASH;
import static org.jruby.runtime.invokedynamic.MethodNames.OP_CMP;
import static org.jruby.RubyEnumerator.SizeFn;

/**
 * The implementation of the built-in class Array in Ruby.
 *
 * Concurrency: no synchronization is required among readers, but
 * all users must synchronize externally with writers.
 *
 */
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">@JRubyClass(name=&quot;Array&quot;)</span>
public class RubyArray extends RubyObject implements List, RandomAccess {
    public static final int DEFAULT_INSPECT_STR_SIZE = 10;

    public static RubyClass createArrayClass(Ruby runtime) {
<span class="fc" id="L98">        RubyClass arrayc = runtime.defineClass(&quot;Array&quot;, runtime.getObject(), ARRAY_ALLOCATOR);</span>
<span class="fc" id="L99">        runtime.setArray(arrayc);</span>

<span class="fc" id="L101">        arrayc.setClassIndex(ClassIndex.ARRAY);</span>
<span class="fc" id="L102">        arrayc.setReifiedClass(RubyArray.class);</span>
        
<span class="fc" id="L104">        arrayc.kindOf = new RubyModule.JavaClassKindOf(RubyArray.class);</span>

<span class="fc" id="L106">        arrayc.includeModule(runtime.getEnumerable());</span>
<span class="fc" id="L107">        arrayc.defineAnnotatedMethods(RubyArray.class);</span>

<span class="fc" id="L109">        return arrayc;</span>
    }

<span class="fc" id="L112">    private static ObjectAllocator ARRAY_ALLOCATOR = new ObjectAllocator() {</span>
        public IRubyObject allocate(Ruby runtime, RubyClass klass) {
<span class="fc" id="L114">            return new RubyArray(runtime, klass, IRubyObject.NULL_ARRAY);</span>
        }
    };

    @Override
    public ClassIndex getNativeClassIndex() {
<span class="fc" id="L120">        return ClassIndex.ARRAY;</span>
    }

    private final void concurrentModification() {
<span class="nc" id="L124">        concurrentModification(getRuntime());</span>
<span class="nc" id="L125">    }</span>

    private static void concurrentModification(Ruby runtime) {
<span class="nc" id="L128">        throw runtime.newConcurrencyError(&quot;Detected invalid array contents due to unsynchronized modifications with concurrent users&quot;);</span>
    }

    /** rb_ary_s_create
     * 
     */
    @JRubyMethod(name = &quot;[]&quot;, rest = true, meta = true)
    public static IRubyObject create(IRubyObject klass, IRubyObject[] args, Block block) {
<span class="fc" id="L136">        RubyArray arr = (RubyArray) ((RubyClass) klass).allocate();</span>

<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (args.length &gt; 0) {</span>
<span class="fc" id="L139">            arr.values = new IRubyObject[args.length];</span>
<span class="fc" id="L140">            System.arraycopy(args, 0, arr.values, 0, args.length);</span>
<span class="fc" id="L141">            arr.realLength = args.length;</span>
        }
<span class="fc" id="L143">        return arr;</span>
    }

    /** rb_ary_new2
     *
     */
    public static final RubyArray newArray(final Ruby runtime, final long len) {
<span class="fc" id="L150">        checkLength(runtime, len);</span>
<span class="fc" id="L151">        return newArray(runtime, (int)len);</span>
    }
    
    public static final RubyArray newArrayLight(final Ruby runtime, final long len) {
<span class="nc" id="L155">        checkLength(runtime, len);</span>
<span class="nc" id="L156">        return newArrayLight(runtime, (int)len);</span>
    }
    
    public static final RubyArray newArray(final Ruby runtime, final int len) {
<span class="fc" id="L160">        RubyArray array = new RubyArray(runtime, len);</span>
<span class="fc" id="L161">        Helpers.fillNil(array.values, 0, array.values.length, runtime);</span>
<span class="fc" id="L162">        return array;</span>
    }

    public static final RubyArray newArrayLight(final Ruby runtime, final int len) {
<span class="nc" id="L166">        RubyArray array = new RubyArray(runtime, len, false);</span>
<span class="nc" id="L167">        Helpers.fillNil(array.values, 0, array.values.length, runtime);</span>
<span class="nc" id="L168">        return array;</span>
    }

    /** rb_ary_new
     *
     */
    public static final RubyArray newArray(final Ruby runtime) {
<span class="fc" id="L175">        return newArray(runtime, ARRAY_DEFAULT_SIZE);</span>
    }

    /** rb_ary_new
     *
     */
    public static final RubyArray newArrayLight(final Ruby runtime) {
        /* Ruby arrays default to holding 16 elements, so we create an
         * ArrayList of the same size if we're not told otherwise
         */
<span class="nc" id="L185">        return newArrayLight(runtime, ARRAY_DEFAULT_SIZE);</span>
    }

    public static RubyArray newArray(Ruby runtime, IRubyObject obj) {
<span class="fc" id="L189">        return new RubyArray(runtime, new IRubyObject[] { obj });</span>
    }

    public static RubyArray newArrayLight(Ruby runtime, IRubyObject obj) {
<span class="fc" id="L193">        return new RubyArray(runtime, new IRubyObject[] { obj }, false);</span>
    }

    public static RubyArray newArrayLight(Ruby runtime, IRubyObject... objs) {
<span class="nc" id="L197">        return new RubyArray(runtime, objs, false);</span>
    }

    /** rb_assoc_new
     *
     */
    public static RubyArray newArray(Ruby runtime, IRubyObject car, IRubyObject cdr) {
<span class="fc" id="L204">        return new RubyArray(runtime, new IRubyObject[] { car, cdr });</span>
    }
    
    public static RubyArray newEmptyArray(Ruby runtime) {
<span class="fc" id="L208">        return new RubyArray(runtime, NULL_ARRAY);</span>
    }

    /** rb_ary_new4, rb_ary_new3
     *   
     */
    public static RubyArray newArray(Ruby runtime, IRubyObject[] args) {
<span class="fc" id="L215">        RubyArray arr = new RubyArray(runtime, new IRubyObject[args.length]);</span>
<span class="fc" id="L216">        System.arraycopy(args, 0, arr.values, 0, args.length);</span>
<span class="fc" id="L217">        arr.realLength = args.length;</span>
<span class="fc" id="L218">        return arr;</span>
    }
    
    public static RubyArray newArrayNoCopy(Ruby runtime, IRubyObject[] args) {
<span class="fc" id="L222">        return new RubyArray(runtime, args);</span>
    }
    
    public static RubyArray newArrayNoCopy(Ruby runtime, IRubyObject[] args, int begin) {
<span class="fc" id="L226">        return new RubyArray(runtime, args, begin);</span>
    }

    public static RubyArray newArrayNoCopy(Ruby runtime, IRubyObject[] args, int begin, int length) {
<span class="nc bnc" id="L230" title="All 4 branches missed.">        assert begin &gt;= 0 : &quot;begin must be &gt;= 0&quot;;</span>
<span class="nc bnc" id="L231" title="All 4 branches missed.">        assert length &gt;= 0 : &quot;length must be &gt;= 0&quot;;</span>
        
<span class="nc" id="L233">        return new RubyArray(runtime, args, begin, length);</span>
    }

    public static RubyArray newArrayNoCopyLight(Ruby runtime, IRubyObject[] args) {
<span class="fc" id="L237">        RubyArray arr = new RubyArray(runtime, false);</span>
<span class="fc" id="L238">        arr.values = args;</span>
<span class="fc" id="L239">        arr.realLength = args.length;</span>
<span class="fc" id="L240">        return arr;</span>
    }

    public static RubyArray newArray(Ruby runtime, Collection&lt;? extends IRubyObject&gt; collection) {
<span class="fc" id="L244">        return new RubyArray(runtime, collection.toArray(new IRubyObject[collection.size()]));</span>
    }

    public static final int ARRAY_DEFAULT_SIZE = 16;    

    // volatile to ensure that initial nil-fill is visible to other threads
    private volatile IRubyObject[] values;

    private static final int TMPLOCK_ARR_F = 1 &lt;&lt; 9;
    private static final int TMPLOCK_OR_FROZEN_ARR_F = TMPLOCK_ARR_F | FROZEN_F;

<span class="pc" id="L255">    private volatile boolean isShared = false;</span>
<span class="pc" id="L256">    private int begin = 0;</span>
<span class="pc" id="L257">    private int realLength = 0;</span>
    
<span class="fc" id="L259">    private static final ByteList EMPTY_ARRAY_BYTELIST = new ByteList(ByteList.plain(&quot;[]&quot;), USASCIIEncoding.INSTANCE);</span>
<span class="fc" id="L260">    private static final ByteList RECURSIVE_ARRAY_BYTELIST = new ByteList(ByteList.plain(&quot;[...]&quot;), USASCIIEncoding.INSTANCE);</span>

    /*
     * plain internal array assignment
     */
    private RubyArray(Ruby runtime, IRubyObject[] vals) {
<span class="fc" id="L266">        super(runtime, runtime.getArray());</span>
<span class="fc" id="L267">        values = vals;</span>
<span class="fc" id="L268">        realLength = vals.length;</span>
<span class="fc" id="L269">    }</span>

    /* 
     * plain internal array assignment
     */
    private RubyArray(Ruby runtime, IRubyObject[] vals, boolean objectSpace) {
<span class="fc" id="L275">        super(runtime, runtime.getArray(), objectSpace);</span>
<span class="fc" id="L276">        values = vals;</span>
<span class="fc" id="L277">        realLength = vals.length;</span>
<span class="fc" id="L278">    }</span>

    /* 
     * plain internal array assignment
     */
    private RubyArray(Ruby runtime, IRubyObject[] vals, int begin) {
<span class="fc" id="L284">        super(runtime, runtime.getArray());</span>
<span class="fc" id="L285">        this.values = vals;</span>
<span class="fc" id="L286">        this.begin = begin;</span>
<span class="fc" id="L287">        this.realLength = vals.length - begin;</span>
<span class="fc" id="L288">        this.isShared = true;</span>
<span class="fc" id="L289">    }</span>

    private RubyArray(Ruby runtime, IRubyObject[] vals, int begin, int length) {
<span class="fc" id="L292">        super(runtime, runtime.getArray());</span>
<span class="fc" id="L293">        this.values = vals;</span>
<span class="fc" id="L294">        this.begin = begin;</span>
<span class="fc" id="L295">        this.realLength = length;</span>
<span class="fc" id="L296">        this.isShared = true;</span>
<span class="fc" id="L297">    }</span>

    private RubyArray(Ruby runtime, RubyClass metaClass, IRubyObject[] vals, int begin, int length) {
<span class="nc" id="L300">        super(runtime, metaClass);</span>
<span class="nc" id="L301">        this.values = vals;</span>
<span class="nc" id="L302">        this.begin = begin;</span>
<span class="nc" id="L303">        this.realLength = length;</span>
<span class="nc" id="L304">        this.isShared = true;</span>
<span class="nc" id="L305">    }</span>
    
    protected RubyArray(Ruby runtime, int length) {
<span class="fc" id="L308">        super(runtime, runtime.getArray());</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">        values = length == 0 ? IRubyObject.NULL_ARRAY : new IRubyObject[length];</span>
<span class="fc" id="L310">    }</span>

    private RubyArray(Ruby runtime, int length, boolean objectspace) {
<span class="fc" id="L313">        super(runtime, runtime.getArray(), objectspace);</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">        values = length == 0 ? IRubyObject.NULL_ARRAY : new IRubyObject[length];</span>
<span class="fc" id="L315">    }</span>

    /* NEWOBJ and OBJSETUP equivalent
     * fastest one, for shared arrays, optional objectspace
     */
    private RubyArray(Ruby runtime, boolean objectSpace) {
<span class="fc" id="L321">        super(runtime, runtime.getArray(), objectSpace);</span>
<span class="fc" id="L322">    }</span>

    private RubyArray(Ruby runtime, RubyClass klass) {
<span class="fc" id="L325">        super(runtime, klass);</span>
<span class="fc" id="L326">    }</span>

    /* Array constructors taking the MetaClass to fulfil MRI Array subclass behaviour
     * 
     */
    private RubyArray(Ruby runtime, RubyClass klass, int length) {
<span class="fc" id="L332">        super(runtime, klass);</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">        values = length == 0 ? IRubyObject.NULL_ARRAY : new IRubyObject[length];</span>
<span class="fc" id="L334">    }</span>

    private RubyArray(Ruby runtime, RubyClass klass, IRubyObject[]vals, boolean objectspace) {
<span class="nc" id="L337">        super(runtime, klass, objectspace);</span>
<span class="nc" id="L338">        values = vals;</span>
<span class="nc" id="L339">    }    </span>

    private RubyArray(Ruby runtime, RubyClass klass, boolean objectSpace) {
<span class="fc" id="L342">        super(runtime, klass, objectSpace);</span>
<span class="fc" id="L343">    }</span>
    
    private RubyArray(Ruby runtime, RubyClass klass, RubyArray original) {
<span class="nc" id="L346">        super(runtime, klass);</span>
<span class="nc" id="L347">        realLength = original.realLength;</span>
<span class="nc" id="L348">        values = new IRubyObject[realLength];</span>
<span class="nc" id="L349">        safeArrayCopy(runtime, original.values, original.begin, values, 0, realLength);</span>
<span class="nc" id="L350">    }</span>
    
    private RubyArray(Ruby runtime, RubyClass klass, IRubyObject[] vals) {
<span class="fc" id="L353">        super(runtime, klass);</span>
<span class="fc" id="L354">        values = vals;</span>
<span class="fc" id="L355">        realLength = vals.length;</span>
<span class="fc" id="L356">    }</span>

    private void alloc(int length) {
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">        IRubyObject[] newValues = length == 0 ? IRubyObject.NULL_ARRAY : new IRubyObject[length];</span>
<span class="fc" id="L360">        Helpers.fillNil(newValues, getRuntime());</span>
<span class="fc" id="L361">        values = newValues;</span>
<span class="fc" id="L362">        begin = 0;</span>
<span class="fc" id="L363">    }</span>

    private void realloc(int newLength, int valuesLength) {
<span class="fc" id="L366">        IRubyObject[] reallocated = new IRubyObject[newLength];</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">        if (newLength &gt; valuesLength) {</span>
<span class="fc" id="L368">            Helpers.fillNil(reallocated, valuesLength, newLength, getRuntime());</span>
<span class="fc" id="L369">            safeArrayCopy(values, begin, reallocated, 0, valuesLength); // elements and trailing nils</span>
        } else {
<span class="fc" id="L371">            safeArrayCopy(values, begin, reallocated, 0, newLength); // ???</span>
        }
<span class="fc" id="L373">        begin = 0;</span>
<span class="fc" id="L374">        values = reallocated;</span>
<span class="fc" id="L375">    }</span>

    private static void fill(IRubyObject[]arr, int from, int to, IRubyObject with) {
<span class="fc bfc" id="L378" title="All 2 branches covered.">        for (int i=from; i&lt;to; i++) {</span>
<span class="fc" id="L379">            arr[i] = with;</span>
        }
<span class="fc" id="L381">    }</span>

    private static final void checkLength(Ruby runtime, long length) {
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">        if (length &lt; 0) {</span>
<span class="nc" id="L385">            throw runtime.newArgumentError(&quot;negative array size (or size too big)&quot;);</span>
        }

<span class="pc bpc" id="L388" title="1 of 2 branches missed.">        if (length &gt;= Integer.MAX_VALUE) {</span>
<span class="nc" id="L389">            throw runtime.newArgumentError(&quot;array size too big&quot;);</span>
        }
<span class="fc" id="L391">    }</span>

    /** Getter for property list.
     * @return Value of property list.
     */
    public List getList() {
<span class="nc" id="L397">        return Arrays.asList(toJavaArray()); </span>
    }

    public int getLength() {
<span class="fc" id="L401">        return realLength;</span>
    }

    public IRubyObject[] toJavaArray() {
<span class="fc" id="L405">        IRubyObject[] copy = new IRubyObject[realLength];</span>
<span class="fc" id="L406">        safeArrayCopy(values, begin, copy, 0, realLength);</span>
<span class="fc" id="L407">        return copy;</span>
    }
    
    public IRubyObject[] toJavaArrayUnsafe() {
<span class="nc bnc" id="L411" title="All 2 branches missed.">        return !isShared ? values : toJavaArray();</span>
    }    

    public IRubyObject[] toJavaArrayMaybeUnsafe() {
<span class="pc bpc" id="L415" title="3 of 6 branches missed.">        return (!isShared &amp;&amp; begin == 0 &amp;&amp; values.length == realLength) ? values : toJavaArray();</span>
    }
    
    /** rb_ary_make_shared
    *
    */
    private RubyArray makeShared() {
<span class="fc" id="L422">        return makeShared(begin, realLength, getMetaClass());</span>
    }

    private RubyArray makeShared(int beg, int len, RubyClass klass) {
<span class="fc" id="L426">        return makeShared(beg, len, new RubyArray(klass.getRuntime(), klass));</span>
    }

    private RubyArray makeShared(int beg, int len, RubyArray sharedArray) {
<span class="fc" id="L430">        isShared = true;</span>
<span class="fc" id="L431">        sharedArray.values = values;</span>
<span class="fc" id="L432">        sharedArray.isShared = true;</span>
<span class="fc" id="L433">        sharedArray.begin = beg;</span>
<span class="fc" id="L434">        sharedArray.realLength = len;</span>
<span class="fc" id="L435">        return sharedArray;</span>
    }

    /** ary_shared_first
     * 
     */
    private RubyArray makeSharedFirst(ThreadContext context, IRubyObject num, boolean last, RubyClass klass) {
<span class="fc" id="L442">        int n = RubyNumeric.num2int(num);</span>
        
<span class="fc bfc" id="L444" title="All 2 branches covered.">        if (n &gt; realLength) {</span>
<span class="fc" id="L445">            n = realLength;</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">        } else if (n &lt; 0) {</span>
<span class="fc" id="L447">            throw context.runtime.newArgumentError(&quot;negative array size&quot;);</span>
        }
        
<span class="fc bfc" id="L450" title="All 2 branches covered.">        return makeShared(last ? begin + realLength - n : begin, n, klass);</span>
    }

    /** rb_ary_modify_check
     *
     */
    private final void modifyCheck() {
<span class="fc bfc" id="L457" title="All 2 branches covered.">        if ((flags &amp; TMPLOCK_OR_FROZEN_ARR_F) != 0) {</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">            if ((flags &amp; FROZEN_F) != 0) throw getRuntime().newFrozenError(&quot;array&quot;);           </span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">            if ((flags &amp; TMPLOCK_ARR_F) != 0) throw getRuntime().newTypeError(&quot;can't modify array during iteration&quot;);</span>
        }
<span class="fc" id="L461">    }</span>

    /** rb_ary_modify
     *
     */
    private final void modify() {
<span class="fc" id="L467">        modifyCheck();</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">        if (isShared) {</span>
<span class="fc" id="L469">            IRubyObject[] vals = new IRubyObject[realLength];</span>
<span class="fc" id="L470">            safeArrayCopy(values, begin, vals, 0, realLength);</span>
<span class="fc" id="L471">            begin = 0;            </span>
<span class="fc" id="L472">            values = vals;</span>
<span class="fc" id="L473">            isShared = false;</span>
        }
<span class="fc" id="L475">    }</span>

    /*  ================
     *  Instance Methods
     *  ================ 
     */

    /**
     * Variable arity version for compatibility. Not bound to a Ruby method.
     * @deprecated Use the versions with zero, one, or two args.
     */
    public IRubyObject initialize(ThreadContext context, IRubyObject[] args, Block block) {
<span class="nc bnc" id="L487" title="All 4 branches missed.">        switch (args.length) {</span>
        case 0:
<span class="nc" id="L489">            return initialize(context, block);</span>
        case 1:
<span class="nc" id="L491">            return initializeCommon(context, args[0], null, block);</span>
        case 2:
<span class="nc" id="L493">            return initializeCommon(context, args[0], args[1], block);</span>
        default:
<span class="nc" id="L495">            Arity.raiseArgumentError(getRuntime(), args.length, 0, 2);</span>
<span class="nc" id="L496">            return null; // not reached</span>
        }
    }    
    
    /** rb_ary_initialize
     * 
     */
    @JRubyMethod(visibility = PRIVATE)
    public IRubyObject initialize(ThreadContext context, Block block) {
<span class="fc" id="L505">        modifyCheck();</span>
<span class="fc" id="L506">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L507">        realLength = 0;</span>
<span class="pc bpc" id="L508" title="1 of 4 branches missed.">        if (block.isGiven() &amp;&amp; runtime.isVerbose()) {</span>
<span class="nc" id="L509">            runtime.getWarnings().warning(ID.BLOCK_UNUSED, &quot;given block not used&quot;);</span>
        }
<span class="fc" id="L511">        return this;</span>
    }

    /** rb_ary_initialize
     * 
     */
    @JRubyMethod(visibility = PRIVATE)
    public IRubyObject initialize(ThreadContext context, IRubyObject arg0, Block block) {
<span class="fc" id="L519">        return initializeCommon(context, arg0, null, block);</span>
    }

    /** rb_ary_initialize
     * 
     */
    @JRubyMethod(visibility = PRIVATE)
    public IRubyObject initialize(ThreadContext context, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="fc" id="L527">        return initializeCommon(context, arg0, arg1, block);</span>
    }

    private IRubyObject initializeCommon(ThreadContext context, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="fc" id="L531">        Ruby runtime = context.runtime;</span>

<span class="fc bfc" id="L533" title="All 4 branches covered.">        if (arg1 == null &amp;&amp; !(arg0 instanceof RubyFixnum)) {</span>
<span class="fc" id="L534">            IRubyObject val = arg0.checkArrayType();</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">            if (!val.isNil()) {</span>
<span class="fc" id="L536">                replace(val);</span>
<span class="fc" id="L537">                return this;</span>
            }
        }

<span class="fc" id="L541">        long len = RubyNumeric.num2long(arg0);</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">        if (len &lt; 0) throw runtime.newArgumentError(&quot;negative array size&quot;);</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">        if (len &gt;= Integer.MAX_VALUE) throw runtime.newArgumentError(&quot;array size too big&quot;);</span>
<span class="fc" id="L544">        int ilen = (int) len;</span>

<span class="fc" id="L546">        modify();</span>

<span class="fc bfc" id="L548" title="All 2 branches covered.">        if (ilen &gt; values.length - begin) {</span>
<span class="fc" id="L549">            values = new IRubyObject[ilen];</span>
<span class="fc" id="L550">            begin = 0;</span>
        }

<span class="fc bfc" id="L553" title="All 2 branches covered.">        if (block.isGiven()) {</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">            if (arg1 != null) {</span>
<span class="fc" id="L555">                runtime.getWarnings().warn(ID.BLOCK_BEATS_DEFAULT_VALUE, &quot;block supersedes default value argument&quot;);</span>
            }

<span class="pc bpc" id="L558" title="1 of 2 branches missed.">            if (block.getBody().getArgumentType() == BlockBody.ZERO_ARGS) {</span>
<span class="nc" id="L559">                IRubyObject nil = runtime.getNil();</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">                for (int i = 0; i &lt; ilen; i++) {</span>
<span class="nc" id="L561">                    store(i, block.yield(context, nil));</span>
<span class="nc" id="L562">                    realLength = i + 1;</span>
                }
<span class="nc" id="L564">            } else {</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">                for (int i = 0; i &lt; ilen; i++) {</span>
<span class="fc" id="L566">                    store(i, block.yield(context, RubyFixnum.newFixnum(runtime, i)));</span>
<span class="fc" id="L567">                    realLength = i + 1;</span>
                }
            }
            
        } else {
            try {
<span class="fc bfc" id="L573" title="All 2 branches covered.">                if (arg1 == null) {</span>
<span class="fc" id="L574">                    Helpers.fillNil(values, begin, begin + ilen, runtime);</span>
                } else {
<span class="fc" id="L576">                    fill(values, begin, begin + ilen, arg1);</span>
                }
<span class="nc" id="L578">            } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L579">                concurrentModification();</span>
<span class="fc" id="L580">            }</span>
<span class="fc" id="L581">            realLength = ilen;</span>
        }
<span class="fc" id="L583">        return this;</span>
    }

    /** rb_ary_initialize_copy
     * 
     */
    @JRubyMethod(name = {&quot;initialize_copy&quot;}, required = 1, visibility=PRIVATE)
    @Override
    public IRubyObject initialize_copy(IRubyObject orig) {
<span class="fc" id="L592">        return this.replace(orig);</span>
    }

    /**
     * Overridden dup for fast-path logic.
     *
     * @return A new RubyArray sharing the original backing store.
     */
    public IRubyObject dup() {
<span class="fc bfc" id="L601" title="All 2 branches covered.">        if (metaClass.getClassIndex() != ClassIndex.ARRAY) return super.dup();</span>

<span class="fc" id="L603">        RubyArray dup = new RubyArray(metaClass.getClassRuntime(), values, begin, realLength);</span>
<span class="fc" id="L604">        dup.isShared = isShared = true;</span>
<span class="fc" id="L605">        dup.flags |= flags &amp; TAINTED_F; // from DUP_SETUP</span>

<span class="fc" id="L607">        return dup;</span>
    }
    
    /** rb_ary_replace
     *
     */
    @JRubyMethod(name = {&quot;replace&quot;}, required = 1)
    public IRubyObject replace(IRubyObject orig) {
<span class="fc" id="L615">        modifyCheck();</span>

<span class="fc" id="L617">        RubyArray origArr = orig.convertToArray();</span>

<span class="fc bfc" id="L619" title="All 2 branches covered.">        if (this == orig) return this;</span>

<span class="fc" id="L621">        origArr.isShared = true;</span>
<span class="fc" id="L622">        isShared = true;</span>
<span class="fc" id="L623">        values = origArr.values;</span>
<span class="fc" id="L624">        realLength = origArr.realLength;</span>
<span class="fc" id="L625">        begin = origArr.begin;</span>


<span class="fc" id="L628">        return this;</span>
    }

    /** rb_ary_to_s
     *
     */
    @JRubyMethod(name = &quot;to_s&quot;)
    @Override
    public IRubyObject to_s() {
<span class="fc" id="L637">        return inspect();</span>
    }

    
    public boolean includes(ThreadContext context, IRubyObject item) {
<span class="fc" id="L642">        int myBegin = this.begin;</span>
<span class="fc" id="L643">        int end = myBegin + realLength;</span>
<span class="fc" id="L644">        IRubyObject[] values = this.values;</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">        for (int i = myBegin; i &lt; end; i++) {</span>
<span class="fc" id="L646">            final IRubyObject value = safeArrayRef(values, i);</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">            if (equalInternal(context, value, item)) return true;</span>
        }
        
<span class="fc" id="L650">        return false;</span>
    }

    /** rb_ary_hash
     * 
     */
    public RubyFixnum hash(ThreadContext context) {
<span class="nc" id="L657">        return hash19(context);</span>
    }

    /** rb_ary_hash
     * 
     */
    @JRubyMethod(name = &quot;hash&quot;)
    public RubyFixnum hash19(final ThreadContext context) {
<span class="fc" id="L665">        return (RubyFixnum) getRuntime().execRecursiveOuter(new Ruby.RecursiveFunction() {</span>
            public IRubyObject call(IRubyObject obj, boolean recur) {
<span class="fc" id="L667">                int begin = RubyArray.this.begin;</span>
<span class="fc" id="L668">                long h = realLength;</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">                if (recur) {</span>
<span class="fc" id="L670">                    h ^= RubyNumeric.num2long(invokedynamic(context, context.runtime.getArray(), HASH));</span>
                } else {
<span class="fc bfc" id="L672" title="All 2 branches covered.">                    for (int i = begin; i &lt; begin + realLength; i++) {</span>
<span class="fc bfc" id="L673" title="All 2 branches covered.">                        h = (h &lt;&lt; 1) | (h &lt; 0 ? 1 : 0);</span>
<span class="fc" id="L674">                        final IRubyObject value = safeArrayRef(values, i);</span>
<span class="fc" id="L675">                        h ^= RubyNumeric.num2long(invokedynamic(context, value, HASH));</span>
                    }
                }
<span class="fc" id="L678">                return getRuntime().newFixnum(h);</span>
            }
        }, RubyArray.this);
    }

    /** rb_ary_store
     *
     */
    public final IRubyObject store(long index, IRubyObject value) {
<span class="fc bfc" id="L687" title="All 4 branches covered.">        if (index &lt; 0 &amp;&amp; (index += realLength) &lt; 0) throw getRuntime().newIndexError(&quot;index &quot; + (index - realLength) + &quot; out of array&quot;);</span>

<span class="fc" id="L689">        modify();</span>

<span class="fc bfc" id="L691" title="All 2 branches covered.">        if (index &gt;= realLength) {</span>
<span class="fc" id="L692">            int valuesLength = values.length - begin;</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">            if (index &gt;= valuesLength) storeRealloc(index, valuesLength);</span>
<span class="fc" id="L694">            realLength = (int) index + 1;</span>
        }

<span class="fc" id="L697">        safeArraySet(values, begin + (int) index, value);</span>
        
<span class="fc" id="L699">        return value;</span>
    }

    private void storeRealloc(long index, int valuesLength) {
<span class="fc" id="L703">        long newLength = valuesLength &gt;&gt; 1;</span>

<span class="pc bpc" id="L705" title="1 of 2 branches missed.">        if (newLength &lt; ARRAY_DEFAULT_SIZE) newLength = ARRAY_DEFAULT_SIZE;</span>

<span class="fc" id="L707">        newLength += index;</span>
<span class="pc bpc" id="L708" title="2 of 4 branches missed.">        if (index &gt;= Integer.MAX_VALUE || newLength &gt;= Integer.MAX_VALUE) {</span>
<span class="nc" id="L709">            throw getRuntime().newArgumentError(&quot;index too big&quot;);</span>
        }
<span class="fc" id="L711">        realloc((int) newLength, valuesLength);</span>
<span class="fc" id="L712">    }</span>

    /** rb_ary_elt
     *
     */
    private final IRubyObject elt(long offset) {
<span class="fc bfc" id="L718" title="All 4 branches covered.">        if (offset &lt; 0 || offset &gt;= realLength) {</span>
<span class="fc" id="L719">            return getRuntime().getNil();</span>
        }
<span class="fc" id="L721">        return eltOk(offset);</span>
    }

    public final IRubyObject eltOk(long offset) {
<span class="fc" id="L725">        return safeArrayRef(values, begin + (int)offset);</span>
    }

    /** rb_ary_entry
     *
     */
    public final IRubyObject entry(long offset) {
<span class="fc bfc" id="L732" title="All 2 branches covered.">        return (offset &lt; 0 ) ? elt(offset + realLength) : elt(offset);</span>
    }

    public final IRubyObject entry(int offset) {
<span class="pc bpc" id="L736" title="1 of 2 branches missed.">        return (offset &lt; 0 ) ? elt(offset + realLength) : elt(offset);</span>
    }

    public final IRubyObject eltInternal(int offset) {
<span class="fc" id="L740">        return values[begin + offset];</span>
    }
    
    public final IRubyObject eltInternalSet(int offset, IRubyObject item) {
<span class="nc" id="L744">        return values[begin + offset] = item;</span>
    }

    /**
     * Variable arity version for compatibility. Not bound to a Ruby method.
     * @deprecated Use the versions with zero, one, or two args.
     */
    public IRubyObject fetch(ThreadContext context, IRubyObject[] args, Block block) {
<span class="nc bnc" id="L752" title="All 3 branches missed.">        switch (args.length) {</span>
        case 1:
<span class="nc" id="L754">            return fetch(context, args[0], block);</span>
        case 2:
<span class="nc" id="L756">            return fetch(context, args[0], args[1], block);</span>
        default:
<span class="nc" id="L758">            Arity.raiseArgumentError(getRuntime(), args.length, 1, 2);</span>
<span class="nc" id="L759">            return null; // not reached</span>
        }
    }    

    /** rb_ary_fetch
     *
     */
    @JRubyMethod
    public IRubyObject fetch(ThreadContext context, IRubyObject arg0, Block block) {
<span class="fc" id="L768">        long index = RubyNumeric.num2long(arg0);</span>

<span class="fc bfc" id="L770" title="All 2 branches covered.">        if (index &lt; 0) index += realLength;</span>
<span class="fc bfc" id="L771" title="All 4 branches covered.">        if (index &lt; 0 || index &gt;= realLength) {</span>
<span class="fc bfc" id="L772" title="All 2 branches covered.">            if (block.isGiven()) return block.yield(context, arg0);</span>
<span class="fc" id="L773">            throw getRuntime().newIndexError(&quot;index &quot; + index + &quot; out of array&quot;);</span>
        }
        
<span class="fc" id="L776">        return safeArrayRef(values, begin + (int) index);</span>
    }

    /** rb_ary_fetch
    *
    */
   @JRubyMethod
   public IRubyObject fetch(ThreadContext context, IRubyObject arg0, IRubyObject arg1, Block block) {
<span class="fc bfc" id="L784" title="All 2 branches covered.">       if (block.isGiven()) getRuntime().getWarnings().warn(ID.BLOCK_BEATS_DEFAULT_VALUE, &quot;block supersedes default value argument&quot;);</span>

<span class="fc" id="L786">       long index = RubyNumeric.num2long(arg0);</span>

<span class="fc bfc" id="L788" title="All 2 branches covered.">       if (index &lt; 0) index += realLength;</span>
<span class="fc bfc" id="L789" title="All 4 branches covered.">       if (index &lt; 0 || index &gt;= realLength) {</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">           if (block.isGiven()) return block.yield(context, arg0);</span>
<span class="fc" id="L791">           return arg1;</span>
       }
       
<span class="fc" id="L794">       return safeArrayRef(values, begin + (int) index);</span>
   }    

    /** rb_ary_to_ary
     * 
     */
    private static RubyArray aryToAry(IRubyObject obj) {
<span class="fc bfc" id="L801" title="All 2 branches covered.">        if (obj instanceof RubyArray) return (RubyArray) obj;</span>

<span class="fc bfc" id="L803" title="All 2 branches covered.">        if (obj.respondsTo(&quot;to_ary&quot;)) return obj.convertToArray();</span>

<span class="fc" id="L805">        RubyArray arr = new RubyArray(obj.getRuntime(), false); // possibly should not in object space</span>
<span class="fc" id="L806">        arr.values = new IRubyObject[]{obj};</span>
<span class="fc" id="L807">        arr.realLength = 1;</span>
<span class="fc" id="L808">        return arr;</span>
    }

    /** rb_ary_splice
     * 
     */
    private final void splice(long beg, long len, IRubyObject rpl, boolean oneNine) {
<span class="fc bfc" id="L815" title="All 2 branches covered.">        if (len &lt; 0) throw getRuntime().newIndexError(&quot;negative length (&quot; + len + &quot;)&quot;);</span>
<span class="fc bfc" id="L816" title="All 4 branches covered.">        if (beg &lt; 0 &amp;&amp; (beg += realLength) &lt; 0) throw getRuntime().newIndexError(&quot;index &quot; + (beg - realLength) + &quot; out of array&quot;);</span>

        final RubyArray rplArr;
        final int rlen;

<span class="pc bpc" id="L821" title="1 of 6 branches missed.">        if (rpl == null || (rpl.isNil() &amp;&amp; !oneNine)) {</span>
<span class="fc" id="L822">            rplArr = null;</span>
<span class="fc" id="L823">            rlen = 0;</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">        } else if (rpl.isNil()) {</span>
            // 1.9 replaces with nil
<span class="fc" id="L826">            rplArr = newArray(getRuntime(), rpl);</span>
<span class="fc" id="L827">            rlen = 1;</span>
        } else {
<span class="fc" id="L829">            rplArr = aryToAry(rpl);</span>
<span class="fc" id="L830">            rlen = rplArr.realLength;</span>
        }

<span class="fc" id="L833">        modify();</span>

<span class="fc" id="L835">        int valuesLength = values.length - begin;</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">        if (beg &gt;= realLength) {</span>
<span class="fc" id="L837">            len = beg + rlen;</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">            if (len &gt;= valuesLength) spliceRealloc((int)len, valuesLength);</span>
            try {
<span class="fc" id="L840">                Helpers.fillNil(values, begin + realLength, begin + ((int) beg), getRuntime());</span>
<span class="nc" id="L841">            } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L842">                concurrentModification();</span>
<span class="fc" id="L843">            }</span>
<span class="fc" id="L844">            realLength = (int) len;</span>
        } else {
<span class="fc bfc" id="L846" title="All 2 branches covered.">            if (beg + len &gt; realLength) len = realLength - beg;</span>
<span class="fc" id="L847">            int alen = realLength + rlen - (int)len;</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">            if (alen &gt;= valuesLength) spliceRealloc(alen, valuesLength);</span>

<span class="fc bfc" id="L850" title="All 2 branches covered.">            if (len != rlen) {</span>
<span class="fc" id="L851">                safeArrayCopy(values, begin + (int) (beg + len), values, begin + (int) beg + rlen, realLength - (int) (beg + len));</span>
<span class="fc" id="L852">                realLength = alen;</span>
            }
        }

<span class="fc bfc" id="L856" title="All 2 branches covered.">        if (rlen &gt; 0) {</span>
<span class="fc" id="L857">            safeArrayCopy(rplArr.values, rplArr.begin, values, begin + (int) beg, rlen);</span>
        }
<span class="fc" id="L859">    }</span>

    /** rb_ary_splice
     * 
     */
    private final void spliceOne(long beg, IRubyObject rpl) {
<span class="nc bnc" id="L865" title="All 4 branches missed.">        if (beg &lt; 0 &amp;&amp; (beg += realLength) &lt; 0) throw getRuntime().newIndexError(&quot;index &quot; + (beg - realLength) + &quot; out of array&quot;);</span>

<span class="nc" id="L867">        modify();</span>

<span class="nc" id="L869">        int valuesLength = values.length - begin;</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">        if (beg &gt;= realLength) {</span>
<span class="nc" id="L871">            int len = (int)beg + 1;</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">            if (len &gt;= valuesLength) spliceRealloc((int)len, valuesLength);</span>
<span class="nc" id="L873">            Helpers.fillNil(values, begin + realLength, begin + ((int) beg), getRuntime());</span>
<span class="nc" id="L874">            realLength = (int) len;</span>
<span class="nc" id="L875">        } else {</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">            int len = beg &gt; realLength ? realLength - (int)beg : 0;</span>
<span class="nc" id="L877">            int alen = realLength + 1 - len;</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">            if (alen &gt;= valuesLength) spliceRealloc((int)alen, valuesLength);</span>

<span class="nc bnc" id="L880" title="All 2 branches missed.">            if (len == 0) {</span>
<span class="nc" id="L881">                safeArrayCopy(values, begin + (int) beg, values, begin + (int) beg + 1, realLength - (int) beg);</span>
<span class="nc" id="L882">                realLength = alen;</span>
            }
        }

<span class="nc" id="L886">        safeArraySet(values, begin + (int)beg, rpl);</span>
<span class="nc" id="L887">    }</span>

    private void spliceRealloc(int length, int valuesLength) {
<span class="fc" id="L890">        int tryLength = valuesLength + (valuesLength &gt;&gt; 1);</span>
<span class="fc bfc" id="L891" title="All 2 branches covered.">        int len = length &gt; tryLength ? length : tryLength;</span>
<span class="fc" id="L892">        IRubyObject[] vals = new IRubyObject[len];</span>
<span class="fc" id="L893">        System.arraycopy(values, begin, vals, 0, realLength);</span>
        
        // only fill if there actually will remain trailing storage
<span class="fc bfc" id="L896" title="All 2 branches covered.">        if (len &gt; length) Helpers.fillNil(vals, length, len, getRuntime());</span>
<span class="fc" id="L897">        begin = 0;</span>
<span class="fc" id="L898">        values = vals;</span>
<span class="fc" id="L899">    }</span>

    public IRubyObject insert() {
<span class="nc" id="L902">        throw getRuntime().newArgumentError(0, 1);</span>
    }

    /** rb_ary_insert
     * 
     */
    public IRubyObject insert(IRubyObject arg) {
<span class="fc" id="L909">        return this;</span>
    }
    
    @JRubyMethod(name = &quot;insert&quot;)
    public IRubyObject insert19(IRubyObject arg) {
<span class="fc" id="L914">        modifyCheck();</span>
        
<span class="fc" id="L916">        return insert(arg);</span>
    }

    public IRubyObject insert(IRubyObject arg1, IRubyObject arg2) {
<span class="nc" id="L920">        long pos = RubyNumeric.num2long(arg1);</span>

<span class="nc bnc" id="L922" title="All 2 branches missed.">        if (pos == -1) pos = realLength;</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">        if (pos &lt; 0) pos++;</span>
        
<span class="nc" id="L925">        spliceOne(pos, arg2); // rb_ary_new4</span>
        
<span class="nc" id="L927">        return this;</span>
    }

    @JRubyMethod(name = &quot;insert&quot;)
    public IRubyObject insert19(IRubyObject arg1, IRubyObject arg2) {
<span class="nc" id="L932">        modifyCheck();</span>

<span class="nc" id="L934">        return insert(arg1, arg2);</span>
    }

    public IRubyObject insert(IRubyObject[] args) {
<span class="pc bpc" id="L938" title="1 of 2 branches missed.">        if (args.length == 1) return this;</span>

<span class="fc" id="L940">        long pos = RubyNumeric.num2long(args[0]);</span>

<span class="fc bfc" id="L942" title="All 2 branches covered.">        if (pos == -1) pos = realLength;</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">        if (pos &lt; 0) pos++;</span>

<span class="fc" id="L945">        RubyArray inserted = new RubyArray(getRuntime(), false);</span>
<span class="fc" id="L946">        inserted.values = args;</span>
<span class="fc" id="L947">        inserted.begin = 1;</span>
<span class="fc" id="L948">        inserted.realLength = args.length - 1;</span>
        
<span class="fc" id="L950">        splice(pos, 0, inserted, false); // rb_ary_new4</span>
        
<span class="fc" id="L952">        return this;</span>
    }

    @JRubyMethod(name = &quot;insert&quot;, required = 1, rest = true)
    public IRubyObject insert19(IRubyObject[] args) {
<span class="fc" id="L957">        modifyCheck();</span>

<span class="fc" id="L959">        return insert(args);</span>
    }

    /** rb_ary_dup
     * 
     */
    public final RubyArray aryDup() {
        // In 1.9, rb_ary_dup logic changed so that on subclasses of Array,
        // dup returns an instance of Array, rather than an instance of the subclass
        // Also, taintedness and trustedness are not inherited to duplicates
<span class="fc" id="L969">        RubyArray dup = new RubyArray(metaClass.getClassRuntime(), values, begin, realLength);</span>
<span class="fc" id="L970">        dup.isShared = true;</span>
<span class="fc" id="L971">        isShared = true;</span>
        // rb_copy_generic_ivar from DUP_SETUP here ...unlikely..
<span class="fc" id="L973">        return dup;</span>
    }

    /** rb_ary_transpose
     * 
     */
    @JRubyMethod(name = &quot;transpose&quot;)
    public RubyArray transpose() {
<span class="fc" id="L981">        RubyArray tmp, result = null;</span>

<span class="fc" id="L983">        int alen = realLength;</span>
<span class="fc bfc" id="L984" title="All 2 branches covered.">        if (alen == 0) return aryDup();</span>
    
<span class="fc" id="L986">        Ruby runtime = getRuntime();</span>
<span class="fc" id="L987">        int elen = -1;</span>
<span class="fc" id="L988">        int end = begin + alen;</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">        for (int i = begin; i &lt; end; i++) {</span>
<span class="fc" id="L990">            tmp = elt(i - begin).convertToArray();</span>
<span class="fc bfc" id="L991" title="All 2 branches covered.">            if (elen &lt; 0) {</span>
<span class="fc" id="L992">                elen = tmp.realLength;</span>
<span class="fc" id="L993">                result = new RubyArray(runtime, elen);</span>
<span class="fc bfc" id="L994" title="All 2 branches covered.">                for (int j = 0; j &lt; elen; j++) {</span>
<span class="fc" id="L995">                    result.store(j, new RubyArray(runtime, alen));</span>
                }
<span class="fc bfc" id="L997" title="All 2 branches covered.">            } else if (elen != tmp.realLength) {</span>
<span class="fc" id="L998">                throw runtime.newIndexError(&quot;element size differs (&quot; + tmp.realLength</span>
                        + &quot; should be &quot; + elen + &quot;)&quot;);
            }
<span class="fc bfc" id="L1001" title="All 2 branches covered.">            for (int j = 0; j &lt; elen; j++) {</span>
<span class="fc" id="L1002">                ((RubyArray) result.elt(j)).store(i - begin, tmp.elt(j));</span>
            }
        }
<span class="fc" id="L1005">        return result;</span>
    }

    /** rb_values_at (internal)
     * 
     */
    private final IRubyObject values_at(long olen, IRubyObject[] args) {
<span class="fc" id="L1012">        RubyArray result = new RubyArray(getRuntime(), args.length);</span>

<span class="fc bfc" id="L1014" title="All 2 branches covered.">        for (int i = 0; i &lt; args.length; i++) {</span>
<span class="fc bfc" id="L1015" title="All 2 branches covered.">            if (args[i] instanceof RubyFixnum) {</span>
<span class="fc" id="L1016">                result.append(entry(((RubyFixnum)args[i]).getLongValue()));</span>
<span class="fc" id="L1017">                continue;</span>
            }

            long beglen[];
<span class="fc bfc" id="L1021" title="All 2 branches covered.">            if (!(args[i] instanceof RubyRange)) {</span>
<span class="fc bfc" id="L1022" title="All 2 branches covered.">            } else if ((beglen = ((RubyRange) args[i]).begLen(olen, 0)) == null) {</span>
<span class="fc" id="L1023">                continue;</span>
            } else {
<span class="fc" id="L1025">                int beg = (int) beglen[0];</span>
<span class="fc" id="L1026">                int len = (int) beglen[1];</span>
<span class="fc" id="L1027">                int end = begin + len;</span>
<span class="fc bfc" id="L1028" title="All 2 branches covered.">                for (int j = begin; j &lt; end; j++) {</span>
<span class="fc" id="L1029">                    result.append(entry(j + beg));</span>
                }
<span class="fc" id="L1031">                continue;</span>
            }
<span class="fc" id="L1033">            result.append(entry(RubyNumeric.num2long(args[i])));</span>
        }

<span class="fc" id="L1036">        Helpers.fillNil(result.values, result.realLength, result.values.length, getRuntime());</span>
<span class="fc" id="L1037">        return result;</span>
    }

    /** rb_values_at
     * 
     */
    @JRubyMethod(name = &quot;values_at&quot;, rest = true)
    public IRubyObject values_at(IRubyObject[] args) {
<span class="fc" id="L1045">        return values_at(realLength, args);</span>
    }

    /** rb_ary_subseq
     *
     */
    public IRubyObject subseq(long beg, long len) {
<span class="fc" id="L1052">        int realLength = this.realLength;</span>
<span class="fc bfc" id="L1053" title="All 6 branches covered.">        if (beg &gt; realLength || beg &lt; 0 || len &lt; 0) return getRuntime().getNil();</span>

<span class="fc bfc" id="L1055" title="All 2 branches covered.">        if (beg + len &gt; realLength) {</span>
<span class="fc" id="L1056">            len = realLength - beg;</span>
            
<span class="pc bpc" id="L1058" title="1 of 2 branches missed.">            if (len &lt; 0) len = 0;</span>
        }
        
<span class="fc bfc" id="L1061" title="All 2 branches covered.">        if (len == 0) return new RubyArray(getRuntime(), getMetaClass(), IRubyObject.NULL_ARRAY);</span>

<span class="fc" id="L1063">        return makeShared(begin + (int) beg, (int) len, getMetaClass());</span>
    }

    /** rb_ary_subseq
     *
     */
    public IRubyObject subseqLight(long beg, long len) {
<span class="fc" id="L1070">        Ruby runtime = getRuntime();</span>
<span class="pc bpc" id="L1071" title="3 of 6 branches missed.">        if (beg &gt; realLength || beg &lt; 0 || len &lt; 0) return runtime.getNil();</span>

<span class="pc bpc" id="L1073" title="1 of 2 branches missed.">        if (beg + len &gt; realLength) {</span>
<span class="nc" id="L1074">            len = realLength - beg;</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">            if (len &lt; 0) len = 0;</span>
        }

<span class="pc bpc" id="L1078" title="1 of 2 branches missed.">        if (len == 0) return new RubyArray(runtime, getMetaClass(), IRubyObject.NULL_ARRAY, false);</span>
<span class="fc" id="L1079">        return makeShared(begin + (int) beg, (int) len, new RubyArray(runtime, getMetaClass(), false));</span>
    }

    /** rb_ary_length
     *
     */
    @JRubyMethod(name = &quot;length&quot;, alias = &quot;size&quot;)
    public RubyFixnum length() {
<span class="fc" id="L1087">        return getRuntime().newFixnum(realLength);</span>
    }

    private SizeFn enumLengthFn() {
<span class="fc" id="L1091">        final RubyArray self = this;</span>
<span class="fc" id="L1092">        return new SizeFn() {</span>
            @Override
            public IRubyObject size(IRubyObject[] args) {
<span class="nc" id="L1095">                return self.length();</span>
            }
        };
    }

    /** rb_ary_push - specialized rb_ary_store 
     *
     */
    @JRubyMethod(name = &quot;&lt;&lt;&quot;, required = 1)
    public RubyArray append(IRubyObject item) {
<span class="fc" id="L1105">        modify();</span>
<span class="fc" id="L1106">        int valuesLength = values.length - begin;</span>
<span class="fc bfc" id="L1107" title="All 2 branches covered.">        if (realLength == valuesLength) {</span>
<span class="pc bpc" id="L1108" title="1 of 2 branches missed.">            if (realLength == Integer.MAX_VALUE) throw getRuntime().newArgumentError(&quot;index too big&quot;);</span>

<span class="fc" id="L1110">            long newLength = valuesLength + (valuesLength &gt;&gt; 1);</span>
<span class="pc bpc" id="L1111" title="1 of 2 branches missed.">            if (newLength &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L1112">                newLength = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L1113" title="All 2 branches covered.">            } else if (newLength &lt; ARRAY_DEFAULT_SIZE) {</span>
<span class="fc" id="L1114">                newLength = ARRAY_DEFAULT_SIZE;</span>
            }

<span class="fc" id="L1117">            realloc((int) newLength, valuesLength);</span>
        }
        
<span class="fc" id="L1120">        safeArraySet(values, begin + realLength++, item);</span>
        
<span class="fc" id="L1122">        return this;</span>
    }

    /** rb_ary_push_m - instance method push
     *
     */
    public RubyArray push_m(IRubyObject[] items) {
<span class="fc bfc" id="L1129" title="All 2 branches covered.">        for (int i = 0; i &lt; items.length; i++) {</span>
<span class="fc" id="L1130">            append(items[i]);</span>
        }
        
<span class="fc" id="L1133">        return this;</span>
    }

    public RubyArray push(IRubyObject item) {
<span class="fc" id="L1137">        append(item);</span>

<span class="fc" id="L1139">        return this;</span>
    }

    @JRubyMethod(name = &quot;push&quot;, rest = true)
    public RubyArray push_m19(IRubyObject[] items) {
<span class="fc" id="L1144">        modifyCheck();</span>

<span class="fc" id="L1146">        return push_m(items);</span>
    }

    /** rb_ary_pop
     *
     */
    @JRubyMethod
    public IRubyObject pop(ThreadContext context) {
<span class="fc" id="L1154">        modifyCheck();</span>

<span class="fc bfc" id="L1156" title="All 2 branches covered.">        if (realLength == 0) return context.runtime.getNil();</span>

<span class="pc bpc" id="L1158" title="1 of 2 branches missed.">        if (isShared) {</span>
<span class="nc" id="L1159">            return safeArrayRef(values, begin + --realLength);</span>
        } else {
<span class="fc" id="L1161">            int index = begin + --realLength;</span>
<span class="fc" id="L1162">            return safeArrayRefSet(values, index, context.runtime.getNil());</span>
        }
    }

    @JRubyMethod
    public IRubyObject pop(ThreadContext context, IRubyObject num) {
<span class="fc" id="L1168">        modifyCheck();</span>
<span class="fc" id="L1169">        RubyArray result = makeSharedFirst(context, num, true, context.runtime.getArray());</span>
<span class="fc" id="L1170">        realLength -= result.realLength;</span>
<span class="fc" id="L1171">        return result;</span>
    }
    
    /** rb_ary_shift
     *
     */
    @JRubyMethod(name = &quot;shift&quot;)
    public IRubyObject shift(ThreadContext context) {
<span class="fc" id="L1179">        modifyCheck();</span>
<span class="fc" id="L1180">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L1181" title="All 2 branches covered.">        if (realLength == 0) return runtime.getNil();</span>

<span class="fc bfc" id="L1183" title="All 2 branches covered.">        final IRubyObject obj = safeArrayRefCondSet(values, begin, !isShared, runtime.getNil());</span>
<span class="fc" id="L1184">        begin++;</span>
<span class="fc" id="L1185">        realLength--;</span>
<span class="fc" id="L1186">        return obj;</span>
        
    }    

    @JRubyMethod(name = &quot;shift&quot;)
    public IRubyObject shift(ThreadContext context, IRubyObject num) {
<span class="fc" id="L1192">        modify();</span>

<span class="fc" id="L1194">        RubyArray result = makeSharedFirst(context, num, false, context.runtime.getArray());</span>

<span class="fc" id="L1196">        int n = result.realLength;</span>
<span class="fc" id="L1197">        begin += n;</span>
<span class="fc" id="L1198">        realLength -= n;</span>
<span class="fc" id="L1199">        return result;</span>
    }

    public IRubyObject unshift() {
<span class="nc" id="L1203">        return this;</span>
    }

    @JRubyMethod(name = &quot;unshift&quot;)
    public IRubyObject unshift19() {
<span class="fc" id="L1208">        modifyCheck();</span>

<span class="fc" id="L1210">        return this;</span>

    }

    /** rb_ary_unshift
     *
     */
    public IRubyObject unshift(IRubyObject item) {
<span class="pc bpc" id="L1218" title="1 of 4 branches missed.">        if (begin == 0 || isShared) {</span>
<span class="fc" id="L1219">            modify();</span>
<span class="fc" id="L1220">            final int valuesLength = values.length - begin;</span>
<span class="fc bfc" id="L1221" title="All 2 branches covered.">            if (realLength == valuesLength) {</span>
<span class="fc" id="L1222">                int newLength = valuesLength &gt;&gt; 1;</span>
<span class="pc bpc" id="L1223" title="1 of 2 branches missed.">                if (newLength &lt; ARRAY_DEFAULT_SIZE) newLength = ARRAY_DEFAULT_SIZE;</span>
    
<span class="fc" id="L1225">                newLength += valuesLength;</span>
<span class="fc" id="L1226">                IRubyObject[]vals = new IRubyObject[newLength];</span>
<span class="fc" id="L1227">                safeArrayCopy(values, begin, vals, 1, valuesLength);</span>
<span class="fc" id="L1228">                Helpers.fillNil(vals, valuesLength + 1, newLength, getRuntime());</span>
<span class="fc" id="L1229">                values = vals;</span>
<span class="fc" id="L1230">                begin = 0;</span>
<span class="fc" id="L1231">            } else {</span>
<span class="fc" id="L1232">                safeArrayCopy(values, begin, values, begin + 1, realLength);</span>
            }
<span class="fc" id="L1234">        } else {</span>
<span class="fc" id="L1235">            modifyCheck();</span>
<span class="fc" id="L1236">            begin--;</span>
        }
<span class="fc" id="L1238">        realLength++;</span>
<span class="fc" id="L1239">        values[begin] = item;</span>
<span class="fc" id="L1240">        return this;</span>
    }

    @JRubyMethod(name = &quot;unshift&quot;)
    public IRubyObject unshift19(IRubyObject item) {
<span class="fc" id="L1245">        modifyCheck();</span>

<span class="fc" id="L1247">        return unshift(item);</span>
    }

    public IRubyObject unshift(IRubyObject[] items) {
<span class="fc" id="L1251">        long len = realLength;</span>
<span class="fc bfc" id="L1252" title="All 2 branches covered.">        if (items.length == 0) return this;</span>

<span class="fc" id="L1254">        store(len + items.length - 1, getRuntime().getNil());</span>

        try {
<span class="fc" id="L1257">            System.arraycopy(values, begin, values, begin + items.length, (int) len);</span>
<span class="fc" id="L1258">            System.arraycopy(items, 0, values, begin, items.length);</span>
<span class="nc" id="L1259">        } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L1260">            concurrentModification();</span>
<span class="fc" id="L1261">        }</span>
        
<span class="fc" id="L1263">        return this;</span>
    }

    @JRubyMethod(name = &quot;unshift&quot;, rest = true)
    public IRubyObject unshift19(IRubyObject[] items) {
<span class="fc" id="L1268">        modifyCheck();</span>

<span class="fc" id="L1270">        return unshift(items);</span>
    }

    /** rb_ary_includes
     * 
     */
    @JRubyMethod(name = &quot;include?&quot;, required = 1)
    public RubyBoolean include_p(ThreadContext context, IRubyObject item) {
<span class="fc" id="L1278">        return context.runtime.newBoolean(includes(context, item));</span>
    }

    /** rb_ary_frozen_p
     *
     */
    @JRubyMethod(name = &quot;frozen?&quot;)
    @Override
    public RubyBoolean frozen_p(ThreadContext context) {
<span class="pc bpc" id="L1287" title="1 of 4 branches missed.">        return context.runtime.newBoolean(isFrozen() || (flags &amp; TMPLOCK_ARR_F) != 0);</span>
    }

    /**
     * Variable arity version for compatibility. Not bound to a Ruby method.
     * @deprecated Use the versions with zero, one, or two args.
     */
    public IRubyObject aref(IRubyObject[] args) {
<span class="nc bnc" id="L1295" title="All 3 branches missed.">        switch (args.length) {</span>
        case 1:
<span class="nc" id="L1297">            return aref(args[0]);</span>
        case 2:
<span class="nc" id="L1299">            return aref(args[0], args[1]);</span>
        default:
<span class="nc" id="L1301">            Arity.raiseArgumentError(getRuntime(), args.length, 1, 2);</span>
<span class="nc" id="L1302">            return null; // not reached</span>
        }
    }

    /** rb_ary_aref
     */
    public IRubyObject aref(IRubyObject arg0) {
<span class="nc" id="L1309">        return aref19(arg0);</span>
    }

    @JRubyMethod(name = {&quot;[]&quot;, &quot;slice&quot;})
    public IRubyObject aref19(IRubyObject arg0) {
<span class="fc bfc" id="L1314" title="All 2 branches covered.">        return arg0 instanceof RubyFixnum ? entry(((RubyFixnum)arg0).getLongValue()) : arefCommon(arg0); </span>
    }

    private IRubyObject arefCommon(IRubyObject arg0) {
<span class="fc" id="L1318">        Ruby runtime = getRuntime();</span>

<span class="fc bfc" id="L1320" title="All 2 branches covered.">        if (arg0 instanceof RubyRange) {</span>
<span class="fc" id="L1321">            long[] beglen = ((RubyRange) arg0).begLen(realLength, 0);</span>
<span class="fc bfc" id="L1322" title="All 2 branches covered.">            return beglen == null ? runtime.getNil() : subseq(beglen[0], beglen[1]);</span>
<span class="pc bpc" id="L1323" title="3 of 4 branches missed.">        } else if (arg0.respondsTo(&quot;begin&quot;) &amp;&amp; arg0.respondsTo(&quot;end&quot;)) {</span>
<span class="nc" id="L1324">            ThreadContext context = getRuntime().getCurrentContext();</span>
<span class="nc" id="L1325">            IRubyObject begin = arg0.callMethod(context, &quot;begin&quot;);</span>
<span class="nc" id="L1326">            IRubyObject end   = arg0.callMethod(context, &quot;end&quot;);</span>
<span class="nc" id="L1327">            IRubyObject excl  = arg0.callMethod(context, &quot;exclude_end?&quot;);</span>
<span class="nc" id="L1328">            RubyRange range = RubyRange.newRange(context, begin, end, excl.isTrue());</span>

<span class="nc" id="L1330">            long[] beglen = range.begLen(realLength, 0);</span>
<span class="nc bnc" id="L1331" title="All 2 branches missed.">            return beglen == null ? runtime.getNil() : subseq(beglen[0], beglen[1]);</span>
        }
<span class="fc" id="L1333">        return entry(RubyNumeric.num2long(arg0));</span>
    }

    public IRubyObject aref(IRubyObject arg0, IRubyObject arg1) {
<span class="nc" id="L1337">        return aref19(arg0, arg1);</span>
    }

    @JRubyMethod(name = {&quot;[]&quot;, &quot;slice&quot;})
    public IRubyObject aref19(IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L1342">        return arefCommon(arg0, arg1);</span>
    }

    private IRubyObject arefCommon(IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L1346">        long beg = RubyNumeric.num2long(arg0);</span>
<span class="fc bfc" id="L1347" title="All 2 branches covered.">        if (beg &lt; 0) beg += realLength;</span>
<span class="fc" id="L1348">        return subseq(beg, RubyNumeric.num2long(arg1));</span>
    }

    /**
     * Variable arity version for compatibility. Not bound to a Ruby method.
     * @deprecated Use the versions with zero, one, or two args.
     */
    public IRubyObject aset(IRubyObject[] args) {
<span class="nc bnc" id="L1356" title="All 3 branches missed.">        switch (args.length) {</span>
        case 2:
<span class="nc" id="L1358">            return aset(args[0], args[1]);</span>
        case 3:
<span class="nc" id="L1360">            return aset(args[0], args[1], args[2]);</span>
        default:
<span class="nc" id="L1362">            throw getRuntime().newArgumentError(&quot;wrong number of arguments (&quot; + args.length + &quot; for 2)&quot;);</span>
        }
    }

    public IRubyObject aset(IRubyObject arg0, IRubyObject arg1) {
<span class="nc" id="L1367">        return aset19(arg0, arg1);</span>
    }

    @JRubyMethod(name = &quot;[]=&quot;)
    public IRubyObject aset19(IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L1372">        modifyCheck();</span>
<span class="fc bfc" id="L1373" title="All 2 branches covered.">        if (arg0 instanceof RubyFixnum) {</span>
<span class="fc" id="L1374">            store(((RubyFixnum)arg0).getLongValue(), arg1);</span>
<span class="fc bfc" id="L1375" title="All 2 branches covered.">        } else if (arg0 instanceof RubyRange) {</span>
<span class="fc" id="L1376">            RubyRange range = (RubyRange)arg0;</span>
<span class="fc" id="L1377">            long beg = range.begLen0(realLength);</span>
<span class="fc" id="L1378">            splice(beg, range.begLen1(realLength, beg), arg1, true);</span>
<span class="pc bpc" id="L1379" title="3 of 4 branches missed.">        } else if (arg0.respondsTo(&quot;begin&quot;) &amp;&amp; arg0.respondsTo(&quot;end&quot;)) {</span>
<span class="nc" id="L1380">            ThreadContext context = getRuntime().getCurrentContext();</span>
<span class="nc" id="L1381">            IRubyObject begin = arg0.callMethod(context, &quot;begin&quot;);</span>
<span class="nc" id="L1382">            IRubyObject end   = arg0.callMethod(context, &quot;end&quot;);</span>
<span class="nc" id="L1383">            IRubyObject excl  = arg0.callMethod(context, &quot;exclude_end?&quot;);</span>
<span class="nc" id="L1384">            RubyRange range = RubyRange.newRange(context, begin, end, excl.isTrue());</span>

<span class="nc" id="L1386">            long beg = range.begLen0(realLength);</span>
<span class="nc" id="L1387">            splice(beg, range.begLen1(realLength, beg), arg1, true);</span>
<span class="nc" id="L1388">        } else {</span>
<span class="fc" id="L1389">            store(RubyNumeric.num2long(arg0), arg1);</span>
        }
<span class="fc" id="L1391">        return arg1;</span>
    }

    /** rb_ary_aset
    *
    */
    public IRubyObject aset(IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {
<span class="nc" id="L1398">        return aset19(arg0, arg1, arg2);</span>
    }

    @JRubyMethod(name = &quot;[]=&quot;)
    public IRubyObject aset19(IRubyObject arg0, IRubyObject arg1, IRubyObject arg2) {
<span class="fc" id="L1403">        modifyCheck();</span>
<span class="fc" id="L1404">        splice(RubyNumeric.num2long(arg0), RubyNumeric.num2long(arg1), arg2, true);</span>
<span class="fc" id="L1405">        return arg2;</span>
    }

    /** rb_ary_at
     *
     */
    @JRubyMethod(name = &quot;at&quot;, required = 1)
    public IRubyObject at(IRubyObject pos) {
<span class="fc" id="L1413">        return entry(RubyNumeric.num2long(pos));</span>
    }

	/** rb_ary_concat
     *
     */
    public RubyArray concat(IRubyObject obj) {
<span class="fc" id="L1420">        return concat19(obj);</span>
    }

    @JRubyMethod(name = &quot;concat&quot;, required = 1)
    public RubyArray concat19(IRubyObject obj) {
<span class="fc" id="L1425">        modifyCheck();</span>

<span class="fc" id="L1427">        RubyArray ary = obj.convertToArray();</span>

<span class="fc bfc" id="L1429" title="All 2 branches covered.">        if (ary.realLength &gt; 0) splice(realLength, 0, ary, false);</span>

<span class="fc" id="L1431">        return this;</span>
    }

    /** inspect_ary
     * 
     */
    private IRubyObject inspectAry(ThreadContext context) {
<span class="fc" id="L1438">        Encoding encoding = context.runtime.getDefaultInternalEncoding();</span>
<span class="pc bpc" id="L1439" title="1 of 2 branches missed.">        if (encoding == null) encoding = USASCIIEncoding.INSTANCE;</span>
<span class="fc" id="L1440">        RubyString str = RubyString.newStringLight(context.runtime, DEFAULT_INSPECT_STR_SIZE, encoding);</span>
<span class="fc" id="L1441">        str.cat((byte)'[');</span>
<span class="fc" id="L1442">        boolean tainted = isTaint();</span>

<span class="fc bfc" id="L1444" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc bfc" id="L1445" title="All 2 branches covered.">            if (i &gt; 0) str.cat((byte)',').cat((byte)' ');</span>

<span class="fc" id="L1447">            RubyString str2 = inspect(context, safeArrayRef(values, begin + i));</span>
<span class="fc bfc" id="L1448" title="All 4 branches covered.">            if (i == 0 &amp;&amp; str2.getEncoding() != encoding) str.setEncoding(str2.getEncoding());</span>
<span class="fc bfc" id="L1449" title="All 2 branches covered.">            if (str2.isTaint()) tainted = true;</span>
            
<span class="fc" id="L1451">            str.cat19(str2);</span>
        }
<span class="fc" id="L1453">        str.cat((byte)']');</span>

<span class="fc bfc" id="L1455" title="All 2 branches covered.">        if (tainted) str.setTaint(true);</span>

<span class="fc" id="L1457">        return str;</span>
    }

    /** rb_ary_inspect
    *
    */
    @JRubyMethod(name = &quot;inspect&quot;)
    @Override
    public IRubyObject inspect() {
<span class="fc bfc" id="L1466" title="All 2 branches covered.">        if (realLength == 0) return RubyString.newStringShared(getRuntime(), EMPTY_ARRAY_BYTELIST);</span>
<span class="fc bfc" id="L1467" title="All 2 branches covered.">        if (getRuntime().isInspecting(this)) return  RubyString.newStringShared(getRuntime(), RECURSIVE_ARRAY_BYTELIST);</span>

        try {
<span class="fc" id="L1470">            getRuntime().registerInspecting(this);</span>
<span class="fc" id="L1471">            return inspectAry(getRuntime().getCurrentContext());</span>
        } finally {
<span class="pc" id="L1473">            getRuntime().unregisterInspecting(this);</span>
        }
    }

    /**
     * Variable arity version for compatibility. Not bound to a Ruby method.
     * @deprecated Use the versions with zero, one, or two args.
     */
    public IRubyObject first(IRubyObject[] args) {
<span class="nc bnc" id="L1482" title="All 3 branches missed.">        switch (args.length) {</span>
        case 0:
<span class="nc" id="L1484">            return first();</span>
        case 1:
<span class="nc" id="L1486">            return first(args[0]);</span>
        default:
<span class="nc" id="L1488">            Arity.raiseArgumentError(getRuntime(), args.length, 0, 1);</span>
<span class="nc" id="L1489">            return null; // not reached</span>
        }
    }

    /** rb_ary_first
     *
     */
    @JRubyMethod(name = &quot;first&quot;)
    public IRubyObject first() {
<span class="fc bfc" id="L1498" title="All 2 branches covered.">        if (realLength == 0) return getRuntime().getNil();</span>
<span class="fc" id="L1499">        return values[begin];</span>
    }

    /** rb_ary_first
    *
    */
    @JRubyMethod(name = &quot;first&quot;)
    public IRubyObject first(IRubyObject arg0) {
<span class="fc" id="L1507">        long n = RubyNumeric.num2long(arg0);</span>
<span class="fc bfc" id="L1508" title="All 2 branches covered.">        if (n &gt; realLength) {</span>
<span class="fc" id="L1509">            n = realLength;</span>
<span class="fc bfc" id="L1510" title="All 2 branches covered.">        } else if (n &lt; 0) {</span>
<span class="fc" id="L1511">            throw getRuntime().newArgumentError(&quot;negative array size (or size too big)&quot;);</span>
        }

<span class="fc" id="L1514">        return makeShared(begin, (int) n, getRuntime().getArray());</span>
    }

    /**
     * Variable arity version for compatibility. Not bound to a Ruby method.
     * @deprecated Use the versions with zero, one, or two args.
     */
    public IRubyObject last(IRubyObject[] args) {
<span class="nc bnc" id="L1522" title="All 3 branches missed.">        switch (args.length) {</span>
        case 0:
<span class="nc" id="L1524">            return last();</span>
        case 1:
<span class="nc" id="L1526">            return last(args[0]);</span>
        default:
<span class="nc" id="L1528">            Arity.raiseArgumentError(getRuntime(), args.length, 0, 1);</span>
<span class="nc" id="L1529">            return null; // not reached</span>
        }
    }

    /** rb_ary_last
     *
     */
    @JRubyMethod(name = &quot;last&quot;)
    public IRubyObject last() {
<span class="fc bfc" id="L1538" title="All 2 branches covered.">        if (realLength == 0) return getRuntime().getNil();</span>
<span class="fc" id="L1539">        return values[begin + realLength - 1];</span>
    }

    /** rb_ary_last
    *
    */
    @JRubyMethod(name = &quot;last&quot;)
    public IRubyObject last(IRubyObject arg0) {
<span class="fc" id="L1547">        long n = RubyNumeric.num2long(arg0);</span>
<span class="fc bfc" id="L1548" title="All 2 branches covered.">        if (n &gt; realLength) {</span>
<span class="fc" id="L1549">            n = realLength;</span>
<span class="fc bfc" id="L1550" title="All 2 branches covered.">        } else if (n &lt; 0) {</span>
<span class="fc" id="L1551">            throw getRuntime().newArgumentError(&quot;negative array size (or size too big)&quot;);</span>
        }

<span class="fc" id="L1554">        return makeShared(begin + realLength - (int) n, (int) n, getRuntime().getArray());</span>
    }

    /**
     * mri: rb_ary_each
     */
    @JRubyMethod
    public IRubyObject each(ThreadContext context, Block block) {
<span class="fc bfc" id="L1562" title="All 2 branches covered.">        if (!block.isGiven()) return enumeratorizeWithSize(context, this, &quot;each&quot;, enumLengthFn());</span>

<span class="fc bfc" id="L1564" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
            // do not coarsen the &quot;safe&quot; catch, since it will misinterpret AIOOBE from the yielded code.
            // See JRUBY-5434
<span class="fc" id="L1567">            block.yield(context, safeArrayRef(values, begin + i));</span>
        }
<span class="fc" id="L1569">        return this;</span>
    }

    public IRubyObject eachSlice(ThreadContext context, int size, Block block) {
<span class="nc" id="L1573">        Ruby runtime = context.runtime;</span>

        // local copies of everything
<span class="nc" id="L1576">        int localRealLength = realLength;</span>
<span class="nc" id="L1577">        IRubyObject[] localValues = values;</span>
<span class="nc" id="L1578">        int localBegin = begin;</span>

        // sliding window
<span class="nc" id="L1581">        RubyArray window = newArrayNoCopy(runtime, localValues, localBegin, size);</span>
<span class="nc" id="L1582">        makeShared();</span>

        // don't expose shared array to ruby
<span class="nc bnc" id="L1585" title="All 4 branches missed.">        final boolean specificArity = (block.arity().isFixed()) &amp;&amp; (block.arity().required() != 1);</span>
        
<span class="nc bnc" id="L1587" title="All 2 branches missed.">        for (; localRealLength &gt;= size; localRealLength -= size) {</span>
<span class="nc" id="L1588">            block.yield(context, window);</span>
<span class="nc bnc" id="L1589" title="All 2 branches missed.">            if (specificArity) { // array is never exposed to ruby, just use for yielding</span>
<span class="nc" id="L1590">                window.begin = localBegin += size;</span>
            } else { // array may be exposed to ruby, create new
<span class="nc" id="L1592">                window = newArrayNoCopy(runtime, localValues, localBegin += size, size);</span>
            }
        }

        // remainder
<span class="nc bnc" id="L1597" title="All 2 branches missed.">        if (localRealLength &gt; 0) {</span>
<span class="nc" id="L1598">            window.realLength = localRealLength;</span>
<span class="nc" id="L1599">            block.yield(context, window);</span>
        }
<span class="nc" id="L1601">        return runtime.getNil();</span>
    }

    @JRubyMethod
    public IRubyObject each_slice(ThreadContext context, IRubyObject arg, Block block) {
<span class="nc" id="L1606">        final int size = RubyNumeric.num2int(arg);</span>
<span class="nc" id="L1607">        final Ruby runtime = context.runtime;</span>
<span class="nc bnc" id="L1608" title="All 2 branches missed.">        if (size &lt;= 0) throw runtime.newArgumentError(&quot;invalid slice size&quot;);</span>
<span class="nc bnc" id="L1609" title="All 2 branches missed.">        return block.isGiven() ? eachSlice(context, size, block) : enumeratorize(context.runtime, this, &quot;each_slice&quot;, arg);</span>
    }

    /** rb_ary_each_index
     *
     */
    public IRubyObject eachIndex(ThreadContext context, Block block) {
<span class="fc" id="L1616">        Ruby runtime = context.runtime;</span>
<span class="pc bpc" id="L1617" title="1 of 2 branches missed.">        if (!block.isGiven()) {</span>
<span class="nc" id="L1618">            throw runtime.newLocalJumpErrorNoBlock();</span>
        }
<span class="fc bfc" id="L1620" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc" id="L1621">            block.yield(context, runtime.newFixnum(i));</span>
        }
<span class="fc" id="L1623">        return this;</span>
    }
    
    @JRubyMethod
    public IRubyObject each_index(ThreadContext context, Block block) {
<span class="fc bfc" id="L1628" title="All 2 branches covered.">        return block.isGiven() ? eachIndex(context, block) : enumeratorize(context.runtime, this, &quot;each_index&quot;);</span>
    }

    /** rb_ary_reverse_each
     *
     */
    public IRubyObject reverseEach(ThreadContext context, Block block) {
<span class="fc" id="L1635">        int len = realLength;</span>

<span class="fc bfc" id="L1637" title="All 2 branches covered.">        while(len-- &gt; 0) {</span>
            // do not coarsen the &quot;safe&quot; catch, since it will misinterpret AIOOBE from the yielded code.
            // See JRUBY-5434
<span class="fc" id="L1640">            block.yield(context, safeArrayRef(values, begin + len));</span>
<span class="pc bpc" id="L1641" title="1 of 2 branches missed.">            if (realLength &lt; len) len = realLength;</span>
        }

<span class="fc" id="L1644">        return this;</span>
    }

    @JRubyMethod
    public IRubyObject reverse_each(ThreadContext context, Block block) {
<span class="fc bfc" id="L1649" title="All 2 branches covered.">        return block.isGiven() ? reverseEach(context, block) : enumeratorizeWithSize(context, this, &quot;reverse_each&quot;, enumLengthFn());</span>
    }

    private IRubyObject inspectJoin(ThreadContext context, RubyArray tmp, IRubyObject sep) {
<span class="nc" id="L1653">        Ruby runtime = context.runtime;</span>

        // If already inspecting, there is no need to register/unregister again.
<span class="nc bnc" id="L1656" title="All 2 branches missed.">        if (runtime.isInspecting(this)) {</span>
<span class="nc" id="L1657">            return tmp.join(context, sep);</span>
        }

        try {
<span class="nc" id="L1661">            runtime.registerInspecting(this);</span>
<span class="nc" id="L1662">            return tmp.join(context, sep);</span>
        } finally {
<span class="nc" id="L1664">            runtime.unregisterInspecting(this);</span>
        }
    }

    /** rb_ary_join
     *
     */
    public IRubyObject join(ThreadContext context, IRubyObject sep) {
<span class="nc" id="L1672">        return join19(context, sep);</span>
    }

    public IRubyObject join(ThreadContext context) {
<span class="nc" id="L1676">        return join19(context);</span>
    }

    // 1.9 MRI: ary_join_0
    private RubyString joinStrings(RubyString sep, int max, RubyString result) {
<span class="fc" id="L1681">        IRubyObject first = values[begin];</span>
<span class="pc bpc" id="L1682" title="1 of 4 branches missed.">        if (max - begin &gt; 0 &amp;&amp; first instanceof EncodingCapable) {</span>
<span class="fc" id="L1683">            result.setEncoding(((EncodingCapable)first).getEncoding());</span>
        }

        try {
<span class="fc bfc" id="L1687" title="All 2 branches covered.">            for(int i = begin; i &lt; max; i++) {</span>
<span class="fc bfc" id="L1688" title="All 4 branches covered.">                if (i &gt; begin &amp;&amp; sep != null) result.append19(sep);</span>
<span class="fc" id="L1689">                result.append19(values[i]);</span>
            }
<span class="nc" id="L1691">        } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L1692">            concurrentModification();</span>
<span class="fc" id="L1693">        }</span>
        
<span class="fc" id="L1695">        return result;</span>
    }

    // 1.9 MRI: ary_join_1
    private RubyString joinAny(ThreadContext context, IRubyObject obj, RubyString sep, 
            int i, RubyString result) {
<span class="pc bpc" id="L1701" title="3 of 4 branches missed.">        assert i &gt;= begin : &quot;joining elements before beginning of array&quot;;</span>
        
<span class="fc" id="L1703">        RubyClass arrayClass = context.runtime.getArray();</span>

<span class="fc bfc" id="L1705" title="All 2 branches covered.">        for (; i &lt; begin + realLength; i++) {</span>
<span class="fc bfc" id="L1706" title="All 4 branches covered.">            if (i &gt; begin &amp;&amp; sep != null) result.append19(sep);</span>

<span class="fc" id="L1708">            IRubyObject val = safeArrayRef(values, i);</span>

<span class="fc bfc" id="L1710" title="All 2 branches covered.">            if (val instanceof RubyString) {</span>
<span class="fc" id="L1711">                result.append19(val);</span>
<span class="fc bfc" id="L1712" title="All 2 branches covered.">            } else if (val instanceof RubyArray) {</span>
<span class="fc" id="L1713">                obj = val;</span>
<span class="fc" id="L1714">                recursiveJoin(context, obj, sep, result, val);</span>
            } else {
<span class="fc" id="L1716">                IRubyObject tmp = val.checkStringType19();</span>
<span class="fc bfc" id="L1717" title="All 2 branches covered.">                if (!tmp.isNil()) {</span>
<span class="fc" id="L1718">                    result.append19(tmp);</span>
<span class="fc" id="L1719">                    continue;</span>
                }
                
<span class="fc" id="L1722">                tmp = TypeConverter.convertToTypeWithCheck(val, arrayClass, &quot;to_ary&quot;);</span>
<span class="fc bfc" id="L1723" title="All 2 branches covered.">                if (!tmp.isNil()) {</span>
<span class="fc" id="L1724">                    obj = val;</span>
<span class="fc" id="L1725">                    recursiveJoin(context, obj, sep, result, tmp);</span>
                } else {
<span class="fc" id="L1727">                    result.append19(RubyString.objAsString(context, val));</span>
                }
            }
        }
        
<span class="fc" id="L1732">        return result;</span>
    }

    private void recursiveJoin(final ThreadContext context, final IRubyObject outValue,
            final RubyString sep, final RubyString result, final IRubyObject ary) {
<span class="fc" id="L1737">        final Ruby runtime = context.runtime;</span>
        
<span class="fc bfc" id="L1739" title="All 2 branches covered.">        if (ary == this) throw runtime.newArgumentError(&quot;recursive array join&quot;);</span>
            
<span class="fc" id="L1741">        runtime.execRecursive(new Ruby.RecursiveFunction() {</span>
            public IRubyObject call(IRubyObject obj, boolean recur) {
<span class="pc bpc" id="L1743" title="1 of 2 branches missed.">                if (recur) throw runtime.newArgumentError(&quot;recursive array join&quot;);</span>
                            
<span class="fc" id="L1745">                RubyArray recAry = ((RubyArray) ary);</span>
<span class="fc" id="L1746">                recAry.joinAny(context, outValue, sep, recAry.begin, result);</span>
                
<span class="fc" id="L1748">                return runtime.getNil();</span>
            }}, outValue);
<span class="fc" id="L1750">    }</span>

    /** rb_ary_join
     *
     */
    @JRubyMethod(name = &quot;join&quot;)
    public IRubyObject join19(final ThreadContext context, IRubyObject sep) {
<span class="fc" id="L1757">        final Ruby runtime = context.runtime;</span>

<span class="fc bfc" id="L1759" title="All 2 branches covered.">        if (realLength == 0) return RubyString.newEmptyString(runtime, USASCIIEncoding.INSTANCE);</span>

<span class="fc bfc" id="L1761" title="All 2 branches covered.">        if (sep.isNil()) sep = runtime.getGlobalVariables().get(&quot;$,&quot;);</span>

<span class="fc" id="L1763">        int len = 1;</span>
<span class="fc" id="L1764">        RubyString sepString = null;</span>
<span class="fc bfc" id="L1765" title="All 2 branches covered.">        if (!sep.isNil()) {</span>
<span class="fc" id="L1766">            sepString = sep.convertToString();</span>
<span class="fc" id="L1767">            len += sepString.size() * (realLength - 1);</span>
        }
        
<span class="fc bfc" id="L1770" title="All 2 branches covered.">        for (int i = begin; i &lt; begin + realLength; i++) {</span>
<span class="fc" id="L1771">            IRubyObject val = safeArrayRef(values, i);</span>
<span class="fc" id="L1772">            IRubyObject tmp = val.checkStringType19();</span>
<span class="fc bfc" id="L1773" title="All 4 branches covered.">            if (tmp.isNil() || tmp != val) {</span>
<span class="fc" id="L1774">                len += ((begin + realLength) - i) * 10;</span>
<span class="fc" id="L1775">                final RubyString result = (RubyString) RubyString.newStringLight(runtime, len, USASCIIEncoding.INSTANCE).infectBy(this);</span>
<span class="fc" id="L1776">                final RubyString sepStringFinal = sepString;</span>
<span class="fc" id="L1777">                final int iFinal = i;</span>

<span class="fc" id="L1779">                return runtime.recursiveListOperation(new Callable&lt;IRubyObject&gt;() {</span>
                    public IRubyObject call() {
<span class="fc" id="L1781">                        return joinAny(context, RubyArray.this, sepStringFinal, iFinal, joinStrings(sepStringFinal, iFinal, result));</span>
                    }
                });
            }

<span class="fc" id="L1786">            len += ((RubyString) tmp).getByteList().length();</span>
        }

<span class="fc" id="L1789">        return joinStrings(sepString, begin + realLength, </span>
<span class="fc" id="L1790">                (RubyString) RubyString.newStringLight(runtime, len).infectBy(this));</span>
    }

    @JRubyMethod(name = &quot;join&quot;)
    public IRubyObject join19(ThreadContext context) {
<span class="fc" id="L1795">        return join19(context, context.runtime.getGlobalVariables().get(&quot;$,&quot;));</span>
    }


    /** rb_ary_to_a
     *
     */
    @JRubyMethod(name = &quot;to_a&quot;)
    @Override
    public RubyArray to_a() {
<span class="fc bfc" id="L1805" title="All 2 branches covered.">        if(getMetaClass() != getRuntime().getArray()) {</span>
<span class="fc" id="L1806">            RubyArray dup = new RubyArray(getRuntime(), getRuntime().isObjectSpaceEnabled());</span>

<span class="fc" id="L1808">            isShared = true;</span>
<span class="fc" id="L1809">            dup.isShared = true;</span>
<span class="fc" id="L1810">            dup.values = values;</span>
<span class="fc" id="L1811">            dup.realLength = realLength; </span>
<span class="fc" id="L1812">            dup.begin = begin;</span>
            
<span class="fc" id="L1814">            return dup;</span>
        }        
<span class="fc" id="L1816">        return this;</span>
    }

    @JRubyMethod(name = &quot;to_ary&quot;)
    public IRubyObject to_ary() {
<span class="fc" id="L1821">    	return this;</span>
    }

    @Override
    public RubyArray convertToArray() {
<span class="fc" id="L1826">        return this;</span>
    }
    
    @Override
    public IRubyObject checkArrayType(){
<span class="fc" id="L1831">        return this;</span>
    }

    /** rb_ary_equal
     *
     */
    @JRubyMethod(name = &quot;==&quot;, required = 1)
    @Override
    public IRubyObject op_equal(ThreadContext context, IRubyObject obj) {
<span class="fc" id="L1840">        Ruby runtime = context.runtime;</span>

<span class="fc bfc" id="L1842" title="All 2 branches covered.">        if (this == obj) {</span>
<span class="fc" id="L1843">            return runtime.getTrue();</span>
        }

<span class="fc bfc" id="L1846" title="All 2 branches covered.">        if (!(obj instanceof RubyArray)) {</span>
<span class="fc bfc" id="L1847" title="All 2 branches covered.">            if (obj == context.nil) return runtime.getFalse();</span>

<span class="fc bfc" id="L1849" title="All 2 branches covered.">            if (!obj.respondsTo(&quot;to_ary&quot;)) {</span>
<span class="fc" id="L1850">                return runtime.getFalse();</span>
            }
<span class="fc" id="L1852">            return Helpers.rbEqual(context, obj, this);</span>
        }
<span class="fc" id="L1854">        return RecursiveComparator.compare(context, MethodNames.OP_EQUAL, this, obj);</span>
    }

    public RubyBoolean compare(ThreadContext context, MethodNames method, IRubyObject other) {
<span class="pc bpc" id="L1858" title="1 of 2 branches missed.">        if (!(other instanceof RubyArray)) {</span>
<span class="nc bnc" id="L1859" title="All 2 branches missed.">            if (!other.respondsTo(&quot;to_ary&quot;)) return context.runtime.getFalse();</span>

<span class="nc" id="L1861">            return Helpers.rbEqual(context, other, this);</span>
        }

<span class="fc" id="L1864">        RubyArray ary = (RubyArray) other;</span>

<span class="fc bfc" id="L1866" title="All 2 branches covered.">        if (realLength != ary.realLength) return context.runtime.getFalse();</span>

<span class="fc bfc" id="L1868" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc" id="L1869">            IRubyObject a = elt(i);</span>
<span class="fc" id="L1870">            IRubyObject b = ary.elt(i);</span>
            
<span class="fc bfc" id="L1872" title="All 2 branches covered.">            if (a == b) continue; // matching MRI opt. mock frameworks can throw errors if we don't</span>
            
<span class="fc bfc" id="L1874" title="All 2 branches covered.">            if (!invokedynamic(context, a, method, b).isTrue()) return context.runtime.getFalse();</span>
        }

<span class="fc" id="L1877">        return context.runtime.getTrue();</span>
    }

    /** rb_ary_eql
     *
     */
    @JRubyMethod(name = &quot;eql?&quot;, required = 1)
    public IRubyObject eql(ThreadContext context, IRubyObject obj) {
<span class="fc bfc" id="L1885" title="All 2 branches covered.">        if(!(obj instanceof RubyArray)) {</span>
<span class="fc" id="L1886">            return context.runtime.getFalse();</span>
        }
<span class="fc" id="L1888">        return RecursiveComparator.compare(context, MethodNames.EQL, this, obj);</span>
    }

    /** rb_ary_compact_bang
     *
     */
    @JRubyMethod(name = &quot;compact!&quot;)
    public IRubyObject compact_bang() {
<span class="fc" id="L1896">        modify();</span>

<span class="fc" id="L1898">        int p = begin;</span>
<span class="fc" id="L1899">        int t = p;</span>
<span class="fc" id="L1900">        int end = p + realLength;</span>

        try {
<span class="fc bfc" id="L1903" title="All 2 branches covered.">            while (t &lt; end) {</span>
<span class="fc bfc" id="L1904" title="All 2 branches covered.">                if (values[t].isNil()) {</span>
<span class="fc" id="L1905">                    t++;</span>
                } else {
<span class="fc" id="L1907">                    values[p++] = values[t++];</span>
                }
            }
<span class="nc" id="L1910">        } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L1911">            concurrentModification();</span>
<span class="fc" id="L1912">        }</span>

<span class="fc" id="L1914">        p -= begin;</span>
<span class="fc bfc" id="L1915" title="All 2 branches covered.">        if (realLength == p) return getRuntime().getNil();</span>

<span class="fc" id="L1917">        realloc(p, values.length - begin);</span>
<span class="fc" id="L1918">        realLength = p;</span>
<span class="fc" id="L1919">        return this;</span>
    }

    /** rb_ary_compact
     *
     */
    public IRubyObject compact() {
<span class="nc" id="L1926">        return compact19();</span>
    }
    
    @JRubyMethod(name = &quot;compact&quot;)
    public IRubyObject compact19() {
<span class="fc" id="L1931">        RubyArray ary = aryDup();</span>
<span class="fc" id="L1932">        ary.compact_bang();</span>
<span class="fc" id="L1933">        return ary;</span>
    }

    /** rb_ary_empty_p
     *
     */
    @JRubyMethod(name = &quot;empty?&quot;)
    public IRubyObject empty_p() {
<span class="fc bfc" id="L1941" title="All 2 branches covered.">        return realLength == 0 ? getRuntime().getTrue() : getRuntime().getFalse();</span>
    }

    /** rb_ary_clear
     *
     */
    @JRubyMethod(name = &quot;clear&quot;)
    public IRubyObject rb_clear() {
<span class="fc" id="L1949">        modifyCheck();</span>

<span class="fc bfc" id="L1951" title="All 2 branches covered.">        if (isShared) {</span>
<span class="fc" id="L1952">            alloc(ARRAY_DEFAULT_SIZE);</span>
<span class="fc" id="L1953">            isShared = false;</span>
<span class="pc bpc" id="L1954" title="1 of 2 branches missed.">        } else if (values.length &gt; ARRAY_DEFAULT_SIZE &lt;&lt; 1) {</span>
<span class="nc" id="L1955">            alloc(ARRAY_DEFAULT_SIZE &lt;&lt; 1);</span>
        } else {
            try {
<span class="fc" id="L1958">                begin = 0;</span>
<span class="fc" id="L1959">                Helpers.fillNil(values, 0, realLength, getRuntime());</span>
<span class="nc" id="L1960">            } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L1961">                concurrentModification();</span>
<span class="fc" id="L1962">            }</span>
        }

<span class="fc" id="L1965">        realLength = 0;</span>
<span class="fc" id="L1966">        return this;</span>
    }

    @JRubyMethod
    public IRubyObject fill(ThreadContext context, Block block) {
<span class="fc bfc" id="L1971" title="All 2 branches covered.">        if (block.isGiven()) return fillCommon(context, 0, realLength, block);</span>
<span class="fc" id="L1972">        throw context.runtime.newArgumentError(0, 1);</span>
    }

    @JRubyMethod
    public IRubyObject fill(ThreadContext context, IRubyObject arg, Block block) {
<span class="fc bfc" id="L1977" title="All 2 branches covered.">        if (block.isGiven()) {</span>
<span class="fc bfc" id="L1978" title="All 2 branches covered.">            if (arg instanceof RubyRange) {</span>
<span class="fc" id="L1979">                int[] beglen = ((RubyRange) arg).begLenInt(realLength, 1);</span>
<span class="fc" id="L1980">                return fillCommon(context, beglen[0], beglen[1], block);</span>
            }
            int beg;
<span class="fc" id="L1983">            return fillCommon(context, beg = fillBegin(arg), fillLen(beg, null),  block);</span>
        } else {
<span class="fc" id="L1985">            return fillCommon(context, 0, realLength, arg);</span>
        }
    }

    @JRubyMethod
    public IRubyObject fill(ThreadContext context, IRubyObject arg1, IRubyObject arg2, Block block) {
<span class="fc bfc" id="L1991" title="All 2 branches covered.">        if (block.isGiven()) {</span>
            int beg;
<span class="fc" id="L1993">            return fillCommon(context, beg = fillBegin(arg1), fillLen(beg, arg2), block);</span>
        } else {
<span class="fc bfc" id="L1995" title="All 2 branches covered.">            if (arg2 instanceof RubyRange) {</span>
<span class="fc" id="L1996">                int[] beglen = ((RubyRange) arg2).begLenInt(realLength, 1);</span>
<span class="fc" id="L1997">                return fillCommon(context, beglen[0], beglen[1], arg1);</span>
            }
            int beg;
<span class="fc" id="L2000">            return fillCommon(context, beg = fillBegin(arg2), fillLen(beg, null), arg1);</span>
        }
    }

    @JRubyMethod
    public IRubyObject fill(ThreadContext context, IRubyObject arg1, IRubyObject arg2, IRubyObject arg3, Block block) {
<span class="fc bfc" id="L2006" title="All 2 branches covered.">        if (block.isGiven()) {</span>
<span class="fc" id="L2007">            throw context.runtime.newArgumentError(3, 2);</span>
        } else {
            int beg;
<span class="fc" id="L2010">            return fillCommon(context, beg = fillBegin(arg2), fillLen(beg, arg3), arg1);</span>
        }
    }

    private int fillBegin(IRubyObject arg) {
<span class="fc bfc" id="L2015" title="All 2 branches covered.">        int beg = arg.isNil() ? 0 : RubyNumeric.num2int(arg);</span>
<span class="fc bfc" id="L2016" title="All 2 branches covered.">        if (beg &lt; 0) {</span>
<span class="fc" id="L2017">            beg = realLength + beg;</span>
<span class="fc bfc" id="L2018" title="All 2 branches covered.">            if (beg &lt; 0) beg = 0;</span>
        }
<span class="fc" id="L2020">        return beg;</span>
    }

    private long fillLen(long beg, IRubyObject arg) {
<span class="fc bfc" id="L2024" title="All 4 branches covered.">        if (arg == null || arg.isNil()) {</span>
<span class="fc" id="L2025">            return realLength - beg;</span>
        } else {
<span class="fc" id="L2027">            return RubyNumeric.num2long(arg);</span>
        }
        // TODO: In MRI 1.9, an explicit check for negative length is
        // added here. IndexError is raised when length is negative.
        // See [ruby-core:12953] for more details.
        //
        // New note: This is actually under re-evaluation,
        // see [ruby-core:17483].
    }

    private IRubyObject fillCommon(ThreadContext context, int beg, long len, IRubyObject item) {
<span class="fc" id="L2038">        modify();</span>

        // See [ruby-core:17483]
<span class="fc bfc" id="L2041" title="All 2 branches covered.">        if (len &lt; 0) return this;</span>

<span class="fc bfc" id="L2043" title="All 2 branches covered.">        if (len &gt; Integer.MAX_VALUE - beg) throw context.runtime.newArgumentError(&quot;argument too big&quot;);</span>

<span class="fc" id="L2045">        int end = (int)(beg + len);</span>
<span class="fc bfc" id="L2046" title="All 2 branches covered.">        if (end &gt; realLength) {</span>
<span class="fc" id="L2047">            int valuesLength = values.length - begin;</span>
<span class="pc bpc" id="L2048" title="1 of 2 branches missed.">            if (end &gt;= valuesLength) realloc(end, valuesLength);</span>
<span class="fc" id="L2049">            realLength = end;</span>
        }

<span class="fc bfc" id="L2052" title="All 2 branches covered.">        if (len &gt; 0) {</span>
            try {
<span class="fc" id="L2054">                fill(values, begin + beg, begin + end, item);</span>
<span class="nc" id="L2055">            } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L2056">                concurrentModification();</span>
<span class="fc" id="L2057">            }</span>
        }

<span class="fc" id="L2060">        return this;</span>
    }

    private IRubyObject fillCommon(ThreadContext context, int beg, long len, Block block) {
<span class="fc" id="L2064">        modify();</span>

        // See [ruby-core:17483]
<span class="fc bfc" id="L2067" title="All 2 branches covered.">        if (len &lt; 0) return this;</span>

<span class="pc bpc" id="L2069" title="1 of 2 branches missed.">        if (len &gt; Integer.MAX_VALUE - beg) throw getRuntime().newArgumentError(&quot;argument too big&quot;);</span>

<span class="fc" id="L2071">        int end = (int)(beg + len);</span>
<span class="fc bfc" id="L2072" title="All 2 branches covered.">        if (end &gt; realLength) {</span>
<span class="fc" id="L2073">            int valuesLength = values.length - begin;</span>
<span class="pc bpc" id="L2074" title="1 of 2 branches missed.">            if (end &gt;= valuesLength) realloc(end, valuesLength);</span>
<span class="fc" id="L2075">            realLength = end;</span>
        }

<span class="fc" id="L2078">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L2079" title="All 2 branches covered.">        for (int i = beg; i &lt; end; i++) {</span>
<span class="fc" id="L2080">            IRubyObject v = block.yield(context, runtime.newFixnum(i));</span>
<span class="pc bpc" id="L2081" title="1 of 2 branches missed.">            if (i &gt;= realLength) break;</span>
<span class="fc" id="L2082">            safeArraySet(values, begin + i, v);</span>
        }
<span class="fc" id="L2084">        return this;</span>
    }


    /** rb_ary_index
     *
     */
    public IRubyObject index(ThreadContext context, IRubyObject obj) {
<span class="fc" id="L2092">        Ruby runtime = context.runtime;</span>

<span class="fc bfc" id="L2094" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc bfc" id="L2095" title="All 2 branches covered.">            if (equalInternal(context, eltOk(i), obj)) return runtime.newFixnum(i);</span>
        }

<span class="fc" id="L2098">        return runtime.getNil();</span>
    }

    @JRubyMethod(name = {&quot;index&quot;, &quot;find_index&quot;})
    public IRubyObject index(ThreadContext context, IRubyObject obj, Block unused) {
<span class="fc bfc" id="L2103" title="All 2 branches covered.">        if (unused.isGiven()) context.runtime.getWarnings().warn(ID.BLOCK_UNUSED, &quot;given block not used&quot;);</span>
<span class="fc" id="L2104">        return index(context, obj); </span>
    }

    @JRubyMethod(name = {&quot;index&quot;, &quot;find_index&quot;})
    public IRubyObject index(ThreadContext context, Block block) {
<span class="fc" id="L2109">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L2110" title="All 2 branches covered.">        if (!block.isGiven()) return enumeratorize(runtime, this, &quot;index&quot;);</span>

<span class="pc bpc" id="L2112" title="1 of 2 branches missed.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc bfc" id="L2113" title="All 2 branches covered.">            if (block.yield(context, eltOk(i)).isTrue()) return runtime.newFixnum(i);</span>
        }

<span class="nc" id="L2116">        return runtime.getNil();</span>
    }
    
    @JRubyMethod
    public IRubyObject bsearch(ThreadContext context, Block block) {
<span class="fc" id="L2121">        Ruby runtime = context.runtime;</span>
        
<span class="fc bfc" id="L2123" title="All 2 branches covered.">        if (!block.isGiven()) {</span>
<span class="fc" id="L2124">            return enumeratorize(context.runtime, this, &quot;bsearch&quot;);</span>
        }
        
<span class="fc" id="L2127">        int low = 0, high = realLength, mid;</span>
<span class="fc" id="L2128">        boolean smaller = false, satisfied = false;</span>
        IRubyObject v, val;
        
<span class="fc bfc" id="L2131" title="All 2 branches covered.">        while (low &lt; high) {</span>
<span class="fc" id="L2132">            mid = low + ((high - low) / 2);</span>
<span class="fc" id="L2133">            val = eltOk(mid);</span>
<span class="fc" id="L2134">            v = block.yieldSpecific(context, val);</span>
            
<span class="fc bfc" id="L2136" title="All 2 branches covered.">            if (v instanceof RubyFixnum) {</span>
<span class="fc" id="L2137">                long fixValue = ((RubyFixnum)v).getLongValue();</span>
<span class="fc bfc" id="L2138" title="All 2 branches covered.">                if (fixValue == 0) return val;</span>
<span class="fc bfc" id="L2139" title="All 2 branches covered.">                smaller = fixValue &lt; 0;</span>
<span class="fc bfc" id="L2140" title="All 2 branches covered.">            } else if (v == runtime.getTrue()) {</span>
<span class="fc" id="L2141">                satisfied = true;</span>
<span class="fc" id="L2142">                smaller = true;</span>
<span class="fc bfc" id="L2143" title="All 4 branches covered.">            } else if (v == runtime.getFalse() || v == runtime.getNil()) {</span>
<span class="fc" id="L2144">                smaller = false;</span>
<span class="fc bfc" id="L2145" title="All 2 branches covered.">            } else if (runtime.getNumeric().isInstance(v)) {</span>
<span class="pc bpc" id="L2146" title="1 of 4 branches missed.">                switch (RubyComparable.cmpint(context, invokedynamic(context, v, OP_CMP, RubyFixnum.zero(runtime)), v, RubyFixnum.zero(runtime))) {</span>
<span class="fc" id="L2147">                    case 0: return val;</span>
<span class="fc" id="L2148">                    case 1: smaller = true; break;</span>
<span class="fc" id="L2149">                    case -1: smaller = false;</span>
                }
            } else {
<span class="fc" id="L2152">                throw runtime.newTypeError(&quot;wrong argument type &quot; + v.getType().getName() + &quot; (must be numeric, true, false or nil&quot;);</span>
            }
<span class="fc bfc" id="L2154" title="All 2 branches covered.">            if (smaller) {</span>
<span class="fc" id="L2155">                high = mid;</span>
            } else {
<span class="fc" id="L2157">                low = mid + 1;</span>
            }
        }
<span class="fc bfc" id="L2160" title="All 2 branches covered.">        if (low == realLength) return context.nil;</span>
<span class="fc bfc" id="L2161" title="All 2 branches covered.">        if (!satisfied) return context.nil;</span>
<span class="fc" id="L2162">        return eltOk(low);</span>
    }

    /** rb_ary_rindex
     *
     */
    public IRubyObject rindex(ThreadContext context, IRubyObject obj) {
<span class="fc" id="L2169">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L2170">        int i = realLength;</span>

<span class="fc bfc" id="L2172" title="All 2 branches covered.">        while (i-- &gt; 0) {</span>
<span class="pc bpc" id="L2173" title="1 of 2 branches missed.">            if (i &gt; realLength) {</span>
<span class="nc" id="L2174">                i = realLength;</span>
<span class="nc" id="L2175">                continue;</span>
            }
<span class="fc bfc" id="L2177" title="All 2 branches covered.">            if (equalInternal(context, eltOk(i), obj)) return runtime.newFixnum(i);</span>
        }

<span class="fc" id="L2180">        return runtime.getNil();</span>
    }

    @JRubyMethod
    public IRubyObject rindex(ThreadContext context, IRubyObject obj, Block unused) {
<span class="fc bfc" id="L2185" title="All 2 branches covered.">        if (unused.isGiven()) context.runtime.getWarnings().warn(ID.BLOCK_UNUSED, &quot;given block not used&quot;);</span>
<span class="fc" id="L2186">        return rindex(context, obj); </span>
    }

    @JRubyMethod
    public IRubyObject rindex(ThreadContext context, Block block) {
<span class="fc" id="L2191">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L2192" title="All 2 branches covered.">        if (!block.isGiven()) return enumeratorize(runtime, this, &quot;rindex&quot;);</span>

<span class="fc" id="L2194">        int i = realLength;</span>

<span class="fc bfc" id="L2196" title="All 2 branches covered.">        while (i-- &gt; 0) {</span>
<span class="fc bfc" id="L2197" title="All 2 branches covered.">            if (i &gt;= realLength) {</span>
<span class="fc" id="L2198">                i = realLength;</span>
<span class="fc" id="L2199">                continue;</span>
            }
<span class="fc bfc" id="L2201" title="All 2 branches covered.">            if (block.yield(context, eltOk(i)).isTrue()) return runtime.newFixnum(i);</span>
        }

<span class="fc" id="L2204">        return runtime.getNil();</span>
    }

    /** rb_ary_indexes
     * 
     */
    @JRubyMethod(name = {&quot;indexes&quot;, &quot;indices&quot;}, required = 1, rest = true)
    public IRubyObject indexes(IRubyObject[] args) {
<span class="nc" id="L2212">        getRuntime().getWarnings().warn(ID.DEPRECATED_METHOD, &quot;Array#indexes is deprecated; use Array#values_at&quot;);</span>

<span class="nc" id="L2214">        RubyArray ary = new RubyArray(getRuntime(), args.length);</span>

<span class="nc bnc" id="L2216" title="All 2 branches missed.">        for (int i = 0; i &lt; args.length; i++) {</span>
<span class="nc" id="L2217">            ary.append(aref(args[i]));</span>
        }

<span class="nc" id="L2220">        return ary;</span>
    }

    /** rb_ary_reverse_bang
     *
     */
    @JRubyMethod(name = &quot;reverse!&quot;)
    public IRubyObject reverse_bang() {
<span class="fc" id="L2228">        modify();</span>

        try {
<span class="fc bfc" id="L2231" title="All 2 branches covered.">            if (realLength &gt; 1) {</span>
<span class="fc" id="L2232">                IRubyObject[] vals = values;</span>
<span class="fc" id="L2233">                int p = begin;</span>
<span class="fc" id="L2234">                int len = realLength;</span>
<span class="fc bfc" id="L2235" title="All 2 branches covered.">                for (int i = 0; i &lt; len &gt;&gt; 1; i++) {</span>
<span class="fc" id="L2236">                    IRubyObject tmp = vals[p + i];</span>
<span class="fc" id="L2237">                    vals[p + i] = vals[p + len - i - 1];</span>
<span class="fc" id="L2238">                    vals[p + len - i - 1] = tmp;</span>
                }
            }
<span class="nc" id="L2241">        } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L2242">            concurrentModification();</span>
<span class="fc" id="L2243">        }</span>
<span class="fc" id="L2244">        return this;</span>
    }

    /** rb_ary_reverse_m
     *
     */
    @JRubyMethod(name = &quot;reverse&quot;)
    public IRubyObject reverse() {
<span class="fc bfc" id="L2252" title="All 2 branches covered.">        if (realLength &gt; 1) {</span>
<span class="fc" id="L2253">            RubyArray dup = safeReverse();</span>
<span class="fc" id="L2254">            dup.flags |= flags &amp; TAINTED_F; // from DUP_SETUP</span>
            // rb_copy_generic_ivar from DUP_SETUP here ...unlikely..
<span class="fc" id="L2256">            return dup;</span>
        } else {
<span class="fc" id="L2258">            return dup();</span>
        }
    }

    private RubyArray safeReverse() {
<span class="fc" id="L2263">        int length = realLength;</span>
<span class="fc" id="L2264">        int myBegin = this.begin;</span>
<span class="fc" id="L2265">        IRubyObject[] myValues = this.values;</span>
<span class="fc" id="L2266">        IRubyObject[] vals = new IRubyObject[length];</span>

        try {
<span class="fc bfc" id="L2269" title="All 2 branches covered.">            for (int i = 0; i &lt;= length &gt;&gt; 1; i++) {</span>
<span class="fc" id="L2270">                vals[i] = myValues[myBegin + length - i - 1];</span>
<span class="fc" id="L2271">                vals[length - i - 1] = myValues[myBegin + i];</span>
            }
<span class="nc" id="L2273">        } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L2274">            concurrentModification();</span>
<span class="fc" id="L2275">        }</span>
<span class="fc" id="L2276">        return new RubyArray(getRuntime(), getMetaClass(), vals);</span>
    }

    /** rb_ary_collect
     *
     */
    public IRubyObject collect(ThreadContext context, Block block) {
<span class="fc" id="L2283">        Ruby runtime = context.runtime;</span>
<span class="pc bpc" id="L2284" title="1 of 2 branches missed.">        if (!block.isGiven()) return new RubyArray(runtime, runtime.getArray(), this);</span>

<span class="fc" id="L2286">        IRubyObject[] arr = new IRubyObject[realLength];</span>

<span class="fc bfc" id="L2288" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
            // Do not coarsen the &quot;safe&quot; check, since it will misinterpret AIOOBE from the yield
            // See JRUBY-5434
<span class="fc" id="L2291">            arr[i] = block.yield(context, safeArrayRef(values, i + begin));</span>
        }

<span class="fc" id="L2294">        return new RubyArray(runtime, arr);</span>
    }

    @JRubyMethod(name = {&quot;collect&quot;})
    public IRubyObject collect19(ThreadContext context, Block block) {
<span class="fc bfc" id="L2299" title="All 2 branches covered.">        return block.isGiven() ? collect(context, block) : enumeratorizeWithSize(context, this, &quot;collect&quot;, enumLengthFn());</span>
    }

    @JRubyMethod(name = {&quot;map&quot;})
    public IRubyObject map19(ThreadContext context, Block block) {
<span class="fc bfc" id="L2304" title="All 2 branches covered.">        return block.isGiven() ? collect(context, block) : enumeratorizeWithSize(context, this, &quot;map&quot;, enumLengthFn());</span>
    }

    /** rb_ary_collect_bang
     *
     */
    public RubyArray collectBang(ThreadContext context, Block block) {
<span class="pc bpc" id="L2311" title="1 of 2 branches missed.">        if (!block.isGiven()) throw context.runtime.newLocalJumpErrorNoBlock();</span>
<span class="fc" id="L2312">        modify();</span>

<span class="fc bfc" id="L2314" title="All 2 branches covered.">        for (int i = 0, len = realLength; i &lt; len; i++) {</span>
            // Do not coarsen the &quot;safe&quot; check, since it will misinterpret AIOOBE from the yield
            // See JRUBY-5434
<span class="fc" id="L2317">            store(i, block.yield(context, safeArrayRef(values, begin + i)));</span>
        }
        
<span class="fc" id="L2320">        return this;</span>
    }

    /** rb_ary_collect_bang
    *
    */
    @JRubyMethod(name = &quot;collect!&quot;)
    public IRubyObject collect_bang(ThreadContext context, Block block) {
<span class="fc bfc" id="L2328" title="All 2 branches covered.">        return block.isGiven() ? collectBang(context, block) : enumeratorize(context.runtime, this, &quot;collect!&quot;);</span>
    }

    /** rb_ary_collect_bang
    *
    */
    @JRubyMethod(name = &quot;map!&quot;)
    public IRubyObject map_bang(ThreadContext context, Block block) {
<span class="fc bfc" id="L2336" title="All 2 branches covered.">        return block.isGiven() ? collectBang(context, block) : enumeratorizeWithSize(context, this, &quot;map!&quot;, enumLengthFn());</span>
    }

    /** rb_ary_select
     *
     */
    public IRubyObject selectCommon(ThreadContext context, Block block) {
<span class="fc" id="L2343">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L2344">        RubyArray result = new RubyArray(runtime, realLength);</span>

<span class="fc bfc" id="L2346" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
            // Do not coarsen the &quot;safe&quot; check, since it will misinterpret AIOOBE from the yield
            // See JRUBY-5434
<span class="fc" id="L2349">            IRubyObject value = safeArrayRef(values, begin + i);</span>

<span class="fc bfc" id="L2351" title="All 2 branches covered.">            if (block.yield(context, value).isTrue()) result.append(value);</span>
        }

<span class="fc" id="L2354">        Helpers.fillNil(result.values, result.realLength, result.values.length, runtime);</span>
<span class="fc" id="L2355">        return result;</span>
    }

    @JRubyMethod
    public IRubyObject select(ThreadContext context, Block block) {
<span class="fc bfc" id="L2360" title="All 2 branches covered.">        return block.isGiven() ? selectCommon(context, block) : enumeratorizeWithSize(context, this, &quot;select&quot;, enumLengthFn());</span>
    }

    @JRubyMethod(name = &quot;select!&quot;)
    public IRubyObject select_bang(ThreadContext context, Block block) {
<span class="fc" id="L2365">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L2366" title="All 2 branches covered.">        if (!block.isGiven()) return enumeratorizeWithSize(context, this, &quot;select!&quot;, enumLengthFn());</span>
        
<span class="fc" id="L2368">        modify();</span>
        
<span class="fc" id="L2370">        int newLength = 0;</span>
<span class="fc" id="L2371">        IRubyObject[] aux = new IRubyObject[values.length];</span>

<span class="fc bfc" id="L2373" title="All 2 branches covered.">        for (int oldIndex = 0; oldIndex &lt; realLength; oldIndex++) {</span>
            // Do not coarsen the &quot;safe&quot; check, since it will misinterpret 
            // AIOOBE from the yield (see JRUBY-5434)
<span class="fc" id="L2376">            IRubyObject value = safeArrayRef(values, begin + oldIndex);</span>
            
<span class="fc bfc" id="L2378" title="All 2 branches covered.">            if (!block.yield(context, value).isTrue()) continue;</span>

<span class="fc" id="L2380">            aux[begin + newLength++] = value;</span>
        }

<span class="fc bfc" id="L2383" title="All 2 branches covered.">        if (realLength == newLength) return runtime.getNil(); // No change</span>

<span class="fc" id="L2385">        safeArrayCopy(aux, begin, values, begin, newLength);</span>
<span class="fc" id="L2386">        realLength = newLength;</span>

<span class="fc" id="L2388">        return this;</span>
    }

    @JRubyMethod
    public IRubyObject keep_if(ThreadContext context, Block block) {
<span class="fc bfc" id="L2393" title="All 2 branches covered.">        if (!block.isGiven()) {</span>
<span class="fc" id="L2394">            return enumeratorizeWithSize(context, this, &quot;keep_if&quot;, enumLengthFn());</span>
        }
<span class="fc" id="L2396">        select_bang(context, block);</span>
<span class="fc" id="L2397">        return this;</span>
    }

    /** rb_ary_delete
     *
     */
    @JRubyMethod(required = 1)
    public IRubyObject delete(ThreadContext context, IRubyObject item, Block block) {
<span class="fc" id="L2405">        int i2 = 0;</span>
<span class="fc" id="L2406">        IRubyObject value = item;</span>

<span class="fc" id="L2408">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L2409" title="All 2 branches covered.">        for (int i1 = 0; i1 &lt; realLength; i1++) {</span>
            // Do not coarsen the &quot;safe&quot; check, since it will misinterpret AIOOBE from equalInternal
            // See JRUBY-5434
<span class="fc" id="L2412">            IRubyObject e = safeArrayRef(values, begin + i1);</span>
<span class="fc bfc" id="L2413" title="All 2 branches covered.">            if (equalInternal(context, e, item)) {</span>
<span class="fc" id="L2414">                value = e;</span>
<span class="fc" id="L2415">                continue;</span>
            }
<span class="fc bfc" id="L2417" title="All 2 branches covered.">            if (i1 != i2) store(i2, e);</span>
<span class="fc" id="L2418">            i2++;</span>
        }

<span class="fc bfc" id="L2421" title="All 2 branches covered.">        if (realLength == i2) {</span>
<span class="fc bfc" id="L2422" title="All 2 branches covered.">            if (block.isGiven()) return block.yield(context, item);</span>

<span class="fc" id="L2424">            return runtime.getNil();</span>
        }

<span class="fc" id="L2427">        modify();</span>

<span class="fc" id="L2429">        final int myRealLength = this.realLength;</span>
<span class="fc" id="L2430">        final int myBegin = this.begin;</span>
<span class="fc" id="L2431">        final IRubyObject[] myValues = this.values;</span>
        try {
<span class="pc bpc" id="L2433" title="1 of 2 branches missed.">            if (myRealLength &gt; i2) {</span>
<span class="fc" id="L2434">                Helpers.fillNil(myValues, myBegin + i2, myBegin + myRealLength, context.runtime);</span>
<span class="fc" id="L2435">                this.realLength = i2;</span>
<span class="fc" id="L2436">                int valuesLength = myValues.length - myBegin;</span>
<span class="pc bpc" id="L2437" title="1 of 4 branches missed.">                if (i2 &lt;&lt; 1 &lt; valuesLength &amp;&amp; valuesLength &gt; ARRAY_DEFAULT_SIZE) realloc(i2 &lt;&lt; 1, valuesLength);</span>
            }
<span class="nc" id="L2439">        } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L2440">            concurrentModification();</span>
<span class="fc" id="L2441">        }</span>

<span class="fc" id="L2443">        return value;</span>
    }

    /** rb_ary_delete_at
     *
     */
    public final IRubyObject delete_at(int pos) {
<span class="fc" id="L2450">        int len = realLength;</span>
<span class="fc bfc" id="L2451" title="All 6 branches covered.">        if (pos &gt;= len || (pos &lt; 0 &amp;&amp; (pos += len) &lt; 0)) return getRuntime().getNil();</span>

<span class="fc" id="L2453">        modify();</span>

<span class="fc" id="L2455">        IRubyObject nil = getRuntime().getNil();</span>
<span class="fc" id="L2456">        IRubyObject obj = null; // should never return null below</span>

        try {
<span class="fc" id="L2459">            obj = values[begin + pos];</span>
            // fast paths for head and tail
<span class="fc bfc" id="L2461" title="All 2 branches covered.">            if (pos == 0) {</span>
<span class="fc" id="L2462">                values[begin] = nil;</span>
<span class="fc" id="L2463">                begin++;</span>
<span class="fc" id="L2464">                realLength--;</span>
<span class="fc" id="L2465">                return obj;</span>
<span class="fc bfc" id="L2466" title="All 2 branches covered.">            } else if (pos == realLength - 1) {</span>
<span class="fc" id="L2467">                values[begin + realLength - 1] = nil;</span>
<span class="fc" id="L2468">                realLength--;</span>
<span class="fc" id="L2469">                return obj;</span>
            }

<span class="fc" id="L2472">            System.arraycopy(values, begin + pos + 1, values, begin + pos, len - (pos + 1));</span>
<span class="fc" id="L2473">            values[begin + len - 1] = getRuntime().getNil();</span>
<span class="nc" id="L2474">        } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L2475">            concurrentModification();</span>
<span class="fc" id="L2476">        }</span>
<span class="fc" id="L2477">        realLength--;</span>

<span class="fc" id="L2479">        return obj;</span>
    }

    /** rb_ary_delete_at_m
     * 
     */
    @JRubyMethod(name = &quot;delete_at&quot;, required = 1)
    public IRubyObject delete_at(IRubyObject obj) {
<span class="fc" id="L2487">        return delete_at((int) RubyNumeric.num2long(obj));</span>
    }

    /** rb_ary_reject_bang
     * 
     */
    public IRubyObject rejectCommon(ThreadContext context, Block block) {
<span class="fc" id="L2494">        RubyArray ary = aryDup();</span>
<span class="fc" id="L2495">        ary.reject_bang(context, block);</span>
<span class="fc" id="L2496">        return ary;</span>
    }

    @JRubyMethod
    public IRubyObject reject(ThreadContext context, Block block) {
<span class="fc bfc" id="L2501" title="All 2 branches covered.">        return block.isGiven() ? rejectCommon(context, block) : enumeratorizeWithSize(context, this, &quot;reject&quot;, enumLengthFn());</span>
    }

    /** rb_ary_reject_bang
     *
     */
    public IRubyObject rejectBang(ThreadContext context, Block block) {
<span class="pc bpc" id="L2508" title="1 of 2 branches missed.">        if (!block.isGiven()) throw context.runtime.newLocalJumpErrorNoBlock();</span>

<span class="fc" id="L2510">        IRubyObject result = context.runtime.getNil();</span>
<span class="fc" id="L2511">        modify();</span>
        
<span class="fc bfc" id="L2513" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; /* we adjust i in the loop */) {</span>
            // Do not coarsen the &quot;safe&quot; check, since it will misinterpret AIOOBE from the yield
            // See JRUBY-5434
<span class="fc" id="L2516">            IRubyObject v = safeArrayRef(values, begin + i);</span>
<span class="fc bfc" id="L2517" title="All 2 branches covered.">            if (block.yield(context, v).isTrue()) {</span>
<span class="fc" id="L2518">                delete_at(i);</span>
<span class="fc" id="L2519">                result = this;</span>
            } else {
<span class="fc" id="L2521">                i++;</span>
            }
<span class="fc" id="L2523">        }</span>

<span class="fc" id="L2525">        return result;</span>
    }

    @JRubyMethod(name = &quot;reject!&quot;)
    public IRubyObject reject_bang(ThreadContext context, Block block) {
<span class="fc bfc" id="L2530" title="All 2 branches covered.">        return block.isGiven() ? rejectBang(context, block) : enumeratorizeWithSize(context, this, &quot;reject!&quot;, enumLengthFn());</span>
    }

    /** rb_ary_delete_if
     *
     */
    public IRubyObject deleteIf(ThreadContext context, Block block) {
<span class="fc" id="L2537">        reject_bang(context, block);</span>
<span class="fc" id="L2538">        return this;</span>
    }

    @JRubyMethod
    public IRubyObject delete_if(ThreadContext context, Block block) {
<span class="fc bfc" id="L2543" title="All 2 branches covered.">        return block.isGiven() ? deleteIf(context, block) : enumeratorizeWithSize(context, this, &quot;delete_if&quot;, enumLengthFn());</span>
    }

    /** rb_ary_zip
     *
     */
    @JRubyMethod(optional = 1, rest = true)
    public IRubyObject zip(ThreadContext context, IRubyObject[] args, Block block) {
<span class="fc" id="L2551">        final Ruby runtime = context.runtime;</span>
<span class="fc" id="L2552">        final int aLen = args.length + 1;</span>
<span class="fc" id="L2553">        RubyClass array = runtime.getArray();</span>

<span class="fc" id="L2555">        final IRubyObject[] newArgs = new IRubyObject[args.length];</span>

<span class="fc" id="L2557">        boolean hasUncoercible = false;</span>
<span class="fc bfc" id="L2558" title="All 2 branches covered.">        for (int i = 0; i &lt; args.length; i++) {</span>
<span class="fc" id="L2559">            newArgs[i] = TypeConverter.convertToType(args[i], array, &quot;to_ary&quot;, false);</span>
<span class="fc bfc" id="L2560" title="All 2 branches covered.">            if (newArgs[i].isNil()) {</span>
<span class="fc" id="L2561">                hasUncoercible = true;</span>
            }
        }

        // Handle uncoercibles by trying to_enum conversion
<span class="fc bfc" id="L2566" title="All 2 branches covered.">        if (hasUncoercible) {</span>
<span class="fc" id="L2567">            RubySymbol each = runtime.newSymbol(&quot;each&quot;);</span>
<span class="fc bfc" id="L2568" title="All 2 branches covered.">            for (int i = 0; i &lt; args.length; i++) {</span>
<span class="fc" id="L2569">                newArgs[i] = args[i].callMethod(context, &quot;to_enum&quot;, each);</span>
            }
        }

<span class="fc bfc" id="L2573" title="All 2 branches covered.">        if (hasUncoercible) {</span>
<span class="fc" id="L2574">            return zipCommon(context, newArgs, block, new ArgumentVisitor() {</span>
                public IRubyObject visit(ThreadContext ctx, IRubyObject arg, int i) {
<span class="fc" id="L2576">                    return RubyEnumerable.zipEnumNext(ctx, arg);</span>
                }
            });
        } else {
<span class="fc" id="L2580">            return zipCommon(context, newArgs, block, new ArgumentVisitor() {</span>
                public IRubyObject visit(ThreadContext ctx, IRubyObject arg, int i) {
<span class="fc" id="L2582">                    return ((RubyArray) arg).elt(i);</span>
                }
            });
        }
    }

    // This can be shared with RubyEnumerable to clean #zipCommon{Enum,Arg} a little
    public static interface ArgumentVisitor {
        IRubyObject visit(ThreadContext ctx, IRubyObject arg, int i);
    }

    private IRubyObject zipCommon(ThreadContext context, IRubyObject[] args, Block block, ArgumentVisitor visitor) {
<span class="fc" id="L2594">        Ruby runtime = context.runtime;</span>

<span class="fc bfc" id="L2596" title="All 2 branches covered.">        if (block.isGiven()) {</span>
<span class="fc bfc" id="L2597" title="All 2 branches covered.">            for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc" id="L2598">                IRubyObject[] tmp = new IRubyObject[args.length + 1];</span>
                // Do not coarsen the &quot;safe&quot; check, since it will misinterpret AIOOBE from the yield
                // See JRUBY-5434
<span class="fc" id="L2601">                tmp[0] = safeArrayRef(values, begin + i);</span>
<span class="fc bfc" id="L2602" title="All 2 branches covered.">                for (int j = 0; j &lt; args.length; j++) {</span>
<span class="fc" id="L2603">                    tmp[j + 1] = visitor.visit(context, args[j], i);</span>
                }
<span class="fc" id="L2605">                block.yield(context, newArrayNoCopyLight(runtime, tmp));</span>
            }
<span class="fc" id="L2607">            return runtime.getNil();</span>
        }

<span class="fc" id="L2610">        IRubyObject[] result = new IRubyObject[realLength];</span>
        try {
<span class="fc bfc" id="L2612" title="All 2 branches covered.">            for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc" id="L2613">                IRubyObject[] tmp = new IRubyObject[args.length + 1];</span>
<span class="fc" id="L2614">                tmp[0] = values[begin + i];</span>
<span class="fc bfc" id="L2615" title="All 2 branches covered.">                for (int j = 0; j &lt; args.length; j++) {</span>
<span class="fc" id="L2616">                    tmp[j + 1] = visitor.visit(context, args[j], i);</span>
                }
<span class="fc" id="L2618">                result[i] = newArrayNoCopyLight(runtime, tmp);</span>
            }
<span class="nc" id="L2620">        } catch (ArrayIndexOutOfBoundsException aioob) {</span>
<span class="nc" id="L2621">            concurrentModification();</span>
<span class="fc" id="L2622">        }</span>
<span class="fc" id="L2623">        return newArrayNoCopy(runtime, result);</span>
    }

    /** rb_ary_cmp
     *
     */
    @JRubyMethod(name = &quot;&lt;=&gt;&quot;, required = 1)
    public IRubyObject op_cmp(ThreadContext context, IRubyObject obj) {
<span class="fc" id="L2631">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L2632">        IRubyObject ary2 = runtime.getNil();</span>
<span class="pc bpc" id="L2633" title="1 of 4 branches missed.">        boolean isAnArray = (obj instanceof RubyArray) || obj.getMetaClass().getSuperClass() == runtime.getArray();</span>

<span class="fc bfc" id="L2635" title="All 4 branches covered.">        if (!isAnArray &amp;&amp; !obj.respondsTo(&quot;to_ary&quot;)) {</span>
<span class="fc" id="L2636">            return ary2;</span>
<span class="fc bfc" id="L2637" title="All 2 branches covered.">        } else if (!isAnArray) {</span>
<span class="fc" id="L2638">            ary2 = obj.callMethod(context, &quot;to_ary&quot;);</span>
        } else {
<span class="fc" id="L2640">            ary2 = obj.convertToArray();</span>
        }
        
<span class="fc" id="L2643">        return cmpCommon(context, runtime, (RubyArray) ary2);</span>
    }

    private IRubyObject cmpCommon(ThreadContext context, Ruby runtime, RubyArray ary2) {
<span class="pc bpc" id="L2647" title="1 of 4 branches missed.">        if (this == ary2 || runtime.isInspecting(this)) return RubyFixnum.zero(runtime);</span>

        try {
<span class="fc" id="L2650">            runtime.registerInspecting(this);</span>

<span class="fc" id="L2652">            int len = realLength;</span>
<span class="fc bfc" id="L2653" title="All 2 branches covered.">            if (len &gt; ary2.realLength) len = ary2.realLength;</span>

<span class="fc bfc" id="L2655" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L2656">                IRubyObject v = invokedynamic(context, elt(i), OP_CMP, ary2.elt(i));</span>
<span class="fc bfc" id="L2657" title="All 4 branches covered.">                if (!(v instanceof RubyFixnum) || ((RubyFixnum) v).getLongValue() != 0) return v;</span>
            }
        } finally {
<span class="pc" id="L2660">            runtime.unregisterInspecting(this);</span>
<span class="fc" id="L2661">        }</span>

<span class="fc" id="L2663">        int len = realLength - ary2.realLength;</span>

<span class="fc bfc" id="L2665" title="All 2 branches covered.">        if (len == 0) return RubyFixnum.zero(runtime);</span>
<span class="fc bfc" id="L2666" title="All 2 branches covered.">        if (len &gt; 0) return RubyFixnum.one(runtime);</span>

<span class="fc" id="L2668">        return RubyFixnum.minus_one(runtime);</span>
    }

    /**
     * Variable arity version for compatibility. Not bound to a Ruby method.
     * @deprecated Use the versions with zero, one, or two args.
     */
    public IRubyObject slice_bang(IRubyObject[] args) {
<span class="nc bnc" id="L2676" title="All 3 branches missed.">        switch (args.length) {</span>
        case 1:
<span class="nc" id="L2678">            return slice_bang(args[0]);</span>
        case 2:
<span class="nc" id="L2680">            return slice_bang(args[0], args[1]);</span>
        default:
<span class="nc" id="L2682">            Arity.raiseArgumentError(getRuntime(), args.length, 1, 2);</span>
<span class="nc" id="L2683">            return null; // not reached</span>
        }
    }

    private IRubyObject slice_internal(long pos, long len, 
            IRubyObject arg0, IRubyObject arg1, Ruby runtime) {
<span class="pc bpc" id="L2689" title="1 of 2 branches missed.">        if(len &lt; 0) return runtime.getNil();</span>
<span class="fc" id="L2690">        int orig_len = realLength;</span>
<span class="fc bfc" id="L2691" title="All 2 branches covered.">        if(pos &lt; 0) {</span>
<span class="fc" id="L2692">            pos += orig_len;</span>
<span class="pc bpc" id="L2693" title="1 of 2 branches missed.">            if(pos &lt; 0) {</span>
<span class="fc" id="L2694">                return runtime.getNil();</span>
            }
<span class="fc bfc" id="L2696" title="All 2 branches covered.">        } else if(orig_len &lt; pos) {</span>
<span class="fc" id="L2697">            return runtime.getNil();</span>
        }

<span class="fc bfc" id="L2700" title="All 2 branches covered.">        if(orig_len &lt; pos + len) {</span>
<span class="fc" id="L2701">            len = orig_len - pos;</span>
        }
<span class="fc bfc" id="L2703" title="All 2 branches covered.">        if(len == 0) {</span>
<span class="fc" id="L2704">            return runtime.newEmptyArray();</span>
        }

<span class="fc" id="L2707">        arg1 = makeShared(begin + (int)pos, (int)len, getMetaClass());</span>
<span class="fc" id="L2708">        splice(pos, len, null, false);</span>

<span class="fc" id="L2710">        return arg1;</span>
    }

    /** rb_ary_slice_bang
     *
     */
    @JRubyMethod(name = &quot;slice!&quot;)
    public IRubyObject slice_bang(IRubyObject arg0) {
<span class="fc" id="L2718">        modifyCheck();</span>
<span class="fc" id="L2719">        Ruby runtime = getRuntime();</span>
<span class="fc bfc" id="L2720" title="All 2 branches covered.">        if (arg0 instanceof RubyRange) {</span>
<span class="fc" id="L2721">            RubyRange range = (RubyRange) arg0;</span>
<span class="fc bfc" id="L2722" title="All 2 branches covered.">            if (!range.checkBegin(realLength)) {</span>
<span class="fc" id="L2723">                return runtime.getNil();</span>
            }

<span class="fc" id="L2726">            long pos = range.begLen0(realLength);</span>
<span class="fc" id="L2727">            long len = range.begLen1(realLength, pos);</span>
<span class="fc" id="L2728">            return slice_internal(pos, len, arg0, null, runtime);</span>
        }
<span class="fc" id="L2730">        return delete_at((int) RubyNumeric.num2long(arg0));</span>
    }

    /** rb_ary_slice_bang
    *
    */
    @JRubyMethod(name = &quot;slice!&quot;)
    public IRubyObject slice_bang(IRubyObject arg0, IRubyObject arg1) {
<span class="fc" id="L2738">        modifyCheck();</span>
<span class="fc" id="L2739">        long pos = RubyNumeric.num2long(arg0);</span>
<span class="fc" id="L2740">        long len = RubyNumeric.num2long(arg1);</span>
<span class="fc" id="L2741">        return slice_internal(pos, len, arg0, arg1, getRuntime());</span>
    }    

    /** rb_ary_assoc
     *
     */
    @JRubyMethod(name = &quot;assoc&quot;, required = 1)
    public IRubyObject assoc(ThreadContext context, IRubyObject key) {
<span class="fc" id="L2749">        Ruby runtime = context.runtime;</span>

<span class="fc bfc" id="L2751" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc" id="L2752">            IRubyObject v = eltOk(i);</span>
<span class="fc bfc" id="L2753" title="All 2 branches covered.">            if (v instanceof RubyArray) {</span>
<span class="fc" id="L2754">                RubyArray arr = (RubyArray)v;</span>
<span class="fc bfc" id="L2755" title="All 4 branches covered.">                if (arr.realLength &gt; 0 &amp;&amp; equalInternal(context, arr.elt(0), key)) return arr;</span>
            }
        }

<span class="fc" id="L2759">        return runtime.getNil();</span>
    }

    /** rb_ary_rassoc
     *
     */
    @JRubyMethod(name = &quot;rassoc&quot;, required = 1)
    public IRubyObject rassoc(ThreadContext context, IRubyObject value) {
<span class="fc" id="L2767">        Ruby runtime = context.runtime;</span>

<span class="fc bfc" id="L2769" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc" id="L2770">            IRubyObject v = eltOk(i);</span>
<span class="fc bfc" id="L2771" title="All 2 branches covered.">            if (v instanceof RubyArray) {</span>
<span class="fc" id="L2772">                RubyArray arr = (RubyArray)v;</span>
<span class="fc bfc" id="L2773" title="All 4 branches covered.">                if (arr.realLength &gt; 1 &amp;&amp; equalInternal(context, arr.eltOk(1), value)) return arr;</span>
            }
        }

<span class="fc" id="L2777">        return runtime.getNil();</span>
    }

    private boolean flatten(ThreadContext context, int level, RubyArray result) {
<span class="fc" id="L2781">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L2782">        RubyArray stack = new RubyArray(runtime, ARRAY_DEFAULT_SIZE, false);</span>
<span class="fc" id="L2783">        IdentityHashMap&lt;Object, Object&gt; memo = new IdentityHashMap&lt;Object, Object&gt;();</span>
<span class="fc" id="L2784">        RubyArray ary = this;</span>
<span class="fc" id="L2785">        memo.put(ary, NEVER);</span>
<span class="fc" id="L2786">        boolean modified = false;</span>

<span class="fc" id="L2788">        int i = 0;</span>

        try {
            while (true) {
                IRubyObject tmp;
<span class="fc bfc" id="L2793" title="All 2 branches covered.">                while (i &lt; ary.realLength) {</span>
<span class="fc" id="L2794">                    IRubyObject elt = ary.values[ary.begin + i++];</span>
<span class="fc" id="L2795">                    tmp = elt.checkArrayType();</span>
<span class="fc bfc" id="L2796" title="All 6 branches covered.">                    if (tmp.isNil() || (level &gt;= 0 &amp;&amp; stack.realLength / 2 &gt;= level)) {</span>
<span class="fc" id="L2797">                        result.append(elt);</span>
                    } else {
<span class="fc" id="L2799">                        modified = true;</span>
<span class="fc bfc" id="L2800" title="All 2 branches covered.">                        if (memo.get(tmp) != null) throw runtime.newArgumentError(&quot;tried to flatten recursive array&quot;);</span>
<span class="fc" id="L2801">                        memo.put(tmp, NEVER);</span>
<span class="fc" id="L2802">                        stack.append(ary);</span>
<span class="fc" id="L2803">                        stack.append(RubyFixnum.newFixnum(runtime, i));</span>
<span class="fc" id="L2804">                        ary = (RubyArray)tmp;</span>
<span class="fc" id="L2805">                        i = 0;</span>
                    }
<span class="fc" id="L2807">                }</span>
<span class="fc bfc" id="L2808" title="All 2 branches covered.">                if (stack.realLength == 0) break;</span>
<span class="fc" id="L2809">                memo.remove(ary);</span>
<span class="fc" id="L2810">                tmp = stack.pop(context);</span>
<span class="fc" id="L2811">                i = (int)((RubyFixnum)tmp).getLongValue();</span>
<span class="fc" id="L2812">                ary = (RubyArray)stack.pop(context);</span>
<span class="fc" id="L2813">            }</span>
<span class="nc" id="L2814">        } catch (ArrayIndexOutOfBoundsException aioob) {</span>
<span class="nc" id="L2815">            concurrentModification();</span>
<span class="fc" id="L2816">        }</span>
<span class="fc" id="L2817">        return modified;</span>
    }

    public IRubyObject flatten_bang(ThreadContext context) {
<span class="fc" id="L2821">        Ruby runtime = context.runtime;</span>

<span class="fc" id="L2823">        RubyArray result = new RubyArray(runtime, getMetaClass(), realLength);</span>
<span class="fc bfc" id="L2824" title="All 2 branches covered.">        if (flatten(context, -1, result)) {</span>
<span class="fc" id="L2825">            modifyCheck();</span>
<span class="fc" id="L2826">            isShared = false;</span>
<span class="fc" id="L2827">            begin = 0;</span>
<span class="fc" id="L2828">            realLength = result.realLength;</span>
<span class="fc" id="L2829">            values = result.values;</span>
<span class="fc" id="L2830">            return this;</span>
        }
<span class="fc" id="L2832">        return runtime.getNil();</span>
    }

    @JRubyMethod(name = &quot;flatten!&quot;)
    public IRubyObject flatten_bang19(ThreadContext context) {
<span class="fc" id="L2837">        modifyCheck();</span>

<span class="fc" id="L2839">        return flatten_bang(context);</span>
    }

    public IRubyObject flatten_bang(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L2843">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L2844">        int level = RubyNumeric.num2int(arg);</span>
<span class="fc bfc" id="L2845" title="All 2 branches covered.">        if (level == 0) return runtime.getNil();</span>

<span class="fc" id="L2847">        RubyArray result = new RubyArray(runtime, getMetaClass(), realLength);</span>
<span class="fc bfc" id="L2848" title="All 2 branches covered.">        if (flatten(context, level, result)) {</span>
<span class="fc" id="L2849">            isShared = false;</span>
<span class="fc" id="L2850">            begin = 0;</span>
<span class="fc" id="L2851">            realLength = result.realLength;</span>
<span class="fc" id="L2852">            values = result.values;</span>
<span class="fc" id="L2853">            return this;</span>
        }
<span class="fc" id="L2855">        return runtime.getNil();</span>
    }

    @JRubyMethod(name = &quot;flatten!&quot;)
    public IRubyObject flatten_bang19(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L2860">        modifyCheck();</span>

<span class="fc" id="L2862">        return flatten_bang(context, arg);</span>
    }

    public IRubyObject flatten(ThreadContext context) {
<span class="nc" id="L2866">        return flatten19(context);</span>
    }

    public IRubyObject flatten(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L2870">        return flatten19(context, arg);</span>
    }

    @JRubyMethod(name = &quot;flatten&quot;)
    public IRubyObject flatten19(ThreadContext context) {
<span class="fc" id="L2875">        Ruby runtime = context.runtime;</span>

<span class="fc" id="L2877">        RubyArray result = new RubyArray(runtime, getMetaClass(), realLength);</span>
<span class="fc" id="L2878">        flatten(context, -1, result);</span>
<span class="fc" id="L2879">        result.infectBy(this);</span>
<span class="fc" id="L2880">        return result;</span>
    }

    @JRubyMethod(name = &quot;flatten&quot;)
    public IRubyObject flatten19(ThreadContext context, IRubyObject arg) {
<span class="fc" id="L2885">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L2886">        int level = RubyNumeric.num2int(arg);</span>
<span class="fc bfc" id="L2887" title="All 2 branches covered.">        if (level == 0) return makeShared();</span>

<span class="fc" id="L2889">        RubyArray result = new RubyArray(runtime, getMetaClass(), realLength);</span>
<span class="fc" id="L2890">        flatten(context, level, result);</span>
<span class="fc" id="L2891">        result.infectBy(this);</span>
<span class="fc" id="L2892">        return result;</span>
    }

    @JRubyMethod(name = &quot;count&quot;)
    public IRubyObject count(ThreadContext context, Block block) {
<span class="fc bfc" id="L2897" title="All 2 branches covered.">        if (block.isGiven()) {</span>
<span class="fc" id="L2898">            int n = 0;</span>
<span class="fc bfc" id="L2899" title="All 2 branches covered.">            for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc bfc" id="L2900" title="All 2 branches covered.">                if (block.yield(context, elt(i)).isTrue()) n++;</span>
            }
<span class="fc" id="L2902">            return RubyFixnum.newFixnum(context.runtime, n);</span>
        } else {
<span class="fc" id="L2904">            return RubyFixnum.newFixnum(context.runtime, realLength);</span>
        }
    }

    @JRubyMethod(name = &quot;count&quot;)
    public IRubyObject count(ThreadContext context, IRubyObject obj, Block block) {
<span class="pc bpc" id="L2910" title="1 of 2 branches missed.">        if (block.isGiven()) context.runtime.getWarnings().warn(ID.BLOCK_UNUSED, &quot;given block not used&quot;);</span>

<span class="fc" id="L2912">        int n = 0;</span>
<span class="fc bfc" id="L2913" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc bfc" id="L2914" title="All 2 branches covered.">            if (equalInternal(context, elt(i), obj)) n++;</span>
        }
<span class="fc" id="L2916">        return RubyFixnum.newFixnum(context.runtime, n);</span>
    }

    /** rb_ary_nitems
     *
     */
    @JRubyMethod(name = &quot;nitems&quot;)
    public IRubyObject nitems() {
<span class="nc" id="L2924">        int n = 0;</span>

<span class="nc bnc" id="L2926" title="All 2 branches missed.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="nc bnc" id="L2927" title="All 2 branches missed.">            if (!eltOk(i).isNil()) n++;</span>
        }
        
<span class="nc" id="L2930">        return getRuntime().newFixnum(n);</span>
    }

    /** rb_ary_plus
     *
     */
    @JRubyMethod(name = &quot;+&quot;, required = 1)
    public IRubyObject op_plus(IRubyObject obj) {
<span class="fc" id="L2938">        RubyArray y = obj.convertToArray();</span>
<span class="fc" id="L2939">        int len = realLength + y.realLength;</span>
<span class="fc" id="L2940">        RubyArray z = new RubyArray(getRuntime(), len);</span>
        try {
<span class="fc" id="L2942">            System.arraycopy(values, begin, z.values, 0, realLength);</span>
<span class="fc" id="L2943">            System.arraycopy(y.values, y.begin, z.values, realLength, y.realLength);</span>
<span class="nc" id="L2944">        } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L2945">            concurrentModification();</span>
<span class="fc" id="L2946">        }</span>
<span class="fc" id="L2947">        z.realLength = len;</span>
<span class="fc" id="L2948">        return z;</span>
    }

    /** rb_ary_times
     *
     */
    public IRubyObject op_times(ThreadContext context, IRubyObject times) {
<span class="nc" id="L2955">        return op_times19(context, times);</span>
    }

    /** rb_ary_times
     *
     */
    @JRubyMethod(name = &quot;*&quot;, required = 1)
    public IRubyObject op_times19(ThreadContext context, IRubyObject times) {
<span class="fc" id="L2963">        IRubyObject tmp = times.checkStringType();</span>

<span class="fc bfc" id="L2965" title="All 2 branches covered.">        if (!tmp.isNil()) return join19(context, tmp);</span>

<span class="fc" id="L2967">        long len = RubyNumeric.num2long(times);</span>
<span class="fc" id="L2968">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L2969" title="All 2 branches covered.">        if (len == 0) return new RubyArray(runtime, getMetaClass(), IRubyObject.NULL_ARRAY).infectBy(this);</span>
<span class="fc bfc" id="L2970" title="All 2 branches covered.">        if (len &lt; 0) throw runtime.newArgumentError(&quot;negative argument&quot;);</span>

<span class="pc bpc" id="L2972" title="1 of 2 branches missed.">        if (Long.MAX_VALUE / len &lt; realLength) {</span>
<span class="nc" id="L2973">            throw runtime.newArgumentError(&quot;argument too big&quot;);</span>
        }

<span class="fc" id="L2976">        len *= realLength;</span>

<span class="fc" id="L2978">        checkLength(runtime, len);</span>
<span class="fc" id="L2979">        RubyArray ary2 = new RubyArray(runtime, getMetaClass(), (int)len);</span>
<span class="fc" id="L2980">        ary2.realLength = ary2.values.length;</span>

        try {
<span class="fc bfc" id="L2983" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i += realLength) {</span>
<span class="fc" id="L2984">                System.arraycopy(values, begin, ary2.values, i, realLength);</span>
            }
<span class="nc" id="L2986">        } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L2987">            concurrentModification();</span>
<span class="fc" id="L2988">        }</span>

<span class="fc" id="L2990">        ary2.infectBy(this);</span>

<span class="fc" id="L2992">        return ary2;</span>
    }

    /** ary_make_hash
     * 
     */
    private RubyHash makeHash() {
<span class="fc" id="L2999">        return makeHash(new RubyHash(getRuntime(), false));</span>
    }

    private RubyHash makeHash(RubyHash hash) {
<span class="fc" id="L3003">        int myBegin = this.begin;</span>
<span class="fc bfc" id="L3004" title="All 2 branches covered.">        for (int i = myBegin; i &lt; myBegin + realLength; i++) {</span>
<span class="fc" id="L3005">            hash.fastASet(values[i], NEVER);</span>
        }
<span class="fc" id="L3007">        return hash;</span>
    }

    private RubyHash makeHash(RubyArray ary2) {
<span class="fc" id="L3011">        return ary2.makeHash(makeHash());</span>
    }

    private RubyHash makeHash(ThreadContext context, Block block) {
<span class="fc" id="L3015">        return makeHash(context, new RubyHash(getRuntime(), false), block);</span>
    }

    private RubyHash makeHash(ThreadContext context, RubyHash hash, Block block) {
<span class="fc bfc" id="L3019" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc" id="L3020">            IRubyObject v = elt(i);</span>
<span class="fc" id="L3021">            IRubyObject k = block.yield(context, v);</span>
<span class="fc bfc" id="L3022" title="All 2 branches covered.">            if (hash.fastARef(k) == null) hash.fastASet(k, v);</span>
        }
<span class="fc" id="L3024">        return hash;</span>
    }

    /** rb_ary_uniq_bang 
     *
     */
    public IRubyObject uniq_bang(ThreadContext context) {
<span class="fc" id="L3031">        RubyHash hash = makeHash();</span>
<span class="fc bfc" id="L3032" title="All 2 branches covered.">        if (realLength == hash.size()) return context.runtime.getNil();</span>

<span class="fc" id="L3034">        int j = 0;</span>
<span class="fc bfc" id="L3035" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc" id="L3036">            IRubyObject v = elt(i);</span>
<span class="fc bfc" id="L3037" title="All 2 branches covered.">            if (hash.fastDelete(v)) store(j++, v);</span>
        }
<span class="fc" id="L3039">        realLength = j;</span>
<span class="fc" id="L3040">        return this;</span>
    }

    @JRubyMethod(name = &quot;uniq!&quot;)
    public IRubyObject uniq_bang19(ThreadContext context, Block block) {
<span class="fc" id="L3045">        modifyCheck();</span>
        
<span class="fc bfc" id="L3047" title="All 2 branches covered.">        if (!block.isGiven()) return uniq_bang(context);</span>
<span class="fc" id="L3048">        RubyHash hash = makeHash(context, block);</span>
<span class="pc bpc" id="L3049" title="1 of 2 branches missed.">        if (realLength == hash.size()) return context.runtime.getNil();</span>
<span class="fc" id="L3050">        realLength = 0;</span>

<span class="fc" id="L3052">        hash.visitAll(new RubyHash.Visitor() {</span>
            @Override
            public void visit(IRubyObject key, IRubyObject value) {
<span class="fc" id="L3055">                append(value);</span>
<span class="fc" id="L3056">            }</span>
        });
<span class="fc" id="L3058">        return this;</span>
    }

    /** rb_ary_uniq 
     *
     */
    public IRubyObject uniq(ThreadContext context) {
<span class="fc" id="L3065">        RubyHash hash = makeHash();</span>
<span class="fc bfc" id="L3066" title="All 2 branches covered.">        if (realLength == hash.size()) return makeShared();</span>

<span class="fc" id="L3068">        RubyArray result = new RubyArray(context.runtime, getMetaClass(), hash.size()); </span>

<span class="fc" id="L3070">        int j = 0;</span>
        try {
<span class="fc bfc" id="L3072" title="All 2 branches covered.">            for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc" id="L3073">                IRubyObject v = elt(i);</span>
<span class="fc bfc" id="L3074" title="All 2 branches covered.">                if (hash.fastDelete(v)) result.values[j++] = v;</span>
            }
<span class="nc" id="L3076">        } catch (ArrayIndexOutOfBoundsException aioob) {</span>
<span class="nc" id="L3077">            concurrentModification();</span>
<span class="fc" id="L3078">        }</span>
<span class="fc" id="L3079">        result.realLength = j;</span>
<span class="fc" id="L3080">        return result;</span>
    }

    @JRubyMethod(name = &quot;uniq&quot;)
    public IRubyObject uniq19(ThreadContext context, Block block) {
<span class="fc bfc" id="L3085" title="All 2 branches covered.">        if (!block.isGiven()) return uniq(context);</span>
<span class="fc" id="L3086">        RubyHash hash = makeHash(context, block);</span>

<span class="fc" id="L3088">        final RubyArray result = new RubyArray(context.runtime, getMetaClass(), hash.size());</span>
<span class="fc" id="L3089">        hash.visitAll(new RubyHash.Visitor() {</span>
            @Override
            public void visit(IRubyObject key, IRubyObject value) {
<span class="fc" id="L3092">                result.append(value);</span>
<span class="fc" id="L3093">            }</span>
        });
<span class="fc" id="L3095">        return result;</span>
    }

    /** rb_ary_diff
     *
     */
    @JRubyMethod(name = &quot;-&quot;, required = 1)
    public IRubyObject op_diff(IRubyObject other) {
<span class="fc" id="L3103">        RubyHash hash = other.convertToArray().makeHash();</span>
<span class="fc" id="L3104">        RubyArray ary3 = new RubyArray(getRuntime(), ARRAY_DEFAULT_SIZE);</span>

<span class="fc" id="L3106">        int myBegin = this.begin;</span>
        try {
<span class="fc bfc" id="L3108" title="All 2 branches covered.">            for (int i = myBegin; i &lt; myBegin + realLength; i++) {</span>
<span class="fc bfc" id="L3109" title="All 2 branches covered.">                if (hash.fastARef(values[i]) != null) continue;</span>
<span class="fc" id="L3110">                ary3.append(elt(i - myBegin));</span>
            }
<span class="nc" id="L3112">        } catch (ArrayIndexOutOfBoundsException aioob) {</span>
<span class="nc" id="L3113">            concurrentModification();</span>
<span class="fc" id="L3114">        }</span>
<span class="fc" id="L3115">        Helpers.fillNil(ary3.values, ary3.realLength, ary3.values.length, getRuntime());</span>

<span class="fc" id="L3117">        return ary3;</span>
    }

    /** rb_ary_and
     *
     */
    @JRubyMethod(name = &quot;&amp;&quot;, required = 1)
    public IRubyObject op_and(IRubyObject other) {
<span class="fc" id="L3125">        RubyArray ary2 = other.convertToArray();</span>
<span class="fc" id="L3126">        RubyHash hash = ary2.makeHash();</span>
<span class="fc bfc" id="L3127" title="All 2 branches covered.">        RubyArray ary3 = new RubyArray(getRuntime(), realLength &lt; ary2.realLength ? realLength : ary2.realLength);</span>

<span class="fc bfc" id="L3129" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc" id="L3130">            IRubyObject v = elt(i);</span>
<span class="fc bfc" id="L3131" title="All 2 branches covered.">            if (hash.fastDelete(v)) ary3.append(v);</span>
        }

<span class="fc" id="L3134">        Helpers.fillNil(ary3.values, ary3.realLength, ary3.values.length, getRuntime());</span>

<span class="fc" id="L3136">        return ary3;</span>
    }

    /** rb_ary_or
     *
     */
    @JRubyMethod(name = &quot;|&quot;, required = 1)
    public IRubyObject op_or(IRubyObject other) {
<span class="fc" id="L3144">        RubyArray ary2 = other.convertToArray();</span>
<span class="fc" id="L3145">        RubyHash set = makeHash(ary2);</span>

<span class="fc" id="L3147">        RubyArray ary3 = new RubyArray(getRuntime(), realLength + ary2.realLength);</span>

<span class="fc bfc" id="L3149" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc" id="L3150">            IRubyObject v = elt(i);</span>
<span class="fc bfc" id="L3151" title="All 2 branches covered.">            if (set.fastDelete(v)) ary3.append(v);</span>
        }
<span class="fc bfc" id="L3153" title="All 2 branches covered.">        for (int i = 0; i &lt; ary2.realLength; i++) {</span>
<span class="fc" id="L3154">            IRubyObject v = ary2.elt(i);</span>
<span class="fc bfc" id="L3155" title="All 2 branches covered.">            if (set.fastDelete(v)) ary3.append(v);</span>
        }

<span class="fc" id="L3158">        Helpers.fillNil(ary3.values, ary3.realLength, ary3.values.length, getRuntime());</span>

<span class="fc" id="L3160">        return ary3;</span>
    }

    /** rb_ary_sort
     *
     */
    public RubyArray sort(ThreadContext context, Block block) {
<span class="nc" id="L3167">        return sort19(context, block);</span>
    }

    @JRubyMethod(name = &quot;sort&quot;)
    public RubyArray sort19(ThreadContext context, Block block) {
<span class="fc" id="L3172">        RubyArray ary = aryDup();</span>
<span class="fc" id="L3173">        ary.sort_bang19(context, block);</span>
<span class="fc" id="L3174">        return ary;</span>
    }

    /** rb_ary_sort_bang
     *
     */
    public IRubyObject sort_bang(ThreadContext context, Block block) {
<span class="fc" id="L3181">        return sort_bang19(context, block);</span>
    }

    @JRubyMethod(name = &quot;sort!&quot;)
    public IRubyObject sort_bang19(ThreadContext context, Block block) {
<span class="fc" id="L3186">        modify();</span>
<span class="fc bfc" id="L3187" title="All 2 branches covered.">        if (realLength &gt; 1) {</span>
<span class="fc bfc" id="L3188" title="All 2 branches covered.">            return block.isGiven() ? sortInternal(context, block) : sortInternal(context, true);</span>
        }
<span class="fc" id="L3190">        return this;</span>
    }

    private IRubyObject sortInternal(final ThreadContext context, boolean honorOverride) {
<span class="fc" id="L3194">        Ruby runtime = context.runtime;</span>

        // One check per specialized fast-path to make the check invariant.
<span class="pc bpc" id="L3197" title="2 of 4 branches missed.">        final boolean fixnumBypass = !honorOverride || runtime.getFixnum().isMethodBuiltin(&quot;&lt;=&gt;&quot;);</span>
<span class="pc bpc" id="L3198" title="2 of 4 branches missed.">        final boolean stringBypass = !honorOverride || runtime.getString().isMethodBuiltin(&quot;&lt;=&gt;&quot;);</span>

        try {
<span class="fc" id="L3201">            Qsort.sort(values, begin, begin + realLength, new Comparator() {</span>
                public int compare(Object o1, Object o2) {
<span class="pc bpc" id="L3203" title="1 of 6 branches missed.">                    if (fixnumBypass &amp;&amp; o1 instanceof RubyFixnum &amp;&amp; o2 instanceof RubyFixnum) {</span>
<span class="fc" id="L3204">                        return compareFixnums((RubyFixnum) o1, (RubyFixnum) o2);</span>
                    }
<span class="pc bpc" id="L3206" title="2 of 6 branches missed.">                    if (stringBypass &amp;&amp; o1 instanceof RubyString &amp;&amp; o2 instanceof RubyString) {</span>
<span class="fc" id="L3207">                        return ((RubyString) o1).op_cmp((RubyString) o2);</span>
                    }
<span class="fc" id="L3209">                    return compareOthers(context, (IRubyObject)o1, (IRubyObject)o2);</span>
                }
            });
<span class="nc" id="L3212">        } catch (ArrayIndexOutOfBoundsException aioob) {</span>
<span class="nc" id="L3213">            concurrentModification();</span>
<span class="fc" id="L3214">        }</span>
<span class="fc" id="L3215">        return this;</span>
    }

    private static int compareFixnums(RubyFixnum o1, RubyFixnum o2) {
<span class="fc" id="L3219">        long a = o1.getLongValue();</span>
<span class="fc" id="L3220">        long b = o2.getLongValue();</span>
<span class="fc bfc" id="L3221" title="All 4 branches covered.">        return a &gt; b ? 1 : a == b ? 0 : -1;</span>
    }

    private static int compareOthers(ThreadContext context, IRubyObject o1, IRubyObject o2) {
<span class="fc" id="L3225">        IRubyObject ret = invokedynamic(context, o1, OP_CMP, o2);</span>
<span class="fc" id="L3226">        int n = RubyComparable.cmpint(context, ret, o1, o2);</span>
        //TODO: ary_sort_check should be done here
<span class="fc" id="L3228">        return n;</span>
    }

    private IRubyObject sortInternal(final ThreadContext context, final Block block) {
<span class="fc" id="L3232">        IRubyObject[] newValues = new IRubyObject[realLength];</span>
<span class="fc" id="L3233">        int length = realLength;</span>

<span class="fc" id="L3235">        safeArrayCopy(values, begin, newValues, 0, length);</span>
<span class="fc" id="L3236">        Qsort.sort(newValues, 0, length, new Comparator() {</span>
            public int compare(Object o1, Object o2) {
<span class="fc" id="L3238">                IRubyObject obj1 = (IRubyObject) o1;</span>
<span class="fc" id="L3239">                IRubyObject obj2 = (IRubyObject) o2;</span>
<span class="fc" id="L3240">                IRubyObject ret = block.yieldArray(context, getRuntime().newArray(obj1, obj2), null);</span>
                //TODO: ary_sort_check should be done here
<span class="fc" id="L3242">                return RubyComparable.cmpint(context, ret, obj1, obj2);</span>
            }
        });
        
<span class="fc" id="L3246">        values = newValues;</span>
<span class="fc" id="L3247">        begin = 0;</span>
<span class="fc" id="L3248">        realLength = length;</span>
<span class="fc" id="L3249">        return this;</span>
    }

    /** rb_ary_sort_by_bang
     * 
     */
    @JRubyMethod(name = &quot;sort_by!&quot;)
    public IRubyObject sort_by_bang(ThreadContext context, Block block) {
<span class="fc bfc" id="L3257" title="All 2 branches covered.">        if (!block.isGiven()) return enumeratorizeWithSize(context, this, &quot;sort_by!&quot;, enumLengthFn());</span>

<span class="fc" id="L3259">        modifyCheck();</span>
<span class="fc" id="L3260">        RubyArray sorted = Helpers.invoke(context, this, &quot;sort_by&quot;, block).convertToArray();</span>
<span class="fc" id="L3261">        values = sorted.values;</span>
<span class="fc" id="L3262">        isShared = false;</span>
<span class="fc" id="L3263">        begin = 0;</span>
<span class="fc" id="L3264">        return this;</span>
    }

    /** rb_ary_take
     * 
     */
    @JRubyMethod(name = &quot;take&quot;)
    public IRubyObject take(ThreadContext context, IRubyObject n) {
<span class="fc" id="L3272">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L3273">        long len = RubyNumeric.num2long(n);</span>
<span class="fc bfc" id="L3274" title="All 2 branches covered.">        if (len &lt; 0) throw runtime.newArgumentError(&quot;attempt to take negative size&quot;);</span>

<span class="fc" id="L3276">        return subseq(0, len);</span>
    }

    /** rb_ary_take_while
     * 
     */
    @JRubyMethod(name = &quot;take_while&quot;)
    public IRubyObject take_while(ThreadContext context, Block block) {
<span class="fc" id="L3284">        Ruby runtime = context.runtime;</span>
<span class="pc bpc" id="L3285" title="1 of 2 branches missed.">        if (!block.isGiven()) return enumeratorize(runtime, this, &quot;take_while&quot;);</span>

<span class="fc" id="L3287">        int i = 0;</span>
<span class="fc bfc" id="L3288" title="All 2 branches covered.">        for (; i &lt; realLength; i++) {</span>
<span class="fc bfc" id="L3289" title="All 2 branches covered.">            if (!block.yield(context, eltOk(i)).isTrue()) break;</span>
        }
<span class="fc" id="L3291">        return subseq(0, i);</span>
    }

    /** rb_ary_take
     * 
     */
    @JRubyMethod(name = &quot;drop&quot;)
    public IRubyObject drop(ThreadContext context, IRubyObject n) {
<span class="fc" id="L3299">        Ruby runtime = context.runtime;</span>
<span class="fc" id="L3300">        long pos = RubyNumeric.num2long(n);</span>
<span class="fc bfc" id="L3301" title="All 2 branches covered.">        if (pos &lt; 0) throw runtime.newArgumentError(&quot;attempt to drop negative size&quot;);</span>

<span class="fc" id="L3303">        IRubyObject result = subseq(pos, realLength);</span>
<span class="fc bfc" id="L3304" title="All 2 branches covered.">        return result.isNil() ? runtime.newEmptyArray() : result;</span>
    }

    /** rb_ary_take_while
     * 
     */
    @JRubyMethod(name = &quot;drop_while&quot;)
    public IRubyObject drop_while(ThreadContext context, Block block) {
<span class="fc" id="L3312">        Ruby runtime = context.runtime;</span>
<span class="pc bpc" id="L3313" title="1 of 2 branches missed.">        if (!block.isGiven()) return enumeratorize(runtime, this, &quot;drop_while&quot;);</span>

<span class="fc" id="L3315">        int i = 0;</span>
<span class="pc bpc" id="L3316" title="1 of 2 branches missed.">        for (; i &lt; realLength; i++) {</span>
<span class="fc bfc" id="L3317" title="All 2 branches covered.">            if (!block.yield(context, eltOk(i)).isTrue()) break;</span>
        }
<span class="fc" id="L3319">        IRubyObject result = subseq(i, realLength);</span>
<span class="pc bpc" id="L3320" title="1 of 2 branches missed.">        return result.isNil() ? runtime.newEmptyArray() : result;</span>
    }

    /** rb_ary_cycle
     * 
     */
    @JRubyMethod(name = &quot;cycle&quot;)
    public IRubyObject cycle(ThreadContext context, Block block) {
<span class="pc bpc" id="L3328" title="1 of 2 branches missed.">        if (!block.isGiven()) return enumeratorizeWithSize(context, this, &quot;cycle&quot;, cycleSizeFn(context));</span>
<span class="fc" id="L3329">        return cycleCommon(context, -1, block);</span>
    }

    /** rb_ary_cycle
     * 
     */
    @JRubyMethod(name = &quot;cycle&quot;)
    public IRubyObject cycle(ThreadContext context, IRubyObject arg, Block block) {
<span class="fc bfc" id="L3337" title="All 2 branches covered.">        if (arg.isNil()) return cycle(context, block);</span>
<span class="pc bpc" id="L3338" title="1 of 2 branches missed.">        if (!block.isGiven()) return enumeratorizeWithSize(context, this, &quot;cycle&quot;, new IRubyObject[] {arg}, cycleSizeFn(context));</span>

<span class="fc" id="L3340">        long times = RubyNumeric.num2long(arg);</span>
<span class="fc bfc" id="L3341" title="All 2 branches covered.">        if (times &lt;= 0) return context.runtime.getNil();</span>

<span class="fc" id="L3343">        return cycleCommon(context, times, block);</span>
    }

    private IRubyObject cycleCommon(ThreadContext context, long n, Block block) {
<span class="fc bfc" id="L3347" title="All 6 branches covered.">        while (realLength &gt; 0 &amp;&amp; (n &lt; 0 || 0 &lt; n--)) {</span>
<span class="fc bfc" id="L3348" title="All 2 branches covered.">            for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc" id="L3349">                block.yield(context, eltOk(i));</span>
            }
        }
<span class="fc" id="L3352">        return context.runtime.getNil();</span>
    }

    private SizeFn cycleSizeFn(final ThreadContext context) {
<span class="nc" id="L3356">        return new SizeFn() {</span>
            @Override
            public IRubyObject size(IRubyObject[] args) {
<span class="nc" id="L3359">                Ruby runtime = context.runtime;</span>
<span class="nc" id="L3360">                IRubyObject n = runtime.getNil();</span>

<span class="nc bnc" id="L3362" title="All 2 branches missed.">                if (realLength == 0) {</span>
<span class="nc" id="L3363">                    return RubyFixnum.zero(runtime);</span>
                }

<span class="nc bnc" id="L3366" title="All 4 branches missed.">                if (args != null &amp;&amp; args.length &gt; 0) {</span>
<span class="nc" id="L3367">                    n = args[0];</span>
                }

<span class="nc bnc" id="L3370" title="All 4 branches missed.">                if (n == null || n.isNil()) {</span>
<span class="nc" id="L3371">                    return RubyFloat.newFloat(runtime, RubyFloat.INFINITY);</span>
                }

<span class="nc" id="L3374">                long multiple = RubyNumeric.num2long(n);</span>
<span class="nc bnc" id="L3375" title="All 2 branches missed.">                if (multiple &lt;= 0) {</span>
<span class="nc" id="L3376">                    return RubyFixnum.zero(runtime);</span>
                }

<span class="nc" id="L3379">                return length().callMethod(context, &quot;*&quot;, RubyFixnum.newFixnum(runtime, multiple));</span>
            }
        };
    }


    /** rb_ary_product
     *
     */
    public IRubyObject product(ThreadContext context, IRubyObject[] args) {
<span class="nc" id="L3389">        return product19(context, args, Block.NULL_BLOCK);</span>
    }
    
    @JRubyMethod(name = &quot;product&quot;, rest = true)
    public IRubyObject product19(ThreadContext context, IRubyObject[] args, Block block) {
<span class="fc" id="L3394">        Ruby runtime = context.runtime;</span>

<span class="fc" id="L3396">        boolean useBlock = block.isGiven();</span>

<span class="fc" id="L3398">        int n = args.length + 1;</span>
<span class="fc" id="L3399">        RubyArray arrays[] = new RubyArray[n];</span>
<span class="fc" id="L3400">        int counters[] = new int[n];</span>

<span class="fc" id="L3402">        arrays[0] = this;</span>
<span class="fc bfc" id="L3403" title="All 2 branches covered.">        for (int i = 1; i &lt; n; i++) arrays[i] = TypeConverter.to_ary(context, args[i - 1]);</span>

<span class="fc" id="L3405">        int resultLen = 1;</span>
<span class="fc bfc" id="L3406" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L3407">            int k = arrays[i].realLength;</span>
<span class="fc" id="L3408">            int l = resultLen;</span>
<span class="fc bfc" id="L3409" title="All 4 branches covered.">            if (k == 0) return useBlock ? this : newEmptyArray(runtime);</span>
<span class="fc" id="L3410">            resultLen *= k;</span>
<span class="pc bpc" id="L3411" title="2 of 6 branches missed.">            if (resultLen &lt; k || resultLen &lt; l || resultLen / k != l) {</span>
<span class="pc bpc" id="L3412" title="1 of 2 branches missed.">                if (!block.isGiven()) throw runtime.newRangeError(&quot;too big to product&quot;);</span>
            }
        }

<span class="fc bfc" id="L3416" title="All 2 branches covered.">        RubyArray result = useBlock ? null : newArray(runtime, resultLen);</span>

<span class="fc bfc" id="L3418" title="All 2 branches covered.">        for (int i = 0; i &lt; resultLen; i++) {</span>
<span class="fc" id="L3419">            RubyArray sub = newArray(runtime, n);</span>
<span class="fc bfc" id="L3420" title="All 2 branches covered.">            for (int j = 0; j &lt; n; j++) sub.append(arrays[j].entry(counters[j]));</span>

<span class="fc bfc" id="L3422" title="All 2 branches covered.">            if (useBlock) {</span>
<span class="fc" id="L3423">                block.yieldSpecific(context, sub);</span>
            } else {
<span class="fc" id="L3425">                result.append(sub);</span>
            }
<span class="fc" id="L3427">            int m = n - 1;</span>
<span class="fc" id="L3428">            counters[m]++;</span>

<span class="fc bfc" id="L3430" title="All 4 branches covered.">            while (m &gt; 0 &amp;&amp; counters[m] == arrays[m].realLength) {</span>
<span class="fc" id="L3431">                counters[m] = 0;</span>
<span class="fc" id="L3432">                m--;</span>
<span class="fc" id="L3433">                counters[m]++;</span>
            }
        }
<span class="fc bfc" id="L3436" title="All 2 branches covered.">        return useBlock ? this : result;</span>
    }

    /** rb_ary_combination
     * 
     */
    @JRubyMethod(name = &quot;combination&quot;)
    public IRubyObject combination(ThreadContext context, IRubyObject num, Block block) {
<span class="fc" id="L3444">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L3445" title="All 2 branches covered.">        if (!block.isGiven()) return enumeratorizeWithSize(context, this, &quot;combination&quot;, new IRubyObject[]{num}, combinationSize(context));</span>

<span class="fc" id="L3447">        int n = RubyNumeric.num2int(num);</span>

<span class="fc bfc" id="L3449" title="All 2 branches covered.">        if (n == 0) {</span>
<span class="fc" id="L3450">            block.yield(context, newEmptyArray(runtime));</span>
<span class="fc bfc" id="L3451" title="All 2 branches covered.">        } else if (n == 1) {</span>
<span class="fc bfc" id="L3452" title="All 2 branches covered.">            for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc" id="L3453">                block.yield(context, newArray(runtime, eltOk(i)));</span>
            }
<span class="fc bfc" id="L3455" title="All 4 branches covered.">        } else if (n &gt;= 0 &amp;&amp; realLength &gt;= n) {</span>
<span class="fc" id="L3456">            int stack[] = new int[n + 1];</span>
<span class="fc" id="L3457">            RubyArray values = makeShared();</span>

<span class="fc" id="L3459">            combinate(context, size(), n, stack, values, block);</span>
        }

<span class="fc" id="L3462">        return this;</span>
    }

    private static void combinate(ThreadContext context, int len, int n, int[] stack, RubyArray values, Block block) {
<span class="fc" id="L3466">        int lev = 0;</span>

<span class="fc" id="L3468">        Arrays.fill(stack, 1, 1 + n, 0);</span>
<span class="fc" id="L3469">        stack[0] = -1;</span>
        for (;;) {
<span class="fc bfc" id="L3471" title="All 2 branches covered.">            for (lev++; lev &lt; n; lev++) {</span>
<span class="fc" id="L3472">                stack[lev+1] = stack[lev]+1;</span>
            }
            // TODO: MRI has a weird reentrancy check that depends on having a null class in values
<span class="fc" id="L3475">            yieldValues(context, n, stack, 1, values, block);</span>
            do {
<span class="fc bfc" id="L3477" title="All 2 branches covered.">                if (lev == 0) return;</span>
<span class="fc" id="L3478">                stack[lev--]++;</span>
<span class="fc bfc" id="L3479" title="All 2 branches covered.">            } while (stack[lev+1]+n == len+lev+1);</span>
        }
    }

    private static void rcombinate(ThreadContext context, int n, int r, int[] p, RubyArray values, Block block) {
<span class="fc" id="L3484">        int i = 0, index = 0;</span>

<span class="fc" id="L3486">        p[index] = i;</span>
        for (;;) {
<span class="fc bfc" id="L3488" title="All 2 branches covered.">            if (++index &lt; r-1) {</span>
<span class="fc" id="L3489">                p[index] = i;</span>
<span class="fc" id="L3490">                continue;</span>
            }
<span class="fc bfc" id="L3492" title="All 2 branches covered.">            for (; i &lt; n; ++i) {</span>
<span class="fc" id="L3493">                p[index] = i;</span>
                // TODO: MRI has a weird reentrancy check that depends on having a null class in values
<span class="fc" id="L3495">                yieldValues(context, r, p, 0, values, block);</span>
            }
            do {
<span class="fc bfc" id="L3498" title="All 2 branches covered.">                if (index &lt;= 0) return;</span>
<span class="fc bfc" id="L3499" title="All 2 branches covered.">            } while ((i = ++p[--index]) &gt;= n);</span>
        }
    }

    private SizeFn combinationSize(final ThreadContext context) {
<span class="fc" id="L3504">        final RubyArray self = this;</span>
<span class="pc bpc" id="L3505" title="1 of 2 branches missed.">        return new SizeFn() {</span>
            @Override
            public IRubyObject size(IRubyObject[] args) {
<span class="nc" id="L3508">                long n = self.realLength;</span>
<span class="nc bnc" id="L3509" title="All 8 branches missed.">                assert args != null &amp;&amp; args.length &gt; 0 &amp;&amp; args[0] instanceof RubyNumeric; // #combination ensures arg[0] is numeric</span>
<span class="nc" id="L3510">                long k = ((RubyNumeric) args[0]).getLongValue();</span>

<span class="nc" id="L3512">                return binomialCoefficient(context, k, n);</span>
            }
        };
    }

    private IRubyObject binomialCoefficient(ThreadContext context, long comb, long size) {
<span class="nc" id="L3518">        Ruby runtime = context.runtime;</span>
<span class="nc bnc" id="L3519" title="All 2 branches missed.">        if (comb &gt; size - comb) {</span>
<span class="nc" id="L3520">            comb = size - comb;</span>
        }

<span class="nc bnc" id="L3523" title="All 2 branches missed.">        if (comb &lt; 0) {</span>
<span class="nc" id="L3524">            return RubyFixnum.zero(runtime);</span>
        }

<span class="nc" id="L3527">        IRubyObject r = descendingFactorial(context, size, comb);</span>
<span class="nc" id="L3528">        IRubyObject v = descendingFactorial(context, comb, comb);</span>
<span class="nc" id="L3529">        return r.callMethod(context, &quot;/&quot;, v);</span>
    }

    @JRubyMethod(name = &quot;repeated_combination&quot;)
    public IRubyObject repeatedCombination(ThreadContext context, IRubyObject num, Block block) {
<span class="fc" id="L3534">        Ruby runtime = context.runtime;</span>
<span class="fc bfc" id="L3535" title="All 2 branches covered.">        if (!block.isGiven()) return enumeratorizeWithSize(context, this, &quot;repeated_combination&quot;, new IRubyObject[] { num }, repeatedCombinationSize(context));</span>

<span class="fc" id="L3537">        int n = RubyNumeric.num2int(num);</span>
<span class="fc" id="L3538">        int len = realLength;</span>

<span class="fc bfc" id="L3540" title="All 2 branches covered.">        if (n &lt; 0) {</span>
            // yield nothing
<span class="fc bfc" id="L3542" title="All 2 branches covered.">        } else if (n == 0) {</span>
<span class="fc" id="L3543">            block.yield(context, newEmptyArray(runtime));</span>
<span class="fc bfc" id="L3544" title="All 2 branches covered.">        } else if (n == 1) {</span>
<span class="fc bfc" id="L3545" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L3546">                block.yield(context, newArray(runtime, eltOk(i)));</span>
            }
        } else {
<span class="fc" id="L3549">            int[] p = new int[n];</span>
<span class="fc" id="L3550">            RubyArray values = makeShared();</span>
<span class="fc" id="L3551">            rcombinate(context, len, n, p, values, block);</span>
        }

<span class="fc" id="L3554">        return this;</span>
    }

    private SizeFn repeatedCombinationSize(final ThreadContext context) {
<span class="fc" id="L3558">        final RubyArray self = this;</span>
<span class="pc bpc" id="L3559" title="1 of 2 branches missed.">        return new SizeFn() {</span>
            @Override
            public IRubyObject size(IRubyObject[] args) {
<span class="nc" id="L3562">                long n = self.realLength;</span>
<span class="nc bnc" id="L3563" title="All 8 branches missed.">                assert args != null &amp;&amp; args.length &gt; 0 &amp;&amp; args[0] instanceof RubyNumeric; // #repeated_combination ensures arg[0] is numeric</span>
<span class="nc" id="L3564">                long k = ((RubyNumeric) args[0]).getLongValue();</span>

<span class="nc bnc" id="L3566" title="All 2 branches missed.">                if (k == 0) {</span>
<span class="nc" id="L3567">                    return RubyFixnum.one(context.runtime);</span>
                }

<span class="nc" id="L3570">                return binomialCoefficient(context, k, n + k - 1);</span>
            }
        };
    }

    private static void permute(ThreadContext context, int n, int r, int[] p, boolean[] used, RubyArray values, Block block) {
<span class="fc" id="L3576">        int i = 0, index = 0;</span>
        for (;;) {
<span class="fc" id="L3578">            int unused = Helpers.memchr(used, i, n - i, false);</span>
<span class="fc bfc" id="L3579" title="All 2 branches covered.">            if (unused == -1) {</span>
<span class="fc bfc" id="L3580" title="All 2 branches covered.">                if (index == 0) break;</span>
<span class="fc" id="L3581">                i = p[--index];</span>
<span class="fc" id="L3582">                used[i++] = false;</span>
            } else {
<span class="fc" id="L3584">                i = unused;</span>
<span class="fc" id="L3585">                p[index] = i;</span>
<span class="fc" id="L3586">                used[i] = true;</span>
<span class="fc" id="L3587">                index++;</span>
<span class="fc bfc" id="L3588" title="All 2 branches covered.">                if (index &lt; r - 1) {</span>
<span class="fc" id="L3589">                    p[index] = i = 0;</span>
<span class="fc" id="L3590">                    continue;</span>
                }
<span class="fc bfc" id="L3592" title="All 2 branches covered.">                for (i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L3593" title="All 2 branches covered.">                    if (used[i]) continue;</span>
<span class="fc" id="L3594">                    p[index] = i;</span>
                    // TODO: MRI has a weird reentrancy check that depends on having a null class in values
<span class="fc" id="L3596">                    yieldValues(context, r, p, 0, values, block);</span>
                }
            }
<span class="fc" id="L3599">        }</span>
<span class="fc" id="L3600">    }</span>

    private static void yieldValues(ThreadContext context, int r, int[] p, int pStart, RubyArray values, Block block) {
<span class="fc" id="L3603">        RubyArray result = newArray(context.runtime, r);</span>

<span class="fc bfc" id="L3605" title="All 2 branches covered.">        for (int j = 0; j &lt; r; j++) {</span>
<span class="fc" id="L3606">            result.values[result.begin + j] = values.values[values.begin + p[j + pStart]];</span>
        }

<span class="fc" id="L3609">        result.realLength = r;</span>
<span class="fc" id="L3610">        block.yield(context, result);</span>
<span class="fc" id="L3611">    }</span>

    private static void rpermute(ThreadContext context, int n, int r, int[] p, RubyArray values, Block block) {
<span class="fc" id="L3614">        int i = 0, index = 0;</span>

<span class="fc" id="L3616">        p[index] = i;</span>
        for (;;) {
<span class="fc bfc" id="L3618" title="All 2 branches covered.">            if (++index &lt; r-1) {</span>
<span class="fc" id="L3619">                p[index] = i = 0;</span>
<span class="fc" id="L3620">                continue;</span>
            }
<span class="fc bfc" id="L3622" title="All 2 branches covered.">            for (i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L3623">                p[index] = i;</span>
                // TODO: MRI has a weird reentrancy check that depends on having a null class in values
<span class="fc" id="L3625">                yieldValues(context, r, p, 0, values, block);</span>
            }
            do {
<span class="fc bfc" id="L3628" title="All 2 branches covered.">                if (index &lt;= 0) return;</span>
<span class="fc bfc" id="L3629" title="All 2 branches covered.">            } while ((i = ++p[--index]) &gt;= n);</span>
        }
    }

    /** rb_ary_permutation
     * 
     */
    @JRubyMethod(name = &quot;permutation&quot;)
    public IRubyObject permutation(ThreadContext context, IRubyObject num, Block block) {
<span class="fc bfc" id="L3638" title="All 2 branches covered.">        return block.isGiven() ? permutationCommon(context, RubyNumeric.num2int(num), false, block) : enumeratorizeWithSize(context, this, &quot;permutation&quot;, new IRubyObject[] { num }, permutationSize(context));</span>
    }

    @JRubyMethod(name = &quot;permutation&quot;)
    public IRubyObject permutation(ThreadContext context, Block block) {
<span class="fc bfc" id="L3643" title="All 2 branches covered.">        return block.isGiven() ? permutationCommon(context, realLength, false, block) : enumeratorizeWithSize(context, this, &quot;permutation&quot;, permutationSize(context));</span>
    }

    @JRubyMethod(name = &quot;repeated_permutation&quot;)
    public IRubyObject repeated_permutation(ThreadContext context, IRubyObject num, Block block) {
<span class="fc bfc" id="L3648" title="All 2 branches covered.">        return block.isGiven() ? permutationCommon(context, RubyNumeric.num2int(num), true, block) : enumeratorizeWithSize(context, this, &quot;repeated_permutation&quot;, new IRubyObject[]{num}, repeatedPermutationSize(context));</span>
    }

    private SizeFn repeatedPermutationSize(final ThreadContext context) {
<span class="fc" id="L3652">        final Ruby runtime = context.runtime;</span>
<span class="fc" id="L3653">        final RubyArray self = this;</span>

<span class="pc bpc" id="L3655" title="1 of 2 branches missed.">        return new SizeFn() {</span>
            @Override
            public IRubyObject size(IRubyObject[] args) {
<span class="nc" id="L3658">                RubyFixnum n = self.length();</span>
<span class="nc bnc" id="L3659" title="All 8 branches missed.">                assert args != null &amp;&amp; args.length &gt; 0 &amp;&amp; args[0] instanceof RubyNumeric; // #repeated_permutation ensures arg[0] is numeric</span>
<span class="nc" id="L3660">                long k = ((RubyNumeric) args[0]).getLongValue();</span>

<span class="nc bnc" id="L3662" title="All 2 branches missed.">                if (k &lt; 0) {</span>
<span class="nc" id="L3663">                    return RubyFixnum.zero(runtime);</span>
                }

<span class="nc" id="L3666">                RubyFixnum v = RubyFixnum.newFixnum(runtime, k);</span>
<span class="nc" id="L3667">                return n.callMethod(context, &quot;**&quot;, v);</span>
            }
        };
    }

    private IRubyObject permutationCommon(ThreadContext context, int r, boolean repeat, Block block) {
<span class="fc bfc" id="L3673" title="All 2 branches covered.">        if (r == 0) {</span>
<span class="fc" id="L3674">            block.yield(context, newEmptyArray(context.runtime));</span>
<span class="fc bfc" id="L3675" title="All 2 branches covered.">        } else if (r == 1) {</span>
<span class="fc bfc" id="L3676" title="All 2 branches covered.">            for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc" id="L3677">                block.yield(context, newArray(context.runtime, eltOk(i)));</span>
            }
<span class="pc bpc" id="L3679" title="1 of 2 branches missed.">        } else if (r &gt;= 0) {</span>
<span class="fc" id="L3680">            int n = realLength;</span>
<span class="fc bfc" id="L3681" title="All 2 branches covered.">            if (repeat) {</span>
<span class="fc" id="L3682">                rpermute(context, n, r,</span>
                        new int[r],
<span class="fc" id="L3684">                        makeShared(begin, n, getMetaClass()), block);</span>
            } else {
<span class="fc" id="L3686">                permute(context, n, r,</span>
                        new int[r],
                        new boolean[n],
<span class="fc" id="L3689">                        makeShared(begin, n, getMetaClass()),</span>
                        block);
            }
        }
<span class="fc" id="L3693">        return this;</span>
    }

    private SizeFn permutationSize(final ThreadContext context) {
<span class="fc" id="L3697">        final RubyArray self = this;</span>

<span class="pc bpc" id="L3699" title="1 of 2 branches missed.">        return new SizeFn() {</span>
            @Override
            public IRubyObject size(IRubyObject[] args) {
<span class="nc" id="L3702">                long n = self.realLength;</span>
                long k;

<span class="nc bnc" id="L3705" title="All 4 branches missed.">                if (args != null &amp;&amp; args.length &gt; 0) {</span>
<span class="nc bnc" id="L3706" title="All 4 branches missed.">                    assert args[0] instanceof RubyNumeric; // #permutation ensures arg[0] is numeric</span>
<span class="nc" id="L3707">                    k = ((RubyNumeric) args[0]).getLongValue();</span>
                } else {
<span class="nc" id="L3709">                    k = n;</span>
                }

<span class="nc" id="L3712">                return descendingFactorial(context, n, k);</span>
            }
        };
    }

    private IRubyObject descendingFactorial(ThreadContext context, long from, long howMany) {
<span class="nc" id="L3718">        Ruby runtime = context.runtime;</span>
<span class="nc bnc" id="L3719" title="All 2 branches missed.">        IRubyObject cnt = howMany &gt;= 0 ? RubyFixnum.one(runtime) : RubyFixnum.zero(runtime);</span>
<span class="nc bnc" id="L3720" title="All 2 branches missed.">        while (howMany-- &gt; 0) {</span>
<span class="nc" id="L3721">            RubyFixnum v = RubyFixnum.newFixnum(runtime, from--);</span>
<span class="nc" id="L3722">            cnt = cnt.callMethod(context, &quot;*&quot;, v);</span>
<span class="nc" id="L3723">        }</span>
<span class="nc" id="L3724">        return cnt;</span>
    }

    @Deprecated
    public IRubyObject choice(ThreadContext context) {
<span class="nc bnc" id="L3729" title="All 2 branches missed.">        if (realLength == 0) {</span>
<span class="nc" id="L3730">            return context.nil;</span>
        }
<span class="nc" id="L3732">        return eltOk((int) (context.runtime.getDefaultRand().genrandReal() * realLength));</span>
    }

    public IRubyObject shuffle_bang(ThreadContext context) {
<span class="nc" id="L3736">        return shuffle_bang(context, IRubyObject.NULL_ARRAY);</span>
    }

    @JRubyMethod(name = &quot;shuffle!&quot;, optional = 1)
    public IRubyObject shuffle_bang(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L3741">        modify();</span>
<span class="fc" id="L3742">        IRubyObject randgen = context.runtime.getRandomClass();</span>
<span class="fc bfc" id="L3743" title="All 2 branches covered.">        if (args.length &gt; 0) {</span>
<span class="fc" id="L3744">            IRubyObject hash = TypeConverter.checkHashType(context.runtime, args[args.length - 1]);</span>
<span class="pc bpc" id="L3745" title="1 of 2 branches missed.">            if (!hash.isNil()) {</span>
<span class="fc" id="L3746">                IRubyObject argRandgen = ((RubyHash) hash).fastARef(context.runtime.newSymbol(&quot;random&quot;));</span>
<span class="fc bfc" id="L3747" title="All 2 branches covered.">                if (argRandgen != null) {</span>
<span class="fc" id="L3748">                    randgen = argRandgen;</span>
                }
            }
        }
<span class="fc" id="L3752">        int i = realLength;</span>
        try {
<span class="fc bfc" id="L3754" title="All 2 branches covered.">            while (i &gt; 0) {</span>
<span class="fc" id="L3755">                int r = (int) (RubyRandom.randomReal(context, randgen) * i);</span>
<span class="fc" id="L3756">                IRubyObject tmp = eltOk(--i);</span>
<span class="fc" id="L3757">                values[begin + i] = eltOk(r);</span>
<span class="fc" id="L3758">                values[begin + r] = tmp;</span>
<span class="fc" id="L3759">            }</span>
<span class="nc" id="L3760">        } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L3761">            concurrentModification();</span>
<span class="fc" id="L3762">        }</span>

<span class="fc" id="L3764">        return this;</span>
    }

    public IRubyObject shuffle(ThreadContext context) {
<span class="nc" id="L3768">        return shuffle(context, IRubyObject.NULL_ARRAY);</span>
    }

    @JRubyMethod(name = &quot;shuffle&quot;, optional = 1)
    public IRubyObject shuffle(ThreadContext context, IRubyObject[] args) {
<span class="fc" id="L3773">        RubyArray ary = aryDup();</span>
<span class="fc" id="L3774">        ary.shuffle_bang(context, args);</span>
<span class="fc" id="L3775">        return ary;</span>
    }

<span class="fc" id="L3778">    private static int SORTED_THRESHOLD = 10; </span>
    @JRubyMethod(name = &quot;sample&quot;, optional = 2)
    public IRubyObject sample(ThreadContext context, IRubyObject[] args) {
        try {
<span class="fc" id="L3782">            IRubyObject randgen = context.runtime.getRandomClass();</span>
<span class="fc bfc" id="L3783" title="All 2 branches covered.">            if (args.length == 0) {</span>
<span class="fc bfc" id="L3784" title="All 2 branches covered.">                if (realLength == 0)</span>
<span class="fc" id="L3785">                    return context.nil;</span>
<span class="pc bpc" id="L3786" title="1 of 2 branches missed.">                int i = realLength == 1 ? 0 : randomReal(context, randgen, realLength);</span>
<span class="fc" id="L3787">                return eltOk(i);</span>
            }
<span class="pc bpc" id="L3789" title="1 of 2 branches missed.">            if (args.length &gt; 0) {</span>
<span class="fc" id="L3790">                IRubyObject hash = TypeConverter.checkHashType(context.runtime,</span>
                        args[args.length - 1]);
<span class="fc bfc" id="L3792" title="All 2 branches covered.">                if (!hash.isNil()) {</span>
<span class="fc" id="L3793">                    IRubyObject argRandgen = ((RubyHash) hash).fastARef(context.runtime.newSymbol(&quot;random&quot;));</span>
<span class="fc bfc" id="L3794" title="All 2 branches covered.">                    if (argRandgen != null) {</span>
<span class="fc" id="L3795">                        randgen = argRandgen;</span>
                    }
<span class="fc" id="L3797">                    IRubyObject[] newargs = new IRubyObject[args.length - 1];</span>
<span class="fc" id="L3798">                    System.arraycopy(args, 0, newargs, 0, args.length - 1);</span>
<span class="fc" id="L3799">                    args = newargs;</span>
                }
            }
<span class="fc bfc" id="L3802" title="All 2 branches covered.">            if (args.length == 0) {</span>
<span class="pc bpc" id="L3803" title="1 of 2 branches missed.">                if (realLength == 0) {</span>
<span class="nc" id="L3804">                    return context.nil;</span>
<span class="pc bpc" id="L3805" title="1 of 2 branches missed.">                } else if (realLength == 1) {</span>
<span class="nc" id="L3806">                    return eltOk(0);</span>
                }
<span class="fc" id="L3808">                return eltOk(randomReal(context, randgen, realLength));</span>
            }
<span class="fc" id="L3810">            Ruby runtime = context.runtime;</span>
<span class="fc" id="L3811">            int n = RubyNumeric.num2int(args[0]);</span>

<span class="fc bfc" id="L3813" title="All 2 branches covered.">            if (n &lt; 0)</span>
<span class="fc" id="L3814">                throw runtime.newArgumentError(&quot;negative sample number&quot;);</span>
<span class="fc bfc" id="L3815" title="All 2 branches covered.">            if (n &gt; realLength)</span>
<span class="fc" id="L3816">                n = realLength;</span>
<span class="fc" id="L3817">            double[] rnds = new double[SORTED_THRESHOLD];</span>
<span class="pc bpc" id="L3818" title="1 of 2 branches missed.">            if (n &lt;= SORTED_THRESHOLD) {</span>
<span class="fc bfc" id="L3819" title="All 2 branches covered.">                for (int idx = 0; idx &lt; n; ++idx) {</span>
<span class="fc" id="L3820">                    rnds[idx] = RubyRandom.randomReal(context, randgen);</span>
                }
            }

            int i, j, k;
<span class="pc bpc" id="L3825" title="1 of 5 branches missed.">            switch (n) {</span>
            case 0:
<span class="fc" id="L3827">                return newEmptyArray(runtime);</span>
            case 1:
<span class="nc bnc" id="L3829" title="All 2 branches missed.">                if (realLength &lt;= 0)</span>
<span class="nc" id="L3830">                    return newEmptyArray(runtime);</span>

<span class="nc" id="L3832">                return newArray(runtime, eltOk((int) (rnds[0] * realLength)));</span>
            case 2:
<span class="fc" id="L3834">                i = (int) (rnds[0] * realLength);</span>
<span class="fc" id="L3835">                j = (int) (rnds[1] * (realLength - 1));</span>
<span class="fc bfc" id="L3836" title="All 2 branches covered.">                if (j &gt;= i)</span>
<span class="fc" id="L3837">                    j++;</span>
<span class="fc" id="L3838">                return newArray(runtime, eltOk(i), eltOk(j));</span>
            case 3:
<span class="fc" id="L3840">                i = (int) (rnds[0] * realLength);</span>
<span class="fc" id="L3841">                j = (int) (rnds[1] * (realLength - 1));</span>
<span class="fc" id="L3842">                k = (int) (rnds[2] * (realLength - 2));</span>
<span class="fc" id="L3843">                int l = j,</span>
<span class="fc" id="L3844">                g = i;</span>
<span class="fc bfc" id="L3845" title="All 2 branches covered.">                if (j &gt;= i) {</span>
<span class="fc" id="L3846">                    l = i;</span>
<span class="fc" id="L3847">                    g = ++j;</span>
                }
<span class="pc bpc" id="L3849" title="1 of 4 branches missed.">                if (k &gt;= l &amp;&amp; (++k &gt;= g))</span>
<span class="nc" id="L3850">                    ++k;</span>
<span class="fc" id="L3851">                return new RubyArray(runtime, new IRubyObject[] { eltOk(i),</span>
<span class="fc" id="L3852">                        eltOk(j), eltOk(k) });</span>
            }

<span class="fc" id="L3855">            int len = realLength;</span>
<span class="pc bpc" id="L3856" title="1 of 2 branches missed.">            if (n &gt; len)</span>
<span class="nc" id="L3857">                n = len;</span>
<span class="pc bpc" id="L3858" title="1 of 2 branches missed.">            if (n &lt; SORTED_THRESHOLD) {</span>
<span class="fc" id="L3859">                int idx[] = new int[SORTED_THRESHOLD];</span>
<span class="fc" id="L3860">                int sorted[] = new int[SORTED_THRESHOLD];</span>
<span class="fc" id="L3861">                sorted[0] = idx[0] = (int) (rnds[0] * len);</span>
<span class="fc bfc" id="L3862" title="All 2 branches covered.">                for (i = 1; i &lt; n; i++) {</span>
<span class="fc" id="L3863">                    k = (int) (rnds[i] * --len);</span>
<span class="fc bfc" id="L3864" title="All 2 branches covered.">                    for (j = 0; j &lt; i; j++) {</span>
<span class="fc bfc" id="L3865" title="All 2 branches covered.">                        if (k &lt; sorted[j])</span>
<span class="fc" id="L3866">                            break;</span>
<span class="fc" id="L3867">                        k++;</span>
                    }
<span class="fc" id="L3869">                    System.arraycopy(sorted, j, sorted, j + 1, i - j);</span>
<span class="fc" id="L3870">                    sorted[j] = idx[i] = k;</span>
                }
<span class="fc" id="L3872">                IRubyObject[] result = new IRubyObject[n];</span>
<span class="fc bfc" id="L3873" title="All 2 branches covered.">                for (i = 0; i &lt; n; i++)</span>
<span class="fc" id="L3874">                    result[i] = eltOk(idx[i]);</span>
<span class="fc" id="L3875">                return new RubyArray(runtime, result);</span>
            } else {
<span class="nc" id="L3877">                IRubyObject[] result = new IRubyObject[len];</span>
<span class="nc" id="L3878">                System.arraycopy(values, begin, result, 0, len);</span>
<span class="nc bnc" id="L3879" title="All 2 branches missed.">                for (i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L3880">                    j = randomReal(context, randgen, len - i) + i;</span>
<span class="nc" id="L3881">                    IRubyObject tmp = result[j];</span>
<span class="nc" id="L3882">                    result[j] = result[i];</span>
<span class="nc" id="L3883">                    result[i] = tmp;</span>
                }
<span class="nc" id="L3885">                RubyArray ary = new RubyArray(runtime, result);</span>
<span class="nc" id="L3886">                ary.realLength = n;</span>
<span class="nc" id="L3887">                return ary;</span>
            }
<span class="nc" id="L3889">        } catch (ArrayIndexOutOfBoundsException aioob) {</span>
<span class="nc" id="L3890">            concurrentModification();</span>
<span class="nc" id="L3891">            return this; // not reached</span>
        }
    }

    private int randomReal(ThreadContext context, IRubyObject randgen, int len) {
<span class="fc" id="L3896">        return (int) (RubyRandom.randomReal(context, randgen) * len);</span>
    }

    private static void aryReverse(IRubyObject[] _p1, int p1, IRubyObject[] _p2, int p2) {
<span class="fc bfc" id="L3900" title="All 2 branches covered.">        while(p1 &lt; p2) {</span>
<span class="fc" id="L3901">            IRubyObject tmp = _p1[p1];</span>
<span class="fc" id="L3902">            _p1[p1++] = _p2[p2];</span>
<span class="fc" id="L3903">            _p2[p2--] = tmp;</span>
<span class="fc" id="L3904">        }</span>
<span class="fc" id="L3905">    }</span>

    private IRubyObject internalRotateBang(ThreadContext context, int cnt) {
<span class="fc" id="L3908">        modify();</span>

        try {
<span class="pc bpc" id="L3911" title="1 of 2 branches missed.">            if(cnt != 0) {</span>
<span class="fc" id="L3912">                IRubyObject[] ptr = values;</span>
<span class="fc" id="L3913">                int len = realLength;</span>

<span class="fc bfc" id="L3915" title="All 4 branches covered.">                if(len &gt; 0 &amp;&amp; (cnt = rotateCount(cnt, len)) &gt; 0) {</span>
<span class="fc" id="L3916">                    --len;</span>
<span class="fc bfc" id="L3917" title="All 2 branches covered.">                    if(cnt &lt; len) aryReverse(ptr, begin + cnt, ptr, begin + len);</span>
<span class="fc bfc" id="L3918" title="All 2 branches covered.">                    if(--cnt &gt; 0) aryReverse(ptr, begin, ptr, begin + cnt);</span>
<span class="pc bpc" id="L3919" title="1 of 2 branches missed.">                    if(len &gt; 0)   aryReverse(ptr, begin, ptr, begin + len);</span>
<span class="fc" id="L3920">                    return this;</span>
                }
            }
<span class="nc" id="L3923">        } catch (ArrayIndexOutOfBoundsException aioob) {</span>
<span class="nc" id="L3924">            concurrentModification();</span>
<span class="fc" id="L3925">        }</span>
        
<span class="fc" id="L3927">        return context.runtime.getNil();</span>
    }

    private static int rotateCount(int cnt, int len) {
<span class="fc bfc" id="L3931" title="All 2 branches covered.">        return (cnt &lt; 0) ? (len - (~cnt % len) - 1) : (cnt % len);</span>
    }

    private IRubyObject internalRotate(ThreadContext context, int cnt) {
<span class="fc" id="L3935">        int len = realLength;</span>
<span class="fc" id="L3936">        RubyArray rotated = aryDup();</span>
<span class="fc" id="L3937">        rotated.modify();</span>

        try {
<span class="fc bfc" id="L3940" title="All 2 branches covered.">            if(len &gt; 0) {</span>
<span class="fc" id="L3941">                cnt = rotateCount(cnt, len);</span>
<span class="fc" id="L3942">                IRubyObject[] ptr = this.values;</span>
<span class="fc" id="L3943">                IRubyObject[] ptr2 = rotated.values;</span>
<span class="fc" id="L3944">                len -= cnt;</span>
<span class="fc" id="L3945">                System.arraycopy(ptr, begin + cnt, ptr2, 0, len);</span>
<span class="fc" id="L3946">                System.arraycopy(ptr, begin, ptr2, len, cnt);</span>
            }
<span class="nc" id="L3948">        } catch (ArrayIndexOutOfBoundsException aioob) {</span>
<span class="nc" id="L3949">            concurrentModification();</span>
<span class="fc" id="L3950">        }</span>
        
<span class="fc" id="L3952">        return rotated;</span>
    }

    @JRubyMethod(name = &quot;rotate!&quot;)
    public IRubyObject rotate_bang(ThreadContext context) {
<span class="fc" id="L3957">        internalRotateBang(context, 1);</span>
<span class="fc" id="L3958">        return this;</span>
    }

    @JRubyMethod(name = &quot;rotate!&quot;)
    public IRubyObject rotate_bang(ThreadContext context, IRubyObject cnt) {
<span class="fc" id="L3963">        internalRotateBang(context, RubyNumeric.fix2int(cnt));</span>
<span class="fc" id="L3964">        return this;</span>
    }

    @JRubyMethod(name = &quot;rotate&quot;)
    public IRubyObject rotate(ThreadContext context) {
<span class="fc" id="L3969">        return internalRotate(context, 1);</span>
    }

    @JRubyMethod(name = &quot;rotate&quot;)
    public IRubyObject rotate(ThreadContext context, IRubyObject cnt) {
<span class="fc" id="L3974">        return internalRotate(context, RubyNumeric.fix2int(cnt));</span>
    }


    // Enumerable direct implementations (non-&quot;each&quot; versions)
    public IRubyObject all_p(ThreadContext context, Block block) {
<span class="pc bpc" id="L3980" title="1 of 2 branches missed.">        if (!isBuiltin(&quot;each&quot;)) return RubyEnumerable.all_pCommon(context, this, block, Arity.OPTIONAL);</span>
<span class="fc bfc" id="L3981" title="All 2 branches covered.">        if (!block.isGiven()) return all_pBlockless(context);</span>

<span class="fc bfc" id="L3983" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc bfc" id="L3984" title="All 2 branches covered.">            if (!block.yield(context, eltOk(i)).isTrue()) return context.runtime.getFalse();</span>
        }

<span class="fc" id="L3987">        return context.runtime.getTrue();</span>
    }

    private IRubyObject all_pBlockless(ThreadContext context) {
<span class="fc bfc" id="L3991" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc bfc" id="L3992" title="All 2 branches covered.">            if (!eltOk(i).isTrue()) return context.runtime.getFalse();</span>
        }

<span class="fc" id="L3995">        return context.runtime.getTrue();</span>
    }

    public IRubyObject any_p(ThreadContext context, Block block) {
<span class="pc bpc" id="L3999" title="1 of 2 branches missed.">        if (!isBuiltin(&quot;each&quot;)) return RubyEnumerable.any_pCommon(context, this, block, Arity.OPTIONAL);</span>
<span class="fc bfc" id="L4000" title="All 2 branches covered.">        if (!block.isGiven()) return any_pBlockless(context);</span>

<span class="fc bfc" id="L4002" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc bfc" id="L4003" title="All 2 branches covered.">            if (block.yield(context, eltOk(i)).isTrue()) return context.runtime.getTrue();</span>
        }

<span class="fc" id="L4006">        return context.runtime.getFalse();</span>
    }

    private IRubyObject any_pBlockless(ThreadContext context) {
<span class="fc bfc" id="L4010" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc bfc" id="L4011" title="All 2 branches covered.">            if (eltOk(i).isTrue()) return context.runtime.getTrue();</span>
        }

<span class="fc" id="L4014">        return context.runtime.getFalse();</span>
    }

    public IRubyObject find(ThreadContext context, IRubyObject ifnone, Block block) {
<span class="pc bpc" id="L4018" title="1 of 2 branches missed.">        if (!isBuiltin(&quot;each&quot;)) return RubyEnumerable.detectCommon(context, this, block);</span>

<span class="fc" id="L4020">        return detectCommon(context, ifnone, block);</span>
    }

    public IRubyObject find_index(ThreadContext context, Block block) {
<span class="nc bnc" id="L4024" title="All 2 branches missed.">        if (!isBuiltin(&quot;each&quot;)) return RubyEnumerable.find_indexCommon(context, this, block, Arity.OPTIONAL);</span>

<span class="nc bnc" id="L4026" title="All 2 branches missed.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="nc bnc" id="L4027" title="All 2 branches missed.">            if (block.yield(context, eltOk(i)).isTrue()) return context.runtime.newFixnum(i);</span>
        }

<span class="nc" id="L4030">        return context.runtime.getNil();</span>
    }

    public IRubyObject find_index(ThreadContext context, IRubyObject cond) {
<span class="nc bnc" id="L4034" title="All 2 branches missed.">        if (!isBuiltin(&quot;each&quot;)) return RubyEnumerable.find_indexCommon(context, this, cond);</span>

<span class="nc bnc" id="L4036" title="All 2 branches missed.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="nc bnc" id="L4037" title="All 2 branches missed.">            if (eltOk(i).equals(cond)) return context.runtime.newFixnum(i);</span>
        }

<span class="nc" id="L4040">        return context.runtime.getNil();</span>
    }

    public IRubyObject detectCommon(ThreadContext context, IRubyObject ifnone, Block block) {
<span class="fc bfc" id="L4044" title="All 2 branches covered.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="fc" id="L4045">            IRubyObject value = eltOk(i);</span>

<span class="fc bfc" id="L4047" title="All 2 branches covered.">            if (block.yield(context, value).isTrue()) return value;</span>
        }

<span class="fc bfc" id="L4050" title="All 2 branches covered.">        return ifnone != null ? ifnone.callMethod(context, &quot;call&quot;) : </span>
<span class="fc" id="L4051">            context.runtime.getNil();</span>
    }

    public static void marshalTo(RubyArray array, MarshalStream output) throws IOException {
<span class="fc" id="L4055">        output.registerLinkTarget(array);</span>
        
<span class="fc" id="L4057">        int length = array.realLength;</span>
<span class="fc" id="L4058">        int begin = array.begin;</span>
<span class="fc" id="L4059">        IRubyObject[] ary = array.values;</span>
        
<span class="fc" id="L4061">        output.writeInt(length);</span>
        try {
<span class="fc bfc" id="L4063" title="All 2 branches covered.">            for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L4064">                output.dumpObject(ary[i + begin]);</span>
            }
<span class="nc" id="L4066">        } catch (ArrayIndexOutOfBoundsException aioob) {</span>
<span class="nc" id="L4067">            concurrentModification(array.getRuntime());</span>
<span class="fc" id="L4068">        }</span>
<span class="fc" id="L4069">    }</span>

    public static RubyArray unmarshalFrom(UnmarshalStream input) throws IOException {
<span class="fc" id="L4072">        int size = input.unmarshalInt();</span>
        
        // we create this now with an empty, nulled array so it's available for links in the marshal data
<span class="fc" id="L4075">        RubyArray result = input.getRuntime().newArray(size);</span>

<span class="fc" id="L4077">        input.registerLinkTarget(result);</span>

<span class="fc bfc" id="L4079" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L4080">            result.append(input.unmarshalObject());</span>
        }

<span class="fc" id="L4083">        return result;</span>
    }

    @JRubyMethod(name = &quot;try_convert&quot;, meta = true)
    public static IRubyObject try_convert(ThreadContext context, IRubyObject self, IRubyObject arg) {
<span class="fc" id="L4088">        return arg.checkArrayType();</span>
    }

    @JRubyMethod(name = &quot;pack&quot;, required = 1)
    public RubyString pack(ThreadContext context, IRubyObject obj) {
<span class="fc" id="L4093">        RubyString iFmt = obj.convertToString();</span>
        try {
<span class="fc" id="L4095">            return Pack.pack(context, context.runtime, this, iFmt);</span>
<span class="nc" id="L4096">        } catch (ArrayIndexOutOfBoundsException aioob) {</span>
<span class="nc" id="L4097">            concurrentModification();</span>
<span class="nc" id="L4098">            return null; // not reached</span>
        }
    }

    @Override
    public Class getJavaClass() {
<span class="nc" id="L4104">        return List.class;</span>
    }
    
    /**
     * Copy the values contained in this array into the target array at the specified offset.
     * It is expected that the target array is large enough to hold all necessary values.
     */
    public void copyInto(IRubyObject[] target, int start) {
<span class="pc bpc" id="L4112" title="3 of 4 branches missed.">        assert target.length - start &gt;= realLength;</span>
<span class="fc" id="L4113">        safeArrayCopy(values, begin, target, start, realLength);</span>
<span class="fc" id="L4114">    }</span>

    // Satisfy java.util.List interface (for Java integration)
    public int size() {
<span class="fc" id="L4118">        return realLength;</span>
    }

    public boolean isEmpty() {
<span class="fc bfc" id="L4122" title="All 2 branches covered.">        return realLength == 0;</span>
    }

    public boolean contains(Object element) {
<span class="nc bnc" id="L4126" title="All 2 branches missed.">        return indexOf(element) != -1;</span>
    }

    public Object[] toArray() {
        // no catch for ArrayIndexOutOfBounds here because this impls a List method
<span class="nc" id="L4131">        Object[] array = new Object[realLength];</span>
<span class="nc bnc" id="L4132" title="All 2 branches missed.">        for (int i = 0; i &lt; realLength; i++) {</span>
<span class="nc" id="L4133">            array[i] = values[i + begin].toJava(Object.class);</span>
        }
<span class="nc" id="L4135">        return array;</span>
    }

    public Object[] toArray(final Object[] arg) {
        // no catch for ArrayIndexOutOfBounds here because this impls a List method
<span class="fc" id="L4140">        Object[] array = arg;</span>
<span class="fc" id="L4141">        Class type = array.getClass().getComponentType();</span>
<span class="pc bpc" id="L4142" title="1 of 2 branches missed.">        if (array.length &lt; realLength) {</span>
<span class="nc" id="L4143">            array = (Object[]) Array.newInstance(type, realLength);</span>
        }
<span class="fc" id="L4145">        int length = realLength - begin;</span>

<span class="fc bfc" id="L4147" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L4148">            array[i] = values[i + begin].toJava(type);</span>
        }
<span class="fc" id="L4150">        return array;</span>
    }

    @Override
    public Object toJava(Class target) {
<span class="nc bnc" id="L4155" title="All 2 branches missed.">        if (target.isArray()) {</span>
<span class="nc" id="L4156">            Class type = target.getComponentType();</span>
<span class="nc" id="L4157">            Object rawJavaArray = Array.newInstance(type, realLength);</span>
            try {
<span class="nc" id="L4159">                ArrayUtils.copyDataToJavaArrayDirect(getRuntime().getCurrentContext(), this, rawJavaArray);</span>
<span class="nc" id="L4160">            } catch (ArrayIndexOutOfBoundsException aioob) {</span>
<span class="nc" id="L4161">                concurrentModification();</span>
<span class="nc" id="L4162">            }</span>
<span class="nc" id="L4163">            return rawJavaArray;</span>
        } else {
<span class="nc" id="L4165">            return super.toJava(target);</span>
        }
    }

    public boolean add(Object element) {
<span class="fc" id="L4170">        append(JavaUtil.convertJavaToUsableRubyObject(getRuntime(), element));</span>
<span class="fc" id="L4171">        return true;</span>
    }

    public boolean remove(Object element) {
<span class="nc" id="L4175">        Ruby runtime = getRuntime();</span>
<span class="nc" id="L4176">        ThreadContext context = runtime.getCurrentContext();</span>
<span class="nc" id="L4177">        IRubyObject item = JavaUtil.convertJavaToUsableRubyObject(runtime, element);</span>
<span class="nc" id="L4178">        boolean listchanged = false;</span>

<span class="nc bnc" id="L4180" title="All 2 branches missed.">        for (int i1 = 0; i1 &lt; realLength; i1++) {</span>
<span class="nc" id="L4181">            IRubyObject e = values[begin + i1];</span>
<span class="nc bnc" id="L4182" title="All 2 branches missed.">            if (equalInternal(context, e, item)) {</span>
<span class="nc" id="L4183">                delete_at(i1);</span>
<span class="nc" id="L4184">                listchanged = true;</span>
<span class="nc" id="L4185">                break;</span>
            }
        }

<span class="nc" id="L4189">        return listchanged;</span>
    }

    public boolean containsAll(Collection c) {
<span class="nc bnc" id="L4193" title="All 2 branches missed.">        for (Iterator iter = c.iterator(); iter.hasNext();) {</span>
<span class="nc bnc" id="L4194" title="All 2 branches missed.">            if (indexOf(iter.next()) == -1) {</span>
<span class="nc" id="L4195">                return false;</span>
            }
        }

<span class="nc" id="L4199">        return true;</span>
    }

    public boolean addAll(Collection c) {
<span class="nc bnc" id="L4203" title="All 2 branches missed.">        for (Iterator iter = c.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L4204">            add(iter.next());</span>
        }
<span class="nc bnc" id="L4206" title="All 2 branches missed.">        return !c.isEmpty();</span>
    }

    public boolean addAll(int index, Collection c) {
<span class="nc" id="L4210">        Iterator iter = c.iterator();</span>
<span class="nc bnc" id="L4211" title="All 2 branches missed.">        for (int i = index; iter.hasNext(); i++) {</span>
<span class="nc" id="L4212">            add(i, iter.next());</span>
        }
<span class="nc bnc" id="L4214" title="All 2 branches missed.">        return !c.isEmpty();</span>
    }

    public boolean removeAll(Collection c) {
<span class="nc" id="L4218">        boolean listChanged = false;</span>
<span class="nc bnc" id="L4219" title="All 2 branches missed.">        for (Iterator iter = c.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L4220">            IRubyObject deleted = delete(getRuntime().getCurrentContext(), JavaUtil.convertJavaToUsableRubyObject(getRuntime(), iter.next()), Block.NULL_BLOCK);</span>
<span class="nc bnc" id="L4221" title="All 2 branches missed.">            if (!deleted.isNil()) {</span>
<span class="nc" id="L4222">                listChanged = true;</span>
            }
<span class="nc" id="L4224">        }</span>
<span class="nc" id="L4225">        return listChanged;</span>
    }

    public boolean retainAll(Collection c) {
<span class="nc" id="L4229">        boolean listChanged = false;</span>

<span class="nc bnc" id="L4231" title="All 2 branches missed.">        for (Iterator iter = iterator(); iter.hasNext();) {</span>
<span class="nc" id="L4232">            Object element = iter.next();</span>
<span class="nc bnc" id="L4233" title="All 2 branches missed.">            if (!c.contains(element)) {</span>
<span class="nc" id="L4234">                remove(element);</span>
<span class="nc" id="L4235">                listChanged = true;</span>
            }
<span class="nc" id="L4237">        }</span>
<span class="nc" id="L4238">        return listChanged;</span>
    }

    public Object get(int index) {
<span class="nc" id="L4242">        return elt(index).toJava(Object.class);</span>
    }

    public Object set(int index, Object element) {
<span class="nc" id="L4246">        Object previous = elt(index).toJava(Object.class);</span>
<span class="nc" id="L4247">        store(index, JavaUtil.convertJavaToUsableRubyObject(getRuntime(), element));</span>
<span class="nc" id="L4248">        return previous;</span>
    }

    // TODO: make more efficient by not creating IRubyArray[]
    public void add(int index, Object element) {
<span class="nc" id="L4253">        insert(new IRubyObject[]{RubyFixnum.newFixnum(getRuntime(), index), JavaUtil.convertJavaToUsableRubyObject(getRuntime(), element)});</span>
<span class="nc" id="L4254">    }</span>

    public Object remove(int index) {
<span class="nc" id="L4257">        return delete_at(index).toJava(Object.class);</span>
    }

    public int indexOf(Object element) {
<span class="nc" id="L4261">        int myBegin = this.begin;</span>

<span class="nc bnc" id="L4263" title="All 2 branches missed.">        if (element != null) {</span>
<span class="nc" id="L4264">            IRubyObject convertedElement = JavaUtil.convertJavaToUsableRubyObject(getRuntime(), element);</span>

<span class="nc bnc" id="L4266" title="All 2 branches missed.">            for (int i = myBegin; i &lt; myBegin + realLength; i++) {</span>
<span class="nc bnc" id="L4267" title="All 2 branches missed.">                if (convertedElement.equals(values[i])) {</span>
<span class="nc" id="L4268">                    return i;</span>
                }
            }
        }
<span class="nc" id="L4272">        return -1;</span>
    }

    public int lastIndexOf(Object element) {
<span class="nc" id="L4276">        int myBegin = this.begin;</span>

<span class="nc bnc" id="L4278" title="All 2 branches missed.">        if (element != null) {</span>
<span class="nc" id="L4279">            IRubyObject convertedElement = JavaUtil.convertJavaToUsableRubyObject(getRuntime(), element);</span>

<span class="nc bnc" id="L4281" title="All 2 branches missed.">            for (int i = myBegin + realLength - 1; i &gt;= myBegin; i--) {</span>
<span class="nc bnc" id="L4282" title="All 2 branches missed.">                if (convertedElement.equals(values[i])) {</span>
<span class="nc" id="L4283">                    return i;</span>
                }
            }
        }

<span class="nc" id="L4288">        return -1;</span>
    }

<span class="nc" id="L4291">    public class RubyArrayConversionIterator implements Iterator {</span>
<span class="nc" id="L4292">        protected int index = 0;</span>
<span class="nc" id="L4293">        protected int last = -1;</span>

        public boolean hasNext() {
<span class="nc bnc" id="L4296" title="All 2 branches missed.">            return index &lt; realLength;</span>
        }

        public Object next() {
<span class="nc" id="L4300">            IRubyObject element = elt(index);</span>
<span class="nc" id="L4301">            last = index++;</span>
<span class="nc" id="L4302">            return element.toJava(Object.class);</span>
        }

        public void remove() {
<span class="nc bnc" id="L4306" title="All 2 branches missed.">            if (last == -1) throw new IllegalStateException();</span>

<span class="nc" id="L4308">            delete_at(last);</span>
<span class="nc bnc" id="L4309" title="All 2 branches missed.">            if (last &lt; index) index--;</span>

<span class="nc" id="L4311">            last = -1;</span>
	
<span class="nc" id="L4313">        }</span>
    }

    public Iterator iterator() {
<span class="nc" id="L4317">        return new RubyArrayConversionIterator();</span>
    }

    final class RubyArrayConversionListIterator extends RubyArrayConversionIterator implements ListIterator {
<span class="nc" id="L4321">        public RubyArrayConversionListIterator() {</span>
<span class="nc" id="L4322">        }</span>

<span class="nc" id="L4324">        public RubyArrayConversionListIterator(int index) {</span>
<span class="nc" id="L4325">            this.index = index;</span>
<span class="nc" id="L4326">        }</span>

        public boolean hasPrevious() {
<span class="nc bnc" id="L4329" title="All 2 branches missed.">            return index &gt;= 0;</span>
        }

        public Object previous() {
<span class="nc" id="L4333">            return elt(last = --index).toJava(Object.class);</span>
        }

        public int nextIndex() {
<span class="nc" id="L4337">            return index;</span>
        }

        public int previousIndex() {
<span class="nc" id="L4341">            return index - 1;</span>
        }

        public void set(Object obj) {
<span class="nc bnc" id="L4345" title="All 2 branches missed.">            if (last == -1) {</span>
<span class="nc" id="L4346">                throw new IllegalStateException();</span>
            }

<span class="nc" id="L4349">            store(last, JavaUtil.convertJavaToUsableRubyObject(getRuntime(), obj));</span>
<span class="nc" id="L4350">        }</span>

        public void add(Object obj) {
<span class="nc" id="L4353">            insert(new IRubyObject[] { RubyFixnum.newFixnum(getRuntime(), index++), JavaUtil.convertJavaToUsableRubyObject(getRuntime(), obj) });</span>
<span class="nc" id="L4354">            last = -1;</span>
<span class="nc" id="L4355">        }</span>
    }

    public ListIterator listIterator() {
<span class="nc" id="L4359">        return new RubyArrayConversionListIterator();</span>
    }

    public ListIterator listIterator(int index) {
<span class="nc" id="L4363">        return new RubyArrayConversionListIterator(index);</span>
	}

    // TODO: list.subList(from, to).clear() is supposed to clear the sublist from the list.
    // How can we support this operation?
    public List subList(int fromIndex, int toIndex) {
<span class="nc bnc" id="L4369" title="All 6 branches missed.">        if (fromIndex &lt; 0 || toIndex &gt; size() || fromIndex &gt; toIndex) {</span>
<span class="nc" id="L4370">            throw new IndexOutOfBoundsException();</span>
        }
        
<span class="nc" id="L4373">        IRubyObject subList = subseq(fromIndex, toIndex - fromIndex);</span>

<span class="nc bnc" id="L4375" title="All 2 branches missed.">        return subList.isNil() ? null : (List) subList;</span>
    }

    public void clear() {
<span class="fc" id="L4379">        rb_clear();</span>
<span class="fc" id="L4380">    }</span>

    private IRubyObject safeArrayRef(IRubyObject[] values, int i) {
<span class="fc" id="L4383">        return safeArrayRef(getRuntime(), values, i);</span>
    }

    private IRubyObject safeArrayRef(Ruby runtime, IRubyObject[] values, int i) {
        try {
<span class="fc" id="L4388">            return values[i];</span>
<span class="nc" id="L4389">        } catch (ArrayIndexOutOfBoundsException x) {</span>
<span class="nc" id="L4390">            concurrentModification(runtime);</span>
<span class="nc" id="L4391">            return null; // not reached</span>
        }
    }

    private IRubyObject safeArraySet(IRubyObject[] values, int i, IRubyObject value) {
<span class="fc" id="L4396">        return safeArraySet(getRuntime(), values, i, value);</span>
    }

    private static IRubyObject safeArraySet(Ruby runtime, IRubyObject[] values, int i, IRubyObject value) {
        try {
<span class="fc" id="L4401">            return values[i] = value;</span>
<span class="nc" id="L4402">        } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L4403">            concurrentModification(runtime);</span>
<span class="nc" id="L4404">            return null; // not reached</span>
        }
    }

    private IRubyObject safeArrayRefSet(IRubyObject[] values, int i, IRubyObject value) {
<span class="fc" id="L4409">        return safeArrayRefSet(getRuntime(), values, i, value);</span>
    }

    private static IRubyObject safeArrayRefSet(Ruby runtime, IRubyObject[] values, int i, IRubyObject value) {
        try {
<span class="fc" id="L4414">            IRubyObject tmp = values[i];</span>
<span class="fc" id="L4415">            values[i] = value;</span>
<span class="fc" id="L4416">            return tmp;</span>
<span class="nc" id="L4417">        } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L4418">            concurrentModification(runtime);</span>
<span class="nc" id="L4419">            return null; // not reached</span>
        }
    }

    private IRubyObject safeArrayRefCondSet(IRubyObject[] values, int i, boolean doSet, IRubyObject value) {
<span class="fc" id="L4424">        return safeArrayRefCondSet(getRuntime(), values, i, doSet, value);</span>
    }

    private static IRubyObject safeArrayRefCondSet(Ruby runtime, IRubyObject[] values, int i, boolean doSet, IRubyObject value) {
        try {
<span class="fc" id="L4429">            IRubyObject tmp = values[i];</span>
<span class="fc bfc" id="L4430" title="All 2 branches covered.">            if (doSet) values[i] = value;</span>
<span class="fc" id="L4431">            return tmp;</span>
<span class="nc" id="L4432">        } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L4433">            concurrentModification(runtime);</span>
<span class="nc" id="L4434">            return null; // not reached</span>
        }
    }

    private void safeArrayCopy(IRubyObject[] source, int sourceStart, IRubyObject[] target, int targetStart, int length) {
<span class="fc" id="L4439">        safeArrayCopy(getRuntime(), source, sourceStart, target, targetStart, length);</span>
<span class="fc" id="L4440">    }</span>

    private void safeArrayCopy(Ruby runtime, IRubyObject[] source, int sourceStart, IRubyObject[] target, int targetStart, int length) {
        try {
<span class="fc" id="L4444">            System.arraycopy(source, sourceStart, target, targetStart, length);</span>
<span class="nc" id="L4445">        } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L4446">            concurrentModification(runtime);</span>
<span class="fc" id="L4447">        }</span>
        // not reached
<span class="fc" id="L4449">    }</span>

    @Deprecated
    public IRubyObject compatc19() {
<span class="nc" id="L4453">        return compact19();</span>
    }

    @Deprecated
    public final RubyArray aryDup19() {
<span class="nc" id="L4458">        return aryDup();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>