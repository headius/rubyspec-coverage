<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RubyBigDecimal.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rubyspec coverage</a> &gt; <a href="index.source.html" class="el_package">org.jruby.ext.bigdecimal</a> &gt; <span class="el_source">RubyBigDecimal.java</span></div><h1>RubyBigDecimal.java</h1><pre class="source lang-java linenums">/***** BEGIN LICENSE BLOCK *****
 * Version: EPL 1.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 1.0 (the &quot;License&quot;); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v10.html
 *
 * Software distributed under the License is distributed on an &quot;AS
 * IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2006 Ola Bini &lt;ola@ologix.com&gt;
 * Copyright (C) 2009 Joseph LaFata &lt;joe@quibb.org&gt;
 * 
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),
 * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/
package org.jruby.ext.bigdecimal;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.jruby.Ruby;
import org.jruby.RubyArray;
import org.jruby.RubyBignum;
import org.jruby.RubyBoolean;
import org.jruby.RubyClass;
import org.jruby.RubyFixnum;
import org.jruby.RubyFloat;
import org.jruby.RubyInteger;
import org.jruby.RubyModule;
import org.jruby.RubyNumeric;
import static org.jruby.RubyNumeric.num2int;
import org.jruby.RubyObject;
import org.jruby.RubyRational;
import org.jruby.RubyString;
import org.jruby.RubySymbol;
import org.jruby.anno.JRubyClass;
import org.jruby.anno.JRubyConstant;
import org.jruby.anno.JRubyMethod;
import org.jruby.runtime.Arity;
import org.jruby.runtime.Block;
import org.jruby.runtime.ObjectAllocator;
import org.jruby.runtime.ThreadContext;
import org.jruby.runtime.Visibility;
import org.jruby.runtime.builtin.IRubyObject;
import static org.jruby.runtime.builtin.IRubyObject.NULL_ARRAY;
import org.jruby.util.Numeric;
import org.jruby.util.SafeDoubleParser;

/**
 * @author &lt;a href=&quot;mailto:ola.bini@ki.se&quot;&gt;Ola Bini&lt;/a&gt;
 */
<span class="nc bnc" id="L70" title="All 2 branches missed.">@JRubyClass(name=&quot;BigDecimal&quot;, parent=&quot;Numeric&quot;)</span>
public class RubyBigDecimal extends RubyNumeric {
<span class="nc" id="L72">    private static final ObjectAllocator BIGDECIMAL_ALLOCATOR = new ObjectAllocator() {</span>
        @Override
        public IRubyObject allocate(Ruby runtime, RubyClass klass) {
<span class="nc" id="L75">            return new RubyBigDecimal(runtime, klass);</span>
        }
    };

    @JRubyConstant
    public final static int ROUND_DOWN = BigDecimal.ROUND_DOWN;
    @JRubyConstant
    public final static int ROUND_CEILING = BigDecimal.ROUND_CEILING;
    @JRubyConstant
    public final static int ROUND_UP = BigDecimal.ROUND_UP;
    @JRubyConstant
    public final static int ROUND_HALF_DOWN = BigDecimal.ROUND_HALF_DOWN;
    @JRubyConstant
    public final static int ROUND_HALF_EVEN = BigDecimal.ROUND_HALF_EVEN;
    @JRubyConstant
    public final static int ROUND_HALF_UP = BigDecimal.ROUND_HALF_UP;
    @JRubyConstant
    public final static int ROUND_FLOOR = BigDecimal.ROUND_FLOOR;

    @JRubyConstant
    public final static int SIGN_POSITIVE_INFINITE = 3;
    @JRubyConstant
    public final static int EXCEPTION_OVERFLOW = 8;
    @JRubyConstant
    public final static int SIGN_POSITIVE_ZERO = 1;
    @JRubyConstant
    public final static int EXCEPTION_ALL = 255;
    @JRubyConstant
    public final static int SIGN_NEGATIVE_FINITE = -2;
    @JRubyConstant
    public final static int EXCEPTION_UNDERFLOW = 4;
    @JRubyConstant
    public final static int SIGN_NaN = 0;
    @JRubyConstant
    public final static int BASE = 10000;
    @JRubyConstant
    public final static int ROUND_MODE = 256;
    @JRubyConstant
    public final static int SIGN_POSITIVE_FINITE = 2;
    @JRubyConstant
    public final static int EXCEPTION_INFINITY = 1;
    @JRubyConstant
    public final static int SIGN_NEGATIVE_INFINITE = -3;
    @JRubyConstant
    public final static int EXCEPTION_ZERODIVIDE = 1;
    @JRubyConstant
    public final static int SIGN_NEGATIVE_ZERO = -1;
    @JRubyConstant
    public final static int EXCEPTION_NaN = 2;
    
    // Static constants
<span class="nc" id="L126">    private static final BigDecimal TWO = new BigDecimal(2);</span>
    private static final double SQRT_10 = 3.162277660168379332;
    
    public static RubyClass createBigDecimal(Ruby runtime) {
        try {
<span class="nc" id="L131">        RubyClass bigDecimal = runtime.defineClass(&quot;BigDecimal&quot;, runtime.getNumeric(), BIGDECIMAL_ALLOCATOR);</span>

<span class="nc" id="L133">        runtime.getKernel().defineAnnotatedMethods(BigDecimalKernelMethods.class);</span>

<span class="nc" id="L135">        bigDecimal.setInternalModuleVariable(&quot;vpPrecLimit&quot;, RubyFixnum.zero(runtime));</span>
<span class="nc" id="L136">        bigDecimal.setInternalModuleVariable(&quot;vpExceptionMode&quot;, RubyFixnum.zero(runtime));</span>
<span class="nc" id="L137">        bigDecimal.setInternalModuleVariable(&quot;vpRoundingMode&quot;, runtime.newFixnum(ROUND_HALF_UP));</span>
        
<span class="nc" id="L139">        bigDecimal.defineAnnotatedMethods(RubyBigDecimal.class);</span>
<span class="nc" id="L140">        bigDecimal.defineAnnotatedConstants(RubyBigDecimal.class);</span>

<span class="nc" id="L142">        RubyModule bigMath = runtime.defineModule(&quot;BigMath&quot;);</span>
        // TODO: BigMath.exp and BigMath.pow in native code

<span class="nc" id="L145">        bigDecimal.defineConstant(&quot;NAN&quot;, newNaN(runtime));</span>
<span class="nc" id="L146">        bigDecimal.defineConstant(&quot;INFINITY&quot;, newInfinity(runtime, 1));</span>

<span class="nc" id="L148">        return bigDecimal;</span>
<span class="nc" id="L149">        } catch (Exception e) {</span>
<span class="nc" id="L150">            System.out.println(&quot;E:&quot; + e);</span>
<span class="nc" id="L151">            e.printStackTrace();</span>
        }
<span class="nc" id="L153">        return null;</span>
    }

    private final boolean isNaN;
    private final int infinitySign;
    private final int zeroSign;
    private BigDecimal value;

    public BigDecimal getValue() {
<span class="nc" id="L162">        return value;</span>
    }

    public RubyBigDecimal(Ruby runtime, RubyClass klass) {
<span class="nc" id="L166">        super(runtime, klass);</span>
<span class="nc" id="L167">        this.isNaN = false;</span>
<span class="nc" id="L168">        this.infinitySign = 0;</span>
<span class="nc" id="L169">        this.zeroSign = 0;</span>
<span class="nc" id="L170">    }</span>

    public RubyBigDecimal(Ruby runtime, BigDecimal value) {
<span class="nc" id="L173">        super(runtime, runtime.getClass(&quot;BigDecimal&quot;));</span>
<span class="nc" id="L174">        this.isNaN = false;</span>
<span class="nc" id="L175">        this.infinitySign = 0;</span>
<span class="nc" id="L176">        this.zeroSign = 0;</span>
<span class="nc" id="L177">        this.value = value;</span>
<span class="nc" id="L178">    }</span>

    public RubyBigDecimal(Ruby runtime, RubyClass klass, BigDecimal value) {
<span class="nc" id="L181">        super(runtime, klass);</span>
<span class="nc" id="L182">        this.isNaN = false;</span>
<span class="nc" id="L183">        this.infinitySign = 0;</span>
<span class="nc" id="L184">        this.zeroSign = 0;</span>
<span class="nc" id="L185">        this.value = value;</span>
<span class="nc" id="L186">    }</span>

    public RubyBigDecimal(Ruby runtime, BigDecimal value, int infinitySign) {
<span class="nc" id="L189">        super(runtime, runtime.getClass(&quot;BigDecimal&quot;));</span>
<span class="nc" id="L190">        this.isNaN = false;</span>
<span class="nc" id="L191">        this.infinitySign = infinitySign;</span>
<span class="nc" id="L192">        this.zeroSign = 0;</span>
<span class="nc" id="L193">        this.value = value;</span>
<span class="nc" id="L194">    }</span>

    public RubyBigDecimal(Ruby runtime, BigDecimal value, int infinitySign, int zeroSign) {
<span class="nc" id="L197">        super(runtime, runtime.getClass(&quot;BigDecimal&quot;));</span>
<span class="nc" id="L198">        this.isNaN = false;</span>
<span class="nc" id="L199">        this.infinitySign = infinitySign;</span>
<span class="nc" id="L200">        this.zeroSign = zeroSign;</span>
<span class="nc" id="L201">        this.value = value;</span>
<span class="nc" id="L202">    }</span>

    public RubyBigDecimal(Ruby runtime, BigDecimal value, boolean isNan) {
<span class="nc" id="L205">        super(runtime, runtime.getClass(&quot;BigDecimal&quot;));</span>
<span class="nc" id="L206">        this.isNaN = isNan;</span>
<span class="nc" id="L207">        this.infinitySign = 0;</span>
<span class="nc" id="L208">        this.zeroSign = 0;</span>
<span class="nc" id="L209">        this.value = value;</span>
<span class="nc" id="L210">    }</span>

    public RubyBigDecimal(Ruby runtime, RubyBigDecimal rbd) {
<span class="nc" id="L213">        this(runtime, runtime.getClass(&quot;BigDecimal&quot;), rbd);</span>
<span class="nc" id="L214">    }</span>

    public RubyBigDecimal(Ruby runtime, RubyClass klass, RubyBigDecimal rbd) {
<span class="nc" id="L217">        super(runtime, klass);</span>
<span class="nc" id="L218">        this.isNaN = rbd.isNaN;</span>
<span class="nc" id="L219">        this.infinitySign = rbd.infinitySign;</span>
<span class="nc" id="L220">        this.zeroSign = rbd.zeroSign;</span>
<span class="nc" id="L221">        this.value = rbd.value;</span>
<span class="nc" id="L222">    }</span>
    
<span class="nc" id="L224">    public static class BigDecimalKernelMethods {</span>
        @JRubyMethod(name = &quot;BigDecimal&quot;, required = 1, optional = 1, module = true, visibility = Visibility.PRIVATE)
        public static IRubyObject newBigDecimal(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
<span class="nc bnc" id="L227" title="All 2 branches missed.">            if (args.length == 1) return newInstance(context, context.runtime.getClass(&quot;BigDecimal&quot;), args[0]);</span>

<span class="nc" id="L229">            return newInstance(context, context.runtime.getClass(&quot;BigDecimal&quot;), args[0], args[1]);</span>
        }
    }

    @JRubyMethod(meta = true)
    public static IRubyObject ver(ThreadContext context, IRubyObject recv) {
<span class="nc" id="L235">        return context.runtime.newString(&quot;1.0.1&quot;);</span>
    }

    @JRubyMethod
    public IRubyObject _dump(ThreadContext context) {
<span class="nc" id="L240">        return RubyString.newUnicodeString(context.runtime, &quot;0:&quot;).append(asString());</span>
    }
    
    @JRubyMethod
    public IRubyObject _dump(ThreadContext context, IRubyObject unused) {
<span class="nc" id="L245">        return RubyString.newUnicodeString(context.runtime, &quot;0:&quot;).append(asString());</span>
    }    
        
    @JRubyMethod(meta = true)
    public static RubyBigDecimal _load(ThreadContext context, IRubyObject recv, IRubyObject from) {
<span class="nc" id="L250">        RubyBigDecimal instance = (RubyBigDecimal) (((RubyClass) recv).allocate());</span>
<span class="nc" id="L251">        String precisionAndValue = from.convertToString().asJavaString();</span>
<span class="nc" id="L252">        String value = precisionAndValue.substring(precisionAndValue.indexOf(&quot;:&quot;)+1);</span>
<span class="nc" id="L253">        instance.value = new BigDecimal(value);</span>
<span class="nc" id="L254">        return instance;</span>
    }

    @JRubyMethod(meta = true)
    public static IRubyObject double_fig(ThreadContext context, IRubyObject recv) {
<span class="nc" id="L259">        return context.runtime.newFixnum(20);</span>
    }
    
    /**
     * Retrieve vpPrecLimit.
     */
    @JRubyMethod(meta = true)
    public static IRubyObject limit(ThreadContext context, IRubyObject recv) {
<span class="nc" id="L267">        return ((RubyModule) recv).searchInternalModuleVariable(&quot;vpPrecLimit&quot;);</span>
    }

    /**
     * Set new vpPrecLimit if Fixnum and return the old value.
     */
    @JRubyMethod(meta = true)
    public static IRubyObject limit(ThreadContext context, IRubyObject recv, IRubyObject arg) {
<span class="nc" id="L275">        IRubyObject old = limit(context, recv);</span>

<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (arg.isNil()) return old;</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (!(arg instanceof RubyFixnum)) throw context.runtime.newTypeError(arg, context.runtime.getFixnum());</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">        if (0 &gt; ((RubyFixnum)arg).getLongValue()) throw context.runtime.newArgumentError(&quot;argument must be positive&quot;);</span>

<span class="nc" id="L281">        ((RubyModule) recv).setInternalModuleVariable(&quot;vpPrecLimit&quot;, arg);</span>

<span class="nc" id="L283">        return old;</span>
    }
        
    @JRubyMethod(meta = true)
    public static IRubyObject save_limit(ThreadContext context, IRubyObject recv, Block block) {
<span class="nc" id="L288">        return modeExecute(&quot;vpPrecLimit&quot;, context, (RubyModule) recv, block);</span>
    }

    @JRubyMethod(meta = true)
    public static IRubyObject save_exception_mode(ThreadContext context, IRubyObject recv, Block block) {
<span class="nc" id="L293">        return modeExecute(&quot;vpExceptionMode&quot;, context, (RubyModule) recv, block);</span>
    }

    @JRubyMethod(meta = true)
    public static IRubyObject save_rounding_mode(ThreadContext context, IRubyObject recv, Block block) {
<span class="nc" id="L298">        return modeExecute(&quot;vpRoundingMode&quot;, context, (RubyModule) recv, block);</span>
    }
    
    private static IRubyObject modeExecute(String modeName, ThreadContext context, RubyModule mod, Block block) {
<span class="nc" id="L302">        IRubyObject savedMode = mod.searchInternalModuleVariable(modeName);</span>

        try {
<span class="nc" id="L305">            return block.yieldSpecific(context);</span>
        } finally {
<span class="nc" id="L307">            mod.setInternalModuleVariable(modeName, savedMode);</span>
        }        
    }

    @JRubyMethod(required = 1, optional = 1, meta = true)
    public static IRubyObject mode(ThreadContext context, IRubyObject recv, IRubyObject[] args) {
        // FIXME: I doubt any of the constants referenced in this method
        // are ever redefined -- should compare to the known values, rather
        // than do an expensive constant lookup.
<span class="nc" id="L316">        RubyClass clazz = context.runtime.getClass(&quot;BigDecimal&quot;);</span>
<span class="nc" id="L317">        RubyModule c = (RubyModule)recv;</span>
        
<span class="nc" id="L319">        args = Arity.scanArgs(context.runtime, args, 1, 1);</span>
        
<span class="nc" id="L321">        IRubyObject mode = args[0];</span>
<span class="nc" id="L322">        IRubyObject value = args[1];</span>
        
<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (!(mode instanceof RubyFixnum)) {</span>
<span class="nc" id="L325">            throw context.runtime.newTypeError(&quot;wrong argument type &quot; + mode.getMetaClass() + &quot; (expected Fixnum)&quot;);</span>
        }
        
<span class="nc" id="L328">        long longMode = ((RubyFixnum)mode).getLongValue();</span>
<span class="nc" id="L329">        long _EXCEPTION_ALL =  bigDecimalConst(context.runtime, &quot;EXCEPTION_ALL&quot;);</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">        if ((longMode &amp; _EXCEPTION_ALL) != 0) {     </span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">            if (value.isNil()) return c.searchInternalModuleVariable(&quot;vpExceptionMode&quot;);</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            if (!(value instanceof RubyBoolean)) throw context.runtime.newArgumentError(&quot;second argument must be true or false&quot;);</span>

<span class="nc" id="L334">            RubyFixnum currentExceptionMode = (RubyFixnum)c.searchInternalModuleVariable(&quot;vpExceptionMode&quot;);</span>
<span class="nc" id="L335">            RubyFixnum newExceptionMode = new RubyFixnum(context.runtime, currentExceptionMode.getLongValue());</span>
            
<span class="nc" id="L337">            RubyFixnum _EXCEPTION_INFINITY = (RubyFixnum)clazz.getConstant(&quot;EXCEPTION_INFINITY&quot;);</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">            if ((longMode &amp; _EXCEPTION_INFINITY.getLongValue()) != 0) {</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">                newExceptionMode = (value.isTrue()) ? (RubyFixnum)currentExceptionMode.callCoerced(context, &quot;|&quot;, _EXCEPTION_INFINITY)</span>
<span class="nc" id="L340">                        : (RubyFixnum)currentExceptionMode.callCoerced(context, &quot;&amp;&quot;, new RubyFixnum(context.runtime, ~(_EXCEPTION_INFINITY).getLongValue()));</span>
            }
            
<span class="nc" id="L343">            RubyFixnum _EXCEPTION_NaN = (RubyFixnum)clazz.getConstant(&quot;EXCEPTION_NaN&quot;);</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">            if ((longMode &amp; _EXCEPTION_NaN.getLongValue()) != 0) {</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">                newExceptionMode = (value.isTrue()) ? (RubyFixnum)currentExceptionMode.callCoerced(context, &quot;|&quot;, _EXCEPTION_NaN)</span>
<span class="nc" id="L346">                        : (RubyFixnum)currentExceptionMode.callCoerced(context, &quot;&amp;&quot;, new RubyFixnum(context.runtime, ~(_EXCEPTION_NaN).getLongValue()));</span>
            }
            
<span class="nc" id="L349">            RubyFixnum _EXCEPTION_UNDERFLOW = (RubyFixnum)clazz.getConstant(&quot;EXCEPTION_UNDERFLOW&quot;);</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">            if ((longMode &amp; _EXCEPTION_UNDERFLOW.getLongValue()) != 0) {</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                newExceptionMode = (value.isTrue()) ? (RubyFixnum)currentExceptionMode.callCoerced(context, &quot;|&quot;, _EXCEPTION_UNDERFLOW)</span>
<span class="nc" id="L352">                        : (RubyFixnum)currentExceptionMode.callCoerced(context, &quot;&amp;&quot;, new RubyFixnum(context.runtime, ~(_EXCEPTION_UNDERFLOW).getLongValue()));</span>
            }
<span class="nc" id="L354">            RubyFixnum _EXCEPTION_OVERFLOW = (RubyFixnum)clazz.getConstant(&quot;EXCEPTION_OVERFLOW&quot;);</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">            if ((longMode &amp; _EXCEPTION_OVERFLOW.getLongValue()) != 0) {</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">                newExceptionMode = (value.isTrue()) ? (RubyFixnum)currentExceptionMode.callCoerced(context, &quot;|&quot;, _EXCEPTION_OVERFLOW)</span>
<span class="nc" id="L357">                        : (RubyFixnum)currentExceptionMode.callCoerced(context, &quot;&amp;&quot;, new RubyFixnum(context.runtime, ~(_EXCEPTION_OVERFLOW).getLongValue()));</span>
            }
<span class="nc" id="L359">            c.setInternalModuleVariable(&quot;vpExceptionMode&quot;, newExceptionMode);</span>
<span class="nc" id="L360">            return newExceptionMode;</span>
        }
        
<span class="nc" id="L363">        long ROUND_MODE = ((RubyFixnum)clazz.getConstant(&quot;ROUND_MODE&quot;)).getLongValue();</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">        if (longMode == ROUND_MODE) {</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">            if (value.isNil()) {</span>
<span class="nc" id="L366">                return c.searchInternalModuleVariable(&quot;vpRoundingMode&quot;);</span>
            }

<span class="nc" id="L369">            RoundingMode javaRoundingMode = javaRoundingModeFromRubyRoundingMode(context.runtime, value);</span>
<span class="nc" id="L370">            RubyFixnum roundingMode = context.runtime.newFixnum(javaRoundingMode.ordinal());</span>
<span class="nc" id="L371">            c.setInternalModuleVariable(&quot;vpRoundingMode&quot;, roundingMode);</span>

<span class="nc" id="L373">            return c.searchInternalModuleVariable(&quot;vpRoundingMode&quot;);</span>
        }
<span class="nc" id="L375">        throw context.runtime.newTypeError(&quot;first argument for BigDecimal#mode invalid&quot;);</span>
    }
    
    private static RubyModule bigDecimal(Ruby runtime) {
<span class="nc" id="L379">        return runtime.getClass(&quot;BigDecimal&quot;);</span>
    }
    
    // The Fixnum cast should be fine because these are internal variables and user code cannot change them.
    private static long bigDecimalVar(Ruby runtime, String variableName) {
<span class="nc" id="L384">        return ((RubyFixnum) bigDecimal(runtime).searchInternalModuleVariable(variableName)).getLongValue();</span>
    }
    
    // FIXME: Old code also blindly casts here.  We can CCE here.
    private static long bigDecimalConst(Ruby runtime, String constantName) {
<span class="nc" id="L389">        return ((RubyFixnum) bigDecimal(runtime).getConstant(constantName)).getLongValue();</span>
    }     

    private static RoundingMode getRoundingMode(Ruby runtime) {
<span class="nc" id="L393">        return RoundingMode.valueOf((int) bigDecimalVar(runtime, &quot;vpRoundingMode&quot;));</span>
    }

    private static boolean isNaNExceptionMode(Ruby runtime) {
<span class="nc bnc" id="L397" title="All 2 branches missed.">        return (bigDecimalVar(runtime, &quot;vpExceptionMode&quot;) &amp; bigDecimalConst(runtime, &quot;EXCEPTION_NaN&quot;)) != 0;</span>
    }

    private static boolean isInfinityExceptionMode(Ruby runtime) {
<span class="nc bnc" id="L401" title="All 2 branches missed.">        return (bigDecimalVar(runtime, &quot;vpExceptionMode&quot;) &amp; bigDecimalConst(runtime, &quot;EXCEPTION_INFINITY&quot;)) != 0;</span>
    }
    
    private static boolean isOverflowExceptionMode(Ruby runtime) {
<span class="nc bnc" id="L405" title="All 2 branches missed.">        return (bigDecimalVar(runtime, &quot;vpExceptionMode&quot;) &amp; bigDecimalConst(runtime, &quot;EXCEPTION_OVERFLOW&quot;)) != 0;</span>
    }
    
    private static RubyBigDecimal cannotBeCoerced(ThreadContext context, IRubyObject v, boolean must) {
<span class="nc bnc" id="L409" title="All 2 branches missed.">        if (must) {</span>
            String err;

<span class="nc bnc" id="L412" title="All 2 branches missed.">            if (v == null) {</span>
<span class="nc" id="L413">                err = &quot;nil&quot;;</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">            } else if (v.isImmediate()) {</span>
<span class="nc" id="L415">                err = RubyObject.inspect(context, v).toString();</span>
            } else {
<span class="nc" id="L417">                err = v.getMetaClass().getBaseName();</span>
            }

<span class="nc" id="L420">            throw context.runtime.newTypeError(err + &quot; can't be coerced into BigDecimal&quot;);</span>
        }

<span class="nc" id="L423">        return null;</span>
    }
    
    private static RubyBigDecimal unableToCoerceWithoutPrec(ThreadContext context, IRubyObject v, boolean must) {
<span class="nc bnc" id="L427" title="All 2 branches missed.">        if (!must) return null;</span>

<span class="nc" id="L429">        throw context.runtime.newArgumentError(v.getMetaClass().getBaseName() + </span>
                &quot; can't be coerced into BigDecimal without a precision&quot;);
    }
    
    private static RubyBigDecimal getVpValue19(ThreadContext context, IRubyObject v, boolean must) {
<span class="nc bnc" id="L434" title="All 4 branches missed.">        long precision = (v instanceof RubyFloat || v instanceof RubyRational) ? 0 : -1;</span>

<span class="nc" id="L436">        return getVpValueWithPrec19(context, v, precision, must);</span>
    }
    
    private static RubyBigDecimal getVpRubyObjectWithPrec19Inner(ThreadContext context, RubyRational r) {
<span class="nc" id="L440">        long numerator = RubyNumeric.num2long(r.numerator(context));</span>
<span class="nc" id="L441">        long denominator = RubyNumeric.num2long(r.denominator(context));</span>
            
<span class="nc" id="L443">        return new RubyBigDecimal(context.runtime, </span>
<span class="nc" id="L444">                BigDecimal.valueOf(numerator).divide(BigDecimal.valueOf(denominator), getRoundingMode(context.runtime)));</span>
    }
    
    private static RubyBigDecimal getVpValueWithPrec19(ThreadContext context, IRubyObject value, long precision, boolean must) {
<span class="nc bnc" id="L448" title="All 2 branches missed.">        if (value instanceof RubyFloat) {</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">            if (precision &gt; Long.MAX_VALUE) cannotBeCoerced(context, value, must);</span>

<span class="nc" id="L451">            return new RubyBigDecimal(context.runtime, BigDecimal.valueOf(((RubyFloat)value).getDoubleValue()));</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">        } else if (value instanceof RubyRational) {</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">            if (precision &lt; 0) return unableToCoerceWithoutPrec(context, value, must);</span>
                
<span class="nc" id="L455">            return getVpRubyObjectWithPrec19Inner(context, (RubyRational) value);</span>
        } 
            
<span class="nc" id="L458">        return getVpValue(context, value, must);</span>
    }

    private static RubyBigDecimal getVpValue(ThreadContext context, IRubyObject v, boolean must) {
<span class="nc bnc" id="L462" title="All 2 branches missed.">        if (v instanceof RubyBigDecimal) return (RubyBigDecimal) v;</span>
<span class="nc bnc" id="L463" title="All 4 branches missed.">        if (v instanceof RubyFixnum || v instanceof RubyBignum) {</span>
            // Converted to a String because some values -inf cannot happen from Java libs
<span class="nc" id="L465">            return newInstance(context, bigDecimal(context.runtime), context.runtime.newString(v.toString()));</span>
        }

<span class="nc" id="L468">        return cannotBeCoerced(v.getRuntime().getCurrentContext(), v, must);</span>
    }

    @JRubyMethod(meta = true)
    public static IRubyObject induced_from(ThreadContext context, IRubyObject recv, IRubyObject arg) {
<span class="nc" id="L473">        return getVpValue(context, arg, true);</span>
    }

<span class="nc" id="L476">    private final static Pattern INFINITY_PATTERN = Pattern.compile(&quot;^([+-])?Infinity$&quot;);</span>
<span class="nc" id="L477">    private final static Pattern NUMBER_PATTERN = Pattern.compile(&quot;^([+-]?\\d*\\.?\\d*([eE][+-]?)?\\d*).*&quot;);</span>
    
    private static RubyBigDecimal newInstance(ThreadContext context, IRubyObject recv, RubyBigDecimal arg) {
<span class="nc" id="L480">        return new RubyBigDecimal(context.runtime, (RubyClass) recv, arg);</span>
    }
    
    private static RubyBigDecimal newInstance(ThreadContext context, IRubyObject recv, RubyFixnum arg, MathContext mathContext) {
<span class="nc" id="L484">        return new RubyBigDecimal(context.runtime, (RubyClass) recv, new BigDecimal(((RubyFixnum) arg).getLongValue(), mathContext));</span>
    }
    
    private static RubyBigDecimal newInstance(ThreadContext context, RubyRational arg, MathContext mathContext) {
<span class="nc" id="L488">        BigDecimal num = new BigDecimal(arg.numerator(context).convertToInteger().getLongValue());</span>
<span class="nc" id="L489">        BigDecimal den = new BigDecimal(arg.denominator(context).convertToInteger().getLongValue());</span>
<span class="nc" id="L490">        BigDecimal value = num.divide(den, mathContext);</span>

<span class="nc" id="L492">        return new RubyBigDecimal(context.runtime, value);</span>
    }
    
    private static RubyBigDecimal newInstance(ThreadContext context, IRubyObject recv, RubyFloat arg, MathContext mathContext) {
        // precision can be no more than float digits
<span class="nc bnc" id="L497" title="All 2 branches missed.">        if (mathContext.getPrecision() &gt; RubyFloat.DIG + 1) throw context.runtime.newArgumentError(&quot;precision too large&quot;);</span>

<span class="nc" id="L499">        return new RubyBigDecimal(context.runtime, (RubyClass) recv, new BigDecimal(arg.getDoubleValue(), mathContext));</span>
    }    
    
    private static RubyBigDecimal newInstance(ThreadContext context, IRubyObject recv, RubyBignum arg, MathContext mathContext) {
<span class="nc" id="L503">        return new RubyBigDecimal(context.runtime, (RubyClass) recv, new BigDecimal(arg.getBigIntegerValue(), mathContext));</span>
    }
        
    private static RubyBigDecimal newInstance(ThreadContext context, IRubyObject recv, IRubyObject arg, MathContext mathContext) {
<span class="nc" id="L507">        String strValue = arg.convertToString().toString().trim();</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (&quot;NaN&quot;.equals(strValue)) return newNaN(context.runtime);</span>

<span class="nc" id="L510">        Matcher m = INFINITY_PATTERN.matcher(strValue);</span>
<span class="nc bnc" id="L511" title="All 4 branches missed.">        if (m.matches()) return newInfinity(context.runtime, &quot;-&quot;.equals(m.group(1)) ? -1 : 1);</span>

        // Convert String to Java understandable format (for BigDecimal).
<span class="nc" id="L514">        strValue = strValue.replaceFirst(&quot;[dD]&quot;, &quot;E&quot;);                  // 1. MRI allows d and D as exponent separators</span>
<span class="nc" id="L515">        strValue = strValue.replaceAll(&quot;_&quot;, &quot;&quot;);                        // 2. MRI allows underscores anywhere</span>
<span class="nc" id="L516">        strValue = NUMBER_PATTERN.matcher(strValue).replaceFirst(&quot;$1&quot;); // 3. MRI ignores the trailing junk</span>

        BigDecimal decimal;
        try {
<span class="nc" id="L520">            decimal = new BigDecimal(strValue, mathContext);</span>
<span class="nc" id="L521">        } catch (NumberFormatException e) {</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">            if (isOverflowExceptionMode(context.runtime)) throw context.runtime.newFloatDomainError(&quot;exponent overflow&quot;);</span>

<span class="nc" id="L524">            decimal = new BigDecimal(0);</span>
<span class="nc" id="L525">        }</span>

        // MRI behavior: -0 and +0 are two different things
<span class="nc bnc" id="L528" title="All 4 branches missed.">        if (decimal.signum() == 0) return newZero(context.runtime, strValue.matches(&quot;^\\s*-.*&quot;) ? -1 : 1);</span>

<span class="nc" id="L530">        return new RubyBigDecimal(context.runtime, (RubyClass)recv, decimal);    </span>
    }
    
    @JRubyMethod(name = &quot;new&quot;, meta = true)
    public static RubyBigDecimal newInstance(ThreadContext context, IRubyObject recv, IRubyObject arg) {
<span class="nc bnc" id="L535" title="All 2 branches missed.">        if (arg instanceof RubyBigDecimal) return newInstance(context, recv, (RubyBigDecimal) arg);</span>
<span class="nc bnc" id="L536" title="All 4 branches missed.">        if (arg instanceof RubyFloat || arg instanceof RubyRational) throw context.runtime.newArgumentError(&quot;can't omit precision for a rational&quot;);</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (arg instanceof RubyFixnum) return newInstance(context, recv, (RubyFixnum) arg, MathContext.UNLIMITED);</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">        if (arg instanceof RubyBignum) return newInstance(context, recv, (RubyBignum) arg, MathContext.UNLIMITED);</span>

<span class="nc" id="L540">        return newInstance(context, recv, arg, MathContext.UNLIMITED);</span>
    }
    
    @JRubyMethod(name = &quot;new&quot;, meta = true)
    public static RubyBigDecimal newInstance(ThreadContext context, IRubyObject recv, IRubyObject arg, IRubyObject mathArg) {
<span class="nc" id="L545">        int digits = (int) mathArg.convertToInteger().getLongValue();</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">        if (digits &lt; 0) throw context.runtime.newArgumentError(&quot;argument must be positive&quot;);</span>

<span class="nc" id="L548">        MathContext mathContext = new MathContext(digits);</span>

<span class="nc bnc" id="L550" title="All 2 branches missed.">        if (arg instanceof RubyBigDecimal) return newInstance(context, recv, (RubyBigDecimal) arg);</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">        if (arg instanceof RubyFloat) return newInstance(context, recv, (RubyFloat) arg, mathContext);</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">        if (arg instanceof RubyRational) return newInstance(context, (RubyRational) arg, mathContext);</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">        if (arg instanceof RubyFixnum) return newInstance(context, recv, (RubyFixnum) arg, mathContext);</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">        if (arg instanceof RubyBignum) return newInstance(context, recv, (RubyBignum) arg, mathContext);</span>

<span class="nc" id="L556">        return newInstance(context, recv, arg, MathContext.UNLIMITED);</span>
    }

    private static RubyBigDecimal newZero(Ruby runtime, int sign) {
<span class="nc bnc" id="L560" title="All 2 branches missed.">        return new RubyBigDecimal(runtime, BigDecimal.ZERO, 0, sign &lt; 0 ? -1 : 1);</span>
    }

    private static RubyBigDecimal newNaN(Ruby runtime) {
<span class="nc bnc" id="L564" title="All 2 branches missed.">        if (isNaNExceptionMode(runtime)) throw runtime.newFloatDomainError(&quot;Computation results to 'NaN'(Not a Number)&quot;);</span>

<span class="nc" id="L566">        return new RubyBigDecimal(runtime, BigDecimal.ZERO, true);</span>
    }
    
    private static RubyBigDecimal newInfinity(Ruby runtime, int sign) {
<span class="nc bnc" id="L570" title="All 2 branches missed.">        if (isInfinityExceptionMode(runtime)) throw runtime.newFloatDomainError(&quot;Computation results to 'Infinity'&quot;);</span>

<span class="nc bnc" id="L572" title="All 2 branches missed.">        return new RubyBigDecimal(runtime, BigDecimal.ZERO, sign &lt; 0 ? -1 : 1);</span>
    }

    private RubyBigDecimal setResult() {
<span class="nc" id="L576">        return setResult(0);</span>
    }

    private RubyBigDecimal setResult(int scale) {
<span class="nc" id="L580">        int prec = RubyFixnum.fix2int(getRuntime().getClass(&quot;BigDecimal&quot;).searchInternalModuleVariable(&quot;vpPrecLimit&quot;));</span>
<span class="nc" id="L581">        int prec2 = Math.max(scale, prec);</span>
<span class="nc bnc" id="L582" title="All 4 branches missed.">        if (prec2 &gt; 0 &amp;&amp; this.value.scale() &gt; (prec2-getExponent())) {</span>
<span class="nc" id="L583">            this.value = this.value.setScale(prec2-getExponent(), BigDecimal.ROUND_HALF_UP);</span>
        }
<span class="nc" id="L585">        return this;</span>
    }
    
    @Override
    @JRubyMethod
    public RubyFixnum hash() {
<span class="nc" id="L591">        return getRuntime().newFixnum(value.stripTrailingZeros().hashCode());</span>
    }

    public IRubyObject op_mod(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L595">        return op_mod19(context, arg);</span>
    }

    @JRubyMethod(name = {&quot;%&quot;, &quot;modulo&quot;}, required = 1)
    public IRubyObject op_mod19(ThreadContext context, IRubyObject other) {
        // TODO: full-precision divmod is 1000x slower than MRI!
<span class="nc" id="L601">        RubyBigDecimal val = getVpValue19(context, other, false);</span>
        
<span class="nc bnc" id="L603" title="All 2 branches missed.">        if (val == null) return callCoerced(context, &quot;%&quot;, other, true);</span>
<span class="nc bnc" id="L604" title="All 8 branches missed.">        if (isNaN() || val.isNaN() || isInfinity() &amp;&amp; val.isInfinity()) return newNaN(context.runtime);</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">        if (val.isZero()) throw context.runtime.newZeroDivisionError();</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">        if (isInfinity()) return newNaN(context.runtime);</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">        if (val.isInfinity()) return this;</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">        if (isZero()) return newZero(context.runtime, value.signum());</span>

        // Java and MRI definitions of modulo are different.
<span class="nc" id="L611">        BigDecimal modulo = value.remainder(val.value);</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">        if (modulo.signum() * val.value.signum() &lt; 0) modulo = modulo.add(val.value);</span>

<span class="nc" id="L614">        return new RubyBigDecimal(context.runtime, modulo).setResult();</span>
    }

    @Override
    public IRubyObject remainder(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L619">        return remainder19(context, arg);</span>
    }

    @JRubyMethod(name = &quot;remainder&quot;, required = 1)
    public IRubyObject remainder19(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L624">        return remainderInternal(context, getVpValue19(context, arg, false), arg);</span>
    }

    private IRubyObject remainderInternal(ThreadContext context, RubyBigDecimal val, IRubyObject arg) {
        // TODO: full-precision remainder is 1000x slower than MRI!
<span class="nc bnc" id="L629" title="All 4 branches missed.">        if (isInfinity() || isNaN()) return newNaN(context.runtime);</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">        if (val == null) return callCoerced(context, &quot;remainder&quot;, arg, true);</span>
<span class="nc bnc" id="L631" title="All 6 branches missed.">        if (val.isInfinity() || val.isNaN() || val.isZero()) return newNaN(context.runtime);</span>

        // Java and MRI definitions of remainder are the same.
<span class="nc" id="L634">        return new RubyBigDecimal(context.runtime, value.remainder(val.value)).setResult();</span>
    }

    public IRubyObject op_mul(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L638">        return op_mul19(context, arg);</span>
    }

    @JRubyMethod(name = &quot;*&quot;, required = 1)
    public IRubyObject op_mul19(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L643">        return mult219(context, arg, bigDecimal(context.runtime).searchInternalModuleVariable(&quot;vpPrecLimit&quot;));</span>
    }

    public IRubyObject mult2(ThreadContext context, IRubyObject b, IRubyObject n) {
<span class="nc" id="L647">        return mult219(context, b, n);</span>
    }

    @JRubyMethod(name = &quot;mult&quot;, required = 2)
    public IRubyObject mult219(ThreadContext context, IRubyObject b, IRubyObject n) {
<span class="nc" id="L652">        RubyBigDecimal val = getVpValue19(context, b, false);</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">        if (val == null) return cannotBeCoerced(context, b, true);</span>

<span class="nc" id="L655">        return multInternal(context, val, b, n);</span>
    }

    private IRubyObject multInternal(ThreadContext context, RubyBigDecimal val, IRubyObject b, IRubyObject n) {
        // TODO: what about n arg?
<span class="nc bnc" id="L660" title="All 2 branches missed.">        if (val == null) return callCoerced(context, &quot;*&quot;, b);</span>

<span class="nc" id="L662">        int digits = RubyNumeric.fix2int(n);</span>

<span class="nc bnc" id="L664" title="All 4 branches missed.">        if (isNaN() || val.isNaN()) return newNaN(context.runtime);</span>
<span class="nc bnc" id="L665" title="All 8 branches missed.">        if ((isInfinity() &amp;&amp; val.isZero()) || (isZero() &amp;&amp; val.isInfinity())) return newNaN(context.runtime);</span>

<span class="nc bnc" id="L667" title="All 4 branches missed.">        if (isZero() || val.isZero()) {</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">            int sign1 = isZero()? zeroSign : value.signum();</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">            int sign2 = val.isZero() ?  val.zeroSign : val.value.signum();</span>
<span class="nc" id="L670">            return newZero(context.runtime, sign1 * sign2);</span>
        }

<span class="nc bnc" id="L673" title="All 4 branches missed.">        if (isInfinity() || val.isInfinity()) {</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">            int sign1 = isInfinity() ? infinitySign : value.signum();</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">            int sign2 = val.isInfinity() ? val.infinitySign : val.value.signum();</span>
<span class="nc" id="L676">            return newInfinity(context.runtime, sign1 * sign2);</span>
        }

<span class="nc" id="L679">        BigDecimal res = value.multiply(val.value);</span>
        // FIXME: rounding mode should not be hard-coded. See #mode.
<span class="nc bnc" id="L681" title="All 2 branches missed.">        if (res.precision() &gt; digits) res = res.round(new MathContext(digits,  RoundingMode.HALF_UP));</span>

<span class="nc" id="L683">        return new RubyBigDecimal(context.runtime, res).setResult();</span>
    }
    
    // Calculate appropriate zero or infinity depending on exponent...
    private IRubyObject newPowOfInfinity(ThreadContext context, IRubyObject exp) {
<span class="nc bnc" id="L688" title="All 2 branches missed.">        if (Numeric.f_negative_p(context, exp)) {</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">            if (infinitySign &gt;= 0) return newZero(context.runtime, 0);</span>

            // (-Infinity) ** (-even_integer) -&gt; +0 AND (-Infinity) ** (-odd_integer) -&gt; -0
<span class="nc bnc" id="L692" title="All 4 branches missed.">            if (Numeric.f_integer_p(context, exp).isTrue()) return newZero(context.runtime, is_even(exp) ? 1 : -1);</span>

<span class="nc" id="L694">            return newZero(context.runtime, -1); // (-Infinity) ** (-non_integer) -&gt; -0</span>
        }
             
<span class="nc bnc" id="L697" title="All 2 branches missed.">        if (infinitySign &gt;= 0) return newInfinity(context.runtime, 1);</span>

<span class="nc bnc" id="L699" title="All 4 branches missed.">        if (Numeric.f_integer_p(context, exp).isTrue()) return newInfinity(context.runtime, is_even(exp) ? 1 : -1);</span>

<span class="nc" id="L701">        throw context.runtime.newMathDomainError(&quot;a non-integral exponent for a negative base&quot;);</span>
    }
    
    @JRubyMethod(name = {&quot;**&quot;, &quot;power&quot;}, required = 1)
    public IRubyObject op_pow(ThreadContext context, IRubyObject exp) {
<span class="nc bnc" id="L706" title="All 2 branches missed.">        if (!(exp instanceof RubyFixnum)) throw getRuntime().newTypeError(&quot;wrong argument type &quot; + </span>
<span class="nc" id="L707">                exp.getMetaClass() + &quot; (expected Fixnum)&quot;);</span>

<span class="nc bnc" id="L709" title="All 2 branches missed.">        if (isNaN()) return newNaN(context.runtime);</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">        if (isInfinity()) return newPowOfInfinity(context, exp);</span>

<span class="nc" id="L712">        int times = RubyNumeric.fix2int(exp.convertToInteger());</span>

<span class="nc bnc" id="L714" title="All 2 branches missed.">        if (times &lt; 0) {</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">            if (isZero()) return newInfinity(getRuntime(), value.signum());</span>

            // Note: MRI has a very non-trivial way of calculating the precision,
            // so we use very simple approximation here:
<span class="nc" id="L719">            int precision = (-times + 4) * (getAllDigits().length() + 4);</span>

<span class="nc" id="L721">            return new RubyBigDecimal(getRuntime(),</span>
<span class="nc" id="L722">                    value.pow(times, new MathContext(precision, RoundingMode.HALF_UP)));</span>
        }
         
<span class="nc" id="L725">        return new RubyBigDecimal(getRuntime(), value.pow(times));</span>
    }

    public IRubyObject op_plus(ThreadContext context, IRubyObject b) {
<span class="nc" id="L729">        return op_plus19(context, b);</span>
    }

    @JRubyMethod(name = &quot;+&quot;)
    public IRubyObject op_plus19(ThreadContext context, IRubyObject b) {
<span class="nc" id="L734">        return addInternal(context, getVpValue19(context, b, false), b, </span>
<span class="nc" id="L735">                bigDecimal(context.runtime).searchInternalModuleVariable(&quot;vpPrecLimit&quot;));</span>
    }

    public IRubyObject add2(ThreadContext context, IRubyObject b, IRubyObject digits) {
<span class="nc" id="L739">        return add219(context, b, digits);</span>
    }

    @JRubyMethod(name = &quot;add&quot;)
    public IRubyObject add219(ThreadContext context, IRubyObject b, IRubyObject digits) {
<span class="nc" id="L744">        return addInternal(context, getVpValue19(context, b, false), b, digits);</span>
    }

    private IRubyObject addInternal(ThreadContext context, RubyBigDecimal val, IRubyObject b, IRubyObject digits) {
<span class="nc" id="L748">        Ruby runtime = context.runtime;</span>
<span class="nc" id="L749">        int prec = getPositiveInt(context, digits);</span>

<span class="nc bnc" id="L751" title="All 2 branches missed.">        if (val == null) {</span>
            // TODO:
            // MRI behavior: Call &quot;+&quot; or &quot;add&quot;, depending on the call.
            // But this leads to exceptions when Floats are added. See:
            // http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-core/17374
            // return callCoerced(context, op, b, true); -- this is MRI behavior.
            // We'll use ours for now, thus providing an ability to add Floats.
<span class="nc" id="L758">            return callCoerced(context, &quot;+&quot;, b, true);</span>
        }

<span class="nc" id="L761">        RubyBigDecimal res = handleAddSpecialValues(val);</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">        if (res != null) return res;</span>

<span class="nc" id="L764">        RoundingMode roundMode = getRoundingMode(runtime);</span>
<span class="nc" id="L765">        return new RubyBigDecimal(runtime, value.add(</span>
                val.value, new MathContext(prec, roundMode))); // TODO: why this: .setResult();
    }

    private int getPositiveInt(ThreadContext context, IRubyObject arg) {
<span class="nc bnc" id="L770" title="All 2 branches missed.">        if (!(arg instanceof RubyFixnum)) throw context.runtime.newTypeError(arg, context.runtime.getFixnum());</span>

<span class="nc" id="L772">        int _value = RubyNumeric.fix2int(arg);</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">        if (_value &lt; 0) throw context.runtime.newArgumentError(&quot;argument must be positive&quot;);</span>
<span class="nc" id="L774">        return _value;</span>
    }

    private RubyBigDecimal handleAddSpecialValues(RubyBigDecimal val) {
<span class="nc bnc" id="L778" title="All 4 branches missed.">        if (isNaN() || val.isNaN) return newNaN(getRuntime());</span>

<span class="nc" id="L780">        int sign = infinitySign * val.infinitySign;</span>
        
<span class="nc bnc" id="L782" title="All 4 branches missed.">        if (sign &gt; 0) return isInfinity() ? this : val;</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">        if (sign &lt; 0) return newNaN(getRuntime());</span>

        // sign == 0
<span class="nc" id="L786">        sign = infinitySign + val.infinitySign;</span>
        
<span class="nc bnc" id="L788" title="All 2 branches missed.">        if (sign != 0) return newInfinity(getRuntime(), sign);</span>

<span class="nc" id="L790">        return null;</span>
    }

    @Override
    @JRubyMethod(name = &quot;+@&quot;)
    public IRubyObject op_uplus() {
<span class="nc" id="L796">        return this;</span>
    }
    
    public IRubyObject op_minus(ThreadContext context, IRubyObject b) {
<span class="nc" id="L800">        return op_minus19(context, b);</span>
    }

    @JRubyMethod(name = &quot;-&quot;, required = 1)
    public IRubyObject op_minus19(ThreadContext context, IRubyObject b) {
<span class="nc" id="L805">        return subInternal(context, getVpValue19(context, b, true), b);</span>
    }

    public IRubyObject sub2(ThreadContext context, IRubyObject b, IRubyObject n) {
<span class="nc" id="L809">        return sub219(context, b, n);</span>
    }

    @JRubyMethod(name = &quot;sub&quot;, required = 2)
    public IRubyObject sub219(ThreadContext context, IRubyObject b, IRubyObject n) {
        // FIXME: Missing handling of n
<span class="nc" id="L815">        return subInternal(context, getVpValue19(context, b, false), b);</span>
    }

    private IRubyObject subInternal(ThreadContext context, RubyBigDecimal val, IRubyObject b) {
<span class="nc bnc" id="L819" title="All 2 branches missed.">        if (val == null) return callCoerced(context, &quot;-&quot;, b);</span>

<span class="nc" id="L821">        RubyBigDecimal res = handleMinusSpecialValues(val);</span>

<span class="nc bnc" id="L823" title="All 2 branches missed.">        return res != null ? res : new RubyBigDecimal(getRuntime(), value.subtract(val.value)).setResult();</span>
    }

    private RubyBigDecimal handleMinusSpecialValues(RubyBigDecimal val) {
<span class="nc bnc" id="L827" title="All 4 branches missed.">        if (isNaN() || val.isNaN()) return newNaN(getRuntime());</span>

<span class="nc" id="L829">        int sign = infinitySign * val.infinitySign;</span>
        
<span class="nc bnc" id="L831" title="All 2 branches missed.">        if (sign &gt; 0) return newNaN(getRuntime());</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">        if (sign &lt; 0) return this;</span>

        // sign == 0
<span class="nc bnc" id="L835" title="All 2 branches missed.">        if (isInfinity()) return this;</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">        if (val.isInfinity()) return newInfinity(getRuntime(), val.infinitySign * -1);</span>

<span class="nc" id="L838">        sign = infinitySign + val.infinitySign;</span>
            
<span class="nc bnc" id="L840" title="All 2 branches missed.">        if (sign != 0) return newInfinity(getRuntime(), sign);</span>

<span class="nc" id="L842">        return null;</span>
    }

    @JRubyMethod(name = &quot;-@&quot;)
    @Override
    public IRubyObject op_uminus(ThreadContext context) {
<span class="nc bnc" id="L848" title="All 2 branches missed.">        if (isNaN()) return newNaN(context.runtime);</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">        if (isInfinity()) return newInfinity(context.runtime, -infinitySign);</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">        if (isZero()) return newZero(context.runtime, -zeroSign);</span>

<span class="nc" id="L852">        return new RubyBigDecimal(getRuntime(), value.negate());</span>
    }

    public IRubyObject op_quo(ThreadContext context, IRubyObject other) {
<span class="nc" id="L856">        return op_quo20(context, other);</span>
    }

    public IRubyObject op_quo19(ThreadContext context, IRubyObject other) {   
<span class="nc" id="L860">        return op_quo19_20(context, other);</span>
    }
    
    @JRubyMethod(name = {&quot;/&quot;, &quot;quo&quot;})
    public IRubyObject op_quo20(ThreadContext context, IRubyObject other) {
<span class="nc" id="L865">        return op_quo19_20(context, other);</span>
    }
    
    private IRubyObject op_quo19_20(ThreadContext context, IRubyObject other) {
<span class="nc" id="L869">        RubyObject preciseOther = getVpValue19(context, other, true);</span>
        // regular division with some default precision
        // TODO: proper algorithm to set the precision
<span class="nc" id="L872">        return op_div(context, preciseOther, getRuntime().newFixnum(200));</span>
    }
    
    public IRubyObject op_div(ThreadContext context, IRubyObject other) {
        // integer division
<span class="nc" id="L877">        RubyBigDecimal val = getVpValue(context, other, false);</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">        if (val == null) return callCoerced(context, &quot;div&quot;, other);</span>
<span class="nc bnc" id="L879" title="All 6 branches missed.">        if (isNaN() || val.isZero() || val.isNaN()) return newNaN(context.runtime);</span>
<span class="nc bnc" id="L880" title="All 4 branches missed.">        if (isInfinity() || val.isInfinity()) return newNaN(context.runtime);</span>

<span class="nc" id="L882">        return new RubyBigDecimal(context.runtime,</span>
<span class="nc" id="L883">                this.value.divideToIntegralValue(val.value)).setResult();</span>
    }

    @JRubyMethod(name = &quot;div&quot;)
    public IRubyObject op_div19(ThreadContext context, IRubyObject r) {
<span class="nc" id="L888">        RubyBigDecimal val = getVpValue19(context, r, true);</span>

<span class="nc bnc" id="L890" title="All 2 branches missed.">        if (val == null) return cannotBeCoerced(context, val, true);</span>
<span class="nc bnc" id="L891" title="All 4 branches missed.">        if (isNaN() || val.isNaN()) throw context.runtime.newFloatDomainError(&quot;Computation results to 'NaN'&quot;);</span>
<span class="nc bnc" id="L892" title="All 4 branches missed.">        if (isInfinity() &amp;&amp; val.isOne()) throw context.runtime.newFloatDomainError(&quot;Computation results to 'Infinity'&quot;);</span>
        
<span class="nc bnc" id="L894" title="All 2 branches missed.">        if (val.isInfinity()) return newZero(getRuntime(), val.infinitySign);</span>

<span class="nc bnc" id="L896" title="All 4 branches missed.">        if (isZero() || val.isZero()) throw context.runtime.newZeroDivisionError();</span>

<span class="nc" id="L898">        return op_div(context, r);</span>
    }

    public IRubyObject op_div(ThreadContext context, IRubyObject other, IRubyObject digits) {
        // TODO: take BigDecimal.mode into account.

<span class="nc" id="L904">        int scale = RubyNumeric.fix2int(digits);</span>

<span class="nc" id="L906">        RubyBigDecimal val = getVpValue(context, other, false);</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">        if (val == null) return callCoerced(context, &quot;/&quot;, other);</span>
<span class="nc bnc" id="L908" title="All 8 branches missed.">        if (isNaN() || (isZero() &amp;&amp; val.isZero()) || val.isNaN()) return newNaN(getRuntime());</span>

<span class="nc bnc" id="L910" title="All 2 branches missed.">        if (val.isZero()) {</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">            int sign1 = isInfinity() ? infinitySign : value.signum();</span>
<span class="nc" id="L912">            return newInfinity(context.runtime, sign1 * val.zeroSign);</span>
        }

<span class="nc bnc" id="L915" title="All 4 branches missed.">        if (isInfinity() &amp;&amp; !val.isInfinity()) return newInfinity(context.runtime, infinitySign * val.value.signum());</span>
<span class="nc bnc" id="L916" title="All 4 branches missed.">        if (!isInfinity() &amp;&amp; val.isInfinity()) return newZero(context.runtime, value.signum() * val.infinitySign);</span>
<span class="nc bnc" id="L917" title="All 4 branches missed.">        if (isInfinity() &amp;&amp; val.isInfinity()) return newNaN(context.runtime);</span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">        if (isZero()) return newZero(context.runtime, zeroSign * val.value.signum());</span>

        // MRI behavior: &quot;If digits is 0, the result is the same as the / operator.&quot;
<span class="nc bnc" id="L921" title="All 2 branches missed.">        if (scale == 0) return op_quo(context, other);</span>

        // TODO: better algorithm to set precision needed
<span class="nc" id="L924">        int prec = Math.max(200, scale);</span>
<span class="nc" id="L925">        return new RubyBigDecimal(context.runtime,</span>
<span class="nc" id="L926">                value.divide(val.value, new MathContext(prec, RoundingMode.HALF_UP))).setResult(scale);</span>
    }
    
    @JRubyMethod(name = &quot;div&quot;)
    public IRubyObject op_div19(ThreadContext context, IRubyObject other, IRubyObject digits) {
<span class="nc" id="L931">        RubyBigDecimal val = getVpValue(context, other, false);</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">        if (val == null) return cannotBeCoerced(context, val, true);</span>

<span class="nc bnc" id="L934" title="All 4 branches missed.">        if (isNaN() || val.isNaN()) {</span>
<span class="nc" id="L935">            throw context.runtime.newFloatDomainError(&quot;Computation results to 'NaN'&quot;);</span>
        }
        
<span class="nc" id="L938">        return op_div(context, other, digits);</span>
    }

    private IRubyObject cmp(ThreadContext context, IRubyObject r, char op) {
        int e;
<span class="nc" id="L943">        RubyBigDecimal rb = getVpValue(context, r, false);</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">        if (rb == null) {</span>
<span class="nc" id="L945">            IRubyObject ee = callCoerced(context, &quot;&lt;=&gt;&quot;, r);</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">            if (ee.isNil()) {</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">                if (op == '*') return getRuntime().getNil();</span>
<span class="nc bnc" id="L948" title="All 4 branches missed.">                if (op == '=' || isNaN()) return getRuntime().getFalse();</span>
                    
<span class="nc" id="L950">                throw getRuntime().newArgumentError(&quot;nil could not be coerced into a BigDecmil&quot;);</span>
            }
<span class="nc" id="L952">            e = RubyNumeric.fix2int(ee);</span>
<span class="nc" id="L953">        } else {</span>
<span class="nc bnc" id="L954" title="All 6 branches missed.">            if (isNaN() || rb.isNaN()) return op == '*' ? getRuntime().getNil() : getRuntime().getFalse();</span>

<span class="nc bnc" id="L956" title="All 4 branches missed.">            e = infinitySign != 0 || rb.infinitySign != 0 ?</span>
<span class="nc" id="L957">                    infinitySign - rb.infinitySign : value.compareTo(rb.value);</span>
        }
<span class="nc bnc" id="L959" title="All 8 branches missed.">        switch(op) {</span>
<span class="nc" id="L960">        case '*': return getRuntime().newFixnum(e);</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">        case '=': return (e==0)?getRuntime().getTrue():getRuntime().getFalse();</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">        case '!': return (e!=0)?getRuntime().getTrue():getRuntime().getFalse();</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">        case 'G': return (e&gt;=0)?getRuntime().getTrue():getRuntime().getFalse();</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">        case '&gt;': return (e&gt; 0)?getRuntime().getTrue():getRuntime().getFalse();</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">        case 'L': return (e&lt;=0)?getRuntime().getTrue():getRuntime().getFalse();</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">        case '&lt;': return (e&lt; 0)?getRuntime().getTrue():getRuntime().getFalse();</span>
        }
<span class="nc" id="L968">        return getRuntime().getNil();</span>
    }

    @Override
    @JRubyMethod(name = &quot;&lt;=&gt;&quot;, required = 1)
    public IRubyObject op_cmp(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L974">        return cmp(context, arg, '*');</span>
    }

    @Override
    @JRubyMethod(name = {&quot;eql?&quot;, &quot;==&quot;, &quot;===&quot;}, required = 1)
    public IRubyObject eql_p(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L980">        return cmp(context, arg, '=');</span>
    }

    @JRubyMethod(name = &quot;&lt;&quot;, required = 1)
    public IRubyObject op_lt(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L985">        return cmp(context, arg, '&lt;');</span>
    }

    @JRubyMethod(name = &quot;&lt;=&quot;, required = 1)
    public IRubyObject op_le(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L990">        return cmp(context, arg, 'L');</span>
    }

    @JRubyMethod(name = &quot;&gt;&quot;, required = 1)
    public IRubyObject op_gt(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L995">        return cmp(context, arg, '&gt;');</span>
    }

    @JRubyMethod(name = &quot;&gt;=&quot;, required = 1)
    public IRubyObject op_ge(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L1000">        return cmp(context, arg, 'G');</span>
    }

    @JRubyMethod
    public IRubyObject abs() {
<span class="nc bnc" id="L1005" title="All 2 branches missed.">        if (isNaN()) return newNaN(getRuntime());</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">        if (isInfinity()) return newInfinity(getRuntime(), 1);</span>

<span class="nc" id="L1008">        return new RubyBigDecimal(getRuntime(), value.abs()).setResult();</span>
    }

    @JRubyMethod
    public IRubyObject ceil(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L1013">        checkFloatDomain();</span>

<span class="nc" id="L1015">        int n = RubyNumeric.fix2int(arg);</span>
        
<span class="nc bnc" id="L1017" title="All 2 branches missed.">        if (value.scale() &lt;= n) return this; // no rounding neccessary</span>
        
<span class="nc" id="L1019">        return new RubyBigDecimal(getRuntime(), value.setScale(n, RoundingMode.CEILING));</span>
    }
    
    @JRubyMethod
    public IRubyObject ceil(ThreadContext context) {
<span class="nc" id="L1024">        checkFloatDomain();</span>

<span class="nc" id="L1026">        BigInteger ceil = value.setScale(0, RoundingMode.CEILING).toBigInteger();</span>
        
<span class="nc bnc" id="L1028" title="All 2 branches missed.">        if (ceil.compareTo(BigInteger.valueOf((long) ceil.intValue())) == 0) { // It fits in Fixnum</span>
<span class="nc" id="L1029">            return RubyInteger.int2fix(context.runtime, ceil.intValue());</span>
        }

<span class="nc" id="L1032">        return RubyBignum.newBignum(context.runtime, ceil);</span>
    }

    // FIXME: Do we really need this Java inheritence for coerce?
    @Override
    public IRubyObject coerce(IRubyObject other) {
<span class="nc" id="L1038">        return coerce(getRuntime().getCurrentContext(), other);</span>
    }

    @JRubyMethod
    public IRubyObject coerce(ThreadContext context, IRubyObject other) {
<span class="nc bnc" id="L1043" title="All 2 branches missed.">        if (other instanceof RubyFloat) return getRuntime().newArray(other, to_f());</span>

<span class="nc" id="L1045">        return getRuntime().newArray(getVpValue(context, other, true), this);</span>
    }

    @Override
    public double getDoubleValue() {
<span class="nc" id="L1050">        return SafeDoubleParser.doubleValue(value);</span>
    }
    
    @Override
    public long getLongValue() {
<span class="nc" id="L1055">        return value.longValue();</span>
    }

    @Override
    public int getIntValue() {
<span class="nc" id="L1060">        return value.intValue();</span>
    }

    @Override
    public BigInteger getBigIntegerValue() {
<span class="nc" id="L1065">        return value.toBigInteger();</span>
    }

    public BigDecimal getBigDecimalValue() {
<span class="nc" id="L1069">        return value;</span>
    }

    public RubyNumeric multiplyWith(ThreadContext context, RubyInteger value) { 
<span class="nc" id="L1073">        return (RubyNumeric)op_mul(context, value);</span>
    }

    public RubyNumeric multiplyWith(ThreadContext context, RubyFloat value) { 
<span class="nc" id="L1077">        return (RubyNumeric)op_mul(context, value);</span>
    }

    public RubyNumeric multiplyWith(ThreadContext context, RubyBignum value) { 
<span class="nc" id="L1081">        return (RubyNumeric)op_mul(context, value);</span>
    }

    @Override
    public IRubyObject divmod(ThreadContext context, IRubyObject other) {
<span class="nc" id="L1086">        return divmod19(context, other);</span>
    }
    
    @Override
    @JRubyMethod(name = &quot;divmod&quot;)
    public IRubyObject divmod19(ThreadContext context, IRubyObject other) {
        // TODO: full-precision divmod is 1000x slower than MRI!
<span class="nc" id="L1093">        Ruby runtime = context.runtime;</span>
<span class="nc" id="L1094">        RubyBigDecimal val = getVpValue19(context, other, false);</span>

<span class="nc bnc" id="L1096" title="All 2 branches missed.">        if (val == null) return callCoerced(context, &quot;divmod&quot;, other, true);</span>
<span class="nc bnc" id="L1097" title="All 8 branches missed.">        if (isNaN() || val.isNaN() || isInfinity() &amp;&amp; val.isInfinity()) return RubyArray.newArray(runtime, newNaN(runtime), newNaN(runtime));</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">        if (val.isZero()) throw context.runtime.newZeroDivisionError();</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">        if (isInfinity()) {</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">            int sign = (infinitySign == val.value.signum()) ? 1 : -1;</span>
<span class="nc" id="L1101">            return RubyArray.newArray(runtime, newInfinity(runtime, sign), newNaN(runtime));</span>
        }
<span class="nc bnc" id="L1103" title="All 2 branches missed.">        if (val.isInfinity()) return RubyArray.newArray(runtime, newZero(runtime, val.value.signum()), this);</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">        if (isZero()) return RubyArray.newArray(runtime, newZero(runtime, value.signum()), newZero(runtime, value.signum()));</span>

        // Java and MRI definitions of divmod are different.
<span class="nc" id="L1107">        BigDecimal[] divmod = value.divideAndRemainder(val.value);</span>

<span class="nc" id="L1109">        BigDecimal div = divmod[0];</span>
<span class="nc" id="L1110">        BigDecimal mod = divmod[1];</span>

<span class="nc bnc" id="L1112" title="All 2 branches missed.">        if (mod.signum() * val.value.signum() &lt; 0) {</span>
<span class="nc" id="L1113">            div = div.subtract(BigDecimal.ONE);</span>
<span class="nc" id="L1114">            mod = mod.add(val.value);</span>
        }

<span class="nc" id="L1117">        return RubyArray.newArray(runtime, new RubyBigDecimal(runtime, div), new RubyBigDecimal(runtime, mod));</span>
    }
    
    @JRubyMethod
    public IRubyObject exponent() {
<span class="nc" id="L1122">        return getRuntime().newFixnum(getExponent());</span>
    }

    @JRubyMethod(name = &quot;finite?&quot;)
    public IRubyObject finite_p() {
<span class="nc bnc" id="L1127" title="All 4 branches missed.">        return getRuntime().newBoolean(!isNaN() &amp;&amp; !isInfinity());</span>
    }

    private void floorNaNInfinityCheck(Ruby runtime) {
<span class="nc bnc" id="L1131" title="All 4 branches missed.">        if (isNaN() || isInfinity()) {</span>
<span class="nc" id="L1132">            throw runtime.newFloatDomainError(&quot;Computation results to '&quot; + to_s(NULL_ARRAY).asJavaString() + &quot;'&quot;);</span>
        }        
<span class="nc" id="L1134">    }</span>
    
    private RubyBigDecimal floorInternal(ThreadContext context, int n) {
<span class="nc bnc" id="L1137" title="All 2 branches missed.">        return value.scale() &gt; n ? new RubyBigDecimal(context.runtime, value.setScale(n, RoundingMode.FLOOR)) : this;</span>
    }
    
    @JRubyMethod public IRubyObject floor(ThreadContext context) {
<span class="nc" id="L1141">        floorNaNInfinityCheck(context.runtime);</span>
<span class="nc" id="L1142">        return floorInternal(context, 0).to_int();</span>
    }
    
    @JRubyMethod public IRubyObject floor(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L1146">        floorNaNInfinityCheck(context.runtime);</span>
<span class="nc" id="L1147">        return floorInternal(context, RubyNumeric.fix2int(arg));</span>
     }    
 
    @JRubyMethod
    public IRubyObject frac(ThreadContext context) {
<span class="nc bnc" id="L1152" title="All 2 branches missed.">        if (isNaN()) return newNaN(context.runtime);</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">        if (isInfinity()) return newInfinity(context.runtime, infinitySign);</span>

<span class="nc bnc" id="L1155" title="All 4 branches missed.">        if (value.scale() &gt; 0 &amp;&amp; value.precision() &lt; value.scale()) return new RubyBigDecimal(context.runtime, value);</span>

<span class="nc" id="L1157">        return new RubyBigDecimal(context.runtime, value.subtract(((RubyBigDecimal)fix()).value));</span>
    }

    @JRubyMethod(name = &quot;infinite?&quot;)
    public IRubyObject infinite_p(ThreadContext context) {
<span class="nc bnc" id="L1162" title="All 2 branches missed.">        return infinitySign == 0 ? context.runtime.getNil() : context.runtime.newFixnum(infinitySign);</span>
    }

    @JRubyMethod
    public IRubyObject inspect(ThreadContext context) {
<span class="nc" id="L1167">        StringBuilder val = new StringBuilder(&quot;#&lt;BigDecimal:&quot;);</span>

<span class="nc" id="L1169">        val.append(Integer.toHexString(System.identityHashCode(this))).append(&quot;,&quot;);</span>
<span class="nc" id="L1170">        val.append(&quot;'&quot;).append(callMethod(context, &quot;to_s&quot;)).append(&quot;'&quot;).append(&quot;,&quot;);</span>
<span class="nc" id="L1171">        val.append(getSignificantDigits().length()).append(&quot;(&quot;);</span>
<span class="nc" id="L1172">        val.append(((getAllDigits().length() / 4) + 1) * 4).append(&quot;)&quot;).append(&quot;&gt;&quot;);</span>

<span class="nc" id="L1174">        return getRuntime().newString(val.toString());</span>
    }

    @JRubyMethod(name = &quot;nan?&quot;)
    public IRubyObject nan_p(ThreadContext context) {
<span class="nc" id="L1179">        return context.runtime.newBoolean(isNaN());</span>
    }

    @JRubyMethod(name = &quot;nonzero?&quot;)
    public IRubyObject nonzero_p() {
<span class="nc bnc" id="L1184" title="All 2 branches missed.">        return isZero() ? getRuntime().getNil() : this;</span>
    }
 
    @JRubyMethod
    public IRubyObject precs(ThreadContext context) {
<span class="nc" id="L1189">        return RubyArray.newArrayNoCopy(context.runtime, </span>
<span class="nc" id="L1190">                new IRubyObject[] {context.runtime.newFixnum(getSignificantDigits().length()), </span>
<span class="nc" id="L1191">                                   context.runtime.newFixnum(((getAllDigits().length() / 4) + 1) * 4)});</span>
    }
    
    @JRubyMethod(name = &quot;round&quot;, optional = 2)
    public IRubyObject round(ThreadContext context, IRubyObject[] args) {
<span class="nc bnc" id="L1196" title="All 2 branches missed.">        int scale = args.length &gt; 0 ? num2int(args[0]) : 0;</span>

        // Special treatment for BigDecimal::NAN and BigDecimal::INFINITY
        //
        // If round is called without any argument, we should raise a
        // FloatDomainError. Otherwise, we don't have to call round ;
        // we can simply return the number itself.
<span class="nc bnc" id="L1203" title="All 6 branches missed.">        if (scale == 0 &amp;&amp; (isNaN() || isInfinity())) {</span>
<span class="nc" id="L1204">            StringBuilder message = new StringBuilder(&quot;Computation results to &quot;);</span>
<span class="nc" id="L1205">            message.append(&quot;'&quot;).append(callMethod(context, &quot;to_s&quot;)).append(&quot;'&quot;);</span>

            // To be consistent with MRI's output
<span class="nc bnc" id="L1208" title="All 2 branches missed.">            if (isNaN()) message.append(&quot;(Not a Number)&quot;);</span>

<span class="nc" id="L1210">            throw getRuntime().newFloatDomainError(message.toString());</span>
        } else {
<span class="nc bnc" id="L1212" title="All 2 branches missed.">            if (isNaN()) {</span>
<span class="nc" id="L1213">                return newNaN(context.runtime);</span>
<span class="nc bnc" id="L1214" title="All 2 branches missed.">            } else if (isInfinity()) {</span>
<span class="nc" id="L1215">                return newInfinity(context.runtime, infinitySign);</span>
            }
        }

<span class="nc bnc" id="L1219" title="All 2 branches missed.">        RoundingMode mode = (args.length &gt; 1) ? javaRoundingModeFromRubyRoundingMode(context.runtime, args[1]) : getRoundingMode(context.runtime);</span>
        // JRUBY-914: Java 1.4 BigDecimal does not allow a negative scale, so we have to simulate it
<span class="nc" id="L1221">        RubyBigDecimal bigDecimal = null;</span>
<span class="nc bnc" id="L1222" title="All 2 branches missed.">        if (scale &lt; 0) {</span>
          // shift the decimal point just to the right of the digit to be rounded to (divide by 10**(abs(scale)))
          // -1 -&gt; 10's digit, -2 -&gt; 100's digit, etc.
<span class="nc" id="L1225">          BigDecimal normalized = value.movePointRight(scale);</span>
          // ...round to that digit
<span class="nc" id="L1227">          BigDecimal rounded = normalized.setScale(0, mode);</span>
          // ...and shift the result back to the left (multiply by 10**(abs(scale)))
<span class="nc" id="L1229">          bigDecimal = new RubyBigDecimal(getRuntime(), rounded.movePointLeft(scale));</span>
<span class="nc" id="L1230">        } else {</span>
<span class="nc" id="L1231">          bigDecimal = new RubyBigDecimal(getRuntime(), value.setScale(scale, mode));</span>
        }
<span class="nc bnc" id="L1233" title="All 2 branches missed.">        if (args.length == 0) {</span>
<span class="nc" id="L1234">            return bigDecimal.to_int();</span>
        } else {
<span class="nc" id="L1236">            return bigDecimal;</span>
        }
    }
    
    public IRubyObject round(ThreadContext context, IRubyObject scale, IRubyObject mode) {
<span class="nc" id="L1241">        return round(context, new IRubyObject[]{scale, mode});</span>
    }    

    //this relies on the Ruby rounding enumerations == Java ones, which they (currently) all are
    private static RoundingMode javaRoundingModeFromRubyRoundingMode(Ruby runtime, IRubyObject arg) {
<span class="nc bnc" id="L1246" title="All 2 branches missed.">        if (arg instanceof RubySymbol) {</span>
<span class="nc" id="L1247">            RubySymbol roundingModeSymbol = (RubySymbol) arg;</span>
<span class="nc" id="L1248">            String roundingModeString = roundingModeSymbol.asJavaString();</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">            if (roundingModeString.equals(&quot;up&quot;)) {</span>
<span class="nc" id="L1250">                return RoundingMode.UP;</span>
<span class="nc bnc" id="L1251" title="All 4 branches missed.">            } else if (roundingModeString.equals(&quot;down&quot;) || roundingModeString.equals(&quot;truncate&quot;)) {</span>
<span class="nc" id="L1252">                return RoundingMode.DOWN;</span>
<span class="nc bnc" id="L1253" title="All 4 branches missed.">            } else if (roundingModeString.equals(&quot;half_up&quot;) || roundingModeString.equals(&quot;default&quot;)) {</span>
<span class="nc" id="L1254">                return RoundingMode.HALF_UP;</span>
<span class="nc bnc" id="L1255" title="All 2 branches missed.">            } else if (roundingModeString.equals(&quot;half_down&quot;)) {</span>
<span class="nc" id="L1256">                return RoundingMode.HALF_DOWN;</span>
<span class="nc bnc" id="L1257" title="All 4 branches missed.">            } else if (roundingModeString.equals(&quot;half_even&quot;) || roundingModeString.equals(&quot;banker&quot;)) {</span>
<span class="nc" id="L1258">                return RoundingMode.HALF_EVEN;</span>
<span class="nc bnc" id="L1259" title="All 4 branches missed.">            } else if (roundingModeString.equals(&quot;ceiling&quot;) || roundingModeString.equals(&quot;ceil&quot;)) {</span>
<span class="nc" id="L1260">                return RoundingMode.CEILING;</span>
<span class="nc bnc" id="L1261" title="All 2 branches missed.">            } else if (roundingModeString.equals(&quot;floor&quot;)) {</span>
<span class="nc" id="L1262">                return RoundingMode.FLOOR;</span>
            } else {
<span class="nc" id="L1264">                throw runtime.newArgumentError(&quot;invalid rounding mode&quot;);</span>
            }
        } else {
            try {
<span class="nc" id="L1268">                return RoundingMode.valueOf(num2int(arg));</span>
<span class="nc" id="L1269">            } catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L1270">                throw runtime.newArgumentError(&quot;invalid rounding mode&quot;);</span>
            }
        }
    }
    
    @JRubyMethod
    public IRubyObject sign() {
<span class="nc bnc" id="L1277" title="All 2 branches missed.">        if (isNaN()) return getMetaClass().getConstant(&quot;SIGN_NaN&quot;);</span>
<span class="nc bnc" id="L1278" title="All 4 branches missed.">        if (isInfinity()) return getMetaClass().getConstant(infinitySign &lt; 0 ? &quot;SIGN_NEGATIVE_INFINITE&quot; : &quot;SIGN_POSITIVE_INFINITE&quot;);</span>
<span class="nc bnc" id="L1279" title="All 4 branches missed.">        if (isZero()) return getMetaClass().getConstant(zeroSign &lt; 0 ? &quot;SIGN_NEGATIVE_ZERO&quot; : &quot;SIGN_POSITIVE_ZERO&quot;);</span>
        
<span class="nc bnc" id="L1281" title="All 2 branches missed.">        return getMetaClass().getConstant(value.signum() &lt; 0 ? &quot;SIGN_NEGATIVE_FINITE&quot; : &quot;SIGN_POSITIVE_FINITE&quot;);</span>
    }
    
    private RubyFixnum signValue(Ruby runtime) {
<span class="nc bnc" id="L1285" title="All 2 branches missed.">        if (isNaN()) return RubyFixnum.zero(runtime);</span>
<span class="nc bnc" id="L1286" title="All 2 branches missed.">        if (isInfinity()) return runtime.newFixnum(infinitySign);</span>
<span class="nc bnc" id="L1287" title="All 2 branches missed.">        if (isZero()) return runtime.newFixnum(zeroSign);</span>

<span class="nc" id="L1289">        return runtime.newFixnum(value.signum());</span>
    } 

    @JRubyMethod
    public RubyArray split(ThreadContext context) {
<span class="nc" id="L1294">        return RubyArray.newArrayNoCopy(context.runtime, new IRubyObject[] {</span>
<span class="nc" id="L1295">            signValue(context.runtime), context.runtime.newString(splitDigits()), </span>
<span class="nc" id="L1296">            context.runtime.newFixnum(10), exponent()</span>
        });
    }
    
    private String splitDigits() {
<span class="nc bnc" id="L1301" title="All 2 branches missed.">        if (isNaN()) return &quot;NaN&quot;;</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">        if (isInfinity()) return &quot;Infinity&quot;;</span>
<span class="nc bnc" id="L1303" title="All 2 branches missed.">        if (isZero()) return &quot;0&quot;;</span>

<span class="nc" id="L1305">        return getSignificantDigits();</span>
    }
    
    // it doesn't handle special cases
    private String getSignificantDigits() {
        // TODO: no need to calculate every time.
<span class="nc" id="L1311">        return value.abs().stripTrailingZeros().unscaledValue().toString();</span>
    }

    private String getAllDigits() {
        // TODO: no need to calculate every time.
<span class="nc" id="L1316">        return value.abs().unscaledValue().toString();</span>
    }    

    private int getExponent() {
<span class="nc bnc" id="L1320" title="All 6 branches missed.">        if (isZero() || isNaN() || isInfinity()) return 0;</span>

<span class="nc" id="L1322">        BigDecimal val = value.abs().stripTrailingZeros();</span>
<span class="nc" id="L1323">        return val.precision() - val.scale();</span>
    }

    @JRubyMethod
    public IRubyObject sqrt(IRubyObject arg) {
<span class="nc" id="L1328">        Ruby runtime = getRuntime();</span>
<span class="nc bnc" id="L1329" title="All 2 branches missed.">        if (isNaN()) throw runtime.newFloatDomainError(&quot;(VpSqrt) SQRT(NaN value)&quot;);</span>
<span class="nc bnc" id="L1330" title="All 6 branches missed.">        if ((isInfinity() &amp;&amp; infinitySign &lt; 0) || value.signum() &lt; 0) throw runtime.newFloatDomainError(&quot;(VpSqrt) SQRT(negative value)&quot;);</span>
<span class="nc bnc" id="L1331" title="All 4 branches missed.">        if (isInfinity() &amp;&amp; infinitySign &gt; 0) return newInfinity(runtime, 1);</span>

        // NOTE: MRI's sqrt precision is limited by 100,
        // but we allow values more than 100.
<span class="nc" id="L1335">        int n = RubyNumeric.fix2int(arg);</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">        if (n &lt; 0) throw runtime.newArgumentError(&quot;argument must be positive&quot;);</span>

<span class="nc" id="L1338">        n += 4; // just in case, add a bit of extra precision</span>

<span class="nc" id="L1340">        return new RubyBigDecimal(runtime, bigSqrt(value, new MathContext(n, RoundingMode.HALF_UP))).setResult();</span>
    }

    @JRubyMethod
    public IRubyObject to_f() {
<span class="nc bnc" id="L1345" title="All 2 branches missed.">        if (isNaN()) return RubyFloat.newFloat(getRuntime(), Double.NaN);</span>
<span class="nc bnc" id="L1346" title="All 4 branches missed.">        if (isInfinity()) return RubyFloat.newFloat(getRuntime(), infinitySign &lt; 0 ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);</span>
<span class="nc bnc" id="L1347" title="All 4 branches missed.">        if (isZero()) return RubyFloat.newFloat(getRuntime(), zeroSign &lt; 0 ? -0.0 : 0.0);</span>
<span class="nc bnc" id="L1348" title="All 2 branches missed.">        if (-value.scale() &lt;= RubyFloat.MAX_10_EXP) return RubyFloat.newFloat(getRuntime(), SafeDoubleParser.doubleValue(value));</span>

<span class="nc bnc" id="L1350" title="All 4 branches missed.">        switch (value.signum()) {</span>
<span class="nc" id="L1351">            case -1: return RubyFloat.newFloat(getRuntime(), Double.NEGATIVE_INFINITY);</span>
<span class="nc" id="L1352">            case 0: return RubyFloat.newFloat(getRuntime(), 0);</span>
<span class="nc" id="L1353">            case 1: return RubyFloat.newFloat(getRuntime(), Double.POSITIVE_INFINITY);</span>
        }

<span class="nc" id="L1356">        throw getRuntime().newArgumentError(&quot;signum of this rational is invalid: &quot; + value.signum());</span>
    }

    @JRubyMethod(name = {&quot;to_i&quot;, &quot;to_int&quot;})
    public IRubyObject to_int() {
<span class="nc" id="L1361">        checkFloatDomain();</span>
    
        try {
<span class="nc" id="L1364">            return RubyNumeric.int2fix(getRuntime(), value.longValueExact());</span>
<span class="nc" id="L1365">        } catch (ArithmeticException ae) {</span>
<span class="nc" id="L1366">            return RubyBignum.bignorm(getRuntime(), value.toBigInteger());            </span>
        }
    }
    
    private String removeTrailingZeroes(String in) {
<span class="nc bnc" id="L1371" title="All 4 branches missed.">        while(in.length() &gt; 0 &amp;&amp; in.charAt(in.length()-1)=='0') {</span>
<span class="nc" id="L1372">            in = in.substring(0, in.length()-1);</span>
        }
<span class="nc" id="L1374">        return in;</span>
    }
  
    public static boolean formatHasLeadingPlus(String format) {
<span class="nc" id="L1378">        return format.startsWith(&quot;+&quot;);</span>
    }

    public static boolean formatHasLeadingSpace(String format) {
<span class="nc" id="L1382">        return format.startsWith(&quot; &quot;);</span>
    }

    public static boolean formatHasFloatingPointNotation(String format) {
<span class="nc" id="L1386">        return format.endsWith(&quot;F&quot;);</span>
    }

    public static int formatFractionalDigitGroups(String format) {
<span class="nc" id="L1390">        Matcher m = Pattern.compile(&quot;(\\+| )?(\\d+)(E|F)?&quot;).matcher(format);</span>
        
<span class="nc bnc" id="L1392" title="All 2 branches missed.">        return m.matches() ? Integer.parseInt(m.group(2)) : 0;</span>
    }
    
    private boolean hasArg(IRubyObject[] args) {
<span class="nc bnc" id="L1396" title="All 4 branches missed.">        return args.length != 0 &amp;&amp; !args[0].isNil();</span>
    }

    private String format(IRubyObject[] args) {
<span class="nc" id="L1400">        return args[0].toString();</span>
    }

    private String firstArgument(IRubyObject[] args) {
<span class="nc bnc" id="L1404" title="All 2 branches missed.">        return hasArg(args) ? format(args) : null;</span>
    }

    private boolean posSpace(String arg) {
<span class="nc bnc" id="L1408" title="All 4 branches missed.">        return arg != null &amp;&amp; formatHasLeadingSpace(arg);</span>
    }

    private boolean posSign(String arg) {
<span class="nc bnc" id="L1412" title="All 6 branches missed.">        return arg != null &amp;&amp; (formatHasLeadingPlus(arg) || posSpace(arg));</span>
    }

    private boolean asEngineering(String arg) {
<span class="nc bnc" id="L1416" title="All 4 branches missed.">        return arg == null || !formatHasFloatingPointNotation(arg);</span>
    }

    private int groups(String arg) {
<span class="nc bnc" id="L1420" title="All 2 branches missed.">        return arg != null ? formatFractionalDigitGroups(arg) : 0;</span>
    }

    private boolean isZero() {
<span class="nc bnc" id="L1424" title="All 6 branches missed.">        return !isNaN() &amp;&amp; !isInfinity() &amp;&amp; (value.signum() == 0);</span>
    }

    private boolean isOne() {
<span class="nc bnc" id="L1428" title="All 2 branches missed.">        return value.abs().compareTo(BigDecimal.ONE) == 0;</span>
    }

    private boolean isNaN() {
<span class="nc" id="L1432">        return isNaN;</span>
    }

    private boolean isInfinity() {
<span class="nc bnc" id="L1436" title="All 2 branches missed.">        return infinitySign != 0;</span>
    }

    private String unscaledValue() {
<span class="nc" id="L1440">        return value.abs().unscaledValue().toString();</span>
    }
    
    private String sign(String arg, int signum) {
<span class="nc bnc" id="L1444" title="All 8 branches missed.">        return signum == -1 ? &quot;-&quot; : (signum == 1 ? (posSign(arg) ? (posSpace(arg) ? &quot; &quot; : &quot;+&quot;) : &quot;&quot;) : &quot;&quot;);</span>
    }

    private IRubyObject engineeringValue(String arg) {
<span class="nc" id="L1448">        StringBuilder build = new StringBuilder().append(sign(arg, value.signum())).append(&quot;0.&quot;);</span>
<span class="nc" id="L1449">        String s = removeTrailingZeroes(unscaledValue());</span>
        
<span class="nc bnc" id="L1451" title="All 2 branches missed.">        if (groups(arg) == 0) {</span>
<span class="nc bnc" id="L1452" title="All 2 branches missed.">            build.append(&quot;&quot;.equals(s) ? &quot;0&quot; : s);</span>
        } else {
<span class="nc" id="L1454">            int length = s.length();</span>
<span class="nc" id="L1455">            String sep = &quot;&quot;;</span>

<span class="nc bnc" id="L1457" title="All 2 branches missed.">            for (int index = 0; index &lt; length; index += groups(arg)) {</span>
<span class="nc" id="L1458">                int next = index + groups(arg);</span>
<span class="nc bnc" id="L1459" title="All 2 branches missed.">                build.append(sep).append(s.substring(index, next &gt; length ? length : next));</span>
<span class="nc" id="L1460">                sep = &quot; &quot;;</span>
            }
        }
<span class="nc" id="L1463">        build.append(&quot;E&quot;).append(getExponent());</span>
<span class="nc" id="L1464">        return getRuntime().newString(build.toString());</span>
    }

    private IRubyObject floatingPointValue(String arg) {
<span class="nc" id="L1468">        String values[] = value.abs().stripTrailingZeros().toPlainString().split(&quot;\\.&quot;);</span>
<span class="nc bnc" id="L1469" title="All 2 branches missed.">        String whole = values.length &gt; 0 ? values[0] : &quot;0&quot;;</span>
<span class="nc bnc" id="L1470" title="All 2 branches missed.">        String after = values.length &gt; 1 ? values[1] : &quot;0&quot;;</span>
<span class="nc" id="L1471">        StringBuilder build = new StringBuilder().append(sign(arg, value.signum()));</span>
        
<span class="nc bnc" id="L1473" title="All 2 branches missed.">        if (groups(arg) == 0) {</span>
<span class="nc" id="L1474">            build.append(whole);</span>
<span class="nc bnc" id="L1475" title="All 2 branches missed.">            if (after != null) build.append(&quot;.&quot;).append(after);</span>
        } else {
<span class="nc" id="L1477">            int index = 0;</span>
<span class="nc" id="L1478">            String sep = &quot;&quot;;</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">            while (index &lt; whole.length()) {</span>
<span class="nc" id="L1480">                int next = index + groups(arg);</span>
<span class="nc bnc" id="L1481" title="All 2 branches missed.">                if (next &gt; whole.length()) next = whole.length();</span>

<span class="nc" id="L1483">                build.append(sep).append(whole.substring(index, next));</span>
<span class="nc" id="L1484">                sep = &quot; &quot;;</span>
<span class="nc" id="L1485">                index += groups(arg);</span>
<span class="nc" id="L1486">            }</span>
<span class="nc bnc" id="L1487" title="All 2 branches missed.">            if (null != after) {</span>
<span class="nc" id="L1488">                build.append(&quot;.&quot;);</span>
<span class="nc" id="L1489">                index = 0;</span>
<span class="nc" id="L1490">                sep = &quot;&quot;;</span>
<span class="nc bnc" id="L1491" title="All 2 branches missed.">                while (index &lt; after.length()) {</span>
<span class="nc" id="L1492">                    int next = index + groups(arg);</span>
<span class="nc bnc" id="L1493" title="All 2 branches missed.">                    if (next &gt; after.length()) next = after.length();</span>

<span class="nc" id="L1495">                    build.append(sep).append(after.substring(index, next));</span>
<span class="nc" id="L1496">                    sep = &quot; &quot;;</span>
<span class="nc" id="L1497">                    index += groups(arg);</span>
<span class="nc" id="L1498">                }</span>
            }
        }
<span class="nc" id="L1501">        return getRuntime().newString(build.toString());</span>
    }
            
    @JRubyMethod(optional = 1)
    public IRubyObject to_s(IRubyObject[] args) {
<span class="nc bnc" id="L1506" title="All 2 branches missed.">        if (isNaN()) return getRuntime().newString(&quot;NaN&quot;);</span>
<span class="nc bnc" id="L1507" title="All 2 branches missed.">        if (isInfinity()) return getRuntime().newString(infinityString());</span>
<span class="nc bnc" id="L1508" title="All 4 branches missed.">        if (isZero()) return getRuntime().newString(zeroSign &lt; 0 ? &quot;-0.0&quot; : &quot;0.0&quot;);</span>
        
<span class="nc" id="L1510">        String arg = firstArgument(args);</span>

<span class="nc bnc" id="L1512" title="All 2 branches missed.">        return asEngineering(arg) ? engineeringValue(arg) : floatingPointValue(arg);</span>
    } 

    // Note: #fix has only no-arg form, but truncate allows optional parameter.

    @JRubyMethod
    public IRubyObject fix() {
<span class="nc" id="L1519">        return truncateInternal(0);</span>
    }

    private RubyBigDecimal truncateInternal(int arg) {
<span class="nc bnc" id="L1523" title="All 2 branches missed.">        if (isNaN()) return newNaN(getRuntime());</span>
<span class="nc bnc" id="L1524" title="All 2 branches missed.">        if (isInfinity()) return newInfinity(getRuntime(), infinitySign);</span>

<span class="nc" id="L1526">        int precision = value.precision() - value.scale() + arg;</span>
        
<span class="nc bnc" id="L1528" title="All 2 branches missed.">        if (precision &gt; 0) return new RubyBigDecimal(getRuntime(),</span>
<span class="nc" id="L1529">                value.round(new MathContext(precision, RoundingMode.DOWN)));</span>

<span class="nc" id="L1531">        return new RubyBigDecimal(getRuntime(), BigDecimal.ZERO); // FIXME: proper sign</span>
    }

    @JRubyMethod
    public IRubyObject truncate(ThreadContext context) {
<span class="nc" id="L1536">        return truncateInternal(0).to_int();</span>
    }
    
    @JRubyMethod
    public IRubyObject truncate(ThreadContext context, IRubyObject arg) {
<span class="nc" id="L1541">        return truncateInternal(RubyNumeric.fix2int(arg));</span>
    }    

    @JRubyMethod(name = &quot;zero?&quot;)
    public IRubyObject zero_p() {
<span class="nc" id="L1546">         return getRuntime().newBoolean(isZero());</span>
    }

    /**
     * Returns the correctly rounded square root of a positive
     * BigDecimal. This method performs the fast &lt;i&gt;Square Root by
     * Coupled Newton Iteration&lt;/i&gt; algorithm by Timm Ahrendt, from
     * the book &quot;Pi, unleashed&quot; by Jörg Arndt in a neat loop.
     * &lt;p&gt;
     * The code is based on Frans Lelieveld's code , used here with
     * permission.
     *
     * @param squarD The number to get the root from.
     * @param rootMC Precision and rounding mode.
     * @return the root of the argument number
     * @throws ArithmeticException
     *                 if the argument number is negative
     * @throws IllegalArgumentException
     *                 if rootMC has precision 0
     * @see http://oldblog.novaloka.nl/blogger.xs4all.nl/novaloka/archive/2007/09/15/295396.html
     */
    public static BigDecimal bigSqrt(BigDecimal squarD, MathContext rootMC) {
       // General number and precision checking
<span class="nc" id="L1569">      int sign = squarD.signum();</span>
<span class="nc bnc" id="L1570" title="All 2 branches missed.">      if (sign == -1) throw new ArithmeticException(&quot;Square root of a negative number: &quot; + squarD);</span>
<span class="nc bnc" id="L1571" title="All 2 branches missed.">      if (sign == 0) return squarD.round(rootMC);</span>

<span class="nc" id="L1573">      int prec = rootMC.getPrecision();           // the requested precision</span>
<span class="nc bnc" id="L1574" title="All 2 branches missed.">      if (prec == 0) throw new IllegalArgumentException(&quot;Most roots won't have infinite precision = 0&quot;);</span>

      // Initial precision is that of double numbers 2^63/2 ~ 4E18
<span class="nc" id="L1577">      int BITS = 62;                              // 63-1 an even number of number bits</span>
<span class="nc" id="L1578">      int nInit = 16;                             // precision seems 16 to 18 digits</span>
<span class="nc" id="L1579">      MathContext nMC = new MathContext(18, RoundingMode.HALF_DOWN);</span>

      // Estimate the square root with the foremost 62 bits of squarD
<span class="nc" id="L1582">      BigInteger bi = squarD.unscaledValue();     // bi and scale are a tandem</span>
<span class="nc" id="L1583">      int biLen = bi.bitLength();</span>
<span class="nc bnc" id="L1584" title="All 2 branches missed.">      int shift = Math.max(0, biLen - BITS + (biLen%2 == 0 ? 0 : 1));   // even shift..</span>
<span class="nc" id="L1585">      bi = bi.shiftRight(shift);                  // ..floors to 62 or 63 bit BigInteger</span>

<span class="nc" id="L1587">      double root = Math.sqrt(SafeDoubleParser.doubleValue(bi));</span>
<span class="nc" id="L1588">      BigDecimal halfBack = new BigDecimal(BigInteger.ONE.shiftLeft(shift/2));</span>

<span class="nc" id="L1590">      int scale = squarD.scale();</span>
<span class="nc bnc" id="L1591" title="All 2 branches missed.">      if (scale % 2 == 1) root *= SQRT_10; // 5 -&gt; 2, -5 -&gt; -3 need half a scale more..</span>

<span class="nc" id="L1593">      scale = (int) Math.ceil(scale/2.);         // ..where 100 -&gt; 10 shifts the scale</span>

      // Initial x - use double root - multiply by halfBack to unshift - set new scale
<span class="nc" id="L1596">      BigDecimal x = new BigDecimal(root, nMC);</span>
<span class="nc" id="L1597">      x = x.multiply(halfBack, nMC);              // x0 ~ sqrt()</span>
<span class="nc bnc" id="L1598" title="All 2 branches missed.">      if (scale != 0) x = x.movePointLeft(scale);</span>

<span class="nc bnc" id="L1600" title="All 2 branches missed.">      if (prec &lt; nInit) {                // for prec 15 root x0 must surely be OK</span>
<span class="nc" id="L1601">          return x.round(rootMC);        // return small prec roots without iterations</span>
      }

      // Initial v - the reciprocal
<span class="nc" id="L1605">      BigDecimal v = BigDecimal.ONE.divide(TWO.multiply(x), nMC);        // v0 = 1/(2*x)</span>

      // Collect iteration precisions beforehand
<span class="nc" id="L1608">      List&lt;Integer&gt; nPrecs = new ArrayList&lt;Integer&gt;();</span>

<span class="nc bnc" id="L1610" title="All 4 branches missed.">      assert nInit &gt; 3 : &quot;Never ending loop!&quot;;                // assume nInit = 16 &lt;= prec</span>

      // Let m be the exact digits precision in an earlier! loop
<span class="nc bnc" id="L1613" title="All 4 branches missed.">      for (int m = prec + 1; m &gt; nInit; m = m/2 + (m &gt; 100 ? 1 : 2)) {</span>
<span class="nc" id="L1614">          nPrecs.add(m);</span>
      }

      // The loop of &quot;Square Root by Coupled Newton Iteration&quot;
<span class="nc bnc" id="L1618" title="All 2 branches missed.">      for (int i = nPrecs.size() - 1; i &gt; -1; i--) {</span>
          // Increase precision - next iteration supplies n exact digits
<span class="nc bnc" id="L1620" title="All 2 branches missed.">          nMC = new MathContext(nPrecs.get(i), i%2 == 1 ? RoundingMode.HALF_UP : RoundingMode.HALF_DOWN);</span>

          // Next x                                        // e = d - x^2
<span class="nc" id="L1623">          BigDecimal e = squarD.subtract(x.multiply(x, nMC), nMC);</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">          if (i != 0) {</span>
<span class="nc" id="L1625">              x = x.add(e.multiply(v, nMC));               // x += e*v     ~ sqrt()</span>
          } else {
<span class="nc" id="L1627">              x = x.add(e.multiply(v, rootMC), rootMC);    // root x is ready!</span>
<span class="nc" id="L1628">              break;</span>
          }

          // Next v                                        // g = 1 - 2*x*v
<span class="nc" id="L1632">          BigDecimal g = BigDecimal.ONE.subtract(TWO.multiply(x).multiply(v, nMC));</span>

<span class="nc" id="L1634">          v = v.add(g.multiply(v, nMC));                   // v += g*v     ~ 1/2/sqrt()</span>
      }

<span class="nc" id="L1637">      return x;                      // return sqrt(squarD) with precision of rootMC</span>
    }

    private void checkFloatDomain() {
<span class="nc bnc" id="L1641" title="All 2 branches missed.">        if (isNaN()) throw this.getRuntime().newFloatDomainError(&quot;NaN&quot;);</span>
<span class="nc bnc" id="L1642" title="All 2 branches missed.">        if (isInfinity()) throw getRuntime().newFloatDomainError(infinityString());</span>
<span class="nc" id="L1643">    }</span>
    
    private String infinityString() {
<span class="nc bnc" id="L1646" title="All 2 branches missed.">        return infinitySign == -1 ? &quot;-Infinity&quot; : &quot;Infinity&quot;;</span>
    }
    
    private boolean is_even(IRubyObject x) {
<span class="nc bnc" id="L1650" title="All 4 branches missed.">        if (x instanceof RubyFixnum) return RubyNumeric.fix2long((RubyFixnum) x) % 2 == 0;</span>
<span class="nc bnc" id="L1651" title="All 4 branches missed.">        if (x instanceof RubyBignum) return RubyBignum.big2long((RubyBignum) x) % 2 == 0;</span>

<span class="nc" id="L1653">        return false;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201501050207</span></div></body></html>